import {
  _asyncToGenerator,
  _callSuper,
  _classCallCheck,
  _createClass,
  _createForOfIteratorHelper,
  _getPrototypeOf,
  _inherits,
  _regeneratorRuntime,
  _toConsumableArray
} from "./chunk-PY5P2O3D.js";
import {
  _defineProperty,
  _objectSpread2,
  _objectWithoutProperties,
  _slicedToArray
} from "./chunk-Z7TI3OZI.js";
import {
  require_react_dom
} from "./chunk-WALXKXZM.js";
import {
  require_react
} from "./chunk-WQMOH32Y.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports, module) {
    module.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports, module) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice3 = Array.prototype.slice;
    var swizzle = module.exports = function swizzle2(args) {
      var results = [];
      for (var i = 0, len5 = args.length; i < len5; i++) {
        var arg = args[i];
        if (isArrayish(arg)) {
          results = concat.call(results, slice3.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports, module) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty2 = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name2 in colorNames) {
      if (hasOwnProperty2.call(colorNames, name2)) {
        reverseNames[colorNames[name2]] = name2;
      }
    }
    var name2;
    var cs = module.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex3 = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba3 = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb3 = [0, 0, 0, 1];
      var match;
      var i;
      var hexAlpha;
      if (match = string.match(hex3)) {
        hexAlpha = match[2];
        match = match[1];
        for (i = 0; i < 3; i++) {
          var i2 = i * 2;
          rgb3[i] = parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb3[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i = 0; i < 3; i++) {
          rgb3[i] = parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          rgb3[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba3)) {
        for (i = 0; i < 3; i++) {
          rgb3[i] = parseInt(match[i + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb3[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb3[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb3[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb3[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb3[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty2.call(colorNames, match[1])) {
          return null;
        }
        rgb3 = colorNames[match[1]];
        rgb3[3] = 1;
        return rgb3;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb3[i] = clamp3(rgb3[i], 0, 255);
      }
      rgb3[3] = clamp3(rgb3[3], 0, 1);
      return rgb3;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl4 = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl4);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var s3 = clamp3(parseFloat(match[2]), 0, 100);
        var l = clamp3(parseFloat(match[3]), 0, 100);
        var a4 = clamp3(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s3, l, a4];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp3(parseFloat(match[2]), 0, 100);
        var b = clamp3(parseFloat(match[3]), 0, 100);
        var a4 = clamp3(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a4];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba3 = swizzle(arguments);
      return "#" + hexDouble(rgba3[0]) + hexDouble(rgba3[1]) + hexDouble(rgba3[2]) + (rgba3[3] < 1 ? hexDouble(Math.round(rgba3[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba3 = swizzle(arguments);
      return rgba3.length < 4 || rgba3[3] === 1 ? "rgb(" + Math.round(rgba3[0]) + ", " + Math.round(rgba3[1]) + ", " + Math.round(rgba3[2]) + ")" : "rgba(" + Math.round(rgba3[0]) + ", " + Math.round(rgba3[1]) + ", " + Math.round(rgba3[2]) + ", " + rgba3[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba3 = swizzle(arguments);
      var r = Math.round(rgba3[0] / 255 * 100);
      var g = Math.round(rgba3[1] / 255 * 100);
      var b = Math.round(rgba3[2] / 255 * 100);
      return rgba3.length < 4 || rgba3[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba3[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla3 = swizzle(arguments);
      return hsla3.length < 4 || hsla3[3] === 1 ? "hsl(" + hsla3[0] + ", " + hsla3[1] + "%, " + hsla3[2] + "%)" : "hsla(" + hsla3[0] + ", " + hsla3[1] + "%, " + hsla3[2] + "%, " + hsla3[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a4 = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a4 = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a4 + ")";
    };
    cs.to.keyword = function(rgb3) {
      return reverseNames[rgb3.slice(0, 3)];
    };
    function clamp3(num, min10, max11) {
      return Math.min(Math.max(min10, num), max11);
    }
    function hexDouble(num) {
      var str7 = Math.round(num).toString(16).toUpperCase();
      return str7.length < 2 ? "0" + str7 : str7;
    }
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0)
        return names;
      for (name2 in events = this._events) {
        if (has.call(events, name2))
          names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a22, a32, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len5 = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len5) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a32), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a32, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a32, a4, a5), true;
        }
        for (i = 1, args = new Array(len5 - 1); i < len5; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length5 = listeners.length, j;
        for (i = 0; i < length5; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len5) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a22);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a22, a32);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len5 - 1); j < len5; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length5 = listeners.length; i < length5; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// node_modules/svg-path-parser/parser.js
var require_parser = __commonJS({
  "node_modules/svg-path-parser/parser.js"(exports, module) {
    "use strict";
    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }
    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }
    peg$subclass(peg$SyntaxError, Error);
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        "class": function(expectation) {
          var escapedParts = "", i;
          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }
          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function(expectation) {
          return "any character";
        },
        end: function(expectation) {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex3(ch2) {
        return ch2.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s3) {
        return s3.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch2) {
          return "\\x0" + hex3(ch2);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch2) {
          return "\\x" + hex3(ch2);
        });
      }
      function classEscape(s3) {
        return s3.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch2) {
          return "\\x0" + hex3(ch2);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch2) {
          return "\\x" + hex3(ch2);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = new Array(expected2.length), i, j;
        for (i = 0; i < expected2.length; i++) {
          descriptions[i] = describeExpectation(expected2[i]);
        }
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {}, peg$startRuleFunctions = { svg_path: peg$parsesvg_path }, peg$startRuleFunction = peg$parsesvg_path, peg$c0 = function(data2) {
        if (!data2)
          return [];
        for (var cmds2 = [], i = 0; i < data2.length; i++)
          cmds2 = cmds2.concat.apply(cmds2, data2[i]);
        var first3 = cmds2[0];
        if (first3 && first3.code == "m") {
          delete first3.relative;
          first3.code = "M";
        }
        return cmds2;
      }, peg$c1 = function(first3, more) {
        return merge2(first3, more);
      }, peg$c2 = /^[Mm]/, peg$c3 = peg$classExpectation(["M", "m"], false, false), peg$c4 = function(c5, first3, more) {
        var move = commands(c5, [first3]);
        if (more)
          move = move.concat(commands(c5 == "M" ? "L" : "l", more[1]));
        return move;
      }, peg$c5 = /^[Zz]/, peg$c6 = peg$classExpectation(["Z", "z"], false, false), peg$c7 = function() {
        return commands("Z");
      }, peg$c8 = /^[Ll]/, peg$c9 = peg$classExpectation(["L", "l"], false, false), peg$c10 = function(c5, args) {
        return commands(c5, args);
      }, peg$c11 = /^[Hh]/, peg$c12 = peg$classExpectation(["H", "h"], false, false), peg$c13 = function(c5, args) {
        return commands(c5, args.map(function(x3) {
          return { x: x3 };
        }));
      }, peg$c14 = /^[Vv]/, peg$c15 = peg$classExpectation(["V", "v"], false, false), peg$c16 = function(c5, args) {
        return commands(c5, args.map(function(y3) {
          return { y: y3 };
        }));
      }, peg$c17 = /^[Cc]/, peg$c18 = peg$classExpectation(["C", "c"], false, false), peg$c19 = function(a4, b, c5) {
        return { x1: a4.x, y1: a4.y, x2: b.x, y2: b.y, x: c5.x, y: c5.y };
      }, peg$c20 = /^[Ss]/, peg$c21 = peg$classExpectation(["S", "s"], false, false), peg$c22 = function(b, c5) {
        return { x2: b.x, y2: b.y, x: c5.x, y: c5.y };
      }, peg$c23 = /^[Qq]/, peg$c24 = peg$classExpectation(["Q", "q"], false, false), peg$c25 = function(a4, b) {
        return { x1: a4.x, y1: a4.y, x: b.x, y: b.y };
      }, peg$c26 = /^[Tt]/, peg$c27 = peg$classExpectation(["T", "t"], false, false), peg$c28 = /^[Aa]/, peg$c29 = peg$classExpectation(["A", "a"], false, false), peg$c30 = function(rx, ry, xrot, large, sweep, xy) {
        return { rx, ry, xAxisRotation: xrot, largeArc: large, sweep, x: xy.x, y: xy.y };
      }, peg$c31 = function(x3, y3) {
        return { x: x3, y: y3 };
      }, peg$c32 = function(n) {
        return n * 1;
      }, peg$c33 = function(parts) {
        return parts.join("") * 1;
      }, peg$c34 = /^[01]/, peg$c35 = peg$classExpectation(["0", "1"], false, false), peg$c36 = function(bit) {
        return bit == "1";
      }, peg$c37 = function() {
        return "";
      }, peg$c38 = ",", peg$c39 = peg$literalExpectation(",", false), peg$c40 = function(parts) {
        return parts.join("");
      }, peg$c41 = ".", peg$c42 = peg$literalExpectation(".", false), peg$c43 = /^[eE]/, peg$c44 = peg$classExpectation(["e", "E"], false, false), peg$c45 = /^[+\-]/, peg$c46 = peg$classExpectation(["+", "-"], false, false), peg$c47 = /^[0-9]/, peg$c48 = peg$classExpectation([["0", "9"]], false, false), peg$c49 = function(digits) {
        return digits.join("");
      }, peg$c50 = /^[ \t\n\r]/, peg$c51 = peg$classExpectation([" ", "	", "\n", "\r"], false, false), peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1 }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error3(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos], p2;
        if (details) {
          return details;
        } else {
          p2 = pos - 1;
          while (!peg$posDetailsCache[p2]) {
            p2--;
          }
          details = peg$posDetailsCache[p2];
          details = {
            line: details.line,
            column: details.column
          };
          while (p2 < pos) {
            if (input.charCodeAt(p2) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p2++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsesvg_path() {
        var s0, s1, s22, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewsp();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewsp();
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsemoveTo_drawTo_commandGroups();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsewsp();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsewsp();
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c0(s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemoveTo_drawTo_commandGroups() {
        var s0, s1, s22, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsemoveTo_drawTo_commandGroup();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$currPos;
          s4 = [];
          s5 = peg$parsewsp();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsewsp();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsemoveTo_drawTo_commandGroup();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$parsewsp();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsewsp();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsemoveTo_drawTo_commandGroup();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemoveTo_drawTo_commandGroup() {
        var s0, s1, s22, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsemoveto();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$currPos;
          s4 = [];
          s5 = peg$parsewsp();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsewsp();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsedrawto_command();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$parsewsp();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsewsp();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsedrawto_command();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedrawto_command() {
        var s0;
        s0 = peg$parseclosepath();
        if (s0 === peg$FAILED) {
          s0 = peg$parselineto();
          if (s0 === peg$FAILED) {
            s0 = peg$parsehorizontal_lineto();
            if (s0 === peg$FAILED) {
              s0 = peg$parsevertical_lineto();
              if (s0 === peg$FAILED) {
                s0 = peg$parsecurveto();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsesmooth_curveto();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsequadratic_bezier_curveto();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsesmooth_quadratic_bezier_curveto();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseelliptical_arc();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsemoveto() {
        var s0, s1, s22, s3, s4, s5, s6;
        s0 = peg$currPos;
        if (peg$c2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s3 = peg$parsecoordinate_pair();
            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              s5 = peg$parsecomma_wsp();
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parselineto_argument_sequence();
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c4(s1, s3, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclosepath() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$c5.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c7();
        }
        s0 = s1;
        return s0;
      }
      function peg$parselineto() {
        var s0, s1, s22, s3;
        s0 = peg$currPos;
        if (peg$c8.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c9);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s3 = peg$parselineto_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parselineto_argument_sequence() {
        var s0, s1, s22, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecoordinate_pair();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecoordinate_pair();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsehorizontal_lineto() {
        var s0, s1, s22, s3;
        s0 = peg$currPos;
        if (peg$c11.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c12);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s3 = peg$parsecoordinate_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c13(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecoordinate_sequence() {
        var s0, s1, s22, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsenumber();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsenumber();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsenumber();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsevertical_lineto() {
        var s0, s1, s22, s3;
        s0 = peg$currPos;
        if (peg$c14.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c15);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s3 = peg$parsecoordinate_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c16(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurveto() {
        var s0, s1, s22, s3;
        s0 = peg$currPos;
        if (peg$c17.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c18);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s3 = peg$parsecurveto_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurveto_argument_sequence() {
        var s0, s1, s22, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsecurveto_argument();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecurveto_argument();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecurveto_argument();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurveto_argument() {
        var s0, s1, s22, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecomma_wsp();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s3 = peg$parsecoordinate_pair();
            if (s3 !== peg$FAILED) {
              s4 = peg$parsecomma_wsp();
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsecoordinate_pair();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c19(s1, s3, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_curveto() {
        var s0, s1, s22, s3;
        s0 = peg$currPos;
        if (peg$c20.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c21);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s3 = peg$parsesmooth_curveto_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_curveto_argument_sequence() {
        var s0, s1, s22, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsesmooth_curveto_argument();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsesmooth_curveto_argument();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsesmooth_curveto_argument();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_curveto_argument() {
        var s0, s1, s22, s3;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecomma_wsp();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s3 = peg$parsecoordinate_pair();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c22(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsequadratic_bezier_curveto() {
        var s0, s1, s22, s3;
        s0 = peg$currPos;
        if (peg$c23.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s3 = peg$parsequadratic_bezier_curveto_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsequadratic_bezier_curveto_argument_sequence() {
        var s0, s1, s22, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsequadratic_bezier_curveto_argument();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsequadratic_bezier_curveto_argument();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsequadratic_bezier_curveto_argument();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsequadratic_bezier_curveto_argument() {
        var s0, s1, s22, s3;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecomma_wsp();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s3 = peg$parsecoordinate_pair();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c25(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_quadratic_bezier_curveto() {
        var s0, s1, s22, s3;
        s0 = peg$currPos;
        if (peg$c26.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c27);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s3 = peg$parsesmooth_quadratic_bezier_curveto_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_quadratic_bezier_curveto_argument_sequence() {
        var s0, s1, s22, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecoordinate_pair();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecoordinate_pair();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseelliptical_arc() {
        var s0, s1, s22, s3;
        s0 = peg$currPos;
        if (peg$c28.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c29);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s3 = peg$parseelliptical_arc_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseelliptical_arc_argument_sequence() {
        var s0, s1, s22, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseelliptical_arc_argument();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseelliptical_arc_argument();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s22.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseelliptical_arc_argument();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseelliptical_arc_argument() {
        var s0, s1, s22, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        s0 = peg$currPos;
        s1 = peg$parsenonnegative_number();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecomma_wsp();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s3 = peg$parsenonnegative_number();
            if (s3 !== peg$FAILED) {
              s4 = peg$parsecomma_wsp();
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsenumber();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsecomma_wsp();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseflag();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parsecomma_wsp();
                      if (s8 === peg$FAILED) {
                        s8 = null;
                      }
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseflag();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parsecomma_wsp();
                          if (s10 === peg$FAILED) {
                            s10 = null;
                          }
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parsecoordinate_pair();
                            if (s11 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c30(s1, s3, s5, s7, s9, s11);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecoordinate_pair() {
        var s0, s1, s22, s3;
        s0 = peg$currPos;
        s1 = peg$parsenumber();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecomma_wsp();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s3 = peg$parsenumber();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c31(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenonnegative_number() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parsefloating_point_constant();
        if (s1 === peg$FAILED) {
          s1 = peg$parsedigit_sequence();
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c32(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsesign();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        if (s22 !== peg$FAILED) {
          s3 = peg$parsefloating_point_constant();
          if (s3 !== peg$FAILED) {
            s22 = [s22, s3];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$parsesign();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s3 = peg$parsedigit_sequence();
            if (s3 !== peg$FAILED) {
              s22 = [s22, s3];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c33(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseflag() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$c34.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c36(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsecomma_wsp() {
        var s0, s1, s22, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewsp();
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsewsp();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecomma();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsewsp();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsewsp();
            }
            if (s3 !== peg$FAILED) {
              s1 = [s1, s22, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          s22 = peg$parsecomma();
          if (s22 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsewsp();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsewsp();
            }
            if (s3 !== peg$FAILED) {
              s22 = [s22, s3];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c37();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsecomma() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 44) {
          s0 = peg$c38;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }
        return s0;
      }
      function peg$parsefloating_point_constant() {
        var s0, s1, s22, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsefractional_constant();
        if (s22 !== peg$FAILED) {
          s3 = peg$parseexponent();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s22 = [s22, s3];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$parsedigit_sequence();
          if (s22 !== peg$FAILED) {
            s3 = peg$parseexponent();
            if (s3 !== peg$FAILED) {
              s22 = [s22, s3];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsefractional_constant() {
        var s0, s1, s22, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsedigit_sequence();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        if (s22 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s3 = peg$c41;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c42);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsedigit_sequence();
            if (s4 !== peg$FAILED) {
              s22 = [s22, s3, s4];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$parsedigit_sequence();
          if (s22 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s3 = peg$c41;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c42);
              }
            }
            if (s3 !== peg$FAILED) {
              s22 = [s22, s3];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseexponent() {
        var s0, s1, s22, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (peg$c43.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c44);
          }
        }
        if (s22 !== peg$FAILED) {
          s3 = peg$parsesign();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsedigit_sequence();
            if (s4 !== peg$FAILED) {
              s22 = [s22, s3, s4];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesign() {
        var s0;
        if (peg$c45.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c46);
          }
        }
        return s0;
      }
      function peg$parsedigit_sequence() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        if (peg$c47.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (peg$c47.test(input.charAt(peg$currPos))) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c49(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsewsp() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$c50.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c51);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c37();
        }
        s0 = s1;
        return s0;
      }
      function merge2(first3, more) {
        if (!more)
          return [first3];
        for (var a4 = [first3], i = 0, l = more.length; i < l; i++)
          a4[i + 1] = more[i][1];
        return a4;
      }
      var cmds = { m: "moveto", l: "lineto", h: "horizontal lineto", v: "vertical lineto", c: "curveto", s: "smooth curveto", q: "quadratic curveto", t: "smooth quadratic curveto", a: "elliptical arc", z: "closepath" };
      for (var code in cmds)
        cmds[code.toUpperCase()] = cmds[code];
      function commands(code2, args) {
        if (!args)
          args = [{}];
        for (var i = args.length; i--; ) {
          var cmd = { code: code2, command: cmds[code2] };
          if (code2 == code2.toLowerCase())
            cmd.relative = true;
          for (var k2 in args[i])
            cmd[k2] = args[i][k2];
          args[i] = cmd;
        }
        return args;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    module.exports = {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }
});

// node_modules/svg-path-parser/index.js
var require_svg_path_parser = __commonJS({
  "node_modules/svg-path-parser/index.js"(exports, module) {
    var parserFunction = require_parser().parse;
    parserFunction.parseSVG = parserFunction;
    parserFunction.makeAbsolute = makeSVGPathCommandsAbsolute;
    module.exports = parserFunction;
    function makeSVGPathCommandsAbsolute(commands) {
      var subpathStart, prevCmd = { x: 0, y: 0 };
      var attr2 = { x: "x0", y: "y0", x1: "x0", y1: "y0", x2: "x0", y2: "y0" };
      commands.forEach(function(cmd) {
        if (cmd.command === "moveto")
          subpathStart = cmd;
        cmd.x0 = prevCmd.x;
        cmd.y0 = prevCmd.y;
        for (var a4 in attr2)
          if (a4 in cmd)
            cmd[a4] += cmd.relative ? cmd[attr2[a4]] : 0;
        if (!("x" in cmd))
          cmd.x = prevCmd.x;
        if (!("y" in cmd))
          cmd.y = prevCmd.y;
        cmd.relative = false;
        cmd.code = cmd.code.toUpperCase();
        if (cmd.command == "closepath") {
          cmd.x = subpathStart.x;
          cmd.y = subpathStart.y;
        }
        prevCmd = cmd;
      });
      return commands;
    }
  }
});

// node_modules/pdfast/src/helper.js
var require_helper = __commonJS({
  "node_modules/pdfast/src/helper.js"(exports, module) {
    "use strict";
    var self2 = module.exports;
    module.exports.isNumber = function(x3) {
      return typeof x3 === "number";
    };
    module.exports.findMin = function(arr) {
      if (arr.length === 0) {
        return Infinity;
      }
      var curr = arr[0];
      for (var i = 1; i < arr.length; i++) {
        curr = Math.min(curr, arr[i]);
      }
      return curr;
    };
    module.exports.findMax = function(arr) {
      if (arr.length === 0) {
        return -Infinity;
      }
      var curr = arr[0];
      for (var i = 1; i < arr.length; i++) {
        curr = Math.max(curr, arr[i]);
      }
      return curr;
    };
    module.exports.findMinMulti = function(arr) {
      var curr = self2.findMin(arr[0]);
      for (var i = 1; i < arr.length; i++) {
        curr = Math.min(curr, self2.findMin(arr[i]));
      }
      return curr;
    };
    module.exports.findMaxMulti = function(arr) {
      var curr = self2.findMax(arr[0]);
      for (var i = 1; i < arr.length; i++) {
        curr = Math.max(curr, self2.findMax(arr[i]));
      }
      return curr;
    };
    module.exports.inside = function(min10, max11, x3) {
      return min10 <= x3 && x3 <= max11;
    };
  }
});

// node_modules/pdfast/src/index.js
var require_src = __commonJS({
  "node_modules/pdfast/src/index.js"(exports, module) {
    "use strict";
    var DEFAULT_SIZE = 50;
    var DEFAULT_WIDTH = 2;
    var LN_2 = Math.log(2);
    var self2 = module.exports;
    var helper = require_helper();
    function kernel(x3) {
      return 1 - Math.abs(x3);
    }
    module.exports.getUnifiedMinMax = function(arr, options) {
      return self2.getUnifiedMinMaxMulti([arr], options);
    };
    module.exports.getUnifiedMinMaxMulti = function(arrMulti, options) {
      options = options || {};
      var relaxMin = false;
      var relaxMax = false;
      var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
      var size3 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
      var min10 = helper.isNumber(options.min) ? options.min : (relaxMin = true, helper.findMinMulti(arrMulti));
      var max11 = helper.isNumber(options.max) ? options.max : (relaxMax = true, helper.findMaxMulti(arrMulti));
      var range3 = max11 - min10;
      var step2 = range3 / (size3 - 1);
      if (relaxMin) {
        min10 = min10 - 2 * width * step2;
      }
      if (relaxMax) {
        max11 = max11 + 2 * width * step2;
      }
      return {
        min: min10,
        max: max11
      };
    };
    module.exports.create = function(arr, options) {
      options = options || {};
      if (!arr || arr.length === 0) {
        return [];
      }
      var size3 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
      var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
      var normalizedMinMax = self2.getUnifiedMinMax(arr, {
        size: size3,
        width,
        min: options.min,
        max: options.max
      });
      var min10 = normalizedMinMax.min;
      var max11 = normalizedMinMax.max;
      var range3 = max11 - min10;
      var step2 = range3 / (size3 - 1);
      if (range3 === 0) {
        return [{ x: min10, y: 1 }];
      }
      var buckets = [];
      for (var i = 0; i < size3; i++) {
        buckets.push({
          x: min10 + i * step2,
          y: 0
        });
      }
      var xToBucket = function(x3) {
        return Math.floor((x3 - min10) / step2);
      };
      var partialArea = generatePartialAreas(kernel, width);
      var fullArea = partialArea[width];
      var c5 = partialArea[width - 1] - partialArea[width - 2];
      var initalValue = 0;
      arr.forEach(function(x3) {
        var bucket = xToBucket(x3);
        if (bucket + width < 0 || bucket - width >= buckets.length) {
          return;
        }
        var start = Math.max(bucket - width, 0);
        var mid2 = bucket;
        var end = Math.min(bucket + width, buckets.length - 1);
        var leftBlockCount = start - (bucket - width);
        var rightBlockCount = bucket + width - end;
        var spilledAreaLeft = partialArea[-width - 1 + leftBlockCount] || 0;
        var spilledAreaRight = partialArea[-width - 1 + rightBlockCount] || 0;
        var weight2 = fullArea / (fullArea - spilledAreaLeft - spilledAreaRight);
        if (leftBlockCount > 0) {
          initalValue += weight2 * (leftBlockCount - 1) * c5;
        }
        var startGradPos = Math.max(0, bucket - width + 1);
        if (helper.inside(0, buckets.length - 1, startGradPos)) {
          buckets[startGradPos].y += weight2 * 1 * c5;
        }
        if (helper.inside(0, buckets.length - 1, mid2 + 1)) {
          buckets[mid2 + 1].y -= weight2 * 2 * c5;
        }
        if (helper.inside(0, buckets.length - 1, end + 1)) {
          buckets[end + 1].y += weight2 * 1 * c5;
        }
      });
      var accumulator = initalValue;
      var gradAccumulator = 0;
      var area2 = 0;
      buckets.forEach(function(bucket) {
        gradAccumulator += bucket.y;
        accumulator += gradAccumulator;
        bucket.y = accumulator;
        area2 += accumulator;
      });
      if (area2 > 0) {
        buckets.forEach(function(bucket) {
          bucket.y /= area2;
        });
      }
      return buckets;
    };
    function generatePartialAreas(kernel2, width) {
      var partialAreas = {};
      var accumulator = 0;
      for (var i = -width; i <= width; i++) {
        accumulator += kernel2(i / width);
        partialAreas[i] = accumulator;
      }
      return partialAreas;
    }
    module.exports.getExpectedValueFromPdf = function(pdf2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var expected = 0;
      pdf2.forEach(function(obj) {
        expected += obj.x * obj.y;
      });
      return expected;
    };
    module.exports.getXWithLeftTailArea = function(pdf2, area2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var accumulator = 0;
      var last5 = 0;
      for (var i = 0; i < pdf2.length; i++) {
        last5 = i;
        accumulator += pdf2[i].y;
        if (accumulator >= area2) {
          break;
        }
      }
      return pdf2[last5].x;
    };
    module.exports.getPerplexity = function(pdf2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var entropy = 0;
      pdf2.forEach(function(obj) {
        var ln2 = Math.log(obj.y);
        if (isFinite(ln2)) {
          entropy += obj.y * ln2;
        }
      });
      entropy = -entropy / LN_2;
      return Math.pow(2, entropy);
    };
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array2, setter, iteratee, accumulator) {
        var index3 = -1, length5 = array2 == null ? 0 : array2.length;
        while (++index3 < length5) {
          var value2 = array2[index3];
          setter(accumulator, value2, iteratee(value2), array2);
        }
        return accumulator;
      }
      function arrayEach(array2, iteratee) {
        var index3 = -1, length5 = array2 == null ? 0 : array2.length;
        while (++index3 < length5) {
          if (iteratee(array2[index3], index3, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEachRight(array2, iteratee) {
        var length5 = array2 == null ? 0 : array2.length;
        while (length5--) {
          if (iteratee(array2[length5], length5, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEvery(array2, predicate) {
        var index3 = -1, length5 = array2 == null ? 0 : array2.length;
        while (++index3 < length5) {
          if (!predicate(array2[index3], index3, array2)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array2, predicate) {
        var index3 = -1, length5 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index3 < length5) {
          var value2 = array2[index3];
          if (predicate(value2, index3, array2)) {
            result[resIndex++] = value2;
          }
        }
        return result;
      }
      function arrayIncludes(array2, value2) {
        var length5 = array2 == null ? 0 : array2.length;
        return !!length5 && baseIndexOf(array2, value2, 0) > -1;
      }
      function arrayIncludesWith(array2, value2, comparator) {
        var index3 = -1, length5 = array2 == null ? 0 : array2.length;
        while (++index3 < length5) {
          if (comparator(value2, array2[index3])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array2, iteratee) {
        var index3 = -1, length5 = array2 == null ? 0 : array2.length, result = Array(length5);
        while (++index3 < length5) {
          result[index3] = iteratee(array2[index3], index3, array2);
        }
        return result;
      }
      function arrayPush(array2, values4) {
        var index3 = -1, length5 = values4.length, offset2 = array2.length;
        while (++index3 < length5) {
          array2[offset2 + index3] = values4[index3];
        }
        return array2;
      }
      function arrayReduce(array2, iteratee, accumulator, initAccum) {
        var index3 = -1, length5 = array2 == null ? 0 : array2.length;
        if (initAccum && length5) {
          accumulator = array2[++index3];
        }
        while (++index3 < length5) {
          accumulator = iteratee(accumulator, array2[index3], index3, array2);
        }
        return accumulator;
      }
      function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
        var length5 = array2 == null ? 0 : array2.length;
        if (initAccum && length5) {
          accumulator = array2[--length5];
        }
        while (length5--) {
          accumulator = iteratee(accumulator, array2[length5], length5, array2);
        }
        return accumulator;
      }
      function arraySome(array2, predicate) {
        var index3 = -1, length5 = array2 == null ? 0 : array2.length;
        while (++index3 < length5) {
          if (predicate(array2[index3], index3, array2)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value2, key, collection2) {
          if (predicate(value2, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array2, predicate, fromIndex, fromRight) {
        var length5 = array2.length, index3 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index3-- : ++index3 < length5) {
          if (predicate(array2[index3], index3, array2)) {
            return index3;
          }
        }
        return -1;
      }
      function baseIndexOf(array2, value2, fromIndex) {
        return value2 === value2 ? strictIndexOf(array2, value2, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array2, value2, fromIndex, comparator) {
        var index3 = fromIndex - 1, length5 = array2.length;
        while (++index3 < length5) {
          if (comparator(array2[index3], value2)) {
            return index3;
          }
        }
        return -1;
      }
      function baseIsNaN(value2) {
        return value2 !== value2;
      }
      function baseMean(array2, iteratee) {
        var length5 = array2 == null ? 0 : array2.length;
        return length5 ? baseSum(array2, iteratee) / length5 : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value2, index3, collection2) {
          accumulator = initAccum ? (initAccum = false, value2) : iteratee(accumulator, value2, index3, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array2, comparer) {
        var length5 = array2.length;
        array2.sort(comparer);
        while (length5--) {
          array2[length5] = array2[length5].value;
        }
        return array2;
      }
      function baseSum(array2, iteratee) {
        var result, index3 = -1, length5 = array2.length;
        while (++index3 < length5) {
          var current = iteratee(array2[index3]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index3 = -1, result = Array(n);
        while (++index3 < n) {
          result[index3] = iteratee(index3);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value2) {
          return func(value2);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache2, key) {
        return cache2.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index3 = -1, length5 = strSymbols.length;
        while (++index3 < length5 && baseIndexOf(chrSymbols, strSymbols[index3], 0) > -1) {
        }
        return index3;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index3 = strSymbols.length;
        while (index3-- && baseIndexOf(chrSymbols, strSymbols[index3], 0) > -1) {
        }
        return index3;
      }
      function countHolders(array2, placeholder) {
        var length5 = array2.length, result = 0;
        while (length5--) {
          if (array2[length5] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data2, result = [];
        while (!(data2 = iterator.next()).done) {
          result.push(data2.value);
        }
        return result;
      }
      function mapToArray(map5) {
        var index3 = -1, result = Array(map5.size);
        map5.forEach(function(value2, key) {
          result[++index3] = [key, value2];
        });
        return result;
      }
      function overArg(func, transform2) {
        return function(arg) {
          return func(transform2(arg));
        };
      }
      function replaceHolders(array2, placeholder) {
        var index3 = -1, length5 = array2.length, resIndex = 0, result = [];
        while (++index3 < length5) {
          var value2 = array2[index3];
          if (value2 === placeholder || value2 === PLACEHOLDER) {
            array2[index3] = PLACEHOLDER;
            result[resIndex++] = index3;
          }
        }
        return result;
      }
      function setToArray(set9) {
        var index3 = -1, result = Array(set9.size);
        set9.forEach(function(value2) {
          result[++index3] = value2;
        });
        return result;
      }
      function setToPairs(set9) {
        var index3 = -1, result = Array(set9.size);
        set9.forEach(function(value2) {
          result[++index3] = [value2, value2];
        });
        return result;
      }
      function strictIndexOf(array2, value2, fromIndex) {
        var index3 = fromIndex - 1, length5 = array2.length;
        while (++index3 < length5) {
          if (array2[index3] === value2) {
            return index3;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array2, value2, fromIndex) {
        var index3 = fromIndex + 1;
        while (index3--) {
          if (array2[index3] === value2) {
            return index3;
          }
        }
        return index3;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index3 = string.length;
        while (index3-- && reWhitespace.test(string.charAt(index3))) {
        }
        return index3;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root2 : _2.defaults(root2.Object(), context, _2.pick(root2, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto3 = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto3.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto3.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root2._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer = moduleExports ? context.Buffer : undefined2, Symbol3 = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto3.propertyIsEnumerable, splice6 = arrayProto.splice, spreadableSymbol = Symbol3 ? Symbol3.isConcatSpreadable : undefined2, symIterator = Symbol3 ? Symbol3.iterator : undefined2, symToStringTag = Symbol3 ? Symbol3.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map3 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map3), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol3 ? Symbol3.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value2) {
          if (isObjectLike3(value2) && !isArray4(value2) && !(value2 instanceof LazyWrapper)) {
            if (value2 instanceof LodashWrapper) {
              return value2;
            }
            if (hasOwnProperty2.call(value2, "__wrapped__")) {
              return wrapperClone(value2);
            }
          }
          return new LodashWrapper(value2);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject6(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value2, chainAll) {
          this.__wrapped__ = value2;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value2) {
          this.__wrapped__ = value2;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray4(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length5 = end - start, index3 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length5, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length5 && takeCount == length5) {
            return baseWrapperValue(array2, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length5-- && resIndex < takeCount) {
              index3 += dir;
              var iterIndex = -1, value2 = array2[index3];
              while (++iterIndex < iterLength) {
                var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed = iteratee2(value2);
                if (type == LAZY_MAP_FLAG) {
                  value2 = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value2;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index3 = -1, length5 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index3 < length5) {
            var entry = entries[index3];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data2 = this.__data__;
          if (nativeCreate) {
            var result2 = data2[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty2.call(data2, key) ? data2[key] : undefined2;
        }
        function hashHas(key) {
          var data2 = this.__data__;
          return nativeCreate ? data2[key] !== undefined2 : hasOwnProperty2.call(data2, key);
        }
        function hashSet(key, value2) {
          var data2 = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data2[key] = nativeCreate && value2 === undefined2 ? HASH_UNDEFINED : value2;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index3 = -1, length5 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index3 < length5) {
            var entry = entries[index3];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data2 = this.__data__, index3 = assocIndexOf(data2, key);
          if (index3 < 0) {
            return false;
          }
          var lastIndex = data2.length - 1;
          if (index3 == lastIndex) {
            data2.pop();
          } else {
            splice6.call(data2, index3, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data2 = this.__data__, index3 = assocIndexOf(data2, key);
          return index3 < 0 ? undefined2 : data2[index3][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value2) {
          var data2 = this.__data__, index3 = assocIndexOf(data2, key);
          if (index3 < 0) {
            ++this.size;
            data2.push([key, value2]);
          } else {
            data2[index3][1] = value2;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index3 = -1, length5 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index3 < length5) {
            var entry = entries[index3];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map3 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value2) {
          var data2 = getMapData(this, key), size4 = data2.size;
          data2.set(key, value2);
          this.size += data2.size == size4 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values5) {
          var index3 = -1, length5 = values5 == null ? 0 : values5.length;
          this.__data__ = new MapCache();
          while (++index3 < length5) {
            this.add(values5[index3]);
          }
        }
        function setCacheAdd(value2) {
          this.__data__.set(value2, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value2) {
          return this.__data__.has(value2);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data2 = this.__data__ = new ListCache(entries);
          this.size = data2.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data2 = this.__data__, result2 = data2["delete"](key);
          this.size = data2.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value2) {
          var data2 = this.__data__;
          if (data2 instanceof ListCache) {
            var pairs2 = data2.__data__;
            if (!Map3 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
              pairs2.push([key, value2]);
              this.size = ++data2.size;
              return this;
            }
            data2 = this.__data__ = new MapCache(pairs2);
          }
          data2.set(key, value2);
          this.size = data2.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value2, inherited) {
          var isArr = isArray4(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer(value2), isType3 = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType3, result2 = skipIndexes ? baseTimes(value2.length, String2) : [], length5 = result2.length;
          for (var key in value2) {
            if ((inherited || hasOwnProperty2.call(value2, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType3 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length5)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array2) {
          var length5 = array2.length;
          return length5 ? array2[baseRandom(0, length5 - 1)] : undefined2;
        }
        function arraySampleSize(array2, n) {
          return shuffleSelf(copyArray(array2), baseClamp(n, 0, array2.length));
        }
        function arrayShuffle(array2) {
          return shuffleSelf(copyArray(array2));
        }
        function assignMergeValue(object, key, value2) {
          if (value2 !== undefined2 && !eq(object[key], value2) || value2 === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value2);
          }
        }
        function assignValue(object, key, value2) {
          var objValue = object[key];
          if (!(hasOwnProperty2.call(object, key) && eq(objValue, value2)) || value2 === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value2);
          }
        }
        function assocIndexOf(array2, key) {
          var length5 = array2.length;
          while (length5--) {
            if (eq(array2[length5][0], key)) {
              return length5;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value2, key, collection2) {
            setter(accumulator, value2, iteratee2(value2), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys2(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value2) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value2,
              "writable": true
            });
          } else {
            object[key] = value2;
          }
        }
        function baseAt(object, paths) {
          var index3 = -1, length5 = paths.length, result2 = Array2(length5), skip = object == null;
          while (++index3 < length5) {
            result2[index3] = skip ? undefined2 : get4(object, paths[index3]);
          }
          return result2;
        }
        function baseClamp(number3, lower2, upper2) {
          if (number3 === number3) {
            if (upper2 !== undefined2) {
              number3 = number3 <= upper2 ? number3 : upper2;
            }
            if (lower2 !== undefined2) {
              number3 = number3 >= lower2 ? number3 : lower2;
            }
          }
          return number3;
        }
        function baseClone(value2, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value2, key, object, stack) : customizer(value2);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject6(value2)) {
            return value2;
          }
          var isArr = isArray4(value2);
          if (isArr) {
            result2 = initCloneArray(value2);
            if (!isDeep) {
              return copyArray(value2, result2);
            }
          } else {
            var tag = getTag(value2), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value2)) {
              return cloneBuffer(value2, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value2);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value2, baseAssignIn(result2, value2)) : copySymbols(value2, baseAssign(result2, value2));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value2 : {};
              }
              result2 = initCloneByTag(value2, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value2);
          if (stacked) {
            return stacked;
          }
          stack.set(value2, result2);
          if (isSet(value2)) {
            value2.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack));
            });
          } else if (isMap(value2)) {
            value2.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
          var props = isArr ? undefined2 : keysFunc(value2);
          arrayEach(props || value2, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value2[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys2(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length5 = props.length;
          if (object == null) {
            return !length5;
          }
          object = Object2(object);
          while (length5--) {
            var key = props[length5], predicate = source[key], value2 = object[key];
            if (value2 === undefined2 && !(key in object) || !predicate(value2)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array2, values5, iteratee2, comparator) {
          var index3 = -1, includes3 = arrayIncludes, isCommon = true, length5 = array2.length, result2 = [], valuesLength = values5.length;
          if (!length5) {
            return result2;
          }
          if (iteratee2) {
            values5 = arrayMap(values5, baseUnary(iteratee2));
          }
          if (comparator) {
            includes3 = arrayIncludesWith;
            isCommon = false;
          } else if (values5.length >= LARGE_ARRAY_SIZE) {
            includes3 = cacheHas;
            isCommon = false;
            values5 = new SetCache(values5);
          }
          outer:
            while (++index3 < length5) {
              var value2 = array2[index3], computed = iteratee2 == null ? value2 : iteratee2(value2);
              value2 = comparator || value2 !== 0 ? value2 : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values5[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value2);
              } else if (!includes3(values5, computed, comparator)) {
                result2.push(value2);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value2, index3, collection2) {
            result2 = !!predicate(value2, index3, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array2, iteratee2, comparator) {
          var index3 = -1, length5 = array2.length;
          while (++index3 < length5) {
            var value2 = array2[index3], current = iteratee2(value2);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value2;
            }
          }
          return result2;
        }
        function baseFill(array2, value2, start, end) {
          var length5 = array2.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length5 ? 0 : length5 + start;
          }
          end = end === undefined2 || end > length5 ? length5 : toInteger(end);
          if (end < 0) {
            end += length5;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array2[start++] = value2;
          }
          return array2;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value2, index3, collection2) {
            if (predicate(value2, index3, collection2)) {
              result2.push(value2);
            }
          });
          return result2;
        }
        function baseFlatten(array2, depth, predicate, isStrict, result2) {
          var index3 = -1, length5 = array2.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index3 < length5) {
            var value2 = array2[index3];
            if (depth > 0 && predicate(value2)) {
              if (depth > 1) {
                baseFlatten(value2, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value2);
              }
            } else if (!isStrict) {
              result2[result2.length] = value2;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys2);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys2);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction4(object[key]);
          });
        }
        function baseGet(object, path2) {
          path2 = castPath(path2, object);
          var index3 = 0, length5 = path2.length;
          while (object != null && index3 < length5) {
            object = object[toKey(path2[index3++])];
          }
          return index3 && index3 == length5 ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray4(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value2) {
          if (value2 == null) {
            return value2 === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value2) ? getRawTag(value2) : objectToString(value2);
        }
        function baseGt(value2, other) {
          return value2 > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty2.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number3, start, end) {
          return number3 >= nativeMin(start, end) && number3 < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes3 = comparator ? arrayIncludesWith : arrayIncludes, length5 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array2 = arrays[othIndex];
            if (othIndex && iteratee2) {
              array2 = arrayMap(array2, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array2.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length5 >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined2;
          }
          array2 = arrays[0];
          var index3 = -1, seen = caches[0];
          outer:
            while (++index3 < length5 && result2.length < maxLength) {
              var value2 = array2[index3], computed = iteratee2 ? iteratee2(value2) : value2;
              value2 = comparator || value2 !== 0 ? value2 : 0;
              if (!(seen ? cacheHas(seen, computed) : includes3(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache2 = caches[othIndex];
                  if (!(cache2 ? cacheHas(cache2, computed) : includes3(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value2);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value2, key, object2) {
            setter(accumulator, iteratee2(value2), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path2, args) {
          path2 = castPath(path2, object);
          object = parent(object, path2);
          var func = object == null ? object : object[toKey(last5(path2))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value2) {
          return isObjectLike3(value2) && baseGetTag(value2) == argsTag;
        }
        function baseIsArrayBuffer(value2) {
          return isObjectLike3(value2) && baseGetTag(value2) == arrayBufferTag;
        }
        function baseIsDate(value2) {
          return isObjectLike3(value2) && baseGetTag(value2) == dateTag;
        }
        function baseIsEqual(value2, other, bitmask, customizer, stack) {
          if (value2 === other) {
            return true;
          }
          if (value2 == null || other == null || !isObjectLike3(value2) && !isObjectLike3(other)) {
            return value2 !== value2 && other !== other;
          }
          return baseIsEqualDeep(value2, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray4(object), othIsArr = isArray4(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value2) {
          return isObjectLike3(value2) && getTag(value2) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index3 = matchData.length, length5 = index3, noCustomizer = !customizer;
          if (object == null) {
            return !length5;
          }
          object = Object2(object);
          while (index3--) {
            var data2 = matchData[index3];
            if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
              return false;
            }
          }
          while (++index3 < length5) {
            data2 = matchData[index3];
            var key = data2[0], objValue = object[key], srcValue = data2[1];
            if (noCustomizer && data2[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value2) {
          if (!isObject6(value2) || isMasked(value2)) {
            return false;
          }
          var pattern = isFunction4(value2) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value2));
        }
        function baseIsRegExp(value2) {
          return isObjectLike3(value2) && baseGetTag(value2) == regexpTag;
        }
        function baseIsSet(value2) {
          return isObjectLike3(value2) && getTag(value2) == setTag;
        }
        function baseIsTypedArray(value2) {
          return isObjectLike3(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
        }
        function baseIteratee(value2) {
          if (typeof value2 == "function") {
            return value2;
          }
          if (value2 == null) {
            return identity7;
          }
          if (typeof value2 == "object") {
            return isArray4(value2) ? baseMatchesProperty(value2[0], value2[1]) : baseMatches(value2);
          }
          return property(value2);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty2.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject6(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value2, other) {
          return value2 < other;
        }
        function baseMap(collection, iteratee2) {
          var index3 = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value2, key, collection2) {
            result2[++index3] = iteratee2(value2, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path2, srcValue) {
          if (isKey(path2) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path2), srcValue);
          }
          return function(object) {
            var objValue = get4(object, path2);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject6(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray4(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray4(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject4(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject6(objValue) || isFunction4(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array2, n) {
          var length5 = array2.length;
          if (!length5) {
            return;
          }
          n += n < 0 ? length5 : 0;
          return isIndex(n, length5) ? array2[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray4(iteratee2)) {
                return function(value2) {
                  return baseGet(value2, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity7];
          }
          var index3 = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value2, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value2);
            });
            return { "criteria": criteria, "index": ++index3, "value": value2 };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value2, path2) {
            return hasIn(object, path2);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index3 = -1, length5 = paths.length, result2 = {};
          while (++index3 < length5) {
            var path2 = paths[index3], value2 = baseGet(object, path2);
            if (predicate(value2, path2)) {
              baseSet(result2, castPath(path2, object), value2);
            }
          }
          return result2;
        }
        function basePropertyDeep(path2) {
          return function(object) {
            return baseGet(object, path2);
          };
        }
        function basePullAll(array2, values5, iteratee2, comparator) {
          var indexOf6 = comparator ? baseIndexOfWith : baseIndexOf, index3 = -1, length5 = values5.length, seen = array2;
          if (array2 === values5) {
            values5 = copyArray(values5);
          }
          if (iteratee2) {
            seen = arrayMap(array2, baseUnary(iteratee2));
          }
          while (++index3 < length5) {
            var fromIndex = 0, value2 = values5[index3], computed = iteratee2 ? iteratee2(value2) : value2;
            while ((fromIndex = indexOf6(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array2) {
                splice6.call(seen, fromIndex, 1);
              }
              splice6.call(array2, fromIndex, 1);
            }
          }
          return array2;
        }
        function basePullAt(array2, indexes2) {
          var length5 = array2 ? indexes2.length : 0, lastIndex = length5 - 1;
          while (length5--) {
            var index3 = indexes2[length5];
            if (length5 == lastIndex || index3 !== previous) {
              var previous = index3;
              if (isIndex(index3)) {
                splice6.call(array2, index3, 1);
              } else {
                baseUnset(array2, index3);
              }
            }
          }
          return array2;
        }
        function baseRandom(lower2, upper2) {
          return lower2 + nativeFloor(nativeRandom() * (upper2 - lower2 + 1));
        }
        function baseRange(start, end, step2, fromRight) {
          var index3 = -1, length5 = nativeMax(nativeCeil((end - start) / (step2 || 1)), 0), result2 = Array2(length5);
          while (length5--) {
            result2[fromRight ? length5 : ++index3] = start;
            start += step2;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity7), func + "");
        }
        function baseSample(collection) {
          return arraySample(values4(collection));
        }
        function baseSampleSize(collection, n) {
          var array2 = values4(collection);
          return shuffleSelf(array2, baseClamp(n, 0, array2.length));
        }
        function baseSet(object, path2, value2, customizer) {
          if (!isObject6(object)) {
            return object;
          }
          path2 = castPath(path2, object);
          var index3 = -1, length5 = path2.length, lastIndex = length5 - 1, nested = object;
          while (nested != null && ++index3 < length5) {
            var key = toKey(path2[index3]), newValue = value2;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index3 != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject6(objValue) ? objValue : isIndex(path2[index3 + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity7 : function(func, data2) {
          metaMap.set(func, data2);
          return func;
        };
        var baseSetToString = !defineProperty ? identity7 : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant4(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values4(collection));
        }
        function baseSlice(array2, start, end) {
          var index3 = -1, length5 = array2.length;
          if (start < 0) {
            start = -start > length5 ? 0 : length5 + start;
          }
          end = end > length5 ? length5 : end;
          if (end < 0) {
            end += length5;
          }
          length5 = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length5);
          while (++index3 < length5) {
            result2[index3] = array2[index3 + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value2, index3, collection2) {
            result2 = predicate(value2, index3, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array2, value2, retHighest) {
          var low = 0, high = array2 == null ? low : array2.length;
          if (typeof value2 == "number" && value2 === value2 && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid2 = low + high >>> 1, computed = array2[mid2];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value2 : computed < value2)) {
                low = mid2 + 1;
              } else {
                high = mid2;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array2, value2, identity7, retHighest);
        }
        function baseSortedIndexBy(array2, value2, iteratee2, retHighest) {
          var low = 0, high = array2 == null ? 0 : array2.length;
          if (high === 0) {
            return 0;
          }
          value2 = iteratee2(value2);
          var valIsNaN = value2 !== value2, valIsNull = value2 === null, valIsSymbol = isSymbol(value2), valIsUndefined = value2 === undefined2;
          while (low < high) {
            var mid2 = nativeFloor((low + high) / 2), computed = iteratee2(array2[mid2]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value2 : computed < value2;
            }
            if (setLow) {
              low = mid2 + 1;
            } else {
              high = mid2;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array2, iteratee2) {
          var index3 = -1, length5 = array2.length, resIndex = 0, result2 = [];
          while (++index3 < length5) {
            var value2 = array2[index3], computed = iteratee2 ? iteratee2(value2) : value2;
            if (!index3 || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value2 === 0 ? 0 : value2;
            }
          }
          return result2;
        }
        function baseToNumber(value2) {
          if (typeof value2 == "number") {
            return value2;
          }
          if (isSymbol(value2)) {
            return NAN;
          }
          return +value2;
        }
        function baseToString(value2) {
          if (typeof value2 == "string") {
            return value2;
          }
          if (isArray4(value2)) {
            return arrayMap(value2, baseToString) + "";
          }
          if (isSymbol(value2)) {
            return symbolToString ? symbolToString.call(value2) : "";
          }
          var result2 = value2 + "";
          return result2 == "0" && 1 / value2 == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array2, iteratee2, comparator) {
          var index3 = -1, includes3 = arrayIncludes, length5 = array2.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes3 = arrayIncludesWith;
          } else if (length5 >= LARGE_ARRAY_SIZE) {
            var set10 = iteratee2 ? null : createSet(array2);
            if (set10) {
              return setToArray(set10);
            }
            isCommon = false;
            includes3 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index3 < length5) {
              var value2 = array2[index3], computed = iteratee2 ? iteratee2(value2) : value2;
              value2 = comparator || value2 !== 0 ? value2 : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value2);
              } else if (!includes3(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value2);
              }
            }
          return result2;
        }
        function baseUnset(object, path2) {
          path2 = castPath(path2, object);
          object = parent(object, path2);
          return object == null || delete object[toKey(last5(path2))];
        }
        function baseUpdate(object, path2, updater, customizer) {
          return baseSet(object, path2, updater(baseGet(object, path2)), customizer);
        }
        function baseWhile(array2, predicate, isDrop, fromRight) {
          var length5 = array2.length, index3 = fromRight ? length5 : -1;
          while ((fromRight ? index3-- : ++index3 < length5) && predicate(array2[index3], index3, array2)) {
          }
          return isDrop ? baseSlice(array2, fromRight ? 0 : index3, fromRight ? index3 + 1 : length5) : baseSlice(array2, fromRight ? index3 + 1 : 0, fromRight ? length5 : index3);
        }
        function baseWrapperValue(value2, actions) {
          var result2 = value2;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length5 = arrays.length;
          if (length5 < 2) {
            return length5 ? baseUniq(arrays[0]) : [];
          }
          var index3 = -1, result2 = Array2(length5);
          while (++index3 < length5) {
            var array2 = arrays[index3], othIndex = -1;
            while (++othIndex < length5) {
              if (othIndex != index3) {
                result2[index3] = baseDifference(result2[index3] || array2, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values5, assignFunc) {
          var index3 = -1, length5 = props.length, valsLength = values5.length, result2 = {};
          while (++index3 < length5) {
            var value2 = index3 < valsLength ? values5[index3] : undefined2;
            assignFunc(result2, props[index3], value2);
          }
          return result2;
        }
        function castArrayLikeObject(value2) {
          return isArrayLikeObject(value2) ? value2 : [];
        }
        function castFunction(value2) {
          return typeof value2 == "function" ? value2 : identity7;
        }
        function castPath(value2, object) {
          if (isArray4(value2)) {
            return value2;
          }
          return isKey(value2, object) ? [value2] : stringToPath(toString5(value2));
        }
        var castRest = baseRest;
        function castSlice(array2, start, end) {
          var length5 = array2.length;
          end = end === undefined2 ? length5 : end;
          return !start && end >= length5 ? array2 : baseSlice(array2, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id4) {
          return root2.clearTimeout(id4);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length5 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length5) : new buffer.constructor(length5);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result2).set(new Uint8Array(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value2, other) {
          if (value2 !== other) {
            var valIsDefined = value2 !== undefined2, valIsNull = value2 === null, valIsReflexive = value2 === value2, valIsSymbol = isSymbol(value2);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value2 > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value2 < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index3 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length5 = objCriteria.length, ordersLength = orders.length;
          while (++index3 < length5) {
            var result2 = compareAscending(objCriteria[index3], othCriteria[index3]);
            if (result2) {
              if (index3 >= ordersLength) {
                return result2;
              }
              var order = orders[index3];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset2 = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset2 + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array2) {
          var index3 = -1, length5 = source.length;
          array2 || (array2 = Array2(length5));
          while (++index3 < length5) {
            array2[index3] = source[index3];
          }
          return array2;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index3 = -1, length5 = props.length;
          while (++index3 < length5) {
            var key = props[index3];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray4(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index3 = -1, length5 = sources.length, customizer = length5 > 1 ? sources[length5 - 1] : undefined2, guard = length5 > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length5--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length5 < 3 ? undefined2 : customizer;
              length5 = 1;
            }
            object = Object2(object);
            while (++index3 < length5) {
              var source = sources[index3];
              if (source) {
                assigner(object, source, index3, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike2(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length5 = collection.length, index3 = fromRight ? length5 : -1, iterable = Object2(collection);
            while (fromRight ? index3-- : ++index3 < length5) {
              if (iteratee2(iterable[index3], index3, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index3 = -1, iterable = Object2(object), props = keysFunc(object), length5 = props.length;
            while (length5--) {
              var key = props[fromRight ? length5 : ++index3];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString5(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject6(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length5 = arguments.length, args = Array2(length5), index3 = length5, placeholder = getHolder(wrapper);
            while (index3--) {
              args[index3] = arguments[index3];
            }
            var holders = length5 < 3 && args[0] !== placeholder && args[length5 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length5 -= holders.length;
            if (length5 < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length5
              );
            }
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike2(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys2(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index3 = findIndexFunc(collection, predicate, fromIndex);
            return index3 > -1 ? iterable[iteratee2 ? collection[index3] : index3] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length5 = funcs.length, index3 = length5, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index3--) {
              var func = funcs[index3];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index3 = wrapper ? index3 : length5;
            while (++index3 < length5) {
              func = funcs[index3];
              var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData3(func) : undefined2;
              if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
                wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value2 = args[0];
              if (wrapper && args.length == 1 && isArray4(value2)) {
                return wrapper.plant(value2).value();
              }
              var index4 = 0, result2 = length5 ? funcs[index4].apply(this, args) : value2;
              while (++index4 < length5) {
                result2 = funcs[index4].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length5 = arguments.length, args = Array2(length5), index3 = length5;
            while (index3--) {
              args[index3] = arguments[index3];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length5 -= holdersCount;
            if (isCurried && length5 < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length5
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length5 = args.length;
            if (argPos) {
              args = reorder2(args, argPos);
            } else if (isFlip && length5 > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length5) {
              args.length = ary2;
            }
            if (this && this !== root2 && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value2, other) {
            var result2;
            if (value2 === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value2 !== undefined2) {
              result2 = value2;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value2 == "string" || typeof other == "string") {
                value2 = baseToString(value2);
                other = baseToString(other);
              } else {
                value2 = baseToNumber(value2);
                other = baseToNumber(other);
              }
              result2 = operator(value2, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length5, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length5) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length5 / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length5).join("") : result2.slice(0, length5);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step2) {
            if (step2 && typeof step2 != "number" && isIterateeCall(start, end, step2)) {
              end = step2 = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step2 = step2 === undefined2 ? start < end ? 1 : -1 : toFinite(step2);
            return baseRange(start, end, step2, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value2, other) {
            if (!(typeof value2 == "string" && typeof other == "string")) {
              value2 = toNumber(value2);
              other = toNumber(other);
            }
            return operator(value2, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData3(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number3, precision) {
            number3 = toNumber(number3);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number3)) {
              var pair = (toString5(number3) + "e").split("e"), value2 = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString5(value2) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number3);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop3 : function(values5) {
          return new Set2(values5);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length5 = partials ? partials.length : 0;
          if (!length5) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length5 -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data2 = isBindKey ? undefined2 : getData3(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data2) {
            mergeData2(newData, data2);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length5, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data2 ? baseSetData : setData3;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto3[key]) && !hasOwnProperty2.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject6(objValue) && isObject6(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value2) {
          return isPlainObject4(value2) ? undefined2 : value2;
        }
        function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array2);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array2;
          }
          var index3 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array2, other);
          stack.set(other, array2);
          while (++index3 < arrLength) {
            var arrValue = array2[index3], othValue = other[index3];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index3, other, array2, stack) : customizer(arrValue, othValue, index3, array2, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array2);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index3 = objLength;
          while (index3--) {
            var key = objProps[index3];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index3 < objLength) {
            key = objProps[index3];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten3), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys2, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData3 = !metaMap ? noop3 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array2 = realNames[result2], length5 = hasOwnProperty2.call(realNames, result2) ? array2.length : 0;
          while (length5--) {
            var data2 = array2[length5], otherFunc = data2.func;
            if (otherFunc == null || otherFunc == func) {
              return data2.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map6, key) {
          var data2 = map6.__data__;
          return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
        }
        function getMatchData(object) {
          var result2 = keys2(object), length5 = result2.length;
          while (length5--) {
            var key = result2[length5], value2 = object[key];
            result2[length5] = [key, value2, isStrictComparable(value2)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value2 = getValue(object, key);
          return baseIsNative(value2) ? value2 : undefined2;
        }
        function getRawTag(value2) {
          var isOwn = hasOwnProperty2.call(value2, symToStringTag), tag = value2[symToStringTag];
          try {
            value2[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value2);
          if (unmasked) {
            if (isOwn) {
              value2[symToStringTag] = tag;
            } else {
              delete value2[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map3 && getTag(new Map3()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value2) {
            var result2 = baseGetTag(value2), Ctor = result2 == objectTag ? value2.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index3 = -1, length5 = transforms.length;
          while (++index3 < length5) {
            var data2 = transforms[index3], size4 = data2.size;
            switch (data2.type) {
              case "drop":
                start += size4;
                break;
              case "dropRight":
                end -= size4;
                break;
              case "take":
                end = nativeMin(end, start + size4);
                break;
              case "takeRight":
                start = nativeMax(start, end - size4);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path2, hasFunc) {
          path2 = castPath(path2, object);
          var index3 = -1, length5 = path2.length, result2 = false;
          while (++index3 < length5) {
            var key = toKey(path2[index3]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index3 != length5) {
            return result2;
          }
          length5 = object == null ? 0 : object.length;
          return !!length5 && isLength(length5) && isIndex(key, length5) && (isArray4(object) || isArguments(object));
        }
        function initCloneArray(array2) {
          var length5 = array2.length, result2 = new array2.constructor(length5);
          if (length5 && typeof array2[0] == "string" && hasOwnProperty2.call(array2, "index")) {
            result2.index = array2.index;
            result2.input = array2.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length5 = details.length;
          if (!length5) {
            return source;
          }
          var lastIndex = length5 - 1;
          details[lastIndex] = (length5 > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length5 > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value2) {
          return isArray4(value2) || isArguments(value2) || !!(spreadableSymbol && value2 && value2[spreadableSymbol]);
        }
        function isIndex(value2, length5) {
          var type = typeof value2;
          length5 = length5 == null ? MAX_SAFE_INTEGER : length5;
          return !!length5 && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length5);
        }
        function isIterateeCall(value2, index3, object) {
          if (!isObject6(object)) {
            return false;
          }
          var type = typeof index3;
          if (type == "number" ? isArrayLike2(object) && isIndex(index3, object.length) : type == "string" && index3 in object) {
            return eq(object[index3], value2);
          }
          return false;
        }
        function isKey(value2, object) {
          if (isArray4(value2)) {
            return false;
          }
          var type = typeof value2;
          if (type == "number" || type == "symbol" || type == "boolean" || value2 == null || isSymbol(value2)) {
            return true;
          }
          return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object != null && value2 in Object2(object);
        }
        function isKeyable(value2) {
          var type = typeof value2;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data2 = getData3(other);
          return !!data2 && func === data2[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction4 : stubFalse;
        function isPrototype(value2) {
          var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto3;
          return value2 === proto;
        }
        function isStrictComparable(value2) {
          return value2 === value2 && !isObject6(value2);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize5(func, function(key) {
            if (cache2.size === MAX_MEMOIZE_SIZE) {
              cache2.clear();
            }
            return key;
          });
          var cache2 = result2.cache;
          return result2;
        }
        function mergeData2(data2, source) {
          var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data2;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data2[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value2 = source[3];
          if (value2) {
            var partials = data2[3];
            data2[3] = partials ? composeArgs(partials, value2, source[4]) : value2;
            data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source[4];
          }
          value2 = source[5];
          if (value2) {
            partials = data2[5];
            data2[5] = partials ? composeArgsRight(partials, value2, source[6]) : value2;
            data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source[6];
          }
          value2 = source[7];
          if (value2) {
            data2[7] = value2;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data2[8] = data2[8] == null ? source[8] : nativeMin(data2[8], source[8]);
          }
          if (data2[9] == null) {
            data2[9] = source[9];
          }
          data2[0] = source[0];
          data2[1] = newBitmask;
          return data2;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value2) {
          return nativeObjectToString.call(value2);
        }
        function overRest(func, start, transform3) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index3 = -1, length5 = nativeMax(args.length - start, 0), array2 = Array2(length5);
            while (++index3 < length5) {
              array2[index3] = args[start + index3];
            }
            index3 = -1;
            var otherArgs = Array2(start + 1);
            while (++index3 < start) {
              otherArgs[index3] = args[index3];
            }
            otherArgs[start] = transform3(array2);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path2) {
          return path2.length < 2 ? object : baseGet(object, baseSlice(path2, 0, -1));
        }
        function reorder2(array2, indexes2) {
          var arrLength = array2.length, length5 = nativeMin(indexes2.length, arrLength), oldArray = copyArray(array2);
          while (length5--) {
            var index3 = indexes2[length5];
            array2[length5] = isIndex(index3, arrLength) ? oldArray[index3] : undefined2;
          }
          return array2;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData3 = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root2.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count4 = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count4 >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count4 = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array2, size4) {
          var index3 = -1, length5 = array2.length, lastIndex = length5 - 1;
          size4 = size4 === undefined2 ? length5 : size4;
          while (++index3 < size4) {
            var rand = baseRandom(index3, lastIndex), value2 = array2[rand];
            array2[rand] = array2[index3];
            array2[index3] = value2;
          }
          array2.length = size4;
          return array2;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number3, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match);
          });
          return result2;
        });
        function toKey(value2) {
          if (typeof value2 == "string" || isSymbol(value2)) {
            return value2;
          }
          var result2 = value2 + "";
          return result2 == "0" && 1 / value2 == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value2 = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value2)) {
              details.push(value2);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array2, size4, guard) {
          if (guard ? isIterateeCall(array2, size4, guard) : size4 === undefined2) {
            size4 = 1;
          } else {
            size4 = nativeMax(toInteger(size4), 0);
          }
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5 || size4 < 1) {
            return [];
          }
          var index3 = 0, resIndex = 0, result2 = Array2(nativeCeil(length5 / size4));
          while (index3 < length5) {
            result2[resIndex++] = baseSlice(array2, index3, index3 += size4);
          }
          return result2;
        }
        function compact(array2) {
          var index3 = -1, length5 = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
          while (++index3 < length5) {
            var value2 = array2[index3];
            if (value2) {
              result2[resIndex++] = value2;
            }
          }
          return result2;
        }
        function concat() {
          var length5 = arguments.length;
          if (!length5) {
            return [];
          }
          var args = Array2(length5 - 1), array2 = arguments[0], index3 = length5;
          while (index3--) {
            args[index3 - 1] = arguments[index3];
          }
          return arrayPush(isArray4(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
        }
        var difference2 = baseRest(function(array2, values5) {
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values5, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array2, values5) {
          var iteratee2 = last5(values5);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values5, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array2, values5) {
          var comparator = last5(values5);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values5, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array2, n, guard) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array2, n < 0 ? 0 : n, length5);
        }
        function dropRight(array2, n, guard) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length5 - n;
          return baseSlice(array2, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
        }
        function fill(array2, value2, start, end) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array2, value2, start)) {
            start = 0;
            end = length5;
          }
          return baseFill(array2, value2, start, end);
        }
        function findIndex(array2, predicate, fromIndex) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return -1;
          }
          var index3 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index3 < 0) {
            index3 = nativeMax(length5 + index3, 0);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index3);
        }
        function findLastIndex(array2, predicate, fromIndex) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return -1;
          }
          var index3 = length5 - 1;
          if (fromIndex !== undefined2) {
            index3 = toInteger(fromIndex);
            index3 = fromIndex < 0 ? nativeMax(length5 + index3, 0) : nativeMin(index3, length5 - 1);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index3, true);
        }
        function flatten3(array2) {
          var length5 = array2 == null ? 0 : array2.length;
          return length5 ? baseFlatten(array2, 1) : [];
        }
        function flattenDeep(array2) {
          var length5 = array2 == null ? 0 : array2.length;
          return length5 ? baseFlatten(array2, INFINITY) : [];
        }
        function flattenDepth(array2, depth) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array2, depth);
        }
        function fromPairs(pairs2) {
          var index3 = -1, length5 = pairs2 == null ? 0 : pairs2.length, result2 = {};
          while (++index3 < length5) {
            var pair = pairs2[index3];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head3(array2) {
          return array2 && array2.length ? array2[0] : undefined2;
        }
        function indexOf5(array2, value2, fromIndex) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return -1;
          }
          var index3 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index3 < 0) {
            index3 = nativeMax(length5 + index3, 0);
          }
          return baseIndexOf(array2, value2, index3);
        }
        function initial(array2) {
          var length5 = array2 == null ? 0 : array2.length;
          return length5 ? baseSlice(array2, 0, -1) : [];
        }
        var intersection3 = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last5(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last5(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last5(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array2, separator) {
          return array2 == null ? "" : nativeJoin.call(array2, separator);
        }
        function last5(array2) {
          var length5 = array2 == null ? 0 : array2.length;
          return length5 ? array2[length5 - 1] : undefined2;
        }
        function lastIndexOf(array2, value2, fromIndex) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return -1;
          }
          var index3 = length5;
          if (fromIndex !== undefined2) {
            index3 = toInteger(fromIndex);
            index3 = index3 < 0 ? nativeMax(length5 + index3, 0) : nativeMin(index3, length5 - 1);
          }
          return value2 === value2 ? strictLastIndexOf(array2, value2, index3) : baseFindIndex(array2, baseIsNaN, index3, true);
        }
        function nth(array2, n) {
          return array2 && array2.length ? baseNth(array2, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array2, values5) {
          return array2 && array2.length && values5 && values5.length ? basePullAll(array2, values5) : array2;
        }
        function pullAllBy(array2, values5, iteratee2) {
          return array2 && array2.length && values5 && values5.length ? basePullAll(array2, values5, getIteratee(iteratee2, 2)) : array2;
        }
        function pullAllWith(array2, values5, comparator) {
          return array2 && array2.length && values5 && values5.length ? basePullAll(array2, values5, undefined2, comparator) : array2;
        }
        var pullAt = flatRest(function(array2, indexes2) {
          var length5 = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes2);
          basePullAt(array2, arrayMap(indexes2, function(index3) {
            return isIndex(index3, length5) ? +index3 : index3;
          }).sort(compareAscending));
          return result2;
        });
        function remove2(array2, predicate) {
          var result2 = [];
          if (!(array2 && array2.length)) {
            return result2;
          }
          var index3 = -1, indexes2 = [], length5 = array2.length;
          predicate = getIteratee(predicate, 3);
          while (++index3 < length5) {
            var value2 = array2[index3];
            if (predicate(value2, index3, array2)) {
              result2.push(value2);
              indexes2.push(index3);
            }
          }
          basePullAt(array2, indexes2);
          return result2;
        }
        function reverse2(array2) {
          return array2 == null ? array2 : nativeReverse.call(array2);
        }
        function slice3(array2, start, end) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array2, start, end)) {
            start = 0;
            end = length5;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length5 : toInteger(end);
          }
          return baseSlice(array2, start, end);
        }
        function sortedIndex2(array2, value2) {
          return baseSortedIndex(array2, value2);
        }
        function sortedIndexBy(array2, value2, iteratee2) {
          return baseSortedIndexBy(array2, value2, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array2, value2) {
          var length5 = array2 == null ? 0 : array2.length;
          if (length5) {
            var index3 = baseSortedIndex(array2, value2);
            if (index3 < length5 && eq(array2[index3], value2)) {
              return index3;
            }
          }
          return -1;
        }
        function sortedLastIndex(array2, value2) {
          return baseSortedIndex(array2, value2, true);
        }
        function sortedLastIndexBy(array2, value2, iteratee2) {
          return baseSortedIndexBy(array2, value2, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array2, value2) {
          var length5 = array2 == null ? 0 : array2.length;
          if (length5) {
            var index3 = baseSortedIndex(array2, value2, true) - 1;
            if (eq(array2[index3], value2)) {
              return index3;
            }
          }
          return -1;
        }
        function sortedUniq(array2) {
          return array2 && array2.length ? baseSortedUniq(array2) : [];
        }
        function sortedUniqBy(array2, iteratee2) {
          return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array2) {
          var length5 = array2 == null ? 0 : array2.length;
          return length5 ? baseSlice(array2, 1, length5) : [];
        }
        function take(array2, n, guard) {
          if (!(array2 && array2.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array2, 0, n < 0 ? 0 : n);
        }
        function takeRight(array2, n, guard) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length5 - n;
          return baseSlice(array2, n < 0 ? 0 : n, length5);
        }
        function takeRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
        }
        var union2 = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last5(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last5(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq3(array2) {
          return array2 && array2.length ? baseUniq(array2) : [];
        }
        function uniqBy2(array2, iteratee2) {
          return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array2, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array2 && array2.length ? baseUniq(array2, undefined2, comparator) : [];
        }
        function unzip(array2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var length5 = 0;
          array2 = arrayFilter(array2, function(group3) {
            if (isArrayLikeObject(group3)) {
              length5 = nativeMax(group3.length, length5);
              return true;
            }
          });
          return baseTimes(length5, function(index3) {
            return arrayMap(array2, baseProperty(index3));
          });
        }
        function unzipWith(array2, iteratee2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var result2 = unzip(array2);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group3) {
            return apply(iteratee2, undefined2, group3);
          });
        }
        var without = baseRest(function(array2, values5) {
          return isArrayLikeObject(array2) ? baseDifference(array2, values5) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last5(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last5(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip2 = baseRest(unzip);
        function zipObject(props, values5) {
          return baseZipObject(props || [], values5 || [], assignValue);
        }
        function zipObjectDeep(props, values5) {
          return baseZipObject(props || [], values5 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length5 = arrays.length, iteratee2 = length5 > 1 ? arrays[length5 - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value2) {
          var result2 = lodash(value2);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value2, interceptor) {
          interceptor(value2);
          return value2;
        }
        function thru(value2, interceptor) {
          return interceptor(value2);
        }
        var wrapperAt = flatRest(function(paths) {
          var length5 = paths.length, start = length5 ? paths[0] : 0, value2 = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length5 > 1 || this.__actions__.length || !(value2 instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value2 = value2.slice(start, +start + (length5 ? 1 : 0));
          value2.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value2, this.__chain__).thru(function(array2) {
            if (length5 && !array2.length) {
              array2.push(undefined2);
            }
            return array2;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value2 = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value2 };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value2) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone9 = wrapperClone(parent2);
            clone9.__index__ = 0;
            clone9.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone9;
            } else {
              result2 = clone9;
            }
            var previous = clone9;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value2;
          return result2;
        }
        function wrapperReverse() {
          var value2 = this.__wrapped__;
          if (value2 instanceof LazyWrapper) {
            var wrapped = value2;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse2],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse2);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value2, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every2(collection, predicate, guard) {
          var func = isArray4(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter3(collection, predicate) {
          var func = isArray4(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find6 = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map5(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map5(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map5(collection, iteratee2), depth);
        }
        function forEach4(collection, iteratee2) {
          var func = isArray4(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray4(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy3 = createAggregator(function(result2, value2, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value2);
          } else {
            baseAssignValue(result2, key, [value2]);
          }
        });
        function includes2(collection, value2, fromIndex, guard) {
          collection = isArrayLike2(collection) ? collection : values4(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length5 = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length5 + fromIndex, 0);
          }
          return isString5(collection) ? fromIndex <= length5 && collection.indexOf(value2, fromIndex) > -1 : !!length5 && baseIndexOf(collection, value2, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path2, args) {
          var index3 = -1, isFunc = typeof path2 == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value2) {
            result2[++index3] = isFunc ? apply(path2, value2, args) : baseInvoke(value2, path2, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value2, key) {
          baseAssignValue(result2, key, value2);
        });
        function map5(collection, iteratee2) {
          var func = isArray4(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray4(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray4(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition2 = createAggregator(function(result2, value2, key) {
          result2[key ? 0 : 1].push(value2);
        }, function() {
          return [[], []];
        });
        function reduce4(collection, iteratee2, accumulator) {
          var func = isArray4(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray4(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray4(collection) ? arrayFilter : baseFilter;
          return func(collection, negate4(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray4(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray4(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle2(collection) {
          var func = isArray4(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size3(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike2(collection)) {
            return isString5(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some3(collection, predicate, guard) {
          var func = isArray4(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy2 = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length5 = iteratees.length;
          if (length5 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length5 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now2 = ctxNow || function() {
          return root2.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce2(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject6(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now2();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel2() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now2());
          }
          function debounced() {
            var time = now2(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel2;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize5(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
            if (cache2.has(key)) {
              return cache2.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache2.set(key, result2) || cache2;
            return result2;
          };
          memoized.cache = new (memoize5.Cache || MapCache)();
          return memoized;
        }
        memoize5.Cache = MapCache;
        function negate4(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray4(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index3 = -1, length5 = nativeMin(args.length, funcsLength);
            while (++index3 < length5) {
              args[index3] = transforms[index3].call(this, args[index3]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes2) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes2);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array2 = args[start], otherArgs = castSlice(args, 0, start);
            if (array2) {
              arrayPush(otherArgs, array2);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject6(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce2(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value2, wrapper) {
          return partial(castFunction(wrapper), value2);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value2 = arguments[0];
          return isArray4(value2) ? value2 : [value2];
        }
        function clone8(value2) {
          return baseClone(value2, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value2, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value2, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep2(value2) {
          return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value2, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys2(source));
        }
        function eq(value2, other) {
          return value2 === other || value2 !== value2 && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value2, other) {
          return value2 >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value2) {
          return isObjectLike3(value2) && hasOwnProperty2.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
        };
        var isArray4 = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike2(value2) {
          return value2 != null && isLength(value2.length) && !isFunction4(value2);
        }
        function isArrayLikeObject(value2) {
          return isObjectLike3(value2) && isArrayLike2(value2);
        }
        function isBoolean3(value2) {
          return value2 === true || value2 === false || isObjectLike3(value2) && baseGetTag(value2) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement4(value2) {
          return isObjectLike3(value2) && value2.nodeType === 1 && !isPlainObject4(value2);
        }
        function isEmpty3(value2) {
          if (value2 == null) {
            return true;
          }
          if (isArrayLike2(value2) && (isArray4(value2) || typeof value2 == "string" || typeof value2.splice == "function" || isBuffer(value2) || isTypedArray(value2) || isArguments(value2))) {
            return !value2.length;
          }
          var tag = getTag(value2);
          if (tag == mapTag || tag == setTag) {
            return !value2.size;
          }
          if (isPrototype(value2)) {
            return !baseKeys(value2).length;
          }
          for (var key in value2) {
            if (hasOwnProperty2.call(value2, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual3(value2, other) {
          return baseIsEqual(value2, other);
        }
        function isEqualWith(value2, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value2, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value2, other, undefined2, customizer) : !!result2;
        }
        function isError(value2) {
          if (!isObjectLike3(value2)) {
            return false;
          }
          var tag = baseGetTag(value2);
          return tag == errorTag || tag == domExcTag || typeof value2.message == "string" && typeof value2.name == "string" && !isPlainObject4(value2);
        }
        function isFinite2(value2) {
          return typeof value2 == "number" && nativeIsFinite(value2);
        }
        function isFunction4(value2) {
          if (!isObject6(value2)) {
            return false;
          }
          var tag = baseGetTag(value2);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger3(value2) {
          return typeof value2 == "number" && value2 == toInteger(value2);
        }
        function isLength(value2) {
          return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
        }
        function isObject6(value2) {
          var type = typeof value2;
          return value2 != null && (type == "object" || type == "function");
        }
        function isObjectLike3(value2) {
          return value2 != null && typeof value2 == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch2(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value2) {
          return isNumber5(value2) && value2 != +value2;
        }
        function isNative(value2) {
          if (isMaskable(value2)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value2);
        }
        function isNull2(value2) {
          return value2 === null;
        }
        function isNil3(value2) {
          return value2 == null;
        }
        function isNumber5(value2) {
          return typeof value2 == "number" || isObjectLike3(value2) && baseGetTag(value2) == numberTag;
        }
        function isPlainObject4(value2) {
          if (!isObjectLike3(value2) || baseGetTag(value2) != objectTag) {
            return false;
          }
          var proto = getPrototype(value2);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value2) {
          return isInteger3(value2) && value2 >= -MAX_SAFE_INTEGER && value2 <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString5(value2) {
          return typeof value2 == "string" || !isArray4(value2) && isObjectLike3(value2) && baseGetTag(value2) == stringTag;
        }
        function isSymbol(value2) {
          return typeof value2 == "symbol" || isObjectLike3(value2) && baseGetTag(value2) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined3(value2) {
          return value2 === undefined2;
        }
        function isWeakMap(value2) {
          return isObjectLike3(value2) && getTag(value2) == weakMapTag;
        }
        function isWeakSet(value2) {
          return isObjectLike3(value2) && baseGetTag(value2) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value2, other) {
          return value2 <= other;
        });
        function toArray(value2) {
          if (!value2) {
            return [];
          }
          if (isArrayLike2(value2)) {
            return isString5(value2) ? stringToArray(value2) : copyArray(value2);
          }
          if (symIterator && value2[symIterator]) {
            return iteratorToArray(value2[symIterator]());
          }
          var tag = getTag(value2), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values4;
          return func(value2);
        }
        function toFinite(value2) {
          if (!value2) {
            return value2 === 0 ? value2 : 0;
          }
          value2 = toNumber(value2);
          if (value2 === INFINITY || value2 === -INFINITY) {
            var sign3 = value2 < 0 ? -1 : 1;
            return sign3 * MAX_INTEGER;
          }
          return value2 === value2 ? value2 : 0;
        }
        function toInteger(value2) {
          var result2 = toFinite(value2), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value2) {
          return value2 ? baseClamp(toInteger(value2), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value2) {
          if (typeof value2 == "number") {
            return value2;
          }
          if (isSymbol(value2)) {
            return NAN;
          }
          if (isObject6(value2)) {
            var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
            value2 = isObject6(other) ? other + "" : other;
          }
          if (typeof value2 != "string") {
            return value2 === 0 ? value2 : +value2;
          }
          value2 = baseTrim(value2);
          var isBinary = reIsBinary.test(value2);
          return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
        }
        function toPlainObject(value2) {
          return copyObject(value2, keysIn(value2));
        }
        function toSafeInteger(value2) {
          return value2 ? baseClamp(toInteger(value2), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value2 === 0 ? value2 : 0;
        }
        function toString5(value2) {
          return value2 == null ? "" : baseToString(value2);
        }
        var assign3 = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike2(source)) {
            copyObject(source, keys2(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys2(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create8(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults4 = baseRest(function(object, sources) {
          object = Object2(object);
          var index3 = -1;
          var length5 = sources.length;
          var guard = length5 > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length5 = 1;
          }
          while (++index3 < length5) {
            var source = sources[index3];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value2 = object[key];
              if (value2 === undefined2 || eq(value2, objectProto3[key]) && !hasOwnProperty2.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith2, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys2(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get4(object, path2, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path2);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path2) {
          return object != null && hasPath(object, path2, baseHas);
        }
        function hasIn(object, path2) {
          return object != null && hasPath(object, path2, baseHasIn);
        }
        var invert5 = createInverter(function(result2, value2, key) {
          if (value2 != null && typeof value2.toString != "function") {
            value2 = nativeObjectToString.call(value2);
          }
          result2[value2] = key;
        }, constant4(identity7));
        var invertBy = createInverter(function(result2, value2, key) {
          if (value2 != null && typeof value2.toString != "function") {
            value2 = nativeObjectToString.call(value2);
          }
          if (hasOwnProperty2.call(result2, value2)) {
            result2[value2].push(key);
          } else {
            result2[value2] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys2(object) {
          return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value2, key, object2) {
            baseAssignValue(result2, iteratee2(value2, key, object2), value2);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value2, key, object2) {
            baseAssignValue(result2, key, iteratee2(value2, key, object2));
          });
          return result2;
        }
        var merge2 = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith2 = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit3 = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path2) {
            path2 = castPath(path2, object);
            isDeep || (isDeep = path2.length > 1);
            return path2;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length5 = paths.length;
          while (length5--) {
            baseUnset(result2, paths[length5]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate4(getIteratee(predicate)));
        }
        var pick3 = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value2, path2) {
            return predicate(value2, path2[0]);
          });
        }
        function result(object, path2, defaultValue) {
          path2 = castPath(path2, object);
          var index3 = -1, length5 = path2.length;
          if (!length5) {
            length5 = 1;
            object = undefined2;
          }
          while (++index3 < length5) {
            var value2 = object == null ? undefined2 : object[toKey(path2[index3])];
            if (value2 === undefined2) {
              index3 = length5;
              value2 = defaultValue;
            }
            object = isFunction4(value2) ? value2.call(object) : value2;
          }
          return object;
        }
        function set9(object, path2, value2) {
          return object == null ? object : baseSet(object, path2, value2);
        }
        function setWith(object, path2, value2, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path2, value2, customizer);
        }
        var toPairs = createToPairs(keys2);
        var toPairsIn = createToPairs(keysIn);
        function transform2(object, iteratee2, accumulator) {
          var isArr = isArray4(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject6(object)) {
              accumulator = isFunction4(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value2, index3, object2) {
            return iteratee2(accumulator, value2, index3, object2);
          });
          return accumulator;
        }
        function unset(object, path2) {
          return object == null ? true : baseUnset(object, path2);
        }
        function update2(object, path2, updater) {
          return object == null ? object : baseUpdate(object, path2, castFunction(updater));
        }
        function updateWith(object, path2, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path2, castFunction(updater), customizer);
        }
        function values4(object) {
          return object == null ? [] : baseValues(object, keys2(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp3(number3, lower2, upper2) {
          if (upper2 === undefined2) {
            upper2 = lower2;
            lower2 = undefined2;
          }
          if (upper2 !== undefined2) {
            upper2 = toNumber(upper2);
            upper2 = upper2 === upper2 ? upper2 : 0;
          }
          if (lower2 !== undefined2) {
            lower2 = toNumber(lower2);
            lower2 = lower2 === lower2 ? lower2 : 0;
          }
          return baseClamp(toNumber(number3), lower2, upper2);
        }
        function inRange2(number3, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number3 = toNumber(number3);
          return baseInRange(number3, start, end);
        }
        function random5(lower2, upper2, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower2, upper2, floating)) {
            upper2 = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper2 == "boolean") {
              floating = upper2;
              upper2 = undefined2;
            } else if (typeof lower2 == "boolean") {
              floating = lower2;
              lower2 = undefined2;
            }
          }
          if (lower2 === undefined2 && upper2 === undefined2) {
            lower2 = 0;
            upper2 = 1;
          } else {
            lower2 = toFinite(lower2);
            if (upper2 === undefined2) {
              upper2 = lower2;
              lower2 = 0;
            } else {
              upper2 = toFinite(upper2);
            }
          }
          if (lower2 > upper2) {
            var temp = lower2;
            lower2 = upper2;
            upper2 = temp;
          }
          if (floating || lower2 % 1 || upper2 % 1) {
            var rand = nativeRandom();
            return nativeMin(lower2 + rand * (upper2 - lower2 + freeParseFloat("1e-" + ((rand + "").length - 1))), upper2);
          }
          return baseRandom(lower2, upper2);
        }
        var camelCase2 = createCompounder(function(result2, word2, index3) {
          word2 = word2.toLowerCase();
          return result2 + (index3 ? capitalize(word2) : word2);
        });
        function capitalize(string) {
          return upperFirst2(toString5(string).toLowerCase());
        }
        function deburr(string) {
          string = toString5(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString5(string);
          target = baseToString(target);
          var length5 = string.length;
          position = position === undefined2 ? length5 : baseClamp(toInteger(position), 0, length5);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString5(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString5(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase2 = createCompounder(function(result2, word2, index3) {
          return result2 + (index3 ? "-" : "") + word2.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word2, index3) {
          return result2 + (index3 ? " " : "") + word2.toLowerCase();
        });
        var lowerFirst2 = createCaseFirst("toLowerCase");
        function pad3(string, length5, chars) {
          string = toString5(string);
          length5 = toInteger(length5);
          var strLength = length5 ? stringSize(string) : 0;
          if (!length5 || strLength >= length5) {
            return string;
          }
          var mid2 = (length5 - strLength) / 2;
          return createPadding(nativeFloor(mid2), chars) + string + createPadding(nativeCeil(mid2), chars);
        }
        function padEnd(string, length5, chars) {
          string = toString5(string);
          length5 = toInteger(length5);
          var strLength = length5 ? stringSize(string) : 0;
          return length5 && strLength < length5 ? string + createPadding(length5 - strLength, chars) : string;
        }
        function padStart(string, length5, chars) {
          string = toString5(string);
          length5 = toInteger(length5);
          var strLength = length5 ? stringSize(string) : 0;
          return length5 && strLength < length5 ? createPadding(length5 - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString5(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString5(string), n);
        }
        function replace() {
          var args = arguments, string = toString5(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word2, index3) {
          return result2 + (index3 ? "_" : "") + word2.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString5(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word2, index3) {
          return result2 + (index3 ? " " : "") + upperFirst2(word2);
        });
        function startsWith2(string, target, position) {
          string = toString5(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString5(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index3 = 0, interpolate4 = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate4.source + "|" + (interpolate4 === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index3, offset2).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index3 = offset2 + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value2) {
          return toString5(value2).toLowerCase();
        }
        function toUpper(value2) {
          return toString5(value2).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString5(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString5(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString5(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length5 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject6(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length5 = "length" in options ? toInteger(options.length) : length5;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString5(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length5 >= strLength) {
            return string;
          }
          var end = length5 - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString5(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index3 = result2.lastIndexOf(separator);
            if (index3 > -1) {
              result2 = result2.slice(0, index3);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString5(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word2, index3) {
          return result2 + (index3 ? " " : "") + word2.toUpperCase();
        });
        var upperFirst2 = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString5(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs2) {
          var length5 = pairs2 == null ? 0 : pairs2.length, toIteratee = getIteratee();
          pairs2 = !length5 ? [] : arrayMap(pairs2, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index3 = -1;
            while (++index3 < length5) {
              var pair = pairs2[index3];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant4(value2) {
          return function() {
            return value2;
          };
        }
        function defaultTo(value2, defaultValue) {
          return value2 == null || value2 !== value2 ? defaultValue : value2;
        }
        var flow4 = createFlow();
        var flowRight = createFlow(true);
        function identity7(value2) {
          return value2;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path2, srcValue) {
          return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path2, args) {
          return function(object) {
            return baseInvoke(object, path2, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path2) {
            return baseInvoke(object, path2, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys2(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject6(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys2(source));
          }
          var chain2 = !(isObject6(options) && "chain" in options) || !!options.chain, isFunc = isFunction4(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root2._ === this) {
            root2._ = oldDash;
          }
          return this;
        }
        function noop3() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path2) {
          return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
        }
        function propertyOf(object) {
          return function(path2) {
            return object == null ? undefined2 : baseGet(object, path2);
          };
        }
        var range3 = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index3 = MAX_ARRAY_LENGTH, length5 = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length5, iteratee2);
          while (++index3 < n) {
            iteratee2(index3);
          }
          return result2;
        }
        function toPath(value2) {
          if (isArray4(value2)) {
            return arrayMap(value2, toKey);
          }
          return isSymbol(value2) ? [value2] : copyArray(stringToPath(toString5(value2)));
        }
        function uniqueId3(prefix) {
          var id4 = ++idCounter;
          return toString5(prefix) + id4;
        }
        var add10 = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil6 = createRound("ceil");
        var divide6 = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor4 = createRound("floor");
        function max11(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity7, baseGt) : undefined2;
        }
        function maxBy2(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean3(array2) {
          return baseMean(array2, identity7);
        }
        function meanBy(array2, iteratee2) {
          return baseMean(array2, getIteratee(iteratee2, 2));
        }
        function min10(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity7, baseLt) : undefined2;
        }
        function minBy(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply7 = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round5 = createRound("round");
        var subtract6 = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum4(array2) {
          return array2 && array2.length ? baseSum(array2, identity7) : 0;
        }
        function sumBy(array2, iteratee2) {
          return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign3;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant4;
        lodash.countBy = countBy;
        lodash.create = create8;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce2;
        lodash.defaults = defaults4;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference2;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter3;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten3;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow4;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy3;
        lodash.initial = initial;
        lodash.intersection = intersection3;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert5;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys2;
        lodash.keysIn = keysIn;
        lodash.map = map5;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize5;
        lodash.merge = merge2;
        lodash.mergeWith = mergeWith2;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate4;
        lodash.nthArg = nthArg;
        lodash.omit = omit3;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition2;
        lodash.pick = pick3;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range3;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove2;
        lodash.rest = rest;
        lodash.reverse = reverse2;
        lodash.sampleSize = sampleSize;
        lodash.set = set9;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle2;
        lodash.slice = slice3;
        lodash.sortBy = sortBy2;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform2;
        lodash.unary = unary;
        lodash.union = union2;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq3;
        lodash.uniqBy = uniqBy2;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update2;
        lodash.updateWith = updateWith;
        lodash.values = values4;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip2;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add10;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase2;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil6;
        lodash.clamp = clamp3;
        lodash.clone = clone8;
        lodash.cloneDeep = cloneDeep2;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide6;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every2;
        lodash.find = find6;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor4;
        lodash.forEach = forEach4;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get4;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head3;
        lodash.identity = identity7;
        lodash.includes = includes2;
        lodash.indexOf = indexOf5;
        lodash.inRange = inRange2;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray4;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike2;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean3;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate2;
        lodash.isElement = isElement4;
        lodash.isEmpty = isEmpty3;
        lodash.isEqual = isEqual3;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction4;
        lodash.isInteger = isInteger3;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch2;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil3;
        lodash.isNull = isNull2;
        lodash.isNumber = isNumber5;
        lodash.isObject = isObject6;
        lodash.isObjectLike = isObjectLike3;
        lodash.isPlainObject = isPlainObject4;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString5;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined3;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase2;
        lodash.last = last5;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst2;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max11;
        lodash.maxBy = maxBy2;
        lodash.mean = mean3;
        lodash.meanBy = meanBy;
        lodash.min = min10;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply7;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop3;
        lodash.now = now2;
        lodash.pad = pad3;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random5;
        lodash.reduce = reduce4;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round5;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size3;
        lodash.snakeCase = snakeCase;
        lodash.some = some3;
        lodash.sortedIndex = sortedIndex2;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith2;
        lodash.subtract = subtract6;
        lodash.sum = sum4;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString5;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId3;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst2;
        lodash.each = forEach4;
        lodash.eachRight = forEachRight;
        lodash.first = head3;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index3) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index3 ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index3) {
          var type = index3 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index3) {
          var takeName = "take" + (index3 ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index3) {
          var dropName = "drop" + (index3 ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity7);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
          if (typeof path2 == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value2) {
            return baseInvoke(value2, path2, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate4(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value2 = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value2 instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray4(value2);
            var interceptor = function(value3) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value3], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value2 = onlyLazy ? value2 : new LazyWrapper(this);
              var result2 = func.apply(value2, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value2 = this.value();
              return func.apply(isArray4(value2) ? value2 : [], args);
            }
            return this[chainName](function(value3) {
              return func.apply(isArray4(value3) ? value3 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _2 = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root2._ = _2;
        define(function() {
          return _2;
        });
      } else if (freeModule) {
        (freeModule.exports = _2)._ = _2;
        freeExports._ = _2;
      } else {
        root2._ = _2;
      }
    }).call(exports);
  }
});

// node_modules/@antv/g2/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  AREA_CLASS_NAME: () => AREA_CLASS_NAME,
  Academy: () => Academy,
  Bin: () => Bin,
  BinX: () => BinX,
  COMPONENT_CLASS_NAME: () => COMPONENT_CLASS_NAME,
  Chart: () => Chart2,
  ChartEvent: () => ChartEvent,
  Classic: () => Classic,
  ClassicDark: () => ClassicDark,
  Dark: () => Dark,
  DiffY: () => DiffY,
  DodgeX: () => DodgeX,
  ELEMENT_CLASS_NAME: () => ELEMENT_CLASS_NAME,
  Filter: () => Filter,
  FlexX: () => FlexX,
  Group: () => Group,
  GroupColor: () => GroupColor,
  GroupX: () => GroupX,
  GroupY: () => GroupY,
  Jitter: () => Jitter,
  JitterX: () => JitterX,
  JitterY: () => JitterY,
  LABEL_CLASS_NAME: () => LABEL_CLASS_NAME,
  LABEL_LAYER_CLASS_NAME: () => LABEL_LAYER_CLASS_NAME,
  Light: () => Light,
  LinearAxis: () => LinearAxis,
  MAIN_LAYER_CLASS_NAME: () => MAIN_LAYER_CLASS_NAME,
  MASK_CLASS_NAME: () => MASK_CLASS_NAME,
  MaybeDefaultX: () => MaybeDefaultX,
  MaybeDefaultY: () => MaybeDefaultY,
  MaybeFunctionAttribute: () => MaybeFunctionAttribute,
  MaybeGradient: () => MaybeGradient,
  MaybeIdentityX: () => MaybeIdentityX,
  MaybeIdentityY: () => MaybeIdentityY,
  MaybeKey: () => MaybeKey,
  MaybeSeries: () => MaybeSeries,
  MaybeSize: () => MaybeSize,
  MaybeStackY: () => MaybeStackY,
  MaybeTitle: () => MaybeTitle,
  MaybeTooltip: () => MaybeTooltip,
  MaybeTuple: () => MaybeTuple,
  MaybeTupleX: () => MaybeTupleX,
  MaybeTupleY: () => MaybeTupleY,
  MaybeVisualPosition: () => MaybeVisualPosition,
  MaybeZeroPadding: () => MaybeZeroPadding,
  MaybeZeroX: () => MaybeZeroX,
  MaybeZeroY: () => MaybeZeroY,
  MaybeZeroY1: () => MaybeZeroY1,
  MaybeZeroZ: () => MaybeZeroZ,
  NormalizeY: () => NormalizeY,
  PLOT_CLASS_NAME: () => PLOT_CLASS_NAME,
  Pack: () => Pack,
  Runtime: () => Runtime,
  Sample: () => Sample,
  Select: () => Select,
  SelectX: () => SelectX,
  SelectY: () => SelectY,
  Selection: () => Selection,
  SortColor: () => SortColor,
  SortX: () => SortX,
  SortY: () => SortY,
  StackEnter: () => StackEnter,
  StackY: () => StackY,
  SymmetryY: () => SymmetryY,
  VIEW_CLASS_NAME: () => VIEW_CLASS_NAME,
  corelib: () => corelib,
  extend: () => extend5,
  geolib: () => geolib,
  graphlib: () => graphlib,
  plotlib: () => plotlib,
  register: () => register,
  render: () => render,
  renderToMountedElement: () => renderToMountedElement,
  select: () => select,
  stdlib: () => stdlib
});

// node_modules/@antv/g2/esm/coordinate/cartesian.js
var Cartesian = () => [["cartesian"]];
Cartesian.props = {};

// node_modules/@antv/g2/esm/utils/angle.js
function convertAngles(startAngle, endAngle) {
  startAngle = startAngle % (2 * Math.PI);
  endAngle = endAngle % (2 * Math.PI);
  if (startAngle < 0) {
    startAngle = 2 * Math.PI + startAngle;
  }
  if (endAngle < 0) {
    endAngle = 2 * Math.PI + endAngle;
  }
  if (startAngle >= endAngle) {
    endAngle = endAngle + 2 * Math.PI;
  }
  return {
    startAngle,
    endAngle
  };
}

// node_modules/@antv/g2/esm/coordinate/polar.js
var getPolarOptions = (options = {}) => {
  const defaultOptions = {
    startAngle: -Math.PI / 2,
    endAngle: Math.PI * 3 / 2,
    innerRadius: 0,
    outerRadius: 1
  };
  const polarOption = Object.assign(Object.assign({}, defaultOptions), options);
  return Object.assign(Object.assign({}, polarOption), convertAngles(polarOption.startAngle, polarOption.endAngle));
};
var Polar = (options) => {
  const { startAngle, endAngle, innerRadius, outerRadius } = getPolarOptions(options);
  return [
    ["translate", 0, 0.5],
    ["reflect.y"],
    ["translate", 0, -0.5],
    ["polar", startAngle, endAngle, innerRadius, outerRadius]
  ];
};
Polar.props = {};

// node_modules/@antv/g2/esm/coordinate/helix.js
var Helix = ({ startAngle = 0, endAngle = Math.PI * 6, innerRadius = 0, outerRadius = 1 }) => [
  ["translate", 0.5, 0.5],
  ["reflect.y"],
  ["translate", -0.5, -0.5],
  ["helix", startAngle, endAngle, innerRadius, outerRadius]
];
Helix.props = {};

// node_modules/@antv/g2/esm/coordinate/transpose.js
var Transpose = () => [
  ["transpose"],
  ["translate", 0.5, 0.5],
  ["reflect.x"],
  ["translate", -0.5, -0.5]
];
Transpose.props = { transform: true };

// node_modules/@antv/g2/esm/coordinate/theta.js
var getThetaOptions = (options = {}) => {
  const defaultOptions = {
    startAngle: -Math.PI / 2,
    endAngle: Math.PI * 3 / 2,
    innerRadius: 0,
    outerRadius: 1
  };
  return Object.assign(Object.assign({}, defaultOptions), options);
};
var Theta = (options) => {
  const { startAngle, endAngle, innerRadius, outerRadius } = getThetaOptions(options);
  return [
    ...Transpose(),
    ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
  ];
};
Theta.props = {};

// node_modules/@antv/g2/esm/coordinate/radial.js
var getRadialOptions = (options = {}) => {
  const defaultOptions = {
    startAngle: -Math.PI / 2,
    endAngle: Math.PI * 3 / 2,
    innerRadius: 0,
    outerRadius: 1
  };
  return Object.assign(Object.assign({}, defaultOptions), options);
};
var Radial = (options) => {
  const { startAngle, endAngle, innerRadius, outerRadius } = getRadialOptions(options);
  return [
    ["transpose"],
    ["translate", 0.5, 0.5],
    ["reflect"],
    ["translate", -0.5, -0.5],
    ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
  ];
};
Radial.props = {};

// node_modules/@antv/g2/esm/coordinate/parallel.js
var Parallel = () => [["parallel", 0, 1, 0, 1]];
Parallel.props = {};

// node_modules/@antv/g2/esm/coordinate/fisheye.js
var Fisheye = ({ focusX = 0, focusY = 0, distortionX = 2, distortionY = 2, visual = false }) => [["fisheye", focusX, focusY, distortionX, distortionY, visual]];
Fisheye.props = { transform: true };

// node_modules/@antv/g2/esm/coordinate/radar.js
var Radar = (options) => {
  const { startAngle = -Math.PI / 2, endAngle = Math.PI * 3 / 2, innerRadius = 0, outerRadius = 1 } = options;
  return [
    ...Parallel(),
    ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
  ];
};
Radar.props = {};

// node_modules/@antv/g2/esm/encode/constant.js
var Constant = ({ value: value2 }) => {
  return (data2) => data2.map(() => value2);
};
Constant.props = {};

// node_modules/@antv/g2/esm/encode/transform.js
var Transform = ({ value: value2 }) => {
  return (data2) => data2.map(value2);
};
Transform.props = {};

// node_modules/@antv/g2/esm/encode/field.js
var Field = ({ value: value2 }) => {
  return (data2) => data2.map((d3) => d3[value2]);
};
Field.props = {};

// node_modules/@antv/g2/esm/encode/column.js
var Column = ({ value: value2 }) => {
  return () => value2;
};
Column.props = {};

// node_modules/@antv/util/esm/color/arr2rgb.js
function toHex(value2) {
  var x16Value = Math.round(value2).toString(16);
  return x16Value.length === 1 ? "0".concat(x16Value) : x16Value;
}
function arr2rgb(arr) {
  return "#".concat(toHex(arr[0])).concat(toHex(arr[1])).concat(toHex(arr[2]));
}

// node_modules/@antv/util/esm/lodash/is-array-like.js
var isArrayLike = function(value2) {
  return value2 !== null && typeof value2 !== "function" && isFinite(value2.length);
};
var is_array_like_default = isArrayLike;

// node_modules/@antv/util/esm/lodash/filter.js
var filter = function(arr, func) {
  if (!is_array_like_default(arr)) {
    return arr;
  }
  var result = [];
  for (var index3 = 0; index3 < arr.length; index3++) {
    var value2 = arr[index3];
    if (func(value2, index3)) {
      result.push(value2);
    }
  }
  return result;
};
var filter_default = filter;

// node_modules/@antv/util/esm/lodash/is-function.js
function isFunction(value2) {
  return typeof value2 === "function";
}

// node_modules/@antv/util/esm/lodash/is-nil.js
function isNil(value2) {
  return value2 === null || value2 === void 0;
}

// node_modules/@antv/util/esm/lodash/is-array.js
function isArray(value2) {
  return Array.isArray(value2);
}

// node_modules/@antv/util/esm/lodash/is-object.js
var is_object_default = function(value2) {
  var type = typeof value2;
  return value2 !== null && type === "object" || type === "function";
};

// node_modules/@antv/util/esm/lodash/each.js
function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (isArray(elements)) {
    for (var i = 0, len5 = elements.length; i < len5; i++) {
      rst = func(elements[i], i);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default(elements)) {
    for (var k2 in elements) {
      if (elements.hasOwnProperty(k2)) {
        rst = func(elements[k2], k2);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default = each;

// node_modules/@antv/util/esm/lodash/keys.js
var keys = Object.keys ? function(obj) {
  return Object.keys(obj);
} : function(obj) {
  var result = [];
  each_default(obj, function(value2, key) {
    if (!(isFunction(obj) && key === "prototype")) {
      result.push(key);
    }
  });
  return result;
};
var keys_default = keys;

// node_modules/@antv/util/esm/lodash/is-match.js
function isMatch(obj, attrs) {
  var _keys = keys_default(attrs);
  var length5 = _keys.length;
  if (isNil(obj))
    return !length5;
  for (var i = 0; i < length5; i += 1) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) {
      return false;
    }
  }
  return true;
}
var is_match_default = isMatch;

// node_modules/@antv/util/esm/lodash/is-object-like.js
var isObjectLike = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var is_object_like_default = isObjectLike;

// node_modules/@antv/util/esm/lodash/is-type.js
var toString = {}.toString;
var isType = function(value2, type) {
  return toString.call(value2) === "[object " + type + "]";
};
var is_type_default = isType;

// node_modules/@antv/util/esm/lodash/is-plain-object.js
var isPlainObject = function(value2) {
  if (!is_object_like_default(value2) || !is_type_default(value2, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value2) === null) {
    return true;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
var is_plain_object_default = isPlainObject;

// node_modules/@antv/util/esm/lodash/find.js
function find(arr, predicate) {
  if (!isArray(arr))
    return null;
  var _predicate;
  if (isFunction(predicate)) {
    _predicate = predicate;
  }
  if (is_plain_object_default(predicate)) {
    _predicate = function(a4) {
      return is_match_default(a4, predicate);
    };
  }
  if (_predicate) {
    for (var i = 0; i < arr.length; i += 1) {
      if (_predicate(arr[i])) {
        return arr[i];
      }
    }
  }
  return null;
}
var find_default = find;

// node_modules/@antv/util/esm/lodash/max.js
function max(arr) {
  if (!Array.isArray(arr))
    return -Infinity;
  var length5 = arr.length;
  if (!length5)
    return -Infinity;
  var max11 = arr[0];
  for (var i = 1; i < length5; i++) {
    max11 = Math.max(max11, arr[i]);
  }
  return max11;
}

// node_modules/@antv/util/esm/lodash/min.js
var min_default = function(arr) {
  if (!isArray(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.min(prev, curr);
  }, arr[0]);
};

// node_modules/@antv/util/esm/lodash/pull.js
var arrPrototype = Array.prototype;
var splice = arrPrototype.splice;
var indexOf = arrPrototype.indexOf;

// node_modules/@antv/util/esm/lodash/pull-at.js
var splice2 = Array.prototype.splice;

// node_modules/@antv/util/esm/lodash/reduce.js
var reduce = function(arr, fn, init) {
  if (!isArray(arr) && !is_plain_object_default(arr)) {
    return arr;
  }
  var result = init;
  each_default(arr, function(data2, i) {
    result = fn(result, data2, i);
  });
  return result;
};
var reduce_default = reduce;

// node_modules/@antv/util/esm/lodash/is-string.js
function isString(value2) {
  return typeof value2 === "string";
}

// node_modules/@antv/util/esm/lodash/last.js
function last(o) {
  if (is_array_like_default(o)) {
    var arr = o;
    return arr[arr.length - 1];
  }
  return void 0;
}

// node_modules/@antv/util/esm/lodash/clamp.js
var clamp = function(a4, min10, max11) {
  if (a4 < min10) {
    return min10;
  } else if (a4 > max11) {
    return max11;
  }
  return a4;
};
var clamp_default = clamp;

// node_modules/@antv/util/esm/lodash/is-number.js
function isNumber(value2) {
  return typeof value2 === "number";
}

// node_modules/@antv/util/esm/lodash/is-number-equal.js
var PRECISION = 1e-5;
function isNumberEqual(a4, b, precision) {
  if (precision === void 0) {
    precision = PRECISION;
  }
  return a4 === b || Math.abs(a4 - b) < precision;
}

// node_modules/@antv/util/esm/lodash/max-by.js
var max_by_default = function(arr, fn) {
  if (!isArray(arr)) {
    return void 0;
  }
  var maxItem;
  var max11 = -Infinity;
  for (var i = 0; i < arr.length; i++) {
    var item = arr[i];
    var v = isFunction(fn) ? fn(item) : item[fn];
    if (v > max11) {
      maxItem = item;
      max11 = v;
    }
  }
  return maxItem;
};

// node_modules/@antv/util/esm/lodash/min-by.js
var min_by_default = function(arr, fn) {
  if (!isArray(arr)) {
    return void 0;
  }
  var minItem;
  var min10 = Infinity;
  for (var i = 0; i < arr.length; i++) {
    var item = arr[i];
    var v = isFunction(fn) ? fn(item) : item[fn];
    if (v < min10) {
      minItem = item;
      min10 = v;
    }
  }
  return minItem;
};

// node_modules/@antv/util/esm/lodash/mod.js
var mod = function(n, m3) {
  return (n % m3 + m3) % m3;
};
var mod_default = mod;

// node_modules/@antv/util/esm/lodash/to-degree.js
var DEGREE = 180 / Math.PI;

// node_modules/@antv/util/esm/lodash/to-radian.js
var RADIAN = Math.PI / 180;

// node_modules/@antv/util/esm/lodash/to-string.js
var to_string_default = function(value2) {
  if (isNil(value2))
    return "";
  return value2.toString();
};

// node_modules/@antv/util/esm/lodash/lower-first.js
var lowerFirst = function(value2) {
  var str7 = to_string_default(value2);
  return str7.charAt(0).toLowerCase() + str7.substring(1);
};
var lower_first_default = lowerFirst;

// node_modules/@antv/util/esm/lodash/substitute.js
function substitute(str7, o) {
  if (!str7 || !o) {
    return str7;
  }
  return str7.replace(/\\?\{([^{}]+)\}/g, function(match, name2) {
    if (match.charAt(0) === "\\") {
      return match.slice(1);
    }
    return o[name2] === void 0 ? "" : o[name2];
  });
}
var substitute_default = substitute;

// node_modules/@antv/util/esm/lodash/upper-first.js
var upperFirst = function(value2) {
  var str7 = to_string_default(value2);
  return str7.charAt(0).toUpperCase() + str7.substring(1);
};
var upper_first_default = upperFirst;

// node_modules/@antv/util/esm/lodash/get-type.js
var toString2 = {}.toString;

// node_modules/@antv/util/esm/lodash/is-boolean.js
var isBoolean = function(value2) {
  return is_type_default(value2, "Boolean");
};
var is_boolean_default = isBoolean;

// node_modules/@antv/util/esm/lodash/is-null.js
function isNull(value2) {
  return value2 === null;
}

// node_modules/@antv/util/esm/lodash/is-prototype.js
var objectProto = Object.prototype;

// node_modules/@antv/util/esm/lodash/is-undefined.js
var isUndefined = function(value2) {
  return value2 === void 0;
};
var is_undefined_default = isUndefined;

// node_modules/@antv/util/esm/lodash/is-element.js
function isElement(value2) {
  return value2 instanceof Element || value2 instanceof Document;
}

// node_modules/@antv/util/esm/lodash/mix.js
function _mix(dist5, obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
      dist5[key] = obj[key];
    }
  }
}
function mix(dist5, src1, src2, src3) {
  if (src1)
    _mix(dist5, src1);
  if (src2)
    _mix(dist5, src2);
  if (src3)
    _mix(dist5, src3);
  return dist5;
}

// node_modules/@antv/util/esm/lodash/clone.js
var clone = function(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  var rst;
  if (isArray(obj)) {
    rst = [];
    for (var i = 0, l = obj.length; i < l; i++) {
      if (typeof obj[i] === "object" && obj[i] != null) {
        rst[i] = clone(obj[i]);
      } else {
        rst[i] = obj[i];
      }
    }
  } else {
    rst = {};
    for (var k2 in obj) {
      if (typeof obj[k2] === "object" && obj[k2] != null) {
        rst[k2] = clone(obj[k2]);
      } else {
        rst[k2] = obj[k2];
      }
    }
  }
  return rst;
};
var clone_default = clone;

// node_modules/@antv/util/esm/lodash/debounce.js
function debounce(func, wait, immediate) {
  var timeout2;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout2 = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout2;
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}
var debounce_default = debounce;

// node_modules/@antv/util/esm/lodash/memoize.js
function flru(max11) {
  var num, curr, prev;
  var limit = max11 || 1;
  function keep(key, value2) {
    if (++num > limit) {
      prev = curr;
      reset(1);
      ++num;
    }
    curr[key] = value2;
  }
  function reset(isPartial) {
    num = 0;
    curr = /* @__PURE__ */ Object.create(null);
    isPartial || (prev = /* @__PURE__ */ Object.create(null));
  }
  reset();
  return {
    clear: reset,
    has: function(key) {
      return curr[key] !== void 0 || prev[key] !== void 0;
    },
    get: function(key) {
      var val = curr[key];
      if (val !== void 0)
        return val;
      if ((val = prev[key]) !== void 0) {
        keep(key, val);
        return val;
      }
    },
    set: function(key, value2) {
      if (curr[key] !== void 0) {
        curr[key] = value2;
      } else {
        keep(key, value2);
      }
    }
  };
}
var CacheMap = /* @__PURE__ */ new Map();
function memoize(fn, resolver, maxSize) {
  if (maxSize === void 0) {
    maxSize = 128;
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    if (!CacheMap.has(fn))
      CacheMap.set(fn, flru(maxSize));
    var cache2 = CacheMap.get(fn);
    if (cache2.has(key))
      return cache2.get(key);
    var result = fn.apply(this, args);
    cache2.set(key, result);
    return result;
  };
  return memoized;
}

// node_modules/@antv/util/esm/lodash/deep-mix.js
var MAX_MIX_LEVEL = 5;
function hasOwn(object, property) {
  if (Object.hasOwn) {
    return Object.hasOwn(object, property);
  }
  if (object == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  return Object.prototype.hasOwnProperty.call(Object(object), property);
}
function _deepMix(dist5, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key in src) {
    if (hasOwn(src, key)) {
      var value2 = src[key];
      if (value2 !== null && is_plain_object_default(value2)) {
        if (!is_plain_object_default(dist5[key])) {
          dist5[key] = {};
        }
        if (level < maxLevel) {
          _deepMix(dist5[key], value2, level + 1, maxLevel);
        } else {
          dist5[key] = src[key];
        }
      } else if (isArray(value2)) {
        dist5[key] = [];
        dist5[key] = dist5[key].concat(value2);
      } else if (value2 !== void 0) {
        dist5[key] = value2;
      }
    }
  }
}
var deepMix = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    _deepMix(rst, args[i]);
  }
  return rst;
};
var deep_mix_default = deepMix;

// node_modules/@antv/util/esm/lodash/index-of.js
var indexOf2 = function(arr, obj) {
  if (!is_array_like_default(arr)) {
    return -1;
  }
  var m3 = Array.prototype.indexOf;
  if (m3) {
    return m3.call(arr, obj);
  }
  var index3 = -1;
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === obj) {
      index3 = i;
      break;
    }
  }
  return index3;
};
var index_of_default = indexOf2;

// node_modules/@antv/util/esm/lodash/is-equal.js
var isEqual = function(value2, other) {
  if (value2 === other) {
    return true;
  }
  if (!value2 || !other) {
    return false;
  }
  if (isString(value2) || isString(other)) {
    return false;
  }
  if (is_array_like_default(value2) || is_array_like_default(other)) {
    if (value2.length !== other.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < value2.length; i++) {
      rst = isEqual(value2[i], other[i]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  if (is_object_like_default(value2) || is_object_like_default(other)) {
    var valueKeys = Object.keys(value2);
    var otherKeys = Object.keys(other);
    if (valueKeys.length !== otherKeys.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < valueKeys.length; i++) {
      rst = isEqual(value2[valueKeys[i]], other[valueKeys[i]]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  return false;
};
var is_equal_default = isEqual;

// node_modules/@antv/util/esm/lodash/get.js
var get_default = function(obj, key, defaultValue) {
  var p2 = 0;
  var keyArr = isString(key) ? key.split(".") : key;
  while (obj && p2 < keyArr.length) {
    obj = obj[keyArr[p2++]];
  }
  return obj === void 0 || p2 < keyArr.length ? defaultValue : obj;
};

// node_modules/@antv/util/esm/lodash/set.js
var set_default = function(obj, path2, value2) {
  var o = obj;
  var keyArr = isString(path2) ? path2.split(".") : path2;
  keyArr.forEach(function(key, idx) {
    if (idx < keyArr.length - 1) {
      if (!is_object_default(o[key])) {
        o[key] = isNumber(keyArr[idx + 1]) ? [] : {};
      }
      o = o[key];
    } else {
      o[key] = value2;
    }
  });
  return obj;
};

// node_modules/@antv/util/esm/lodash/pick.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
var pick_default = function(object, keys2) {
  if (object === null || !is_plain_object_default(object)) {
    return {};
  }
  var result = {};
  each_default(keys2, function(key) {
    if (hasOwnProperty.call(object, key)) {
      result[key] = object[key];
    }
  });
  return result;
};

// node_modules/@antv/util/esm/lodash/omit.js
var omit_default = function(obj, keys2) {
  return reduce_default(obj, function(r, curr, key) {
    if (!keys2.includes(key)) {
      r[key] = curr;
    }
    return r;
  }, {});
};

// node_modules/@antv/util/esm/lodash/throttle.js
var throttle_default = function(func, wait, options) {
  var timeout2, context, args, result;
  var previous = 0;
  if (!options)
    options = {};
  var later = function() {
    previous = options.leading === false ? 0 : Date.now();
    timeout2 = null;
    result = func.apply(context, args);
    if (!timeout2)
      context = args = null;
  };
  var throttled = function() {
    var now2 = Date.now();
    if (!previous && options.leading === false)
      previous = now2;
    var remaining = wait - (now2 - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout2) {
        clearTimeout(timeout2);
        timeout2 = null;
      }
      previous = now2;
      result = func.apply(context, args);
      if (!timeout2)
        context = args = null;
    } else if (!timeout2 && options.trailing !== false) {
      timeout2 = setTimeout(later, remaining);
    }
    return result;
  };
  throttled.cancel = function() {
    clearTimeout(timeout2);
    previous = 0;
    timeout2 = context = args = null;
  };
  return throttled;
};

// node_modules/@antv/util/esm/lodash/noop.js
var noop_default = function() {
};

// node_modules/@antv/util/esm/lodash/identity.js
var identity_default = function(v) {
  return v;
};

// node_modules/@antv/util/esm/lodash/size.js
function size(o) {
  if (isNil(o)) {
    return 0;
  }
  if (is_array_like_default(o)) {
    return o.length;
  }
  return Object.keys(o).length;
}

// node_modules/@antv/util/esm/lodash/cache.js
var default_1 = (
  /** @class */
  function() {
    function default_13() {
      this.map = {};
    }
    default_13.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_13.prototype.get = function(key, def) {
      var v = this.map[key];
      return v === void 0 ? def : v;
    };
    default_13.prototype.set = function(key, value2) {
      this.map[key] = value2;
    };
    default_13.prototype.clear = function() {
      this.map = {};
    };
    default_13.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_13.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_13;
  }()
);

// node_modules/@antv/util/esm/color/torgb.js
var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
function getTmp() {
  var i = document.getElementById("antv-web-colour-picker");
  if (i) {
    return i;
  }
  i = document.createElement("i");
  i.id = "antv-web-colour-picker";
  i.title = "Web Colour Picker";
  i.style.display = "none";
  document.body.appendChild(i);
  return i;
}
function toRGBString(color3) {
  if (color3[0] === "#" && color3.length === 7) {
    return color3;
  }
  var iEl = getTmp();
  iEl.style.color = color3;
  var rst = document.defaultView.getComputedStyle(iEl, "").getPropertyValue("color");
  var matches = RGB_REG.exec(rst);
  var cArray = matches[1].split(/\s*,\s*/).map(function(s3) {
    return Number(s3);
  });
  rst = arr2rgb(cArray);
  return rst;
}
var toRGB = memoize(toRGBString, function(color3) {
  return color3;
}, 256);

// node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var degree = Math.PI / 180;
if (!Math.hypot)
  Math.hypot = function() {
    var y3 = 0, i = arguments.length;
    while (i--) {
      y3 += arguments[i] * arguments[i];
    }
    return Math.sqrt(y3);
  };

// node_modules/gl-matrix/esm/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone2,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  translate: () => translate,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[4];
  out[4] = a4[5];
  out[5] = a4[6];
  out[6] = a4[8];
  out[7] = a4[9];
  out[8] = a4[10];
  return out;
}
function clone2(a4) {
  var out = new ARRAY_TYPE(9);
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  out[4] = a4[4];
  out[5] = a4[5];
  out[6] = a4[6];
  out[7] = a4[7];
  out[8] = a4[8];
  return out;
}
function copy(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  out[4] = a4[4];
  out[5] = a4[5];
  out[6] = a4[6];
  out[7] = a4[7];
  out[8] = a4[8];
  return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a4) {
  if (out === a4) {
    var a01 = a4[1], a02 = a4[2], a12 = a4[5];
    out[1] = a4[3];
    out[2] = a4[6];
    out[3] = a01;
    out[5] = a4[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a4[0];
    out[1] = a4[3];
    out[2] = a4[6];
    out[3] = a4[1];
    out[4] = a4[4];
    out[5] = a4[7];
    out[6] = a4[2];
    out[7] = a4[5];
    out[8] = a4[8];
  }
  return out;
}
function invert(out, a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2];
  var a10 = a4[3], a11 = a4[4], a12 = a4[5];
  var a20 = a4[6], a21 = a4[7], a22 = a4[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2];
  var a10 = a4[3], a11 = a4[4], a12 = a4[5];
  var a20 = a4[6], a21 = a4[7], a22 = a4[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2];
  var a10 = a4[3], a11 = a4[4], a12 = a4[5];
  var a20 = a4[6], a21 = a4[7], a22 = a4[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a4, b) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2];
  var a10 = a4[3], a11 = a4[4], a12 = a4[5];
  var a20 = a4[6], a21 = a4[7], a22 = a4[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a4, v) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a10 = a4[3], a11 = a4[4], a12 = a4[5], a20 = a4[6], a21 = a4[7], a22 = a4[8], x3 = v[0], y3 = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x3 * a00 + y3 * a10 + a20;
  out[7] = x3 * a01 + y3 * a11 + a21;
  out[8] = x3 * a02 + y3 * a12 + a22;
  return out;
}
function rotate(out, a4, rad2) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a10 = a4[3], a11 = a4[4], a12 = a4[5], a20 = a4[6], a21 = a4[7], a22 = a4[8], s3 = Math.sin(rad2), c5 = Math.cos(rad2);
  out[0] = c5 * a00 + s3 * a10;
  out[1] = c5 * a01 + s3 * a11;
  out[2] = c5 * a02 + s3 * a12;
  out[3] = c5 * a10 - s3 * a00;
  out[4] = c5 * a11 - s3 * a01;
  out[5] = c5 * a12 - s3 * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale(out, a4, v) {
  var x3 = v[0], y3 = v[1];
  out[0] = x3 * a4[0];
  out[1] = x3 * a4[1];
  out[2] = x3 * a4[2];
  out[3] = y3 * a4[3];
  out[4] = y3 * a4[4];
  out[5] = y3 * a4[5];
  out[6] = a4[6];
  out[7] = a4[7];
  out[8] = a4[8];
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad2) {
  var s3 = Math.sin(rad2), c5 = Math.cos(rad2);
  out[0] = c5;
  out[1] = s3;
  out[2] = 0;
  out[3] = -s3;
  out[4] = c5;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = 0;
  out[3] = a4[2];
  out[4] = a4[3];
  out[5] = 0;
  out[6] = a4[4];
  out[7] = a4[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q) {
  var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
  var x22 = x3 + x3;
  var y22 = y3 + y3;
  var z2 = z + z;
  var xx = x3 * x22;
  var yx = y3 * x22;
  var yy = y3 * y22;
  var zx = z * x22;
  var zy = z * y22;
  var zz = z * z2;
  var wx = w * x22;
  var wy = w * y22;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
  var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
  var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
  var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str(a4) {
  return "mat3(" + a4[0] + ", " + a4[1] + ", " + a4[2] + ", " + a4[3] + ", " + a4[4] + ", " + a4[5] + ", " + a4[6] + ", " + a4[7] + ", " + a4[8] + ")";
}
function frob(a4) {
  return Math.hypot(a4[0], a4[1], a4[2], a4[3], a4[4], a4[5], a4[6], a4[7], a4[8]);
}
function add(out, a4, b) {
  out[0] = a4[0] + b[0];
  out[1] = a4[1] + b[1];
  out[2] = a4[2] + b[2];
  out[3] = a4[3] + b[3];
  out[4] = a4[4] + b[4];
  out[5] = a4[5] + b[5];
  out[6] = a4[6] + b[6];
  out[7] = a4[7] + b[7];
  out[8] = a4[8] + b[8];
  return out;
}
function subtract(out, a4, b) {
  out[0] = a4[0] - b[0];
  out[1] = a4[1] - b[1];
  out[2] = a4[2] - b[2];
  out[3] = a4[3] - b[3];
  out[4] = a4[4] - b[4];
  out[5] = a4[5] - b[5];
  out[6] = a4[6] - b[6];
  out[7] = a4[7] - b[7];
  out[8] = a4[8] - b[8];
  return out;
}
function multiplyScalar(out, a4, b) {
  out[0] = a4[0] * b;
  out[1] = a4[1] * b;
  out[2] = a4[2] * b;
  out[3] = a4[3] * b;
  out[4] = a4[4] * b;
  out[5] = a4[5] * b;
  out[6] = a4[6] * b;
  out[7] = a4[7] * b;
  out[8] = a4[8] * b;
  return out;
}
function multiplyScalarAndAdd(out, a4, b, scale11) {
  out[0] = a4[0] + b[0] * scale11;
  out[1] = a4[1] + b[1] * scale11;
  out[2] = a4[2] + b[2] * scale11;
  out[3] = a4[3] + b[3] * scale11;
  out[4] = a4[4] + b[4] * scale11;
  out[5] = a4[5] + b[5] * scale11;
  out[6] = a4[6] + b[6] * scale11;
  out[7] = a4[7] + b[7] * scale11;
  out[8] = a4[8] + b[8] * scale11;
  return out;
}
function exactEquals(a4, b) {
  return a4[0] === b[0] && a4[1] === b[1] && a4[2] === b[2] && a4[3] === b[3] && a4[4] === b[4] && a4[5] === b[5] && a4[6] === b[6] && a4[7] === b[7] && a4[8] === b[8];
}
function equals(a4, b) {
  var a0 = a4[0], a1 = a4[1], a22 = a4[2], a32 = a4[3], a42 = a4[4], a5 = a4[5], a6 = a4[6], a7 = a4[7], a8 = a4[8];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3)) && Math.abs(a42 - b4) <= EPSILON * Math.max(1, Math.abs(a42), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul = multiply;
var sub = subtract;

// node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add2,
  adjoint: () => adjoint2,
  clone: () => clone3,
  copy: () => copy2,
  create: () => create2,
  determinant: () => determinant2,
  equals: () => equals2,
  exactEquals: () => exactEquals2,
  frob: () => frob2,
  fromQuat: () => fromQuat3,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation2,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling2,
  fromTranslation: () => fromTranslation2,
  fromValues: () => fromValues2,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity2,
  invert: () => invert2,
  lookAt: () => lookAt,
  mul: () => mul2,
  multiply: () => multiply2,
  multiplyScalar: () => multiplyScalar2,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate2,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale2,
  set: () => set2,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  targetTo: () => targetTo,
  translate: () => translate2,
  transpose: () => transpose2
});
function create2() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone3(a4) {
  var out = new ARRAY_TYPE(16);
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  out[4] = a4[4];
  out[5] = a4[5];
  out[6] = a4[6];
  out[7] = a4[7];
  out[8] = a4[8];
  out[9] = a4[9];
  out[10] = a4[10];
  out[11] = a4[11];
  out[12] = a4[12];
  out[13] = a4[13];
  out[14] = a4[14];
  out[15] = a4[15];
  return out;
}
function copy2(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  out[4] = a4[4];
  out[5] = a4[5];
  out[6] = a4[6];
  out[7] = a4[7];
  out[8] = a4[8];
  out[9] = a4[9];
  out[10] = a4[10];
  out[11] = a4[11];
  out[12] = a4[12];
  out[13] = a4[13];
  out[14] = a4[14];
  out[15] = a4[15];
  return out;
}
function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set2(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a4) {
  if (out === a4) {
    var a01 = a4[1], a02 = a4[2], a03 = a4[3];
    var a12 = a4[6], a13 = a4[7];
    var a23 = a4[11];
    out[1] = a4[4];
    out[2] = a4[8];
    out[3] = a4[12];
    out[4] = a01;
    out[6] = a4[9];
    out[7] = a4[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a4[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a4[0];
    out[1] = a4[4];
    out[2] = a4[8];
    out[3] = a4[12];
    out[4] = a4[1];
    out[5] = a4[5];
    out[6] = a4[9];
    out[7] = a4[13];
    out[8] = a4[2];
    out[9] = a4[6];
    out[10] = a4[10];
    out[11] = a4[14];
    out[12] = a4[3];
    out[13] = a4[7];
    out[14] = a4[11];
    out[15] = a4[15];
  }
  return out;
}
function invert2(out, a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
  var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
  var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
  var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint2(out, a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
  var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
  var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
  var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
function determinant2(a4) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
  var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
  var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
  var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply2(out, a4, b) {
  var a00 = a4[0], a01 = a4[1], a02 = a4[2], a03 = a4[3];
  var a10 = a4[4], a11 = a4[5], a12 = a4[6], a13 = a4[7];
  var a20 = a4[8], a21 = a4[9], a22 = a4[10], a23 = a4[11];
  var a30 = a4[12], a31 = a4[13], a32 = a4[14], a33 = a4[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate2(out, a4, v) {
  var x3 = v[0], y3 = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a4 === out) {
    out[12] = a4[0] * x3 + a4[4] * y3 + a4[8] * z + a4[12];
    out[13] = a4[1] * x3 + a4[5] * y3 + a4[9] * z + a4[13];
    out[14] = a4[2] * x3 + a4[6] * y3 + a4[10] * z + a4[14];
    out[15] = a4[3] * x3 + a4[7] * y3 + a4[11] * z + a4[15];
  } else {
    a00 = a4[0];
    a01 = a4[1];
    a02 = a4[2];
    a03 = a4[3];
    a10 = a4[4];
    a11 = a4[5];
    a12 = a4[6];
    a13 = a4[7];
    a20 = a4[8];
    a21 = a4[9];
    a22 = a4[10];
    a23 = a4[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x3 + a10 * y3 + a20 * z + a4[12];
    out[13] = a01 * x3 + a11 * y3 + a21 * z + a4[13];
    out[14] = a02 * x3 + a12 * y3 + a22 * z + a4[14];
    out[15] = a03 * x3 + a13 * y3 + a23 * z + a4[15];
  }
  return out;
}
function scale2(out, a4, v) {
  var x3 = v[0], y3 = v[1], z = v[2];
  out[0] = a4[0] * x3;
  out[1] = a4[1] * x3;
  out[2] = a4[2] * x3;
  out[3] = a4[3] * x3;
  out[4] = a4[4] * y3;
  out[5] = a4[5] * y3;
  out[6] = a4[6] * y3;
  out[7] = a4[7] * y3;
  out[8] = a4[8] * z;
  out[9] = a4[9] * z;
  out[10] = a4[10] * z;
  out[11] = a4[11] * z;
  out[12] = a4[12];
  out[13] = a4[13];
  out[14] = a4[14];
  out[15] = a4[15];
  return out;
}
function rotate2(out, a4, rad2, axis) {
  var x3 = axis[0], y3 = axis[1], z = axis[2];
  var len5 = Math.hypot(x3, y3, z);
  var s3, c5, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x3 *= len5;
  y3 *= len5;
  z *= len5;
  s3 = Math.sin(rad2);
  c5 = Math.cos(rad2);
  t = 1 - c5;
  a00 = a4[0];
  a01 = a4[1];
  a02 = a4[2];
  a03 = a4[3];
  a10 = a4[4];
  a11 = a4[5];
  a12 = a4[6];
  a13 = a4[7];
  a20 = a4[8];
  a21 = a4[9];
  a22 = a4[10];
  a23 = a4[11];
  b00 = x3 * x3 * t + c5;
  b01 = y3 * x3 * t + z * s3;
  b02 = z * x3 * t - y3 * s3;
  b10 = x3 * y3 * t - z * s3;
  b11 = y3 * y3 * t + c5;
  b12 = z * y3 * t + x3 * s3;
  b20 = x3 * z * t + y3 * s3;
  b21 = y3 * z * t - x3 * s3;
  b22 = z * z * t + c5;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a4 !== out) {
    out[12] = a4[12];
    out[13] = a4[13];
    out[14] = a4[14];
    out[15] = a4[15];
  }
  return out;
}
function rotateX(out, a4, rad2) {
  var s3 = Math.sin(rad2);
  var c5 = Math.cos(rad2);
  var a10 = a4[4];
  var a11 = a4[5];
  var a12 = a4[6];
  var a13 = a4[7];
  var a20 = a4[8];
  var a21 = a4[9];
  var a22 = a4[10];
  var a23 = a4[11];
  if (a4 !== out) {
    out[0] = a4[0];
    out[1] = a4[1];
    out[2] = a4[2];
    out[3] = a4[3];
    out[12] = a4[12];
    out[13] = a4[13];
    out[14] = a4[14];
    out[15] = a4[15];
  }
  out[4] = a10 * c5 + a20 * s3;
  out[5] = a11 * c5 + a21 * s3;
  out[6] = a12 * c5 + a22 * s3;
  out[7] = a13 * c5 + a23 * s3;
  out[8] = a20 * c5 - a10 * s3;
  out[9] = a21 * c5 - a11 * s3;
  out[10] = a22 * c5 - a12 * s3;
  out[11] = a23 * c5 - a13 * s3;
  return out;
}
function rotateY(out, a4, rad2) {
  var s3 = Math.sin(rad2);
  var c5 = Math.cos(rad2);
  var a00 = a4[0];
  var a01 = a4[1];
  var a02 = a4[2];
  var a03 = a4[3];
  var a20 = a4[8];
  var a21 = a4[9];
  var a22 = a4[10];
  var a23 = a4[11];
  if (a4 !== out) {
    out[4] = a4[4];
    out[5] = a4[5];
    out[6] = a4[6];
    out[7] = a4[7];
    out[12] = a4[12];
    out[13] = a4[13];
    out[14] = a4[14];
    out[15] = a4[15];
  }
  out[0] = a00 * c5 - a20 * s3;
  out[1] = a01 * c5 - a21 * s3;
  out[2] = a02 * c5 - a22 * s3;
  out[3] = a03 * c5 - a23 * s3;
  out[8] = a00 * s3 + a20 * c5;
  out[9] = a01 * s3 + a21 * c5;
  out[10] = a02 * s3 + a22 * c5;
  out[11] = a03 * s3 + a23 * c5;
  return out;
}
function rotateZ(out, a4, rad2) {
  var s3 = Math.sin(rad2);
  var c5 = Math.cos(rad2);
  var a00 = a4[0];
  var a01 = a4[1];
  var a02 = a4[2];
  var a03 = a4[3];
  var a10 = a4[4];
  var a11 = a4[5];
  var a12 = a4[6];
  var a13 = a4[7];
  if (a4 !== out) {
    out[8] = a4[8];
    out[9] = a4[9];
    out[10] = a4[10];
    out[11] = a4[11];
    out[12] = a4[12];
    out[13] = a4[13];
    out[14] = a4[14];
    out[15] = a4[15];
  }
  out[0] = a00 * c5 + a10 * s3;
  out[1] = a01 * c5 + a11 * s3;
  out[2] = a02 * c5 + a12 * s3;
  out[3] = a03 * c5 + a13 * s3;
  out[4] = a10 * c5 - a00 * s3;
  out[5] = a11 * c5 - a01 * s3;
  out[6] = a12 * c5 - a02 * s3;
  out[7] = a13 * c5 - a03 * s3;
  return out;
}
function fromTranslation2(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling2(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation2(out, rad2, axis) {
  var x3 = axis[0], y3 = axis[1], z = axis[2];
  var len5 = Math.hypot(x3, y3, z);
  var s3, c5, t;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x3 *= len5;
  y3 *= len5;
  z *= len5;
  s3 = Math.sin(rad2);
  c5 = Math.cos(rad2);
  t = 1 - c5;
  out[0] = x3 * x3 * t + c5;
  out[1] = y3 * x3 * t + z * s3;
  out[2] = z * x3 * t - y3 * s3;
  out[3] = 0;
  out[4] = x3 * y3 * t - z * s3;
  out[5] = y3 * y3 * t + c5;
  out[6] = z * y3 * t + x3 * s3;
  out[7] = 0;
  out[8] = x3 * z * t + y3 * s3;
  out[9] = y3 * z * t - x3 * s3;
  out[10] = z * z * t + c5;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad2) {
  var s3 = Math.sin(rad2);
  var c5 = Math.cos(rad2);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c5;
  out[6] = s3;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s3;
  out[10] = c5;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad2) {
  var s3 = Math.sin(rad2);
  var c5 = Math.cos(rad2);
  out[0] = c5;
  out[1] = 0;
  out[2] = -s3;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s3;
  out[9] = 0;
  out[10] = c5;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad2) {
  var s3 = Math.sin(rad2);
  var c5 = Math.cos(rad2);
  out[0] = c5;
  out[1] = s3;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s3;
  out[5] = c5;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q, v) {
  var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
  var x22 = x3 + x3;
  var y22 = y3 + y3;
  var z2 = z + z;
  var xx = x3 * x22;
  var xy = x3 * y22;
  var xz = x3 * z2;
  var yy = y3 * y22;
  var yz = y3 * z2;
  var zz = z * z2;
  var wx = w * x22;
  var wy = w * y22;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a4) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a4[0], by = -a4[1], bz = -a4[2], bw = a4[3], ax = a4[4], ay = a4[5], az = a4[6], aw = a4[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a4, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function fromRotationTranslationScale(out, q, v, s3) {
  var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
  var x22 = x3 + x3;
  var y22 = y3 + y3;
  var z2 = z + z;
  var xx = x3 * x22;
  var xy = x3 * y22;
  var xz = x3 * z2;
  var yy = y3 * y22;
  var yz = y3 * z2;
  var zz = z * z2;
  var wx = w * x22;
  var wy = w * y22;
  var wz = w * z2;
  var sx = s3[0];
  var sy = s3[1];
  var sz = s3[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s3, o) {
  var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
  var x22 = x3 + x3;
  var y22 = y3 + y3;
  var z2 = z + z;
  var xx = x3 * x22;
  var xy = x3 * y22;
  var xz = x3 * z2;
  var yy = y3 * y22;
  var yz = y3 * z2;
  var zz = z * z2;
  var wx = w * x22;
  var wy = w * y22;
  var wz = w * z2;
  var sx = s3[0];
  var sy = s3[1];
  var sz = s3[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q) {
  var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
  var x22 = x3 + x3;
  var y22 = y3 + y3;
  var z2 = z + z;
  var xx = x3 * x22;
  var yx = y3 * x22;
  var yy = y3 * y22;
  var zx = z * x22;
  var zy = z * y22;
  var zz = z * z2;
  var wx = w * x22;
  var wy = w * y22;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left2, right2, bottom, top, near, far) {
  var rl = 1 / (right2 - left2);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right2 + left2) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left2, right2, bottom, top, near, far) {
  var lr = 1 / (left2 - right2);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left2 + right2) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left2, right2, bottom, top, near, far) {
  var lr = 1 / (left2 - right2);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left2 + right2) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center2, up) {
  var x05, x12, x22, y05, y12, y22, z0, z1, z2, len5;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center2[0];
  var centery = center2[1];
  var centerz = center2[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity2(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len5 = 1 / Math.hypot(z0, z1, z2);
  z0 *= len5;
  z1 *= len5;
  z2 *= len5;
  x05 = upy * z2 - upz * z1;
  x12 = upz * z0 - upx * z2;
  x22 = upx * z1 - upy * z0;
  len5 = Math.hypot(x05, x12, x22);
  if (!len5) {
    x05 = 0;
    x12 = 0;
    x22 = 0;
  } else {
    len5 = 1 / len5;
    x05 *= len5;
    x12 *= len5;
    x22 *= len5;
  }
  y05 = z1 * x22 - z2 * x12;
  y12 = z2 * x05 - z0 * x22;
  y22 = z0 * x12 - z1 * x05;
  len5 = Math.hypot(y05, y12, y22);
  if (!len5) {
    y05 = 0;
    y12 = 0;
    y22 = 0;
  } else {
    len5 = 1 / len5;
    y05 *= len5;
    y12 *= len5;
    y22 *= len5;
  }
  out[0] = x05;
  out[1] = y05;
  out[2] = z0;
  out[3] = 0;
  out[4] = x12;
  out[5] = y12;
  out[6] = z1;
  out[7] = 0;
  out[8] = x22;
  out[9] = y22;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x05 * eyex + x12 * eyey + x22 * eyez);
  out[13] = -(y05 * eyex + y12 * eyey + y22 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len5 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    z0 *= len5;
    z1 *= len5;
    z2 *= len5;
  }
  var x05 = upy * z2 - upz * z1, x12 = upz * z0 - upx * z2, x22 = upx * z1 - upy * z0;
  len5 = x05 * x05 + x12 * x12 + x22 * x22;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    x05 *= len5;
    x12 *= len5;
    x22 *= len5;
  }
  out[0] = x05;
  out[1] = x12;
  out[2] = x22;
  out[3] = 0;
  out[4] = z1 * x22 - z2 * x12;
  out[5] = z2 * x05 - z0 * x22;
  out[6] = z0 * x12 - z1 * x05;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str2(a4) {
  return "mat4(" + a4[0] + ", " + a4[1] + ", " + a4[2] + ", " + a4[3] + ", " + a4[4] + ", " + a4[5] + ", " + a4[6] + ", " + a4[7] + ", " + a4[8] + ", " + a4[9] + ", " + a4[10] + ", " + a4[11] + ", " + a4[12] + ", " + a4[13] + ", " + a4[14] + ", " + a4[15] + ")";
}
function frob2(a4) {
  return Math.hypot(a4[0], a4[1], a4[2], a4[3], a4[4], a4[5], a4[6], a4[7], a4[8], a4[9], a4[10], a4[11], a4[12], a4[13], a4[14], a4[15]);
}
function add2(out, a4, b) {
  out[0] = a4[0] + b[0];
  out[1] = a4[1] + b[1];
  out[2] = a4[2] + b[2];
  out[3] = a4[3] + b[3];
  out[4] = a4[4] + b[4];
  out[5] = a4[5] + b[5];
  out[6] = a4[6] + b[6];
  out[7] = a4[7] + b[7];
  out[8] = a4[8] + b[8];
  out[9] = a4[9] + b[9];
  out[10] = a4[10] + b[10];
  out[11] = a4[11] + b[11];
  out[12] = a4[12] + b[12];
  out[13] = a4[13] + b[13];
  out[14] = a4[14] + b[14];
  out[15] = a4[15] + b[15];
  return out;
}
function subtract2(out, a4, b) {
  out[0] = a4[0] - b[0];
  out[1] = a4[1] - b[1];
  out[2] = a4[2] - b[2];
  out[3] = a4[3] - b[3];
  out[4] = a4[4] - b[4];
  out[5] = a4[5] - b[5];
  out[6] = a4[6] - b[6];
  out[7] = a4[7] - b[7];
  out[8] = a4[8] - b[8];
  out[9] = a4[9] - b[9];
  out[10] = a4[10] - b[10];
  out[11] = a4[11] - b[11];
  out[12] = a4[12] - b[12];
  out[13] = a4[13] - b[13];
  out[14] = a4[14] - b[14];
  out[15] = a4[15] - b[15];
  return out;
}
function multiplyScalar2(out, a4, b) {
  out[0] = a4[0] * b;
  out[1] = a4[1] * b;
  out[2] = a4[2] * b;
  out[3] = a4[3] * b;
  out[4] = a4[4] * b;
  out[5] = a4[5] * b;
  out[6] = a4[6] * b;
  out[7] = a4[7] * b;
  out[8] = a4[8] * b;
  out[9] = a4[9] * b;
  out[10] = a4[10] * b;
  out[11] = a4[11] * b;
  out[12] = a4[12] * b;
  out[13] = a4[13] * b;
  out[14] = a4[14] * b;
  out[15] = a4[15] * b;
  return out;
}
function multiplyScalarAndAdd2(out, a4, b, scale11) {
  out[0] = a4[0] + b[0] * scale11;
  out[1] = a4[1] + b[1] * scale11;
  out[2] = a4[2] + b[2] * scale11;
  out[3] = a4[3] + b[3] * scale11;
  out[4] = a4[4] + b[4] * scale11;
  out[5] = a4[5] + b[5] * scale11;
  out[6] = a4[6] + b[6] * scale11;
  out[7] = a4[7] + b[7] * scale11;
  out[8] = a4[8] + b[8] * scale11;
  out[9] = a4[9] + b[9] * scale11;
  out[10] = a4[10] + b[10] * scale11;
  out[11] = a4[11] + b[11] * scale11;
  out[12] = a4[12] + b[12] * scale11;
  out[13] = a4[13] + b[13] * scale11;
  out[14] = a4[14] + b[14] * scale11;
  out[15] = a4[15] + b[15] * scale11;
  return out;
}
function exactEquals2(a4, b) {
  return a4[0] === b[0] && a4[1] === b[1] && a4[2] === b[2] && a4[3] === b[3] && a4[4] === b[4] && a4[5] === b[5] && a4[6] === b[6] && a4[7] === b[7] && a4[8] === b[8] && a4[9] === b[9] && a4[10] === b[10] && a4[11] === b[11] && a4[12] === b[12] && a4[13] === b[13] && a4[14] === b[14] && a4[15] === b[15];
}
function equals2(a4, b) {
  var a0 = a4[0], a1 = a4[1], a22 = a4[2], a32 = a4[3];
  var a42 = a4[4], a5 = a4[5], a6 = a4[6], a7 = a4[7];
  var a8 = a4[8], a9 = a4[9], a10 = a4[10], a11 = a4[11];
  var a12 = a4[12], a13 = a4[13], a14 = a4[14], a15 = a4[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3)) && Math.abs(a42 - b4) <= EPSILON * Math.max(1, Math.abs(a42), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul2 = multiply2;
var sub2 = subtract2;

// node_modules/gl-matrix/esm/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add5,
  calculateW: () => calculateW,
  clone: () => clone6,
  conjugate: () => conjugate,
  copy: () => copy5,
  create: () => create5,
  dot: () => dot3,
  equals: () => equals5,
  exactEquals: () => exactEquals5,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues5,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity3,
  invert: () => invert3,
  len: () => len3,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul5,
  multiply: () => multiply5,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random3,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  rotationTo: () => rotationTo,
  scale: () => scale5,
  set: () => set5,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen3,
  squaredLength: () => squaredLength3,
  str: () => str5
});

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add3,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone4,
  copy: () => copy3,
  create: () => create3,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals3,
  exactEquals: () => exactEquals3,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues3,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max2,
  min: () => min,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round,
  scale: () => scale3,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set3,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone4(a4) {
  var out = new ARRAY_TYPE(3);
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  return out;
}
function length(a4) {
  var x3 = a4[0];
  var y3 = a4[1];
  var z = a4[2];
  return Math.hypot(x3, y3, z);
}
function fromValues3(x3, y3, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  return out;
}
function copy3(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  return out;
}
function set3(out, x3, y3, z) {
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  return out;
}
function add3(out, a4, b) {
  out[0] = a4[0] + b[0];
  out[1] = a4[1] + b[1];
  out[2] = a4[2] + b[2];
  return out;
}
function subtract3(out, a4, b) {
  out[0] = a4[0] - b[0];
  out[1] = a4[1] - b[1];
  out[2] = a4[2] - b[2];
  return out;
}
function multiply3(out, a4, b) {
  out[0] = a4[0] * b[0];
  out[1] = a4[1] * b[1];
  out[2] = a4[2] * b[2];
  return out;
}
function divide(out, a4, b) {
  out[0] = a4[0] / b[0];
  out[1] = a4[1] / b[1];
  out[2] = a4[2] / b[2];
  return out;
}
function ceil(out, a4) {
  out[0] = Math.ceil(a4[0]);
  out[1] = Math.ceil(a4[1]);
  out[2] = Math.ceil(a4[2]);
  return out;
}
function floor(out, a4) {
  out[0] = Math.floor(a4[0]);
  out[1] = Math.floor(a4[1]);
  out[2] = Math.floor(a4[2]);
  return out;
}
function min(out, a4, b) {
  out[0] = Math.min(a4[0], b[0]);
  out[1] = Math.min(a4[1], b[1]);
  out[2] = Math.min(a4[2], b[2]);
  return out;
}
function max2(out, a4, b) {
  out[0] = Math.max(a4[0], b[0]);
  out[1] = Math.max(a4[1], b[1]);
  out[2] = Math.max(a4[2], b[2]);
  return out;
}
function round(out, a4) {
  out[0] = Math.round(a4[0]);
  out[1] = Math.round(a4[1]);
  out[2] = Math.round(a4[2]);
  return out;
}
function scale3(out, a4, b) {
  out[0] = a4[0] * b;
  out[1] = a4[1] * b;
  out[2] = a4[2] * b;
  return out;
}
function scaleAndAdd(out, a4, b, scale11) {
  out[0] = a4[0] + b[0] * scale11;
  out[1] = a4[1] + b[1] * scale11;
  out[2] = a4[2] + b[2] * scale11;
  return out;
}
function distance(a4, b) {
  var x3 = b[0] - a4[0];
  var y3 = b[1] - a4[1];
  var z = b[2] - a4[2];
  return Math.hypot(x3, y3, z);
}
function squaredDistance(a4, b) {
  var x3 = b[0] - a4[0];
  var y3 = b[1] - a4[1];
  var z = b[2] - a4[2];
  return x3 * x3 + y3 * y3 + z * z;
}
function squaredLength(a4) {
  var x3 = a4[0];
  var y3 = a4[1];
  var z = a4[2];
  return x3 * x3 + y3 * y3 + z * z;
}
function negate(out, a4) {
  out[0] = -a4[0];
  out[1] = -a4[1];
  out[2] = -a4[2];
  return out;
}
function inverse(out, a4) {
  out[0] = 1 / a4[0];
  out[1] = 1 / a4[1];
  out[2] = 1 / a4[2];
  return out;
}
function normalize(out, a4) {
  var x3 = a4[0];
  var y3 = a4[1];
  var z = a4[2];
  var len5 = x3 * x3 + y3 * y3 + z * z;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a4[0] * len5;
  out[1] = a4[1] * len5;
  out[2] = a4[2] * len5;
  return out;
}
function dot(a4, b) {
  return a4[0] * b[0] + a4[1] * b[1] + a4[2] * b[2];
}
function cross(out, a4, b) {
  var ax = a4[0], ay = a4[1], az = a4[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a4, b, t) {
  var ax = a4[0];
  var ay = a4[1];
  var az = a4[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function hermite(out, a4, b, c5, d3, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a4[0] * factor1 + b[0] * factor2 + c5[0] * factor3 + d3[0] * factor4;
  out[1] = a4[1] * factor1 + b[1] * factor2 + c5[1] * factor3 + d3[1] * factor4;
  out[2] = a4[2] * factor1 + b[2] * factor2 + c5[2] * factor3 + d3[2] * factor4;
  return out;
}
function bezier(out, a4, b, c5, d3, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a4[0] * factor1 + b[0] * factor2 + c5[0] * factor3 + d3[0] * factor4;
  out[1] = a4[1] * factor1 + b[1] * factor2 + c5[1] * factor3 + d3[1] * factor4;
  out[2] = a4[2] * factor1 + b[2] * factor2 + c5[2] * factor3 + d3[2] * factor4;
  return out;
}
function random(out, scale11) {
  scale11 = scale11 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale11;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale11;
  return out;
}
function transformMat4(out, a4, m3) {
  var x3 = a4[0], y3 = a4[1], z = a4[2];
  var w = m3[3] * x3 + m3[7] * y3 + m3[11] * z + m3[15];
  w = w || 1;
  out[0] = (m3[0] * x3 + m3[4] * y3 + m3[8] * z + m3[12]) / w;
  out[1] = (m3[1] * x3 + m3[5] * y3 + m3[9] * z + m3[13]) / w;
  out[2] = (m3[2] * x3 + m3[6] * y3 + m3[10] * z + m3[14]) / w;
  return out;
}
function transformMat3(out, a4, m3) {
  var x3 = a4[0], y3 = a4[1], z = a4[2];
  out[0] = x3 * m3[0] + y3 * m3[3] + z * m3[6];
  out[1] = x3 * m3[1] + y3 * m3[4] + z * m3[7];
  out[2] = x3 * m3[2] + y3 * m3[5] + z * m3[8];
  return out;
}
function transformQuat(out, a4, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x3 = a4[0], y3 = a4[1], z = a4[2];
  var uvx = qy * z - qz * y3, uvy = qz * x3 - qx * z, uvz = qx * y3 - qy * x3;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x3 + uvx + uuvx;
  out[1] = y3 + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX2(out, a4, b, rad2) {
  var p2 = [], r = [];
  p2[0] = a4[0] - b[0];
  p2[1] = a4[1] - b[1];
  p2[2] = a4[2] - b[2];
  r[0] = p2[0];
  r[1] = p2[1] * Math.cos(rad2) - p2[2] * Math.sin(rad2);
  r[2] = p2[1] * Math.sin(rad2) + p2[2] * Math.cos(rad2);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY2(out, a4, b, rad2) {
  var p2 = [], r = [];
  p2[0] = a4[0] - b[0];
  p2[1] = a4[1] - b[1];
  p2[2] = a4[2] - b[2];
  r[0] = p2[2] * Math.sin(rad2) + p2[0] * Math.cos(rad2);
  r[1] = p2[1];
  r[2] = p2[2] * Math.cos(rad2) - p2[0] * Math.sin(rad2);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ2(out, a4, b, rad2) {
  var p2 = [], r = [];
  p2[0] = a4[0] - b[0];
  p2[1] = a4[1] - b[1];
  p2[2] = a4[2] - b[2];
  r[0] = p2[0] * Math.cos(rad2) - p2[1] * Math.sin(rad2);
  r[1] = p2[0] * Math.sin(rad2) + p2[1] * Math.cos(rad2);
  r[2] = p2[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a4, b) {
  var ax = a4[0], ay = a4[1], az = a4[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a4, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str3(a4) {
  return "vec3(" + a4[0] + ", " + a4[1] + ", " + a4[2] + ")";
}
function exactEquals3(a4, b) {
  return a4[0] === b[0] && a4[1] === b[1] && a4[2] === b[2];
}
function equals3(a4, b) {
  var a0 = a4[0], a1 = a4[1], a22 = a4[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2));
}
var sub3 = subtract3;
var mul3 = multiply3;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create3();
  return function(a4, stride, offset2, count4, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset2) {
      offset2 = 0;
    }
    if (count4) {
      l = Math.min(count4 * stride + offset2, a4.length);
    } else {
      l = a4.length;
    }
    for (i = offset2; i < l; i += stride) {
      vec[0] = a4[i];
      vec[1] = a4[i + 1];
      vec[2] = a4[i + 2];
      fn(vec, vec, arg);
      a4[i] = vec[0];
      a4[i + 1] = vec[1];
      a4[i + 2] = vec[2];
    }
    return a4;
  };
}();

// node_modules/gl-matrix/esm/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add4,
  ceil: () => ceil2,
  clone: () => clone5,
  copy: () => copy4,
  create: () => create4,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals4,
  exactEquals: () => exactEquals4,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues4,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp2,
  max: () => max3,
  min: () => min2,
  mul: () => mul4,
  multiply: () => multiply4,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  round: () => round2,
  scale: () => scale4,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set4,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract4,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat2,
  zero: () => zero2
});
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone5(a4) {
  var out = new ARRAY_TYPE(4);
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  return out;
}
function fromValues4(x3, y3, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy4(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  out[2] = a4[2];
  out[3] = a4[3];
  return out;
}
function set4(out, x3, y3, z, w) {
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  out[3] = w;
  return out;
}
function add4(out, a4, b) {
  out[0] = a4[0] + b[0];
  out[1] = a4[1] + b[1];
  out[2] = a4[2] + b[2];
  out[3] = a4[3] + b[3];
  return out;
}
function subtract4(out, a4, b) {
  out[0] = a4[0] - b[0];
  out[1] = a4[1] - b[1];
  out[2] = a4[2] - b[2];
  out[3] = a4[3] - b[3];
  return out;
}
function multiply4(out, a4, b) {
  out[0] = a4[0] * b[0];
  out[1] = a4[1] * b[1];
  out[2] = a4[2] * b[2];
  out[3] = a4[3] * b[3];
  return out;
}
function divide2(out, a4, b) {
  out[0] = a4[0] / b[0];
  out[1] = a4[1] / b[1];
  out[2] = a4[2] / b[2];
  out[3] = a4[3] / b[3];
  return out;
}
function ceil2(out, a4) {
  out[0] = Math.ceil(a4[0]);
  out[1] = Math.ceil(a4[1]);
  out[2] = Math.ceil(a4[2]);
  out[3] = Math.ceil(a4[3]);
  return out;
}
function floor2(out, a4) {
  out[0] = Math.floor(a4[0]);
  out[1] = Math.floor(a4[1]);
  out[2] = Math.floor(a4[2]);
  out[3] = Math.floor(a4[3]);
  return out;
}
function min2(out, a4, b) {
  out[0] = Math.min(a4[0], b[0]);
  out[1] = Math.min(a4[1], b[1]);
  out[2] = Math.min(a4[2], b[2]);
  out[3] = Math.min(a4[3], b[3]);
  return out;
}
function max3(out, a4, b) {
  out[0] = Math.max(a4[0], b[0]);
  out[1] = Math.max(a4[1], b[1]);
  out[2] = Math.max(a4[2], b[2]);
  out[3] = Math.max(a4[3], b[3]);
  return out;
}
function round2(out, a4) {
  out[0] = Math.round(a4[0]);
  out[1] = Math.round(a4[1]);
  out[2] = Math.round(a4[2]);
  out[3] = Math.round(a4[3]);
  return out;
}
function scale4(out, a4, b) {
  out[0] = a4[0] * b;
  out[1] = a4[1] * b;
  out[2] = a4[2] * b;
  out[3] = a4[3] * b;
  return out;
}
function scaleAndAdd2(out, a4, b, scale11) {
  out[0] = a4[0] + b[0] * scale11;
  out[1] = a4[1] + b[1] * scale11;
  out[2] = a4[2] + b[2] * scale11;
  out[3] = a4[3] + b[3] * scale11;
  return out;
}
function distance2(a4, b) {
  var x3 = b[0] - a4[0];
  var y3 = b[1] - a4[1];
  var z = b[2] - a4[2];
  var w = b[3] - a4[3];
  return Math.hypot(x3, y3, z, w);
}
function squaredDistance2(a4, b) {
  var x3 = b[0] - a4[0];
  var y3 = b[1] - a4[1];
  var z = b[2] - a4[2];
  var w = b[3] - a4[3];
  return x3 * x3 + y3 * y3 + z * z + w * w;
}
function length2(a4) {
  var x3 = a4[0];
  var y3 = a4[1];
  var z = a4[2];
  var w = a4[3];
  return Math.hypot(x3, y3, z, w);
}
function squaredLength2(a4) {
  var x3 = a4[0];
  var y3 = a4[1];
  var z = a4[2];
  var w = a4[3];
  return x3 * x3 + y3 * y3 + z * z + w * w;
}
function negate2(out, a4) {
  out[0] = -a4[0];
  out[1] = -a4[1];
  out[2] = -a4[2];
  out[3] = -a4[3];
  return out;
}
function inverse2(out, a4) {
  out[0] = 1 / a4[0];
  out[1] = 1 / a4[1];
  out[2] = 1 / a4[2];
  out[3] = 1 / a4[3];
  return out;
}
function normalize2(out, a4) {
  var x3 = a4[0];
  var y3 = a4[1];
  var z = a4[2];
  var w = a4[3];
  var len5 = x3 * x3 + y3 * y3 + z * z + w * w;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = x3 * len5;
  out[1] = y3 * len5;
  out[2] = z * len5;
  out[3] = w * len5;
  return out;
}
function dot2(a4, b) {
  return a4[0] * b[0] + a4[1] * b[1] + a4[2] * b[2] + a4[3] * b[3];
}
function cross2(out, u, v, w) {
  var A6 = v[0] * w[1] - v[1] * w[0], B4 = v[0] * w[2] - v[2] * w[0], C4 = v[0] * w[3] - v[3] * w[0], D2 = v[1] * w[2] - v[2] * w[1], E2 = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E2 + J * D2;
  out[1] = -(G * F) + I * C4 - J * B4;
  out[2] = G * E2 - H * C4 + J * A6;
  out[3] = -(G * D2) + H * B4 - I * A6;
  return out;
}
function lerp2(out, a4, b, t) {
  var ax = a4[0];
  var ay = a4[1];
  var az = a4[2];
  var aw = a4[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
function random2(out, scale11) {
  scale11 = scale11 || 1;
  var v1, v2, v3, v4;
  var s1, s22;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s22 = v3 * v3 + v4 * v4;
  } while (s22 >= 1);
  var d3 = Math.sqrt((1 - s1) / s22);
  out[0] = scale11 * v1;
  out[1] = scale11 * v2;
  out[2] = scale11 * v3 * d3;
  out[3] = scale11 * v4 * d3;
  return out;
}
function transformMat42(out, a4, m3) {
  var x3 = a4[0], y3 = a4[1], z = a4[2], w = a4[3];
  out[0] = m3[0] * x3 + m3[4] * y3 + m3[8] * z + m3[12] * w;
  out[1] = m3[1] * x3 + m3[5] * y3 + m3[9] * z + m3[13] * w;
  out[2] = m3[2] * x3 + m3[6] * y3 + m3[10] * z + m3[14] * w;
  out[3] = m3[3] * x3 + m3[7] * y3 + m3[11] * z + m3[15] * w;
  return out;
}
function transformQuat2(out, a4, q) {
  var x3 = a4[0], y3 = a4[1], z = a4[2];
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var ix = qw * x3 + qy * z - qz * y3;
  var iy = qw * y3 + qz * x3 - qx * z;
  var iz = qw * z + qx * y3 - qy * x3;
  var iw = -qx * x3 - qy * y3 - qz * z;
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a4[3];
  return out;
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str4(a4) {
  return "vec4(" + a4[0] + ", " + a4[1] + ", " + a4[2] + ", " + a4[3] + ")";
}
function exactEquals4(a4, b) {
  return a4[0] === b[0] && a4[1] === b[1] && a4[2] === b[2] && a4[3] === b[3];
}
function equals4(a4, b) {
  var a0 = a4[0], a1 = a4[1], a22 = a4[2], a32 = a4[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3));
}
var sub4 = subtract4;
var mul4 = multiply4;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var len2 = length2;
var sqrLen2 = squaredLength2;
var forEach2 = function() {
  var vec = create4();
  return function(a4, stride, offset2, count4, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset2) {
      offset2 = 0;
    }
    if (count4) {
      l = Math.min(count4 * stride + offset2, a4.length);
    } else {
      l = a4.length;
    }
    for (i = offset2; i < l; i += stride) {
      vec[0] = a4[i];
      vec[1] = a4[i + 1];
      vec[2] = a4[i + 2];
      vec[3] = a4[i + 3];
      fn(vec, vec, arg);
      a4[i] = vec[0];
      a4[i + 1] = vec[1];
      a4[i + 2] = vec[2];
      a4[i + 3] = vec[3];
    }
    return a4;
  };
}();

// node_modules/gl-matrix/esm/quat.js
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity3(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad2) {
  rad2 = rad2 * 0.5;
  var s3 = Math.sin(rad2);
  out[0] = s3 * axis[0];
  out[1] = s3 * axis[1];
  out[2] = s3 * axis[2];
  out[3] = Math.cos(rad2);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad2 = Math.acos(q[3]) * 2;
  var s3 = Math.sin(rad2 / 2);
  if (s3 > EPSILON) {
    out_axis[0] = q[0] / s3;
    out_axis[1] = q[1] / s3;
    out_axis[2] = q[2] / s3;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad2;
}
function getAngle(a4, b) {
  var dotproduct = dot3(a4, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply5(out, a4, b) {
  var ax = a4[0], ay = a4[1], az = a4[2], aw = a4[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a4, rad2) {
  rad2 *= 0.5;
  var ax = a4[0], ay = a4[1], az = a4[2], aw = a4[3];
  var bx = Math.sin(rad2), bw = Math.cos(rad2);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a4, rad2) {
  rad2 *= 0.5;
  var ax = a4[0], ay = a4[1], az = a4[2], aw = a4[3];
  var by = Math.sin(rad2), bw = Math.cos(rad2);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a4, rad2) {
  rad2 *= 0.5;
  var ax = a4[0], ay = a4[1], az = a4[2], aw = a4[3];
  var bz = Math.sin(rad2), bw = Math.cos(rad2);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a4) {
  var x3 = a4[0], y3 = a4[1], z = a4[2];
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x3 * x3 - y3 * y3 - z * z));
  return out;
}
function exp(out, a4) {
  var x3 = a4[0], y3 = a4[1], z = a4[2], w = a4[3];
  var r = Math.sqrt(x3 * x3 + y3 * y3 + z * z);
  var et = Math.exp(w);
  var s3 = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x3 * s3;
  out[1] = y3 * s3;
  out[2] = z * s3;
  out[3] = et * Math.cos(r);
  return out;
}
function ln(out, a4) {
  var x3 = a4[0], y3 = a4[1], z = a4[2], w = a4[3];
  var r = Math.sqrt(x3 * x3 + y3 * y3 + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x3 * t;
  out[1] = y3 * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x3 * x3 + y3 * y3 + z * z + w * w);
  return out;
}
function pow(out, a4, b) {
  ln(out, a4);
  scale5(out, out, b);
  exp(out, out);
  return out;
}
function slerp(out, a4, b, t) {
  var ax = a4[0], ay = a4[1], az = a4[2], aw = a4[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random3(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert3(out, a4) {
  var a0 = a4[0], a1 = a4[1], a22 = a4[2], a32 = a4[3];
  var dot9 = a0 * a0 + a1 * a1 + a22 * a22 + a32 * a32;
  var invDot = dot9 ? 1 / dot9 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a22 * invDot;
  out[3] = a32 * invDot;
  return out;
}
function conjugate(out, a4) {
  out[0] = -a4[0];
  out[1] = -a4[1];
  out[2] = -a4[2];
  out[3] = a4[3];
  return out;
}
function fromMat3(out, m3) {
  var fTrace = m3[0] + m3[4] + m3[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m3[5] - m3[7]) * fRoot;
    out[1] = (m3[6] - m3[2]) * fRoot;
    out[2] = (m3[1] - m3[3]) * fRoot;
  } else {
    var i = 0;
    if (m3[4] > m3[0])
      i = 1;
    if (m3[8] > m3[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k2 = (i + 2) % 3;
    fRoot = Math.sqrt(m3[i * 3 + i] - m3[j * 3 + j] - m3[k2 * 3 + k2] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m3[j * 3 + k2] - m3[k2 * 3 + j]) * fRoot;
    out[j] = (m3[j * 3 + i] + m3[i * 3 + j]) * fRoot;
    out[k2] = (m3[k2 * 3 + i] + m3[i * 3 + k2]) * fRoot;
  }
  return out;
}
function fromEuler(out, x3, y3, z) {
  var halfToRad = 0.5 * Math.PI / 180;
  x3 *= halfToRad;
  y3 *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x3);
  var cx = Math.cos(x3);
  var sy = Math.sin(y3);
  var cy = Math.cos(y3);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
function str5(a4) {
  return "quat(" + a4[0] + ", " + a4[1] + ", " + a4[2] + ", " + a4[3] + ")";
}
var clone6 = clone5;
var fromValues5 = fromValues4;
var copy5 = copy4;
var set5 = set4;
var add5 = add4;
var mul5 = multiply5;
var scale5 = scale4;
var dot3 = dot2;
var lerp3 = lerp2;
var length3 = length2;
var len3 = length3;
var squaredLength3 = squaredLength2;
var sqrLen3 = squaredLength3;
var normalize3 = normalize2;
var exactEquals5 = exactEquals4;
var equals5 = equals4;
var rotationTo = function() {
  var tmpvec3 = create3();
  var xUnitVec3 = fromValues3(1, 0, 0);
  var yUnitVec3 = fromValues3(0, 1, 0);
  return function(out, a4, b) {
    var dot9 = dot(a4, b);
    if (dot9 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a4);
      if (len(tmpvec3) < 1e-6)
        cross(tmpvec3, yUnitVec3, a4);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot9 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a4, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot9;
      return normalize3(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create5();
  var temp2 = create5();
  return function(out, a4, b, c5, d3, t) {
    slerp(temp1, a4, d3, t);
    slerp(temp2, b, c5, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
var setAxes = function() {
  var matr = create();
  return function(out, view, right2, up) {
    matr[0] = right2[0];
    matr[3] = right2[1];
    matr[6] = right2[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
}();

// node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add6,
  angle: () => angle2,
  ceil: () => ceil3,
  clone: () => clone7,
  copy: () => copy6,
  create: () => create6,
  cross: () => cross3,
  dist: () => dist3,
  distance: () => distance3,
  div: () => div3,
  divide: () => divide3,
  dot: () => dot4,
  equals: () => equals6,
  exactEquals: () => exactEquals6,
  floor: () => floor3,
  forEach: () => forEach3,
  fromValues: () => fromValues6,
  inverse: () => inverse3,
  len: () => len4,
  length: () => length4,
  lerp: () => lerp4,
  max: () => max4,
  min: () => min3,
  mul: () => mul6,
  multiply: () => multiply6,
  negate: () => negate3,
  normalize: () => normalize4,
  random: () => random4,
  rotate: () => rotate3,
  round: () => round3,
  scale: () => scale6,
  scaleAndAdd: () => scaleAndAdd3,
  set: () => set6,
  sqrDist: () => sqrDist3,
  sqrLen: () => sqrLen4,
  squaredDistance: () => squaredDistance3,
  squaredLength: () => squaredLength4,
  str: () => str6,
  sub: () => sub5,
  subtract: () => subtract5,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat43,
  zero: () => zero3
});
function create6() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone7(a4) {
  var out = new ARRAY_TYPE(2);
  out[0] = a4[0];
  out[1] = a4[1];
  return out;
}
function fromValues6(x3, y3) {
  var out = new ARRAY_TYPE(2);
  out[0] = x3;
  out[1] = y3;
  return out;
}
function copy6(out, a4) {
  out[0] = a4[0];
  out[1] = a4[1];
  return out;
}
function set6(out, x3, y3) {
  out[0] = x3;
  out[1] = y3;
  return out;
}
function add6(out, a4, b) {
  out[0] = a4[0] + b[0];
  out[1] = a4[1] + b[1];
  return out;
}
function subtract5(out, a4, b) {
  out[0] = a4[0] - b[0];
  out[1] = a4[1] - b[1];
  return out;
}
function multiply6(out, a4, b) {
  out[0] = a4[0] * b[0];
  out[1] = a4[1] * b[1];
  return out;
}
function divide3(out, a4, b) {
  out[0] = a4[0] / b[0];
  out[1] = a4[1] / b[1];
  return out;
}
function ceil3(out, a4) {
  out[0] = Math.ceil(a4[0]);
  out[1] = Math.ceil(a4[1]);
  return out;
}
function floor3(out, a4) {
  out[0] = Math.floor(a4[0]);
  out[1] = Math.floor(a4[1]);
  return out;
}
function min3(out, a4, b) {
  out[0] = Math.min(a4[0], b[0]);
  out[1] = Math.min(a4[1], b[1]);
  return out;
}
function max4(out, a4, b) {
  out[0] = Math.max(a4[0], b[0]);
  out[1] = Math.max(a4[1], b[1]);
  return out;
}
function round3(out, a4) {
  out[0] = Math.round(a4[0]);
  out[1] = Math.round(a4[1]);
  return out;
}
function scale6(out, a4, b) {
  out[0] = a4[0] * b;
  out[1] = a4[1] * b;
  return out;
}
function scaleAndAdd3(out, a4, b, scale11) {
  out[0] = a4[0] + b[0] * scale11;
  out[1] = a4[1] + b[1] * scale11;
  return out;
}
function distance3(a4, b) {
  var x3 = b[0] - a4[0], y3 = b[1] - a4[1];
  return Math.hypot(x3, y3);
}
function squaredDistance3(a4, b) {
  var x3 = b[0] - a4[0], y3 = b[1] - a4[1];
  return x3 * x3 + y3 * y3;
}
function length4(a4) {
  var x3 = a4[0], y3 = a4[1];
  return Math.hypot(x3, y3);
}
function squaredLength4(a4) {
  var x3 = a4[0], y3 = a4[1];
  return x3 * x3 + y3 * y3;
}
function negate3(out, a4) {
  out[0] = -a4[0];
  out[1] = -a4[1];
  return out;
}
function inverse3(out, a4) {
  out[0] = 1 / a4[0];
  out[1] = 1 / a4[1];
  return out;
}
function normalize4(out, a4) {
  var x3 = a4[0], y3 = a4[1];
  var len5 = x3 * x3 + y3 * y3;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a4[0] * len5;
  out[1] = a4[1] * len5;
  return out;
}
function dot4(a4, b) {
  return a4[0] * b[0] + a4[1] * b[1];
}
function cross3(out, a4, b) {
  var z = a4[0] * b[1] - a4[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp4(out, a4, b, t) {
  var ax = a4[0], ay = a4[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function random4(out, scale11) {
  scale11 = scale11 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale11;
  out[1] = Math.sin(r) * scale11;
  return out;
}
function transformMat2(out, a4, m3) {
  var x3 = a4[0], y3 = a4[1];
  out[0] = m3[0] * x3 + m3[2] * y3;
  out[1] = m3[1] * x3 + m3[3] * y3;
  return out;
}
function transformMat2d(out, a4, m3) {
  var x3 = a4[0], y3 = a4[1];
  out[0] = m3[0] * x3 + m3[2] * y3 + m3[4];
  out[1] = m3[1] * x3 + m3[3] * y3 + m3[5];
  return out;
}
function transformMat32(out, a4, m3) {
  var x3 = a4[0], y3 = a4[1];
  out[0] = m3[0] * x3 + m3[3] * y3 + m3[6];
  out[1] = m3[1] * x3 + m3[4] * y3 + m3[7];
  return out;
}
function transformMat43(out, a4, m3) {
  var x3 = a4[0];
  var y3 = a4[1];
  out[0] = m3[0] * x3 + m3[4] * y3 + m3[12];
  out[1] = m3[1] * x3 + m3[5] * y3 + m3[13];
  return out;
}
function rotate3(out, a4, b, rad2) {
  var p0 = a4[0] - b[0], p1 = a4[1] - b[1], sinC = Math.sin(rad2), cosC = Math.cos(rad2);
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
function angle2(a4, b) {
  var x12 = a4[0], y12 = a4[1], x22 = b[0], y22 = b[1], mag = Math.sqrt(x12 * x12 + y12 * y12) * Math.sqrt(x22 * x22 + y22 * y22), cosine = mag && (x12 * x22 + y12 * y22) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str6(a4) {
  return "vec2(" + a4[0] + ", " + a4[1] + ")";
}
function exactEquals6(a4, b) {
  return a4[0] === b[0] && a4[1] === b[1];
}
function equals6(a4, b) {
  var a0 = a4[0], a1 = a4[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len4 = length4;
var sub5 = subtract5;
var mul6 = multiply6;
var div3 = divide3;
var dist3 = distance3;
var sqrDist3 = squaredDistance3;
var sqrLen4 = squaredLength4;
var forEach3 = function() {
  var vec = create6();
  return function(a4, stride, offset2, count4, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset2) {
      offset2 = 0;
    }
    if (count4) {
      l = Math.min(count4 * stride + offset2, a4.length);
    } else {
      l = a4.length;
    }
    for (i = offset2; i < l; i += stride) {
      vec[0] = a4[i];
      vec[1] = a4[i + 1];
      fn(vec, vec, arg);
      a4[i] = vec[0];
      a4[i + 1] = vec[1];
    }
    return a4;
  };
}();

// node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d3, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
    d4.__proto__ = b2;
  } || function(d4, b2) {
    for (var p2 in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p2))
        d4[p2] = b2[p2];
  };
  return extendStatics(d3, b);
};
function __extends(d3, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d3, b);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign56(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
}
function __values(o) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o[s3], i = 0;
  if (m3)
    return m3.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArrays() {
  for (var s3 = 0, i = 0, il = arguments.length; i < il; i++)
    s3 += arguments[i].length;
  for (var r = Array(s3), k2 = 0, i = 0; i < il; i++)
    for (var a4 = arguments[i], j = 0, jl = a4.length; j < jl; j++, k2++)
      r[k2] = a4[j];
  return r;
}
function __spreadArray(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

// node_modules/@antv/util/esm/path/parser/params-parser.js
var paramsParser = {
  x1: 0,
  y1: 0,
  x2: 0,
  y2: 0,
  x: 0,
  y: 0,
  qx: null,
  qy: null
};

// node_modules/@antv/util/esm/path/process/fix-arc.js
function fixArc(pathArray, allPathCommands, i) {
  if (pathArray[i].length > 7) {
    pathArray[i].shift();
    var pi4 = pathArray[i];
    var ni = i;
    while (pi4.length) {
      allPathCommands[i] = "A";
      pathArray.splice(ni += 1, 0, ["C"].concat(pi4.splice(0, 6)));
    }
    pathArray.splice(i, 1);
  }
}

// node_modules/@antv/util/esm/path/parser/params-count.js
var paramsCount = {
  a: 7,
  c: 6,
  h: 1,
  l: 2,
  m: 2,
  r: 4,
  q: 4,
  s: 4,
  t: 2,
  v: 1,
  z: 0
};

// node_modules/@antv/util/esm/path/util/is-path-array.js
function isPathArray(path2) {
  return Array.isArray(path2) && path2.every(function(seg) {
    var lk = seg[0].toLowerCase();
    return paramsCount[lk] === seg.length - 1 && "achlmqstvz".includes(lk);
  });
}

// node_modules/@antv/util/esm/path/util/is-absolute-array.js
function isAbsoluteArray(path2) {
  return isPathArray(path2) && // @ts-ignore -- `isPathArray` also checks if it's `Array`
  path2.every(function(_a2) {
    var x3 = _a2[0];
    return x3 === x3.toUpperCase();
  });
}

// node_modules/@antv/util/esm/path/util/is-normalized-array.js
function isNormalizedArray(path2) {
  return isAbsoluteArray(path2) && path2.every(function(_a2) {
    var pc = _a2[0];
    return "ACLMQZ".includes(pc);
  });
}

// node_modules/@antv/util/esm/path/parser/finalize-segment.js
function finalizeSegment(path2) {
  var pathCommand = path2.pathValue[path2.segmentStart];
  var LK = pathCommand.toLowerCase();
  var data2 = path2.data;
  while (data2.length >= paramsCount[LK]) {
    if (LK === "m" && data2.length > 2) {
      path2.segments.push([pathCommand].concat(data2.splice(0, 2)));
      LK = "l";
      pathCommand = pathCommand === "m" ? "l" : "L";
    } else {
      path2.segments.push([pathCommand].concat(data2.splice(0, paramsCount[LK])));
    }
    if (!paramsCount[LK]) {
      break;
    }
  }
}

// node_modules/@antv/util/esm/path/parser/scan-flag.js
function scanFlag(path2) {
  var index3 = path2.index, pathValue = path2.pathValue;
  var code = pathValue.charCodeAt(index3);
  if (code === 48) {
    path2.param = 0;
    path2.index += 1;
    return;
  }
  if (code === 49) {
    path2.param = 1;
    path2.index += 1;
    return;
  }
  path2.err = '[path-util]: invalid Arc flag "'.concat(pathValue[index3], '", expecting 0 or 1 at index ').concat(index3);
}

// node_modules/@antv/util/esm/path/parser/is-digit-start.js
function isDigitStart(code) {
  return code >= 48 && code <= 57 || code === 43 || code === 45 || code === 46;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}

// node_modules/@antv/util/esm/path/parser/scan-param.js
function scanParam(path2) {
  var max11 = path2.max, pathValue = path2.pathValue, start = path2.index;
  var index3 = start;
  var zeroFirst = false;
  var hasCeiling = false;
  var hasDecimal = false;
  var hasDot = false;
  var ch2;
  if (index3 >= max11) {
    path2.err = "[path-util]: Invalid path value at index ".concat(index3, ', "pathValue" is missing param');
    return;
  }
  ch2 = pathValue.charCodeAt(index3);
  if (ch2 === 43 || ch2 === 45) {
    index3 += 1;
    ch2 = pathValue.charCodeAt(index3);
  }
  if (!isDigit(ch2) && ch2 !== 46) {
    path2.err = "[path-util]: Invalid path value at index ".concat(index3, ', "').concat(pathValue[index3], '" is not a number');
    return;
  }
  if (ch2 !== 46) {
    zeroFirst = ch2 === 48;
    index3 += 1;
    ch2 = pathValue.charCodeAt(index3);
    if (zeroFirst && index3 < max11) {
      if (ch2 && isDigit(ch2)) {
        path2.err = "[path-util]: Invalid path value at index ".concat(start, ', "').concat(pathValue[start], '" illegal number');
        return;
      }
    }
    while (index3 < max11 && isDigit(pathValue.charCodeAt(index3))) {
      index3 += 1;
      hasCeiling = true;
    }
    ch2 = pathValue.charCodeAt(index3);
  }
  if (ch2 === 46) {
    hasDot = true;
    index3 += 1;
    while (isDigit(pathValue.charCodeAt(index3))) {
      index3 += 1;
      hasDecimal = true;
    }
    ch2 = pathValue.charCodeAt(index3);
  }
  if (ch2 === 101 || ch2 === 69) {
    if (hasDot && !hasCeiling && !hasDecimal) {
      path2.err = "[path-util]: Invalid path value at index ".concat(index3, ', "').concat(pathValue[index3], '" invalid float exponent');
      return;
    }
    index3 += 1;
    ch2 = pathValue.charCodeAt(index3);
    if (ch2 === 43 || ch2 === 45) {
      index3 += 1;
    }
    if (index3 < max11 && isDigit(pathValue.charCodeAt(index3))) {
      while (index3 < max11 && isDigit(pathValue.charCodeAt(index3))) {
        index3 += 1;
      }
    } else {
      path2.err = "[path-util]: Invalid path value at index ".concat(index3, ', "').concat(pathValue[index3], '" invalid integer exponent');
      return;
    }
  }
  path2.index = index3;
  path2.param = +path2.pathValue.slice(start, index3);
}

// node_modules/@antv/util/esm/path/parser/is-space.js
function isSpace(ch2) {
  var specialSpaces = [
    5760,
    6158,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8239,
    8287,
    12288,
    65279
  ];
  return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233 || // Line terminators
  // White spaces
  ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && specialSpaces.includes(ch2);
}

// node_modules/@antv/util/esm/path/parser/skip-spaces.js
function skipSpaces(path2) {
  var pathValue = path2.pathValue, max11 = path2.max;
  while (path2.index < max11 && isSpace(pathValue.charCodeAt(path2.index))) {
    path2.index += 1;
  }
}

// node_modules/@antv/util/esm/path/parser/is-path-command.js
function isPathCommand(code) {
  switch (code | 32) {
    case 109:
    case 122:
    case 108:
    case 104:
    case 118:
    case 99:
    case 115:
    case 113:
    case 116:
    case 97:
      return true;
    default:
      return false;
  }
}

// node_modules/@antv/util/esm/path/parser/is-arc-command.js
function isArcCommand(code) {
  return (code | 32) === 97;
}

// node_modules/@antv/util/esm/path/parser/scan-segment.js
function scanSegment(path2) {
  var max11 = path2.max, pathValue = path2.pathValue, index3 = path2.index;
  var cmdCode = pathValue.charCodeAt(index3);
  var reqParams = paramsCount[pathValue[index3].toLowerCase()];
  path2.segmentStart = index3;
  if (!isPathCommand(cmdCode)) {
    path2.err = '[path-util]: Invalid path value "'.concat(pathValue[index3], '" is not a path command');
    return;
  }
  path2.index += 1;
  skipSpaces(path2);
  path2.data = [];
  if (!reqParams) {
    finalizeSegment(path2);
    return;
  }
  for (; ; ) {
    for (var i = reqParams; i > 0; i -= 1) {
      if (isArcCommand(cmdCode) && (i === 3 || i === 4))
        scanFlag(path2);
      else
        scanParam(path2);
      if (path2.err.length) {
        return;
      }
      path2.data.push(path2.param);
      skipSpaces(path2);
      if (path2.index < max11 && pathValue.charCodeAt(path2.index) === 44) {
        path2.index += 1;
        skipSpaces(path2);
      }
    }
    if (path2.index >= path2.max) {
      break;
    }
    if (!isDigitStart(pathValue.charCodeAt(path2.index))) {
      break;
    }
  }
  finalizeSegment(path2);
}

// node_modules/@antv/util/esm/path/parser/path-parser.js
var PathParser = (
  /** @class */
  function() {
    function PathParser2(pathString) {
      this.pathValue = pathString;
      this.segments = [];
      this.max = pathString.length;
      this.index = 0;
      this.param = 0;
      this.segmentStart = 0;
      this.data = [];
      this.err = "";
    }
    return PathParser2;
  }()
);

// node_modules/@antv/util/esm/path/parser/parse-path-string.js
function parsePathString(pathInput) {
  if (isPathArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path2 = new PathParser(pathInput);
  skipSpaces(path2);
  while (path2.index < path2.max && !path2.err.length) {
    scanSegment(path2);
  }
  return path2.err ? path2.err : path2.segments;
}

// node_modules/@antv/util/esm/path/convert/path-2-absolute.js
function path2Absolute(pathInput) {
  if (isAbsoluteArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path2 = parsePathString(pathInput);
  var x3 = 0;
  var y3 = 0;
  var mx = 0;
  var my = 0;
  return path2.map(function(segment) {
    var values4 = segment.slice(1).map(Number);
    var pathCommand = segment[0];
    var absCommand = pathCommand.toUpperCase();
    if (pathCommand === "M") {
      x3 = values4[0], y3 = values4[1];
      mx = x3;
      my = y3;
      return ["M", x3, y3];
    }
    var absoluteSegment;
    if (pathCommand !== absCommand) {
      switch (absCommand) {
        case "A":
          absoluteSegment = [
            absCommand,
            values4[0],
            values4[1],
            values4[2],
            values4[3],
            values4[4],
            values4[5] + x3,
            values4[6] + y3
          ];
          break;
        case "V":
          absoluteSegment = [absCommand, values4[0] + y3];
          break;
        case "H":
          absoluteSegment = [absCommand, values4[0] + x3];
          break;
        default: {
          var absValues = values4.map(function(n, j) {
            return n + (j % 2 ? y3 : x3);
          });
          absoluteSegment = [absCommand].concat(absValues);
        }
      }
    } else {
      absoluteSegment = [absCommand].concat(values4);
    }
    var segLength = absoluteSegment.length;
    switch (absCommand) {
      case "Z":
        x3 = mx;
        y3 = my;
        break;
      case "H":
        x3 = absoluteSegment[1];
        break;
      case "V":
        y3 = absoluteSegment[1];
        break;
      default:
        x3 = absoluteSegment[segLength - 2];
        y3 = absoluteSegment[segLength - 1];
        if (absCommand === "M") {
          mx = x3;
          my = y3;
        }
    }
    return absoluteSegment;
  });
}

// node_modules/@antv/util/esm/path/process/normalize-segment.js
function normalizeSegment(segment, params) {
  var pathCommand = segment[0];
  var px1 = params.x1, py1 = params.y1, px2 = params.x2, py2 = params.y2;
  var values4 = segment.slice(1).map(Number);
  var result = segment;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  if (pathCommand === "H") {
    result = ["L", segment[1], py1];
  } else if (pathCommand === "V") {
    result = ["L", px1, segment[1]];
  } else if (pathCommand === "S") {
    var x12 = px1 * 2 - px2;
    var y12 = py1 * 2 - py2;
    params.x1 = x12;
    params.y1 = y12;
    result = ["C", x12, y12].concat(values4);
  } else if (pathCommand === "T") {
    var qx = px1 * 2 - params.qx;
    var qy = py1 * 2 - params.qy;
    params.qx = qx;
    params.qy = qy;
    result = ["Q", qx, qy].concat(values4);
  } else if (pathCommand === "Q") {
    var nqx = values4[0], nqy = values4[1];
    params.qx = nqx;
    params.qy = nqy;
  }
  return result;
}

// node_modules/@antv/util/esm/path/process/normalize-path.js
function normalizePath(pathInput) {
  if (isNormalizedArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path2 = path2Absolute(pathInput);
  var params = __assign({}, paramsParser);
  for (var i = 0; i < path2.length; i += 1) {
    path2[i] = normalizeSegment(path2[i], params);
    var segment = path2[i];
    var seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  return path2;
}

// node_modules/@antv/util/esm/path/util/is-curve-array.js
function isCurveArray(path2) {
  return isNormalizedArray(path2) && path2.every(function(_a2) {
    var pc = _a2[0];
    return "MC".includes(pc);
  });
}

// node_modules/@antv/util/esm/path/util/rotate-vector.js
function rotateVector(x3, y3, rad2) {
  var X = x3 * Math.cos(rad2) - y3 * Math.sin(rad2);
  var Y = x3 * Math.sin(rad2) + y3 * Math.cos(rad2);
  return { x: X, y: Y };
}

// node_modules/@antv/util/esm/path/process/arc-2-cubic.js
function arcToCubic(X12, Y12, RX, RY, angle4, LAF, SF, X22, Y22, recursive) {
  var x12 = X12;
  var y12 = Y12;
  var rx = RX;
  var ry = RY;
  var x22 = X22;
  var y22 = Y22;
  var d120 = Math.PI * 120 / 180;
  var rad2 = Math.PI / 180 * (+angle4 || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  if (!recursive) {
    xy = rotateVector(x12, y12, -rad2);
    x12 = xy.x;
    y12 = xy.y;
    xy = rotateVector(x22, y22, -rad2);
    x22 = xy.x;
    y22 = xy.y;
    var x3 = (x12 - x22) / 2;
    var y3 = (y12 - y22) / 2;
    var h = x3 * x3 / (rx * rx) + y3 * y3 / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx *= h;
      ry *= h;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k2 = (LAF === SF ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y3 * y3 - ry2 * x3 * x3) / (rx2 * y3 * y3 + ry2 * x3 * x3)));
    cx = k2 * rx * y3 / ry + (x12 + x22) / 2;
    cy = k2 * -ry * x3 / rx + (y12 + y22) / 2;
    f1 = Math.asin(((y12 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f2 = Math.asin(((y22 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f1 = x12 < cx ? Math.PI - f1 : f1;
    f2 = x22 < cx ? Math.PI - f2 : f2;
    if (f1 < 0)
      f1 = Math.PI * 2 + f1;
    if (f2 < 0)
      f2 = Math.PI * 2 + f2;
    if (SF && f1 > f2) {
      f1 -= Math.PI * 2;
    }
    if (!SF && f2 > f1) {
      f2 -= Math.PI * 2;
    }
  } else {
    f1 = recursive[0], f2 = recursive[1], cx = recursive[2], cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > d120) {
    var f2old = f2;
    var x2old = x22;
    var y2old = y22;
    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);
    x22 = cx + rx * Math.cos(f2);
    y22 = cy + ry * Math.sin(f2);
    res = arcToCubic(x22, y22, rx, ry, angle4, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c22 = Math.cos(f2);
  var s22 = Math.sin(f2);
  var t = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t;
  var hy = 4 / 3 * ry * t;
  var m1 = [x12, y12];
  var m22 = [x12 + hx * s1, y12 - hy * c1];
  var m3 = [x22 + hx * s22, y22 - hy * c22];
  var m4 = [x22, y22];
  m22[0] = 2 * m1[0] - m22[0];
  m22[1] = 2 * m1[1] - m22[1];
  if (recursive) {
    return m22.concat(m3, m4, res);
  }
  res = m22.concat(m3, m4, res);
  var newres = [];
  for (var i = 0, ii = res.length; i < ii; i += 1) {
    newres[i] = i % 2 ? rotateVector(res[i - 1], res[i], rad2).y : rotateVector(res[i], res[i + 1], rad2).x;
  }
  return newres;
}

// node_modules/@antv/util/esm/path/process/quad-2-cubic.js
function quadToCubic(x12, y12, qx, qy, x22, y22) {
  var r13 = 1 / 3;
  var r23 = 2 / 3;
  return [
    r13 * x12 + r23 * qx,
    // cpx1
    r13 * y12 + r23 * qy,
    // cpy1
    r13 * x22 + r23 * qx,
    // cpx2
    r13 * y22 + r23 * qy,
    // cpy2
    x22,
    y22
    // x,y
  ];
}

// node_modules/@antv/util/esm/path/util/mid-point.js
function midPoint(a4, b, t) {
  var ax = a4[0];
  var ay = a4[1];
  var bx = b[0];
  var by = b[1];
  return [ax + (bx - ax) * t, ay + (by - ay) * t];
}

// node_modules/@antv/util/esm/path/process/line-2-cubic.js
var lineToCubic = function(x12, y12, x22, y22) {
  var t = 0.5;
  var mid2 = midPoint([x12, y12], [x22, y22], t);
  return __spreadArray(__spreadArray([], mid2, true), [x22, y22, x22, y22], false);
};

// node_modules/@antv/util/esm/path/process/segment-2-cubic.js
function segmentToCubic(segment, params) {
  var pathCommand = segment[0];
  var values4 = segment.slice(1).map(Number);
  var x3 = values4[0], y3 = values4[1];
  var args;
  var px1 = params.x1, py1 = params.y1, px2 = params.x, py = params.y;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  switch (pathCommand) {
    case "M":
      params.x = x3;
      params.y = y3;
      return segment;
    case "A":
      args = [px1, py1].concat(values4);
      return ["C"].concat(arcToCubic(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]));
    case "Q":
      params.qx = x3;
      params.qy = y3;
      args = [px1, py1].concat(values4);
      return ["C"].concat(quadToCubic(args[0], args[1], args[2], args[3], args[4], args[5]));
    case "L":
      return ["C"].concat(lineToCubic(px1, py1, x3, y3));
    case "Z":
      if (px1 === px2 && py1 === py) {
        return ["C", px1, py1, px2, py, px2, py];
      }
      return ["C"].concat(lineToCubic(px1, py1, px2, py));
    default:
  }
  return segment;
}

// node_modules/@antv/util/esm/path/convert/path-2-curve.js
function path2Curve(pathInput, needZCommandIndexes) {
  if (needZCommandIndexes === void 0) {
    needZCommandIndexes = false;
  }
  if (isCurveArray(pathInput)) {
    var cloned = [].concat(pathInput);
    if (needZCommandIndexes) {
      return [cloned, []];
    } else {
      return cloned;
    }
  }
  var path2 = normalizePath(pathInput);
  var params = __assign({}, paramsParser);
  var allPathCommands = [];
  var pathCommand = "";
  var ii = path2.length;
  var segment;
  var seglen;
  var zCommandIndexes = [];
  for (var i = 0; i < ii; i += 1) {
    if (path2[i])
      pathCommand = path2[i][0];
    allPathCommands[i] = pathCommand;
    var curveSegment = segmentToCubic(path2[i], params);
    path2[i] = curveSegment;
    fixArc(path2, allPathCommands, i);
    ii = path2.length;
    if (pathCommand === "Z") {
      zCommandIndexes.push(i);
    }
    segment = path2[i];
    seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  if (needZCommandIndexes) {
    return [path2, zCommandIndexes];
  } else {
    return path2;
  }
}

// node_modules/@antv/util/esm/path/process/clone-path.js
function clonePath(path2) {
  return path2.map(function(x3) {
    return Array.isArray(x3) ? [].concat(x3) : x3;
  });
}

// node_modules/@antv/util/esm/path/process/reverse-curve.js
function reverseCurve(pathArray) {
  var rotatedCurve = pathArray.slice(1).map(function(x3, i, curveOnly) {
    return !i ? pathArray[0].slice(1).concat(x3.slice(1)) : curveOnly[i - 1].slice(-2).concat(x3.slice(1));
  }).map(function(x3) {
    return x3.map(function(y3, i) {
      return x3[x3.length - i - 2 * (1 - i % 2)];
    });
  }).reverse();
  return [["M"].concat(rotatedCurve[0].slice(0, 2))].concat(rotatedCurve.map(function(x3) {
    return ["C"].concat(x3.slice(2));
  }));
}

// node_modules/@antv/util/esm/path/util/distance-square-root.js
function distanceSquareRoot(a4, b) {
  return Math.sqrt((a4[0] - b[0]) * (a4[0] - b[0]) + (a4[1] - b[1]) * (a4[1] - b[1]));
}

// node_modules/@antv/util/esm/path/util/segment-line-factory.js
function segmentLineFactory(x12, y12, x22, y22, distance7) {
  var length5 = distanceSquareRoot([x12, y12], [x22, y22]);
  var point7 = { x: 0, y: 0 };
  if (typeof distance7 === "number") {
    if (distance7 <= 0) {
      point7 = { x: x12, y: y12 };
    } else if (distance7 >= length5) {
      point7 = { x: x22, y: y22 };
    } else {
      var _a2 = midPoint([x12, y12], [x22, y22], distance7 / length5), x3 = _a2[0], y3 = _a2[1];
      point7 = { x: x3, y: y3 };
    }
  }
  return {
    length: length5,
    point: point7,
    min: {
      x: Math.min(x12, x22),
      y: Math.min(y12, y22)
    },
    max: {
      x: Math.max(x12, x22),
      y: Math.max(y12, y22)
    }
  };
}

// node_modules/@antv/util/esm/path/util/segment-arc-factory.js
function angleBetween(v0, v1) {
  var v0x = v0.x, v0y = v0.y;
  var v1x = v1.x, v1y = v1.y;
  var p2 = v0x * v1x + v0y * v1y;
  var n = Math.sqrt((Math.pow(v0x, 2) + Math.pow(v0y, 2)) * (Math.pow(v1x, 2) + Math.pow(v1y, 2)));
  var sign3 = v0x * v1y - v0y * v1x < 0 ? -1 : 1;
  var angle4 = sign3 * Math.acos(p2 / n);
  return angle4;
}
function getPointAtArcSegmentLength(x12, y12, RX, RY, angle4, LAF, SF, x3, y3, t) {
  var abs3 = Math.abs, sin3 = Math.sin, cos3 = Math.cos, sqrt4 = Math.sqrt, PI = Math.PI;
  var rx = abs3(RX);
  var ry = abs3(RY);
  var xRot = (angle4 % 360 + 360) % 360;
  var xRotRad = xRot * (PI / 180);
  if (x12 === x3 && y12 === y3) {
    return { x: x12, y: y12 };
  }
  if (rx === 0 || ry === 0) {
    return segmentLineFactory(x12, y12, x3, y3, t).point;
  }
  var dx = (x12 - x3) / 2;
  var dy = (y12 - y3) / 2;
  var transformedPoint = {
    x: cos3(xRotRad) * dx + sin3(xRotRad) * dy,
    y: -sin3(xRotRad) * dx + cos3(xRotRad) * dy
  };
  var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
  if (radiiCheck > 1) {
    rx *= sqrt4(radiiCheck);
    ry *= sqrt4(radiiCheck);
  }
  var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  var cCoef = (LAF !== SF ? 1 : -1) * sqrt4(cRadicand);
  var transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  var center2 = {
    x: cos3(xRotRad) * transformedCenter.x - sin3(xRotRad) * transformedCenter.y + (x12 + x3) / 2,
    y: sin3(xRotRad) * transformedCenter.x + cos3(xRotRad) * transformedCenter.y + (y12 + y3) / 2
  };
  var startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  var startAngle = angleBetween({ x: 1, y: 0 }, startVector);
  var endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  var sweepAngle = angleBetween(startVector, endVector);
  if (!SF && sweepAngle > 0) {
    sweepAngle -= 2 * PI;
  } else if (SF && sweepAngle < 0) {
    sweepAngle += 2 * PI;
  }
  sweepAngle %= 2 * PI;
  var alpha = startAngle + sweepAngle * t;
  var ellipseComponentX = rx * cos3(alpha);
  var ellipseComponentY = ry * sin3(alpha);
  var point7 = {
    x: cos3(xRotRad) * ellipseComponentX - sin3(xRotRad) * ellipseComponentY + center2.x,
    y: sin3(xRotRad) * ellipseComponentX + cos3(xRotRad) * ellipseComponentY + center2.y
  };
  return point7;
}
function segmentArcFactory(X12, Y12, RX, RY, angle4, LAF, SF, X22, Y22, distance7, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 30 : _d;
  var distanceIsNumber = typeof distance7 === "number";
  var x3 = X12;
  var y3 = Y12;
  var LENGTH = 0;
  var prev = [x3, y3, LENGTH];
  var cur = [x3, y3];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x3, y: y3 }];
  if (distanceIsNumber && distance7 <= 0) {
    POINT = { x: x3, y: y3 };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    _a2 = getPointAtArcSegmentLength(X12, Y12, RX, RY, angle4, LAF, SF, X22, Y22, t), x3 = _a2.x, y3 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x3, y: y3 });
    }
    if (length5) {
      LENGTH += distanceSquareRoot(cur, [x3, y3]);
    }
    cur = [x3, y3];
    if (distanceIsNumber && LENGTH >= distance7 && distance7 > prev[2]) {
      var dv = (LENGTH - distance7) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x3, y3, LENGTH];
  }
  if (distanceIsNumber && distance7 >= LENGTH) {
    POINT = { x: X22, y: Y22 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/@antv/util/esm/path/util/segment-cubic-factory.js
function getPointAtCubicSegmentLength(x12, y12, c1x, c1y, c2x, c2y, x22, y22, t) {
  var t12 = 1 - t;
  return {
    x: Math.pow(t12, 3) * x12 + 3 * Math.pow(t12, 2) * t * c1x + 3 * t12 * Math.pow(t, 2) * c2x + Math.pow(t, 3) * x22,
    y: Math.pow(t12, 3) * y12 + 3 * Math.pow(t12, 2) * t * c1y + 3 * t12 * Math.pow(t, 2) * c2y + Math.pow(t, 3) * y22
  };
}
function segmentCubicFactory(x12, y12, c1x, c1y, c2x, c2y, x22, y22, distance7, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance7 === "number";
  var x3 = x12;
  var y3 = y12;
  var LENGTH = 0;
  var prev = [x3, y3, LENGTH];
  var cur = [x3, y3];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x3, y: y3 }];
  if (distanceIsNumber && distance7 <= 0) {
    POINT = { x: x3, y: y3 };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    _a2 = getPointAtCubicSegmentLength(x12, y12, c1x, c1y, c2x, c2y, x22, y22, t), x3 = _a2.x, y3 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x3, y: y3 });
    }
    if (length5) {
      LENGTH += distanceSquareRoot(cur, [x3, y3]);
    }
    cur = [x3, y3];
    if (distanceIsNumber && LENGTH >= distance7 && distance7 > prev[2]) {
      var dv = (LENGTH - distance7) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x3, y3, LENGTH];
  }
  if (distanceIsNumber && distance7 >= LENGTH) {
    POINT = { x: x22, y: y22 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/@antv/util/esm/path/util/segment-quad-factory.js
function getPointAtQuadSegmentLength(x12, y12, cx, cy, x22, y22, t) {
  var t12 = 1 - t;
  return {
    x: Math.pow(t12, 2) * x12 + 2 * t12 * t * cx + Math.pow(t, 2) * x22,
    y: Math.pow(t12, 2) * y12 + 2 * t12 * t * cy + Math.pow(t, 2) * y22
  };
}
function segmentQuadFactory(x12, y12, qx, qy, x22, y22, distance7, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance7 === "number";
  var x3 = x12;
  var y3 = y12;
  var LENGTH = 0;
  var prev = [x3, y3, LENGTH];
  var cur = [x3, y3];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x3, y: y3 }];
  if (distanceIsNumber && distance7 <= 0) {
    POINT = { x: x3, y: y3 };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    _a2 = getPointAtQuadSegmentLength(x12, y12, qx, qy, x22, y22, t), x3 = _a2.x, y3 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x3, y: y3 });
    }
    if (length5) {
      LENGTH += distanceSquareRoot(cur, [x3, y3]);
    }
    cur = [x3, y3];
    if (distanceIsNumber && LENGTH >= distance7 && distance7 > prev[2]) {
      var dv = (LENGTH - distance7) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x3, y3, LENGTH];
  }
  if (distanceIsNumber && distance7 >= LENGTH) {
    POINT = { x: x22, y: y22 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/@antv/util/esm/path/util/path-length-factory.js
function pathLengthFactory(pathInput, distance7, options) {
  var _a2, _b, _c, _d, _e, _f;
  var path2 = normalizePath(pathInput);
  var distanceIsNumber = typeof distance7 === "number";
  var isM;
  var data2 = [];
  var pathCommand;
  var x3 = 0;
  var y3 = 0;
  var mx = 0;
  var my = 0;
  var seg;
  var MIN = [];
  var MAX = [];
  var length5 = 0;
  var min10 = { x: 0, y: 0 };
  var max11 = min10;
  var point7 = min10;
  var POINT = min10;
  var LENGTH = 0;
  for (var i = 0, ll = path2.length; i < ll; i += 1) {
    seg = path2[i];
    pathCommand = seg[0];
    isM = pathCommand === "M";
    data2 = !isM ? [x3, y3].concat(seg.slice(1)) : data2;
    if (isM) {
      mx = seg[1], my = seg[2];
      min10 = { x: mx, y: my };
      max11 = min10;
      length5 = 0;
      if (distanceIsNumber && distance7 < 1e-3) {
        POINT = min10;
      }
    } else if (pathCommand === "L") {
      _a2 = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance7 || 0) - LENGTH), length5 = _a2.length, min10 = _a2.min, max11 = _a2.max, point7 = _a2.point;
    } else if (pathCommand === "A") {
      _b = segmentArcFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], data2[8], (distance7 || 0) - LENGTH, options || {}), length5 = _b.length, min10 = _b.min, max11 = _b.max, point7 = _b.point;
    } else if (pathCommand === "C") {
      _c = segmentCubicFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], (distance7 || 0) - LENGTH, options || {}), length5 = _c.length, min10 = _c.min, max11 = _c.max, point7 = _c.point;
    } else if (pathCommand === "Q") {
      _d = segmentQuadFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], (distance7 || 0) - LENGTH, options || {}), length5 = _d.length, min10 = _d.min, max11 = _d.max, point7 = _d.point;
    } else if (pathCommand === "Z") {
      data2 = [x3, y3, mx, my];
      _e = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance7 || 0) - LENGTH), length5 = _e.length, min10 = _e.min, max11 = _e.max, point7 = _e.point;
    }
    if (distanceIsNumber && LENGTH < distance7 && LENGTH + length5 >= distance7) {
      POINT = point7;
    }
    MAX.push(max11);
    MIN.push(min10);
    LENGTH += length5;
    _f = pathCommand !== "Z" ? seg.slice(-2) : [mx, my], x3 = _f[0], y3 = _f[1];
  }
  if (distanceIsNumber && distance7 >= LENGTH) {
    POINT = { x: x3, y: y3 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, MIN.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, MIN.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, MAX.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, MAX.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/@antv/util/esm/path/util/get-total-length.js
function getTotalLength(pathInput, options) {
  return pathLengthFactory(pathInput, void 0, __assign(__assign({}, options), { bbox: false, length: true })).length;
}

// node_modules/@antv/util/esm/path/util/get-rotated-curve.js
function getRotations(a4) {
  var segCount = a4.length;
  var pointCount = segCount - 1;
  return a4.map(function(f, idx) {
    return a4.map(function(p2, i) {
      var oldSegIdx = idx + i;
      var seg;
      if (i === 0 || a4[oldSegIdx] && a4[oldSegIdx][0] === "M") {
        seg = a4[oldSegIdx];
        return ["M"].concat(seg.slice(-2));
      }
      if (oldSegIdx >= segCount)
        oldSegIdx -= pointCount;
      return a4[oldSegIdx];
    });
  });
}
function getRotatedCurve(a4, b) {
  var segCount = a4.length - 1;
  var lineLengths = [];
  var computedIndex = 0;
  var sumLensSqrd = 0;
  var rotations = getRotations(a4);
  rotations.forEach(function(r, i) {
    a4.slice(1).forEach(function(s3, j) {
      sumLensSqrd += distanceSquareRoot(a4[(i + j) % segCount].slice(-2), b[j % segCount].slice(-2));
    });
    lineLengths[i] = sumLensSqrd;
    sumLensSqrd = 0;
  });
  computedIndex = lineLengths.indexOf(Math.min.apply(null, lineLengths));
  return rotations[computedIndex];
}

// node_modules/@antv/util/esm/path/util/get-path-area.js
function getCubicSegArea(x12, y12, c1x, c1y, c2x, c2y, x22, y22) {
  return 3 * ((y22 - y12) * (c1x + c2x) - (x22 - x12) * (c1y + c2y) + c1y * (x12 - c2x) - c1x * (y12 - c2y) + y22 * (c2x + x12 / 3) - x22 * (c2y + y12 / 3)) / 20;
}
function getPathArea(path2) {
  var x3 = 0;
  var y3 = 0;
  var len5 = 0;
  return path2Curve(path2).map(function(seg) {
    var _a2;
    switch (seg[0]) {
      case "M":
        x3 = seg[1], y3 = seg[2];
        return 0;
      default:
        var _b = seg.slice(1), c1x = _b[0], c1y = _b[1], c2x = _b[2], c2y = _b[3], x22 = _b[4], y22 = _b[5];
        len5 = getCubicSegArea(x3, y3, c1x, c1y, c2x, c2y, x22, y22);
        _a2 = seg.slice(-2), x3 = _a2[0], y3 = _a2[1];
        return len5;
    }
  }).reduce(function(a4, b) {
    return a4 + b;
  }, 0);
}

// node_modules/@antv/util/esm/path/util/get-draw-direction.js
function getDrawDirection(pathArray) {
  return getPathArea(pathArray) >= 0;
}

// node_modules/@antv/util/esm/path/util/get-point-at-length.js
function getPointAtLength(pathInput, distance7, options) {
  return pathLengthFactory(pathInput, distance7, __assign(__assign({}, options), { bbox: false, length: true })).point;
}

// node_modules/@antv/util/esm/path/util/equalize-segments.js
function splitCubic(pts, t) {
  if (t === void 0) {
    t = 0.5;
  }
  var p0 = pts.slice(0, 2);
  var p1 = pts.slice(2, 4);
  var p2 = pts.slice(4, 6);
  var p3 = pts.slice(6, 8);
  var p4 = midPoint(p0, p1, t);
  var p5 = midPoint(p1, p2, t);
  var p6 = midPoint(p2, p3, t);
  var p7 = midPoint(p4, p5, t);
  var p8 = midPoint(p5, p6, t);
  var p9 = midPoint(p7, p8, t);
  return [
    // @ts-ignore
    ["C"].concat(p4, p7, p9),
    // @ts-ignore
    ["C"].concat(p8, p6, p3)
  ];
}
function getCurveArray(segments) {
  return segments.map(function(segment, i, pathArray) {
    var segmentData = i && pathArray[i - 1].slice(-2).concat(segment.slice(1));
    var curveLength = i ? segmentCubicFactory(segmentData[0], segmentData[1], segmentData[2], segmentData[3], segmentData[4], segmentData[5], segmentData[6], segmentData[7], segmentData[8], { bbox: false }).length : 0;
    var subsegs;
    if (i) {
      subsegs = curveLength ? splitCubic(segmentData) : [segment, segment];
    } else {
      subsegs = [segment];
    }
    return {
      s: segment,
      ss: subsegs,
      l: curveLength
    };
  });
}
function equalizeSegments(path1, path2, TL) {
  var c1 = getCurveArray(path1);
  var c22 = getCurveArray(path2);
  var L1 = c1.length;
  var L2 = c22.length;
  var l1 = c1.filter(function(x3) {
    return x3.l;
  }).length;
  var l2 = c22.filter(function(x3) {
    return x3.l;
  }).length;
  var m1 = c1.filter(function(x3) {
    return x3.l;
  }).reduce(function(a4, _a2) {
    var l = _a2.l;
    return a4 + l;
  }, 0) / l1 || 0;
  var m22 = c22.filter(function(x3) {
    return x3.l;
  }).reduce(function(a4, _a2) {
    var l = _a2.l;
    return a4 + l;
  }, 0) / l2 || 0;
  var tl = TL || Math.max(L1, L2);
  var mm = [m1, m22];
  var dif = [tl - L1, tl - L2];
  var canSplit = 0;
  var result = [c1, c22].map(function(x3, i) {
    return x3.l === tl ? x3.map(function(y3) {
      return y3.s;
    }) : x3.map(function(y3, j) {
      canSplit = j && dif[i] && y3.l >= mm[i];
      dif[i] -= canSplit ? 1 : 0;
      return canSplit ? y3.ss : [y3.s];
    }).flat();
  });
  return result[0].length === result[1].length ? result : equalizeSegments(result[0], result[1], tl);
}

// node_modules/@antv/util/esm/dom/create-dom.js
function createDOM(str7) {
  var container = document.createElement("div");
  container.innerHTML = str7;
  var dom2 = container.childNodes[0];
  if (dom2 && container.contains(dom2)) {
    container.removeChild(dom2);
  }
  return dom2;
}

// node_modules/@antv/g2/esm/transform/utils/helper.js
function column(value2, field3) {
  if (value2 === null)
    return void 0;
  return { type: "column", value: value2, field: field3 };
}
function inferredColumn(value2, field3) {
  const c5 = column(value2, field3);
  return Object.assign(Object.assign({}, c5), { inferred: true });
}
function visualColumn(value2, field3) {
  if (value2 === null)
    return void 0;
  return { type: "column", value: value2, field: field3, visual: true };
}
function nonConstantColumn(value2, field3) {
  const c5 = column(value2, field3);
  return Object.assign(Object.assign({}, c5), { constant: false });
}
function constant(I, value2) {
  const array2 = [];
  for (const i of I)
    array2[i] = value2;
  return array2;
}
function columnOf(encode, key) {
  const channel = encode[key];
  if (!channel)
    return [null, null];
  const { value: value2, field: field3 = null } = channel;
  return [value2, field3];
}
function maybeColumnOf(encode, ...K2) {
  for (const key of K2) {
    if (typeof key === "string") {
      const [KV, fv] = columnOf(encode, key);
      if (KV !== null)
        return [KV, fv];
    } else {
      return [key, null];
    }
  }
  return [null, null];
}
function isObject(d3) {
  if (d3 instanceof Date)
    return false;
  return typeof d3 === "object";
}

// node_modules/@antv/g2/esm/transform/maybeZeroY1.js
var MaybeZeroY1 = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y1: y12 } = encode;
    if (y12 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { y1: inferredColumn(constant(I, 0)) }
      })
    ];
  };
};
MaybeZeroY1.props = {};

// node_modules/d3-array/src/ascending.js
function ascending(a4, b) {
  return a4 == null || b == null ? NaN : a4 < b ? -1 : a4 > b ? 1 : a4 >= b ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a4, b) {
  return a4 == null || b == null ? NaN : b < a4 ? -1 : b > a4 ? 1 : b >= a4 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d3, x3) => ascending(f(d3), x3);
    delta = (d3, x3) => f(d3) - x3;
  } else {
    compare1 = f === ascending || f === descending ? f : zero4;
    compare2 = f;
    delta = f;
  }
  function left2(a4, x3, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare1(x3, x3) !== 0)
        return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a4[mid2], x3) < 0)
          lo = mid2 + 1;
        else
          hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a4, x3, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare1(x3, x3) !== 0)
        return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a4[mid2], x3) <= 0)
          lo = mid2 + 1;
        else
          hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a4, x3, lo = 0, hi = a4.length) {
    const i = left2(a4, x3, lo, hi - 1);
    return i > lo && delta(a4[i - 1], x3) > -delta(a4[i], x3) ? i - 1 : i;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero4() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x3) {
  return x3 === null ? NaN : +x3;
}
function* numbers(values4, valueof2) {
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  }
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/blur.js
var blur2 = Blur2(blurf);
var blurImage = Blur2(blurfImage);
function Blur2(blur3) {
  return function(data2, rx, ry = rx) {
    if (!((rx = +rx) >= 0))
      throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0))
      throw new RangeError("invalid ry");
    let { data: values4, width, height } = data2;
    if (!((width = Math.floor(width)) >= 0))
      throw new RangeError("invalid width");
    if (!((height = Math.floor(height !== void 0 ? height : values4.length / width)) >= 0))
      throw new RangeError("invalid height");
    if (!width || !height || !rx && !ry)
      return data2;
    const blurx = rx && blur3(rx);
    const blury = ry && blur3(ry);
    const temp = values4.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values4, width, height);
      blurh(blurx, values4, temp, width, height);
      blurh(blurx, temp, values4, width, height);
      blurv(blury, values4, temp, width, height);
      blurv(blury, temp, values4, width, height);
      blurv(blury, values4, temp, width, height);
    } else if (blurx) {
      blurh(blurx, values4, temp, width, height);
      blurh(blurx, temp, values4, width, height);
      blurh(blurx, values4, temp, width, height);
    } else if (blury) {
      blurv(blury, values4, temp, width, height);
      blurv(blury, temp, values4, width, height);
      blurv(blury, values4, temp, width, height);
    }
    return data2;
  };
}
function blurh(blur3, T, S, w, h) {
  for (let y3 = 0, n = w * h; y3 < n; ) {
    blur3(T, S, y3, y3 += w, 1);
  }
}
function blurv(blur3, T, S, w, h) {
  for (let x3 = 0, n = w * h; x3 < w; ++x3) {
    blur3(T, S, x3, x3 + n, w);
  }
}
function blurfImage(radius) {
  const blur3 = blurf(radius);
  return (T, S, start, stop, step2) => {
    start <<= 2, stop <<= 2, step2 <<= 2;
    blur3(T, S, start + 0, stop + 0, step2);
    blur3(T, S, start + 1, stop + 1, step2);
    blur3(T, S, start + 2, stop + 2, step2);
    blur3(T, S, start + 3, stop + 3, step2);
  };
}
function blurf(radius) {
  const radius0 = Math.floor(radius);
  if (radius0 === radius)
    return bluri(radius);
  const t = radius - radius0;
  const w = 2 * radius + 1;
  return (T, S, start, stop, step2) => {
    if (!((stop -= step2) >= start))
      return;
    let sum4 = radius0 * S[start];
    const s0 = step2 * radius0;
    const s1 = s0 + step2;
    for (let i = start, j = start + s0; i < j; i += step2) {
      sum4 += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step2) {
      sum4 += S[Math.min(stop, i + s0)];
      T[i] = (sum4 + t * (S[Math.max(start, i - s1)] + S[Math.min(stop, i + s1)])) / w;
      sum4 -= S[Math.max(start, i - s0)];
    }
  };
}
function bluri(radius) {
  const w = 2 * radius + 1;
  return (T, S, start, stop, step2) => {
    if (!((stop -= step2) >= start))
      return;
    let sum4 = radius * S[start];
    const s3 = step2 * radius;
    for (let i = start, j = start + s3; i < j; i += step2) {
      sum4 += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step2) {
      sum4 += S[Math.min(stop, i + s3)];
      T[i] = sum4 / w;
      sum4 -= S[Math.max(start, i - s3)];
    }
  };
}

// node_modules/d3-array/src/count.js
function count(values4, valueof2) {
  let count4 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 != null && (value2 = +value2) >= value2) {
        ++count4;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (value2 = +value2) >= value2) {
        ++count4;
      }
    }
  }
  return count4;
}

// node_modules/d3-array/src/variance.js
function variance(values4, valueof2) {
  let count4 = 0;
  let delta;
  let mean3 = 0;
  let sum4 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 != null && (value2 = +value2) >= value2) {
        delta = value2 - mean3;
        mean3 += delta / ++count4;
        sum4 += delta * (value2 - mean3);
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (value2 = +value2) >= value2) {
        delta = value2 - mean3;
        mean3 += delta / ++count4;
        sum4 += delta * (value2 - mean3);
      }
    }
  }
  if (count4 > 1)
    return sum4 / (count4 - 1);
}

// node_modules/d3-array/src/deviation.js
function deviation(values4, valueof2) {
  const v = variance(values4, valueof2);
  return v ? Math.sqrt(v) : v;
}

// node_modules/d3-array/src/extent.js
function extent(values4, valueof2) {
  let min10;
  let max11;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      if (value2 != null) {
        if (min10 === void 0) {
          if (value2 >= value2)
            min10 = max11 = value2;
        } else {
          if (min10 > value2)
            min10 = value2;
          if (max11 < value2)
            max11 = value2;
        }
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null) {
        if (min10 === void 0) {
          if (value2 >= value2)
            min10 = max11 = value2;
        } else {
          if (min10 > value2)
            min10 = value2;
          if (max11 < value2)
            max11 = value2;
        }
      }
    }
  }
  return [min10, max11];
}

// node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x3) {
    const p2 = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y3 = p2[j], hi = x3 + y3, lo = Math.abs(x3) < Math.abs(y3) ? x3 - (hi - y3) : y3 - (hi - x3);
      if (lo)
        p2[i++] = lo;
      x3 = hi;
    }
    p2[i] = x3;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p2 = this._partials;
    let n = this._n, x3, y3, lo, hi = 0;
    if (n > 0) {
      hi = p2[--n];
      while (n > 0) {
        x3 = hi;
        y3 = p2[--n];
        hi = x3 + y3;
        lo = y3 - (hi - x3);
        if (lo)
          break;
      }
      if (n > 0 && (lo < 0 && p2[n - 1] < 0 || lo > 0 && p2[n - 1] > 0)) {
        y3 = lo * 2;
        x3 = hi + y3;
        if (y3 == x3 - hi)
          hi = x3;
      }
    }
    return hi;
  }
};

// node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null)
      for (const [key2, value2] of entries)
        this.set(key2, value2);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value2) {
    return super.set(intern_set(this, key), value2);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
function intern_get({ _intern, _key }, value2) {
  const key = _key(value2);
  return _intern.has(key) ? _intern.get(key) : value2;
}
function intern_set({ _intern, _key }, value2) {
  const key = _key(value2);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value2);
  return value2;
}
function intern_delete({ _intern, _key }, value2) {
  const key = _key(value2);
  if (_intern.has(key)) {
    value2 = _intern.get(key);
    _intern.delete(key);
  }
  return value2;
}
function keyof(value2) {
  return value2 !== null && typeof value2 === "object" ? value2.valueOf() : value2;
}

// node_modules/d3-array/src/identity.js
function identity4(x3) {
  return x3;
}

// node_modules/d3-array/src/group.js
function group(values4, ...keys2) {
  return nest(values4, identity4, identity4, keys2);
}
function groups(values4, ...keys2) {
  return nest(values4, Array.from, identity4, keys2);
}
function rollup(values4, reduce4, ...keys2) {
  return nest(values4, identity4, reduce4, keys2);
}
function rollups(values4, reduce4, ...keys2) {
  return nest(values4, Array.from, reduce4, keys2);
}
function nest(values4, map5, reduce4, keys2) {
  return function regroup(values5, i) {
    if (i >= keys2.length)
      return reduce4(values5);
    const groups2 = new InternMap();
    const keyof3 = keys2[i++];
    let index3 = -1;
    for (const value2 of values5) {
      const key = keyof3(value2, ++index3, values5);
      const group3 = groups2.get(key);
      if (group3)
        group3.push(value2);
      else
        groups2.set(key, [value2]);
    }
    for (const [key, values6] of groups2) {
      groups2.set(key, regroup(values6, i));
    }
    return map5(groups2);
  }(values4, 0);
}

// node_modules/d3-array/src/permute.js
function permute(source, keys2) {
  return Array.from(keys2, (key) => source[key]);
}

// node_modules/d3-array/src/sort.js
function sort(values4, ...F) {
  if (typeof values4[Symbol.iterator] !== "function")
    throw new TypeError("values is not iterable");
  values4 = Array.from(values4);
  let [f] = F;
  if (f && f.length !== 2 || F.length > 1) {
    const index3 = Uint32Array.from(values4, (d3, i) => i);
    if (F.length > 1) {
      F = F.map((f2) => values4.map(f2));
      index3.sort((i, j) => {
        for (const f2 of F) {
          const c5 = ascendingDefined(f2[i], f2[j]);
          if (c5)
            return c5;
        }
      });
    } else {
      f = values4.map(f);
      index3.sort((i, j) => ascendingDefined(f[i], f[j]));
    }
    return permute(values4, index3);
  }
  return values4.sort(compareDefined(f));
}
function compareDefined(compare = ascending) {
  if (compare === ascending)
    return ascendingDefined;
  if (typeof compare !== "function")
    throw new TypeError("compare is not a function");
  return (a4, b) => {
    const x3 = compare(a4, b);
    if (x3 || x3 === 0)
      return x3;
    return (compare(b, b) === 0) - (compare(a4, a4) === 0);
  };
}
function ascendingDefined(a4, b) {
  return (a4 == null || !(a4 >= a4)) - (b == null || !(b >= b)) || (a4 < b ? -1 : a4 > b ? 1 : 0);
}

// node_modules/d3-array/src/groupSort.js
function groupSort(values4, reduce4, key) {
  return (reduce4.length !== 2 ? sort(rollup(values4, reduce4, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values4, key), ([ak, av], [bk, bv]) => reduce4(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
}

// node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// node_modules/d3-array/src/constant.js
function constant2(x3) {
  return () => x3;
}

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start, stop, count4) {
  const step2 = (stop - start) / Math.max(0, count4), power = Math.floor(Math.log10(step2)), error3 = step2 / Math.pow(10, power), factor = error3 >= e10 ? 10 : error3 >= e5 ? 5 : error3 >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start)
      ++i1;
    if (i2 / inc > stop)
      --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start)
      ++i1;
    if (i2 * inc > stop)
      --i2;
  }
  if (i2 < i1 && 0.5 <= count4 && count4 < 2)
    return tickSpec(start, stop, count4 * 2);
  return [i1, i2, inc];
}
function ticks(start, stop, count4) {
  stop = +stop, start = +start, count4 = +count4;
  if (!(count4 > 0))
    return [];
  if (start === stop)
    return [start];
  const reverse2 = stop < start, [i1, i2, inc] = reverse2 ? tickSpec(stop, start, count4) : tickSpec(start, stop, count4);
  if (!(i2 >= i1))
    return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse2) {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop, count4) {
  stop = +stop, start = +start, count4 = +count4;
  return tickSpec(start, stop, count4)[2];
}

// node_modules/d3-array/src/nice.js
function nice(start, stop, count4) {
  let prestep;
  while (true) {
    const step2 = tickIncrement(start, stop, count4);
    if (step2 === prestep || step2 === 0 || !isFinite(step2)) {
      return [start, stop];
    } else if (step2 > 0) {
      start = Math.floor(start / step2) * step2;
      stop = Math.ceil(stop / step2) * step2;
    } else if (step2 < 0) {
      start = Math.ceil(start * step2) / step2;
      stop = Math.floor(stop * step2) / step2;
    }
    prestep = step2;
  }
}

// node_modules/d3-array/src/threshold/sturges.js
function thresholdSturges(values4) {
  return Math.max(1, Math.ceil(Math.log(count(values4)) / Math.LN2) + 1);
}

// node_modules/d3-array/src/bin.js
function bin() {
  var value2 = identity4, domain = extent, threshold = thresholdSturges;
  function histogram(data2) {
    if (!Array.isArray(data2))
      data2 = Array.from(data2);
    var i, n = data2.length, x3, step2, values4 = new Array(n);
    for (i = 0; i < n; ++i) {
      values4[i] = value2(data2[i], i, data2);
    }
    var xz = domain(values4), x05 = xz[0], x12 = xz[1], tz = threshold(values4, x05, x12);
    if (!Array.isArray(tz)) {
      const max11 = x12, tn = +tz;
      if (domain === extent)
        [x05, x12] = nice(x05, x12, tn);
      tz = ticks(x05, x12, tn);
      if (tz[0] <= x05)
        step2 = tickIncrement(x05, x12, tn);
      if (tz[tz.length - 1] >= x12) {
        if (max11 >= x12 && domain === extent) {
          const step3 = tickIncrement(x05, x12, tn);
          if (isFinite(step3)) {
            if (step3 > 0) {
              x12 = (Math.floor(x12 / step3) + 1) * step3;
            } else if (step3 < 0) {
              x12 = (Math.ceil(x12 * -step3) + 1) / -step3;
            }
          }
        } else {
          tz.pop();
        }
      }
    }
    var m3 = tz.length, a4 = 0, b = m3;
    while (tz[a4] <= x05)
      ++a4;
    while (tz[b - 1] > x12)
      --b;
    if (a4 || b < m3)
      tz = tz.slice(a4, b), m3 = b - a4;
    var bins = new Array(m3 + 1), bin2;
    for (i = 0; i <= m3; ++i) {
      bin2 = bins[i] = [];
      bin2.x0 = i > 0 ? tz[i - 1] : x05;
      bin2.x1 = i < m3 ? tz[i] : x12;
    }
    if (isFinite(step2)) {
      if (step2 > 0) {
        for (i = 0; i < n; ++i) {
          if ((x3 = values4[i]) != null && x05 <= x3 && x3 <= x12) {
            bins[Math.min(m3, Math.floor((x3 - x05) / step2))].push(data2[i]);
          }
        }
      } else if (step2 < 0) {
        for (i = 0; i < n; ++i) {
          if ((x3 = values4[i]) != null && x05 <= x3 && x3 <= x12) {
            const j = Math.floor((x05 - x3) * step2);
            bins[Math.min(m3, j + (tz[j] <= x3))].push(data2[i]);
          }
        }
      }
    } else {
      for (i = 0; i < n; ++i) {
        if ((x3 = values4[i]) != null && x05 <= x3 && x3 <= x12) {
          bins[bisect_default(tz, x3, 0, m3)].push(data2[i]);
        }
      }
    }
    return bins;
  }
  histogram.value = function(_2) {
    return arguments.length ? (value2 = typeof _2 === "function" ? _2 : constant2(_2), histogram) : value2;
  };
  histogram.domain = function(_2) {
    return arguments.length ? (domain = typeof _2 === "function" ? _2 : constant2([_2[0], _2[1]]), histogram) : domain;
  };
  histogram.thresholds = function(_2) {
    return arguments.length ? (threshold = typeof _2 === "function" ? _2 : constant2(Array.isArray(_2) ? slice.call(_2) : _2), histogram) : threshold;
  };
  return histogram;
}

// node_modules/d3-array/src/max.js
function max5(values4, valueof2) {
  let max11;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      if (value2 != null && (max11 < value2 || max11 === void 0 && value2 >= value2)) {
        max11 = value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (max11 < value2 || max11 === void 0 && value2 >= value2)) {
        max11 = value2;
      }
    }
  }
  return max11;
}

// node_modules/d3-array/src/maxIndex.js
function maxIndex(values4, valueof2) {
  let max11;
  let maxIndex2 = -1;
  let index3 = -1;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      ++index3;
      if (value2 != null && (max11 < value2 || max11 === void 0 && value2 >= value2)) {
        max11 = value2, maxIndex2 = index3;
      }
    }
  } else {
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (max11 < value2 || max11 === void 0 && value2 >= value2)) {
        max11 = value2, maxIndex2 = index3;
      }
    }
  }
  return maxIndex2;
}

// node_modules/d3-array/src/min.js
function min4(values4, valueof2) {
  let min10;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      if (value2 != null && (min10 > value2 || min10 === void 0 && value2 >= value2)) {
        min10 = value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (min10 > value2 || min10 === void 0 && value2 >= value2)) {
        min10 = value2;
      }
    }
  }
  return min10;
}

// node_modules/d3-array/src/minIndex.js
function minIndex(values4, valueof2) {
  let min10;
  let minIndex2 = -1;
  let index3 = -1;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      ++index3;
      if (value2 != null && (min10 > value2 || min10 === void 0 && value2 >= value2)) {
        min10 = value2, minIndex2 = index3;
      }
    }
  } else {
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (min10 > value2 || min10 === void 0 && value2 >= value2)) {
        min10 = value2, minIndex2 = index3;
      }
    }
  }
  return minIndex2;
}

// node_modules/d3-array/src/quickselect.js
function quickselect(array2, k2, left2 = 0, right2 = Infinity, compare) {
  k2 = Math.floor(k2);
  left2 = Math.floor(Math.max(0, left2));
  right2 = Math.floor(Math.min(array2.length - 1, right2));
  if (!(left2 <= k2 && k2 <= right2))
    return array2;
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      const n = right2 - left2 + 1;
      const m3 = k2 - left2 + 1;
      const z = Math.log(n);
      const s3 = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s3 * (n - s3) / n) * (m3 - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left2, Math.floor(k2 - m3 * s3 / n + sd));
      const newRight = Math.min(right2, Math.floor(k2 + (n - m3) * s3 / n + sd));
      quickselect(array2, k2, newLeft, newRight, compare);
    }
    const t = array2[k2];
    let i = left2;
    let j = right2;
    swap(array2, left2, k2);
    if (compare(array2[right2], t) > 0)
      swap(array2, left2, right2);
    while (i < j) {
      swap(array2, i, j), ++i, --j;
      while (compare(array2[i], t) < 0)
        ++i;
      while (compare(array2[j], t) > 0)
        --j;
    }
    if (compare(array2[left2], t) === 0)
      swap(array2, left2, j);
    else
      ++j, swap(array2, j, right2);
    if (j <= k2)
      left2 = j + 1;
    if (k2 <= j)
      right2 = j - 1;
  }
  return array2;
}
function swap(array2, i, j) {
  const t = array2[i];
  array2[i] = array2[j];
  array2[j] = t;
}

// node_modules/d3-array/src/greatest.js
function greatest(values4, compare = ascending) {
  let max11;
  let defined4 = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values4) {
      const value2 = compare(element);
      if (defined4 ? ascending(value2, maxValue) > 0 : ascending(value2, value2) === 0) {
        max11 = element;
        maxValue = value2;
        defined4 = true;
      }
    }
  } else {
    for (const value2 of values4) {
      if (defined4 ? compare(value2, max11) > 0 : compare(value2, value2) === 0) {
        max11 = value2;
        defined4 = true;
      }
    }
  }
  return max11;
}

// node_modules/d3-array/src/quantile.js
function quantile(values4, p2, valueof2) {
  values4 = Float64Array.from(numbers(values4, valueof2));
  if (!(n = values4.length) || isNaN(p2 = +p2))
    return;
  if (p2 <= 0 || n < 2)
    return min4(values4);
  if (p2 >= 1)
    return max5(values4);
  var n, i = (n - 1) * p2, i0 = Math.floor(i), value0 = max5(quickselect(values4, i0).subarray(0, i0 + 1)), value1 = min4(values4.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileIndex(values4, p2, valueof2 = number) {
  if (isNaN(p2 = +p2))
    return;
  numbers2 = Float64Array.from(values4, (_2, i2) => number(valueof2(values4[i2], i2, values4)));
  if (p2 <= 0)
    return minIndex(numbers2);
  if (p2 >= 1)
    return maxIndex(numbers2);
  var numbers2, index3 = Uint32Array.from(values4, (_2, i2) => i2), j = numbers2.length - 1, i = Math.floor(j * p2);
  quickselect(index3, i, 0, j, (i2, j2) => ascendingDefined(numbers2[i2], numbers2[j2]));
  i = greatest(index3.subarray(0, i + 1), (i2) => numbers2[i2]);
  return i >= 0 ? i : -1;
}

// node_modules/d3-array/src/threshold/scott.js
function thresholdScott(values4, min10, max11) {
  const c5 = count(values4), d3 = deviation(values4);
  return c5 && d3 ? Math.ceil((max11 - min10) * Math.cbrt(c5) / (3.49 * d3)) : 1;
}

// node_modules/d3-array/src/mean.js
function mean(values4, valueof2) {
  let count4 = 0;
  let sum4 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 != null && (value2 = +value2) >= value2) {
        ++count4, sum4 += value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (value2 = +value2) >= value2) {
        ++count4, sum4 += value2;
      }
    }
  }
  if (count4)
    return sum4 / count4;
}

// node_modules/d3-array/src/median.js
function median(values4, valueof2) {
  return quantile(values4, 0.5, valueof2);
}
function medianIndex(values4, valueof2) {
  return quantileIndex(values4, 0.5, valueof2);
}

// node_modules/d3-array/src/merge.js
function* flatten(arrays) {
  for (const array2 of arrays) {
    yield* array2;
  }
}
function merge(arrays) {
  return Array.from(flatten(arrays));
}

// node_modules/d3-array/src/range.js
function range(start, stop, step2) {
  start = +start, stop = +stop, step2 = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step2;
  var i = -1, n = Math.max(0, Math.ceil((stop - start) / step2)) | 0, range3 = new Array(n);
  while (++i < n) {
    range3[i] = start + i * step2;
  }
  return range3;
}

// node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random5) {
  return function shuffle2(array2, i0 = 0, i1 = array2.length) {
    let m3 = i1 - (i0 = +i0);
    while (m3) {
      const i = random5() * m3-- | 0, t = array2[m3 + i0];
      array2[m3 + i0] = array2[i + i0];
      array2[i + i0] = t;
    }
    return array2;
  };
}

// node_modules/d3-array/src/sum.js
function sum(values4, valueof2) {
  let sum4 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 = +value2) {
        sum4 += value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if (value2 = +valueof2(value2, ++index3, values4)) {
        sum4 += value2;
      }
    }
  }
  return sum4;
}

// node_modules/@antv/g2/esm/utils/helper.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function identity5(x3) {
  return x3;
}
function compose(fns) {
  return fns.reduce((composed, fn) => (x3, ...args) => fn(composed(x3, ...args), ...args), identity5);
}
function composeAsync(fns) {
  return fns.reduce((composed, fn) => (x3) => __awaiter(this, void 0, void 0, function* () {
    const value2 = yield composed(x3);
    return fn(value2);
  }), identity5);
}
function capitalizeFirst(str7) {
  return str7.replace(/( |^)[a-z]/g, (L) => L.toUpperCase());
}
function error(message = "") {
  throw new Error(message);
}
function copyAttributes(target, source) {
  const { attributes } = source;
  const exclude2 = /* @__PURE__ */ new Set(["id", "className"]);
  for (const [key, value2] of Object.entries(attributes)) {
    if (!exclude2.has(key)) {
      target.attr(key, value2);
    }
  }
}
function defined(x3) {
  return x3 !== void 0 && x3 !== null && !Number.isNaN(x3);
}
function useMemo(compute2) {
  const map5 = /* @__PURE__ */ new Map();
  return (key) => {
    if (map5.has(key))
      return map5.get(key);
    const value2 = compute2(key);
    map5.set(key, value2);
    return value2;
  };
}
function appendTransform(node, transform2) {
  const { transform: preTransform } = node.style;
  const unset = (d3) => d3 === "none" || d3 === void 0;
  const prefix = unset(preTransform) ? "" : preTransform;
  node.style.transform = `${prefix} ${transform2}`.trimStart();
}
function subObject(obj, prefix) {
  return maybeSubObject(obj, prefix) || {};
}
function maybeSubObject(obj, prefix) {
  const entries = Object.entries(obj || {}).filter(([key]) => key.startsWith(prefix)).map(([key, value2]) => [lower_first_default(key.replace(prefix, "").trim()), value2]).filter(([key]) => !!key);
  return entries.length === 0 ? null : Object.fromEntries(entries);
}
function filterPrefixObject(obj, prefix) {
  return Object.fromEntries(Object.entries(obj).filter(([key]) => prefix.find((p2) => key.startsWith(p2))));
}
function omitPrefixObject(obj, ...prefixes2) {
  return Object.fromEntries(Object.entries(obj).filter(([key]) => prefixes2.every((prefix) => !key.startsWith(prefix))));
}
function maybePercentage(x3, size3) {
  if (x3 === void 0)
    return null;
  if (typeof x3 === "number")
    return x3;
  const px2 = +x3.replace("%", "");
  return Number.isNaN(px2) ? null : px2 / 100 * size3;
}
function isStrictObject(d3) {
  return typeof d3 === "object" && !(d3 instanceof Date) && d3 !== null && !Array.isArray(d3);
}
function isUnset(value2) {
  return value2 === null || value2 === false;
}
function deepAssign(dist5, src, maxLevel = 5, level = 0) {
  if (level >= maxLevel)
    return;
  for (const key of Object.keys(src)) {
    const value2 = src[key];
    if (!is_plain_object_default(value2) || !is_plain_object_default(dist5[key])) {
      dist5[key] = value2;
    } else {
      deepAssign(dist5[key], value2, maxLevel, level + 1);
    }
  }
  return dist5;
}

// node_modules/@antv/g2/esm/utils/array.js
function mapObject(object, callbackfn) {
  return Object.entries(object).reduce((obj, [key, value2]) => {
    obj[key] = callbackfn(value2, key, object);
    return obj;
  }, {});
}
function indexOf3(array2) {
  return array2.map((_2, i) => i);
}
function firstOf(array2) {
  return array2[0];
}
function lastOf(array2) {
  return array2[array2.length - 1];
}
function unique(array2) {
  return Array.from(new Set(array2));
}
function divide4(array2, callbackfn) {
  const result = [[], []];
  array2.forEach((item) => {
    result[callbackfn(item) ? 0 : 1].push(item);
  });
  return result;
}
function comb(array2, len5 = array2.length) {
  if (len5 === 1)
    return array2.map((item) => [item]);
  const result = [];
  for (let i = 0; i < array2.length; i++) {
    const rest = array2.slice(i + 1);
    const restComb = comb(rest, len5 - 1);
    restComb.forEach((comb2) => {
      result.push([array2[i], ...comb2]);
    });
  }
  return result;
}
function combine(array2) {
  if (array2.length === 1)
    return [array2];
  const result = [];
  for (let i = 1; i <= array2.length; i++) {
    result.push(...comb(array2, i));
  }
  return result;
}

// node_modules/@antv/g2/esm/transform/utils/order.js
function createGroups(groupBy3, I, mark2) {
  const { encode } = mark2;
  if (groupBy3 === null)
    return [I];
  const G = normalizeGroupBy(groupBy3).map((k2) => {
    var _a2;
    return [k2, (_a2 = columnOf(encode, k2)) === null || _a2 === void 0 ? void 0 : _a2[0]];
  }).filter(([, column2]) => defined(column2));
  const key = (i) => G.map(([, V]) => V[i]).join("-");
  return Array.from(group(I, key).values());
}
function normalizeComparator(order) {
  if (Array.isArray(order))
    return createFieldsOrder(order);
  if (typeof order === "function")
    return createFunctionOrder(order);
  if (order === "series")
    return createSeriesOrder;
  if (order === "value")
    return createValueOrder;
  if (order === "sum")
    return createSumOrder;
  if (order === "maxIndex")
    return createMaxIndexOrder;
  return null;
}
function applyOrder(groups2, comparator) {
  for (const group3 of groups2) {
    group3.sort(comparator);
  }
}
function domainOf(value2, scale11) {
  return (scale11 === null || scale11 === void 0 ? void 0 : scale11.domain) || Array.from(new Set(value2));
}
function normalizeGroupBy(groupBy3) {
  if (Array.isArray(groupBy3))
    return groupBy3;
  return [groupBy3];
}
function createSeriesOrder(data2, Y, S) {
  return ascendingComparator((i) => S[i]);
}
function createFunctionOrder(order) {
  return (data2, Y, S) => {
    return ascendingComparator((i) => order(data2[i]));
  };
}
function createFieldsOrder(order) {
  return (data2, Y, S) => {
    return (i, j) => order.reduce((eq, f) => eq !== 0 ? eq : ascending(data2[i][f], data2[j][f]), 0);
  };
}
function createValueOrder(data2, Y, S) {
  return ascendingComparator((i) => Y[i]);
}
function createSumOrder(data2, Y, S) {
  const I = indexOf3(data2);
  const groups2 = Array.from(group(I, (i) => S[+i]).entries());
  const seriesSum = new Map(groups2.map(([k2, GI]) => [k2, GI.reduce((s3, i) => s3 + +Y[i])]));
  return ascendingComparator((i) => seriesSum.get(S[i]));
}
function createMaxIndexOrder(data2, Y, S) {
  const I = indexOf3(data2);
  const groups2 = Array.from(group(I, (i) => S[+i]).entries());
  const seriesMaxIndex = new Map(groups2.map(([k2, GI]) => [k2, maxIndex(GI, (i) => Y[i])]));
  return ascendingComparator((i) => seriesMaxIndex.get(S[i]));
}
function ascendingComparator(order) {
  return (i, j) => ascending(order(i), order(j));
}

// node_modules/@antv/g2/esm/transform/stackY.js
var StackY = (options = {}) => {
  const { groupBy: groupBy3 = "x", orderBy = null, reverse: reverse2 = false, y: fromY = "y", y1: fromY1 = "y1", series = true } = options;
  return (I, mark2) => {
    var _a2;
    const { data: data2, encode, style = {} } = mark2;
    const [Y, fy] = columnOf(encode, "y");
    const [Y12, fy1] = columnOf(encode, "y1");
    const [S] = series ? maybeColumnOf(encode, "series", "color") : columnOf(encode, "color");
    const groups2 = createGroups(groupBy3, I, mark2);
    const createComparator = (_a2 = normalizeComparator(orderBy)) !== null && _a2 !== void 0 ? _a2 : () => null;
    const comparator = createComparator(data2, Y, S);
    if (comparator)
      applyOrder(groups2, comparator);
    const newY = new Array(I.length);
    const newY1 = new Array(I.length);
    const TY = new Array(I.length);
    const F = [];
    const L = [];
    for (const G of groups2) {
      if (reverse2)
        G.reverse();
      const start = Y12 ? +Y12[G[0]] : 0;
      const PG = [];
      const NG = [];
      for (const i2 of G) {
        const y3 = TY[i2] = +Y[i2] - start;
        if (y3 < 0)
          NG.push(i2);
        else if (y3 >= 0)
          PG.push(i2);
      }
      const FG = PG.length > 0 ? PG : NG;
      const LG = NG.length > 0 ? NG : PG;
      let i = PG.length - 1;
      let j = 0;
      while (i > 0 && Y[FG[i]] === 0)
        i--;
      while (j < LG.length - 1 && Y[LG[j]] === 0)
        j++;
      F.push(FG[i]);
      L.push(LG[j]);
      let ny = start;
      for (const i2 of NG.reverse()) {
        const y3 = TY[i2];
        ny = newY[i2] = (newY1[i2] = ny) + y3;
      }
      let py = start;
      for (const i2 of PG) {
        const y3 = TY[i2];
        if (y3 > 0)
          py = newY[i2] = (newY1[i2] = py) + y3;
        else
          newY[i2] = newY1[i2] = py;
      }
    }
    const FS = new Set(F);
    const LS = new Set(L);
    const V = fromY === "y" ? newY : newY1;
    const V1 = fromY1 === "y" ? newY : newY1;
    let newEncode;
    if (mark2.type === "point") {
      newEncode = {
        y0: inferredColumn(Y, fy),
        y: column(V, fy)
      };
    } else {
      newEncode = {
        y0: inferredColumn(Y, fy),
        y: column(V, fy),
        y1: column(V1, fy1)
      };
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: Object.assign({}, newEncode),
        style: Object.assign({ first: (_2, i) => FS.has(i), last: (_2, i) => LS.has(i) }, style)
      })
    ];
  };
};
StackY.props = {};

// node_modules/@antv/g2/esm/transform/maybeStackY.js
function exclude(transform2) {
  const { type } = transform2;
  const excludes = ["stackY", "dodgeX", "groupX"];
  return typeof type === "string" && excludes.includes(type);
}
var MaybeStackY = (options) => {
  return (I, mark2, context) => {
    const { encode, transform: transform2 = [] } = mark2;
    if (transform2.some(exclude))
      return [I, mark2];
    const { x: x3, y: y3 } = encode;
    if (x3 === void 0 || y3 === void 0)
      return [I, mark2];
    const { series } = options;
    const groupBy3 = series ? ["x", "series"] : "x";
    return StackY({ groupBy: groupBy3 })(I, mark2, context);
  };
};
MaybeStackY.props = {};

// node_modules/@antv/g2/esm/utils/dateFormat.js
function fillZero(digit) {
  if (Math.abs(digit) > 10)
    return String(digit);
  return digit.toString().padStart(2, "0");
}
function dynamicFormatDateTime(date) {
  const year2 = date.getFullYear();
  const month2 = fillZero(date.getMonth() + 1);
  const day2 = fillZero(date.getDate());
  const yyyyMMDD = `${year2}-${month2}-${day2}`;
  const hour2 = date.getHours();
  const minutes = date.getMinutes();
  const seconds = date.getSeconds();
  if (hour2 || minutes || seconds)
    return `${yyyyMMDD} ${fillZero(hour2)}:${fillZero(minutes)}:${fillZero(seconds)}`;
  return yyyyMMDD;
}

// node_modules/@antv/g2/esm/transform/maybeTitle.js
var MaybeTitle = (options = {}) => {
  const { channel = "x" } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const { tooltip: tooltip2 } = mark2;
    if (isUnset(tooltip2))
      return [I, mark2];
    const { title } = tooltip2;
    if (title !== void 0)
      return [I, mark2];
    const titles = Object.keys(encode).filter((key) => key.startsWith(channel)).filter((key) => !encode[key].inferred).map((key) => columnOf(encode, key)).filter(([T2]) => T2).map((d3) => d3[0]);
    if (titles.length === 0)
      return [I, mark2];
    const T = [];
    for (const i of I) {
      T[i] = {
        value: titles.map((t) => t[i] instanceof Date ? dynamicFormatDateTime(t[i]) : t[i]).join(", ")
      };
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        tooltip: {
          title: T
        }
      })
    ];
  };
};
MaybeTitle.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroX.js
var MaybeZeroX = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { x: x3 } = encode;
    if (x3 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { x: inferredColumn(constant(I, 0)) },
        scale: { x: { guide: null } }
      })
    ];
  };
};
MaybeZeroX.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroY.js
var MaybeZeroY = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y: y3 } = encode;
    if (y3 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { y: inferredColumn(constant(I, 0)) },
        scale: { y: { guide: null } }
      })
    ];
  };
};
MaybeZeroY.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroZ.js
var MaybeZeroZ = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { z } = encode;
    if (z !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { z: inferredColumn(constant(I, 0)) },
        scale: { z: { guide: null } }
      })
    ];
  };
};
MaybeZeroZ.props = {};

// node_modules/@antv/g2/esm/transform/maybeSize.js
var MaybeSize = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { size: size3 } = encode;
    if (size3 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, { encode: { size: visualColumn(constant(I, 3)) } })
    ];
  };
};
MaybeSize.props = {};

// node_modules/@antv/g2/esm/transform/maybeKey.js
var __rest2 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var MaybeKey = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { key } = encode, rest = __rest2(encode, ["key"]);
    if (key !== void 0)
      return [I, mark2];
    const values4 = Object.values(rest).map(({ value: value2 }) => value2);
    const K2 = I.map((i) => values4.filter(Array.isArray).map((V) => V[i]).join("-"));
    return [I, deep_mix_default({}, mark2, { encode: { key: column(K2) } })];
  };
};
MaybeKey.props = {};

// node_modules/@antv/g2/esm/transform/maybeSeries.js
var MaybeSeries = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { series, color: color3 } = encode;
    if (series !== void 0 || color3 === void 0)
      return [I, mark2];
    const [C4, fc] = columnOf(encode, "color");
    return [I, deep_mix_default({}, mark2, { encode: { series: column(C4, fc) } })];
  };
};
MaybeSeries.props = {};

// node_modules/@antv/g2/esm/transform/maybeTupleY.js
var MaybeTupleY = () => {
  return (I, mark2) => {
    const { data: data2 } = mark2;
    if (!Array.isArray(data2) || data2.some(isObject))
      return [I, mark2];
    return [I, deep_mix_default({}, mark2, { encode: { y: column(data2) } })];
  };
};
MaybeTupleY.props = {};

// node_modules/@antv/g2/esm/transform/maybeTupleX.js
var MaybeTupleX = () => {
  return (I, mark2) => {
    const { data: data2 } = mark2;
    if (!Array.isArray(data2) || data2.some(isObject))
      return [I, mark2];
    return [I, deep_mix_default({}, mark2, { encode: { x: column(data2) } })];
  };
};
MaybeTupleX.props = {};

// node_modules/@antv/g2/esm/transform/maybeIdentityY.js
var MaybeIdentityY = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y1: y12 } = encode;
    if (y12)
      return [I, mark2];
    const [Y] = columnOf(encode, "y");
    return [I, deep_mix_default({}, mark2, { encode: { y1: column([...Y]) } })];
  };
};
MaybeIdentityY.props = {};

// node_modules/@antv/g2/esm/transform/maybeIdentityX.js
var MaybeIdentityX = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { x1: x12 } = encode;
    if (x12)
      return [I, mark2];
    const [X] = columnOf(encode, "x");
    return [I, deep_mix_default({}, mark2, { encode: { x1: column([...X]) } })];
  };
};
MaybeIdentityX.props = {};

// node_modules/@antv/g2/esm/transform/maybeDefaultX.js
var MaybeDefaultX = () => {
  return (I, mark2) => {
    const { data: data2 } = mark2;
    if (Array.isArray(data2) && (data2.every(Array.isArray) || !data2.some(isObject))) {
      const extractX = (data3, index3) => Array.isArray(data3[0]) ? data3.map((item) => item[index3]) : [data3[index3]];
      return [
        I,
        deep_mix_default({}, mark2, {
          encode: {
            x: column(extractX(data2, 0)),
            x1: column(extractX(data2, 1))
          }
        })
      ];
    }
    return [I, mark2];
  };
};
MaybeDefaultX.props = {};

// node_modules/@antv/g2/esm/transform/maybeDefaultY.js
var MaybeDefaultY = () => {
  return (I, mark2) => {
    const { data: data2 } = mark2;
    if (Array.isArray(data2) && (data2.every(Array.isArray) || !data2.some(isObject))) {
      const extractY = (data3, index3) => Array.isArray(data3[0]) ? data3.map((item) => item[index3]) : [data3[index3]];
      return [
        I,
        deep_mix_default({}, mark2, {
          encode: {
            y: column(extractY(data2, 0)),
            y1: column(extractY(data2, 1))
          }
        })
      ];
    }
    return [I, mark2];
  };
};
MaybeDefaultY.props = {};

// node_modules/@antv/g2/esm/transform/maybeTooltip.js
var MaybeTooltip = (options) => {
  const { channel } = options;
  return (I, mark2) => {
    const { encode, tooltip: tooltip2 } = mark2;
    if (isUnset(tooltip2))
      return [I, mark2];
    const { items = [] } = tooltip2;
    if (!items || items.length > 0)
      return [I, mark2];
    const channels = Array.isArray(channel) ? channel : [channel];
    const newItems = channels.flatMap((channel2) => Object.keys(encode).filter((key) => key.startsWith(channel2)).map((key) => {
      const { field: field3, value: value2, inferred = false, aggregate } = encode[key];
      if (inferred)
        return null;
      if (aggregate && value2)
        return { channel: key };
      if (field3)
        return { field: field3 };
      if (value2)
        return { channel: key };
      return null;
    }).filter((d3) => d3 !== null));
    return [I, deep_mix_default({}, mark2, { tooltip: { items: newItems } })];
  };
};
MaybeTooltip.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroPadding.js
var MaybeZeroPadding = () => {
  return (I, mark2) => {
    return [
      I,
      deep_mix_default({ scale: { x: { padding: 0 }, y: { padding: 0 } } }, mark2)
    ];
  };
};
MaybeZeroPadding.props = {};

// node_modules/@antv/g2/esm/transform/maybeVisualPosition.js
var __rest3 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var MaybeVisualPosition = () => {
  return (I, mark2) => {
    const { data: data2, style = {} } = mark2, restMark = __rest3(mark2, ["data", "style"]);
    const { x: x05, y: y05 } = style, rest = __rest3(style, ["x", "y"]);
    if (x05 == void 0 || y05 == void 0)
      return [I, mark2];
    const x3 = x05 || 0;
    const y3 = y05 || 0;
    return [
      [0],
      deep_mix_default({}, restMark, {
        data: [0],
        cartesian: true,
        encode: {
          x: column([x3]),
          y: column([y3])
        },
        scale: {
          x: { type: "identity", independent: true, guide: null },
          y: { type: "identity", independent: true, guide: null }
          // hide axis
        },
        style: rest
      })
    ];
  };
};
MaybeVisualPosition.props = {};

// node_modules/@antv/g2/esm/transform/maybeFunctionAttribute.js
var MaybeFunctionAttribute = () => {
  return (I, mark2) => {
    const { style = {} } = mark2;
    return [
      I,
      deep_mix_default({}, mark2, {
        style: Object.assign(Object.assign({}, style), Object.fromEntries(Object.entries(style).filter(([, v]) => typeof v === "function").map(([k2, v]) => [k2, () => v])))
      })
    ];
  };
};
MaybeFunctionAttribute.props = {};

// node_modules/@antv/g2/esm/transform/maybeTuple.js
var MaybeTuple = () => {
  return (I, mark2) => {
    const { data: data2 } = mark2;
    if (!Array.isArray(data2) || data2.some(isObject))
      return [I, mark2];
    const position = Array.isArray(data2[0]) ? data2 : [data2];
    const X = position.map((d3) => d3[0]);
    const Y = position.map((d3) => d3[1]);
    return [I, deep_mix_default({}, mark2, { encode: { x: column(X), y: column(Y) } })];
  };
};
MaybeTuple.props = {};

// node_modules/@antv/g2/esm/transform/maybeGradient.js
var MaybeGradient = () => {
  return (I, mark2) => {
    const { style = {}, encode } = mark2;
    const { series } = encode;
    const { gradient: gradient2 } = style;
    if (!gradient2 || series)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: {
          series: visualColumn(constant(I, void 0))
        }
      })
    ];
  };
};
MaybeGradient.props = {};

// node_modules/@antv/g2/esm/transform/dodgeX.js
var __rest4 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var DodgeX = (options = {}) => {
  const { groupBy: groupBy3 = "x", reverse: reverse2 = false, orderBy, padding } = options, rest = __rest4(options, ["groupBy", "reverse", "orderBy", "padding"]);
  return (I, mark2) => {
    const { data: data2, encode, scale: scale11 } = mark2;
    const { series: scaleSeries } = scale11;
    const [Y] = columnOf(encode, "y");
    const [S] = maybeColumnOf(encode, "series", "color");
    const domainSeries = domainOf(S, scaleSeries);
    const newMark = deep_mix_default({}, mark2, {
      scale: {
        series: {
          domain: domainSeries,
          paddingInner: padding
        }
      }
    });
    const groups2 = createGroups(groupBy3, I, mark2);
    const createComparator = normalizeComparator(orderBy);
    if (!createComparator) {
      return [I, deep_mix_default(newMark, { encode: { series: column(S) } })];
    }
    const comparator = createComparator(data2, Y, S);
    if (comparator)
      applyOrder(groups2, comparator);
    const newS = new Array(I.length);
    for (const G of groups2) {
      if (reverse2)
        G.reverse();
      for (let i = 0; i < G.length; i++) {
        newS[G[i]] = domainSeries[i];
      }
    }
    return [
      I,
      deep_mix_default(newMark, {
        encode: {
          series: column(orderBy ? newS : S)
        }
      })
    ];
  };
};
DodgeX.props = {};

// node_modules/@antv/g2/esm/transform/stackEnter.js
var StackEnter = (options) => {
  const { groupBy: groupBy3 = ["x"], reducer = (I, V) => V[I[0]], orderBy = null, reverse: reverse2 = false, duration } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const by = Array.isArray(groupBy3) ? groupBy3 : [groupBy3];
    const groupEntries = by.map((k2) => [k2, columnOf(encode, k2)[0]]);
    if (groupEntries.length === 0)
      return [I, mark2];
    let groups2 = [I];
    for (const [, V] of groupEntries) {
      const newGroups = [];
      for (const I2 of groups2) {
        const G = Array.from(group(I2, (i) => V[i]).values());
        newGroups.push(...G);
      }
      groups2 = newGroups;
    }
    if (orderBy) {
      const [V] = columnOf(encode, orderBy);
      if (V)
        groups2.sort((I2, J) => reducer(I2, V) - reducer(J, V));
      if (reverse2)
        groups2.reverse();
    }
    const t = (duration || 3e3) / groups2.length;
    const [ED2] = duration ? [constant(I, t)] : maybeColumnOf(encode, "enterDuration", constant(I, t));
    const [EDL] = maybeColumnOf(encode, "enterDelay", constant(I, 0));
    const newEnterDelay = new Array(I.length);
    for (let i = 0, pd = 0; i < groups2.length; i++) {
      const I2 = groups2[i];
      const maxDuration = max5(I2, (i2) => +ED2[i2]);
      for (const j of I2)
        newEnterDelay[j] = +EDL[j] + pd;
      pd += maxDuration;
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: {
          enterDuration: visualColumn(ED2),
          enterDelay: visualColumn(newEnterDelay)
        }
      })
    ];
  };
};
StackEnter.props = {};

// node_modules/@antv/g2/esm/transform/normalizeY.js
var __rest5 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function normalizeBasis(basis2) {
  if (typeof basis2 === "function")
    return basis2;
  const registry = {
    min: (I, Y) => min4(I, (i) => Y[+i]),
    max: (I, Y) => max5(I, (i) => Y[+i]),
    first: (I, Y) => Y[I[0]],
    last: (I, Y) => Y[I[I.length - 1]],
    mean: (I, Y) => mean(I, (i) => Y[+i]),
    median: (I, Y) => median(I, (i) => Y[+i]),
    sum: (I, Y) => sum(I, (i) => Y[+i]),
    deviation: (I, Y) => deviation(I, (i) => Y[+i])
  };
  return registry[basis2] || max5;
}
var NormalizeY = (options = {}) => {
  const { groupBy: groupBy3 = "x", basis: basis2 = "max" } = options;
  return (I, mark2) => {
    const { encode, tooltip: tooltip2 } = mark2;
    const { x: x3 } = encode, rest = __rest5(encode, ["x"]);
    const Yn2 = Object.entries(rest).filter(([k2]) => k2.startsWith("y")).map(([k2]) => [k2, columnOf(encode, k2)[0]]);
    const [, Y] = Yn2.find(([k2]) => k2 === "y");
    const newYn = Yn2.map(([k2]) => [k2, new Array(I.length)]);
    const groups2 = createGroups(groupBy3, I, mark2);
    const basisFunction = normalizeBasis(basis2);
    for (const I2 of groups2) {
      const basisValue = basisFunction(I2, Y);
      for (const i of I2) {
        for (let j = 0; j < Yn2.length; j++) {
          const [, V] = Yn2[j];
          const [, newV] = newYn[j];
          newV[i] = +V[i] / basisValue;
        }
      }
    }
    const specifiedTooltip = isUnset(tooltip2) || (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.items) && (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.items.length) !== 0;
    return [
      I,
      deep_mix_default({}, mark2, Object.assign({ encode: Object.fromEntries(newYn.map(([k2, v]) => [k2, column(v, columnOf(encode, k2)[1])])) }, !specifiedTooltip && encode.y0 && {
        tooltip: { items: [{ channel: "y0" }] }
      }))
    ];
  };
};
NormalizeY.props = {};

// node_modules/@antv/scale/esm/utils/compose.js
function compose2(fn, ...rest) {
  return rest.reduce((pre, cur) => (x3) => pre(cur(x3)), fn);
}

// node_modules/@antv/scale/esm/utils/normalize.js
function createNormalize(a4, b) {
  return b - a4 ? (t) => (t - a4) / (b - a4) : (_2) => 0.5;
}

// node_modules/@antv/scale/esm/utils/clamp.js
function createClamp(a4, b) {
  const lo = b < a4 ? b : a4;
  const hi = a4 > b ? a4 : b;
  return (x3) => Math.min(Math.max(lo, x3), hi);
}

// node_modules/@antv/scale/esm/utils/bisect.js
function bisect(array2, x3, lo, hi, getter) {
  let i = lo || 0;
  let j = hi || array2.length;
  const get4 = getter || ((x4) => x4);
  while (i < j) {
    const mid2 = Math.floor((i + j) / 2);
    if (get4(array2[mid2]) > x3) {
      j = mid2;
    } else {
      i = mid2 + 1;
    }
  }
  return i;
}

// node_modules/@antv/scale/esm/utils/ticks.js
var e102 = Math.sqrt(50);
var e52 = Math.sqrt(10);
var e22 = Math.sqrt(2);
function tickIncrement2(start, stop, count4) {
  const step2 = (stop - start) / Math.max(0, count4);
  const power = Math.floor(Math.log(step2) / Math.LN10);
  const error3 = step2 / 10 ** power;
  if (power >= 0) {
    return (error3 >= e102 ? 10 : error3 >= e52 ? 5 : error3 >= e22 ? 2 : 1) * 10 ** power;
  }
  return -(10 ** -power) / (error3 >= e102 ? 10 : error3 >= e52 ? 5 : error3 >= e22 ? 2 : 1);
}
function tickStep2(start, stop, count4) {
  const step0 = Math.abs(stop - start) / Math.max(0, count4);
  let step1 = 10 ** Math.floor(Math.log(step0) / Math.LN10);
  const error3 = step0 / step1;
  if (error3 >= e102)
    step1 *= 10;
  else if (error3 >= e52)
    step1 *= 5;
  else if (error3 >= e22)
    step1 *= 2;
  return stop < start ? -step1 : step1;
}

// node_modules/@antv/scale/esm/utils/d3-linear-nice.js
var d3LinearNice = (min10, max11, count4 = 5) => {
  const d3 = [min10, max11];
  let i0 = 0;
  let i1 = d3.length - 1;
  let start = d3[i0];
  let stop = d3[i1];
  let step2;
  if (stop < start) {
    [start, stop] = [stop, start];
    [i0, i1] = [i1, i0];
  }
  step2 = tickIncrement2(start, stop, count4);
  if (step2 > 0) {
    start = Math.floor(start / step2) * step2;
    stop = Math.ceil(stop / step2) * step2;
    step2 = tickIncrement2(start, stop, count4);
  } else if (step2 < 0) {
    start = Math.ceil(start * step2) / step2;
    stop = Math.floor(stop * step2) / step2;
    step2 = tickIncrement2(start, stop, count4);
  }
  if (step2 > 0) {
    d3[i0] = Math.floor(start / step2) * step2;
    d3[i1] = Math.ceil(stop / step2) * step2;
  } else if (step2 < 0) {
    d3[i0] = Math.ceil(start * step2) / step2;
    d3[i1] = Math.floor(stop * step2) / step2;
  }
  return d3;
};

// node_modules/@antv/scale/esm/utils/time-interval.js
var DURATION_SECOND = 1e3;
var DURATION_MINUTE = DURATION_SECOND * 60;
var DURATION_HOUR = DURATION_MINUTE * 60;
var DURATION_DAY = DURATION_HOUR * 24;
var DURATION_WEEK = DURATION_DAY * 7;
var DURATION_MONTH = DURATION_DAY * 30;
var DURATION_YEAR = DURATION_DAY * 365;
function createInterval(duration, floorish, offseti, field3) {
  const adjust2 = (date, step2) => {
    const test = (date2) => field3(date2) % step2 === 0;
    let i = step2;
    while (i && !test(date)) {
      offseti(date, -1);
      i -= 1;
    }
    return date;
  };
  const floori = (date, step2) => {
    if (step2)
      adjust2(date, step2);
    floorish(date);
  };
  const floor4 = (date, step2) => {
    const d3 = /* @__PURE__ */ new Date(+date);
    floori(d3, step2);
    return d3;
  };
  const ceil6 = (date, step2) => {
    const d3 = new Date(+date - 1);
    floori(d3, step2);
    offseti(d3, step2);
    floori(d3);
    return d3;
  };
  const range3 = (start, stop, step2, shouldAdjust) => {
    const ticks2 = [];
    const roundStep = Math.floor(step2);
    const t = shouldAdjust ? ceil6(start, step2) : ceil6(start);
    for (let i = t; i < stop; offseti(i, roundStep), floori(i)) {
      ticks2.push(/* @__PURE__ */ new Date(+i));
    }
    return ticks2;
  };
  return {
    ceil: ceil6,
    floor: floor4,
    range: range3,
    duration
  };
}
var millisecond = createInterval(1, (date) => date, (date, step2 = 1) => {
  date.setTime(+date + step2);
}, (date) => date.getTime());
var second = createInterval(DURATION_SECOND, (date) => {
  date.setMilliseconds(0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_SECOND * step2);
}, (date) => date.getSeconds());
var minute = createInterval(DURATION_MINUTE, (date) => {
  date.setSeconds(0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_MINUTE * step2);
}, (date) => date.getMinutes());
var hour = createInterval(DURATION_HOUR, (date) => {
  date.setMinutes(0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_HOUR * step2);
}, (date) => date.getHours());
var day = createInterval(DURATION_DAY, (date) => {
  date.setHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_DAY * step2);
}, (date) => date.getDate() - 1);
var month = createInterval(DURATION_MONTH, (date) => {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  const month2 = date.getMonth();
  date.setMonth(month2 + step2);
}, (date) => date.getMonth());
var week = createInterval(DURATION_WEEK, (date) => {
  date.setDate(date.getDate() - date.getDay() % 7);
  date.setHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  date.setDate(date.getDate() + 7 * step2);
}, (date) => {
  const start = month.floor(date);
  const end = /* @__PURE__ */ new Date(+date);
  return Math.floor((+end - +start) / DURATION_WEEK);
});
var year = createInterval(DURATION_YEAR, (date) => {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  const year2 = date.getFullYear();
  date.setFullYear(year2 + step2);
}, (date) => date.getFullYear());
var localIntervalMap = {
  millisecond,
  second,
  minute,
  hour,
  day,
  week,
  month,
  year
};

// node_modules/@antv/scale/esm/utils/utc-interval.js
var utcMillisecond = createInterval(1, (date) => date, (date, step2 = 1) => {
  date.setTime(+date + step2);
}, (date) => date.getTime());
var utcSecond = createInterval(DURATION_SECOND, (date) => {
  date.setUTCMilliseconds(0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_SECOND * step2);
}, (date) => date.getUTCSeconds());
var utcMinute = createInterval(DURATION_MINUTE, (date) => {
  date.setUTCSeconds(0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_MINUTE * step2);
}, (date) => date.getUTCMinutes());
var utcHour = createInterval(DURATION_HOUR, (date) => {
  date.setUTCMinutes(0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_HOUR * step2);
}, (date) => date.getUTCHours());
var utcDay = createInterval(DURATION_DAY, (date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_DAY * step2);
}, (date) => date.getUTCDate() - 1);
var utcMonth = createInterval(DURATION_MONTH, (date) => {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  const month2 = date.getUTCMonth();
  date.setUTCMonth(month2 + step2);
}, (date) => date.getUTCMonth());
var utcWeek = createInterval(DURATION_WEEK, (date) => {
  date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7) % 7);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_WEEK * step2);
}, (date) => {
  const start = utcMonth.floor(date);
  const end = /* @__PURE__ */ new Date(+date);
  return Math.floor((+end - +start) / DURATION_WEEK);
});
var utcYear = createInterval(DURATION_YEAR, (date) => {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  const year2 = date.getUTCFullYear();
  date.setUTCFullYear(year2 + step2);
}, (date) => date.getUTCFullYear());
var utcIntervalMap = {
  millisecond: utcMillisecond,
  second: utcSecond,
  minute: utcMinute,
  hour: utcHour,
  day: utcDay,
  week: utcWeek,
  month: utcMonth,
  year: utcYear
};

// node_modules/@antv/scale/esm/utils/find-tick-interval.js
function chooseTickIntervals(utc) {
  const intervalMap = utc ? utcIntervalMap : localIntervalMap;
  const { year: year2, month: month2, week: week2, day: day2, hour: hour2, minute: minute2, second: second2, millisecond: millisecond2 } = intervalMap;
  const tickIntervals = [
    [second2, 1],
    [second2, 5],
    [second2, 15],
    [second2, 30],
    [minute2, 1],
    [minute2, 5],
    [minute2, 15],
    [minute2, 30],
    [hour2, 1],
    [hour2, 3],
    [hour2, 6],
    [hour2, 12],
    [day2, 1],
    [day2, 2],
    [week2, 1],
    [month2, 1],
    [month2, 3],
    [year2, 1]
  ];
  return {
    tickIntervals,
    year: year2,
    millisecond: millisecond2
  };
}
function findTickInterval(start, stop, count4, interval2, utc) {
  const lo = +start;
  const hi = +stop;
  const { tickIntervals, year: year2, millisecond: millisecond2 } = chooseTickIntervals(utc);
  const getter = ([interval3, count5]) => interval3.duration * count5;
  const targetCount = interval2 ? (hi - lo) / interval2 : count4 || 5;
  const targetInterval = interval2 || (hi - lo) / targetCount;
  const len5 = tickIntervals.length;
  const i = bisect(tickIntervals, targetInterval, 0, len5, getter);
  let matchInterval;
  if (i === len5) {
    const step2 = tickStep2(lo / year2.duration, hi / year2.duration, targetCount);
    matchInterval = [year2, step2];
  } else if (i) {
    const closeToLow = targetInterval / getter(tickIntervals[i - 1]) < getter(tickIntervals[i]) / targetInterval;
    const [timeInterval, targetStep] = closeToLow ? tickIntervals[i - 1] : tickIntervals[i];
    const step2 = interval2 ? Math.ceil(interval2 / timeInterval.duration) : targetStep;
    matchInterval = [timeInterval, step2];
  } else {
    const step2 = Math.max(tickStep2(lo, hi, targetCount), 1);
    matchInterval = [millisecond2, step2];
  }
  return matchInterval;
}

// node_modules/@antv/scale/esm/utils/d3-time-nice.js
var d3TimeNice = (min10, max11, count4, interval2, utc) => {
  const r = min10 > max11;
  const lo = r ? max11 : min10;
  const hi = r ? min10 : max11;
  const [tickInterval, step2] = findTickInterval(lo, hi, count4, interval2, utc);
  const domain = [tickInterval.floor(lo, step2), tickInterval.ceil(hi, step2)];
  return r ? domain.reverse() : domain;
};

// node_modules/@antv/scale/esm/utils/is-valid.js
function isValid(x3) {
  return !is_undefined_default(x3) && !isNull(x3) && !Number.isNaN(x3);
}

// node_modules/@antv/scale/esm/utils/log.js
var reflect = (f) => {
  return (x3) => -f(-x3);
};
var logs = (base, shouldReflect) => {
  const baseCache = Math.log(base);
  const log2 = base === Math.E ? Math.log : base === 10 ? Math.log10 : base === 2 ? Math.log2 : (x3) => Math.log(x3) / baseCache;
  return shouldReflect ? reflect(log2) : log2;
};
var pows = (base, shouldReflect) => {
  const pow3 = base === Math.E ? Math.exp : (x3) => base ** x3;
  return shouldReflect ? reflect(pow3) : pow3;
};

// node_modules/@antv/scale/esm/utils/d3-log-nice.js
var d3LogNice = (a4, b, _2, base) => {
  const shouldReflect = a4 < 0;
  const log2 = logs(base, shouldReflect);
  const pow3 = pows(base, shouldReflect);
  const r = a4 > b;
  const min10 = r ? b : a4;
  const max11 = r ? a4 : b;
  const niceDomain = [pow3(Math.floor(log2(min10))), pow3(Math.ceil(log2(max11)))];
  return r ? niceDomain.reverse() : niceDomain;
};

// node_modules/@antv/scale/esm/utils/interpolatize.js
var createInterpolatorRound = (interpolator) => {
  return (t) => {
    const res = interpolator(t);
    return isNumber(res) ? Math.round(res) : res;
  };
};
function interpolatize(rangeOf5, normalizeDomain3) {
  return (Scale) => {
    Scale.prototype.rescale = function() {
      this.initRange();
      this.nice();
      const [transform2] = this.chooseTransforms();
      this.composeOutput(transform2, this.chooseClamp(transform2));
    };
    Scale.prototype.initRange = function() {
      const { interpolator } = this.options;
      this.options.range = rangeOf5(interpolator);
    };
    Scale.prototype.composeOutput = function(transform2, clamp3) {
      const { domain, interpolator, round: round5 } = this.getOptions();
      const normalize10 = normalizeDomain3(domain.map(transform2));
      const interpolate4 = round5 ? createInterpolatorRound(interpolator) : interpolator;
      this.output = compose2(interpolate4, normalize10, clamp3, transform2);
    };
    Scale.prototype.invert = void 0;
  };
}

// node_modules/@antv/scale/esm/utils/color.js
var import_color_string = __toESM(require_color_string());
function hue2rgb(p2, q, m3) {
  let t = m3;
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p2 + (q - p2) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p2 + (q - p2) * (2 / 3 - t) * 6;
  return p2;
}
function hsl2rbg(hsl4) {
  const h = hsl4[0] / 360;
  const s3 = hsl4[1] / 100;
  const l = hsl4[2] / 100;
  const a4 = hsl4[3];
  if (s3 === 0)
    return [l * 255, l * 255, l * 255, a4];
  const q = l < 0.5 ? l * (1 + s3) : l + s3 - l * s3;
  const p2 = 2 * l - q;
  const r = hue2rgb(p2, q, h + 1 / 3);
  const g = hue2rgb(p2, q, h);
  const b = hue2rgb(p2, q, h - 1 / 3);
  return [r * 255, g * 255, b * 255, a4];
}
function string2rbg(s3) {
  const color3 = import_color_string.default.get(s3);
  if (!color3)
    return null;
  const { model, value: value2 } = color3;
  if (model === "rgb")
    return value2;
  if (model === "hsl")
    return hsl2rbg(value2);
  return null;
}

// node_modules/@antv/scale/esm/utils/interpolate.js
var createInterpolateNumber = (a4, b) => {
  return (t) => a4 * (1 - t) + b * t;
};
var createInterpolateColor = (a4, b) => {
  const c1 = string2rbg(a4);
  const c22 = string2rbg(b);
  if (c1 === null || c22 === null)
    return c1 ? () => a4 : () => b;
  return (t) => {
    const values4 = new Array(4);
    for (let i = 0; i < 4; i += 1) {
      const from = c1[i];
      const to = c22[i];
      values4[i] = from * (1 - t) + to * t;
    }
    const [r, g, b2, a5] = values4;
    return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b2)}, ${a5})`;
  };
};
var createInterpolateValue = (a4, b) => {
  if (typeof a4 === "number" && typeof b === "number")
    return createInterpolateNumber(a4, b);
  if (typeof a4 === "string" && typeof b === "string")
    return createInterpolateColor(a4, b);
  return () => a4;
};
var createInterpolateRound = (a4, b) => {
  const interpolateNumber = createInterpolateNumber(a4, b);
  return (t) => Math.round(interpolateNumber(t));
};

// node_modules/@antv/scale/esm/utils/choose-mask.js
function chooseNiceTimeMask(date, intervalMap) {
  const { second: second2, minute: minute2, hour: hour2, day: day2, week: week2, month: month2, year: year2 } = intervalMap;
  if (second2.floor(date) < date)
    return ".SSS";
  if (minute2.floor(date) < date)
    return ":ss";
  if (hour2.floor(date) < date)
    return "hh:mm";
  if (day2.floor(date) < date)
    return "hh A";
  if (month2.floor(date) < date) {
    if (week2.floor(date) < date)
      return "MMM DD";
    return "ddd DD";
  }
  if (year2.floor(date) < date)
    return "MMMM";
  return "YYYY";
}

// node_modules/@antv/scale/esm/utils/internMap.js
function internGet({ map: map5, initKey }, value2) {
  const key = initKey(value2);
  return map5.has(key) ? map5.get(key) : value2;
}
function internSet({ map: map5, initKey }, value2) {
  const key = initKey(value2);
  if (map5.has(key))
    return map5.get(key);
  map5.set(key, value2);
  return value2;
}
function internDelete({ map: map5, initKey }, value2) {
  const key = initKey(value2);
  if (map5.has(key)) {
    value2 = map5.get(key);
    map5.delete(key);
  }
  return value2;
}
function keyof2(value2) {
  return typeof value2 === "object" ? value2.valueOf() : value2;
}
var InternMap2 = class extends Map {
  constructor(entries) {
    super();
    this.map = /* @__PURE__ */ new Map();
    this.initKey = keyof2;
    if (entries !== null) {
      for (const [key, value2] of entries) {
        this.set(key, value2);
      }
    }
  }
  get(key) {
    return super.get(internGet({ map: this.map, initKey: this.initKey }, key));
  }
  has(key) {
    return super.has(internGet({ map: this.map, initKey: this.initKey }, key));
  }
  set(key, value2) {
    return super.set(internSet({ map: this.map, initKey: this.initKey }, key), value2);
  }
  delete(key) {
    return super.delete(internDelete({ map: this.map, initKey: this.initKey }, key));
  }
};

// node_modules/@antv/scale/esm/scales/base.js
var Base = class {
  /**
   * 构造函数，根据自定义的选项和默认选项生成当前选项
   * @param options 需要自定义配置的选项
   */
  constructor(options) {
    this.options = deep_mix_default({}, this.getDefaultOptions());
    this.update(options);
  }
  /**
   * 返回当前的所有选项
   * @returns 当前的所有选项
   */
  getOptions() {
    return this.options;
  }
  /**
   * 更新选项和比例尺的内部状态
   * @param updateOptions 需要更新的选项
   */
  update(updateOptions = {}) {
    this.options = deep_mix_default({}, this.options, updateOptions);
    this.rescale(updateOptions);
  }
  /**
   * 根据需要更新 options 和更新后的 options 更新 scale 的内部状态，
   * 在函数内部可以用 this.options 获得更新后的 options
   * @param options 需要更新的 options
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  rescale(options) {
  }
};

// node_modules/@antv/scale/esm/scales/ordinal.js
var defaultUnknown = Symbol("defaultUnknown");
function updateIndexMap(target, arr, key) {
  for (let i = 0; i < arr.length; i += 1) {
    if (!target.has(arr[i])) {
      target.set(key(arr[i]), i);
    }
  }
}
function mapBetweenArrByMapIndex(options) {
  const { value: value2, from, to, mapper, notFoundReturn } = options;
  let mappedIndex = mapper.get(value2);
  if (mappedIndex === void 0) {
    if (notFoundReturn !== defaultUnknown) {
      return notFoundReturn;
    }
    mappedIndex = from.push(value2) - 1;
    mapper.set(value2, mappedIndex);
  }
  return to[mappedIndex % to.length];
}
function createKey(d3) {
  if (d3 instanceof Date)
    return (d4) => `${d4}`;
  if (typeof d3 === "object")
    return (d4) => JSON.stringify(d4);
  return (d4) => d4;
}
var Ordinal = class _Ordinal extends Base {
  // 覆盖默认配置
  getDefaultOptions() {
    return {
      domain: [],
      range: [],
      unknown: defaultUnknown
    };
  }
  // 显示指定 options 的类型为 OrdinalOptions，从而推断出 O 的类型
  constructor(options) {
    super(options);
  }
  map(x3) {
    if (this.domainIndexMap.size === 0) {
      updateIndexMap(this.domainIndexMap, this.getDomain(), this.domainKey);
    }
    return mapBetweenArrByMapIndex({
      value: this.domainKey(x3),
      mapper: this.domainIndexMap,
      from: this.getDomain(),
      to: this.getRange(),
      notFoundReturn: this.options.unknown
    });
  }
  invert(y3) {
    if (this.rangeIndexMap.size === 0) {
      updateIndexMap(this.rangeIndexMap, this.getRange(), this.rangeKey);
    }
    return mapBetweenArrByMapIndex({
      value: this.rangeKey(y3),
      mapper: this.rangeIndexMap,
      from: this.getRange(),
      to: this.getDomain(),
      notFoundReturn: this.options.unknown
    });
  }
  // 因为 ordinal 比例尺更新内部状态的开销较大，所以按需更新
  rescale(options) {
    const [d3] = this.options.domain;
    const [r] = this.options.range;
    this.domainKey = createKey(d3);
    this.rangeKey = createKey(r);
    if (!this.rangeIndexMap) {
      this.rangeIndexMap = /* @__PURE__ */ new Map();
      this.domainIndexMap = /* @__PURE__ */ new Map();
      return;
    }
    if (!options || options.range) {
      this.rangeIndexMap.clear();
    }
    if (!options || options.domain || options.compare) {
      this.domainIndexMap.clear();
      this.sortedDomain = void 0;
    }
  }
  clone() {
    return new _Ordinal(this.options);
  }
  getRange() {
    return this.options.range;
  }
  getDomain() {
    if (this.sortedDomain)
      return this.sortedDomain;
    const { domain, compare } = this.options;
    this.sortedDomain = compare ? [...domain].sort(compare) : domain;
    return this.sortedDomain;
  }
};

// node_modules/@antv/scale/esm/scales/band.js
function normalize5(array2) {
  const min10 = Math.min(...array2);
  return array2.map((d3) => d3 / min10);
}
function splice3(array2, n) {
  const sn = array2.length;
  const diff = n - sn;
  return diff > 0 ? [...array2, ...new Array(diff).fill(1)] : diff < 0 ? array2.slice(0, n) : array2;
}
function pretty(n) {
  return Math.round(n * 1e12) / 1e12;
}
function computeFlexBandState(options) {
  const { domain, range: range3, paddingOuter, paddingInner, flex: F, round: round5, align } = options;
  const n = domain.length;
  const flex2 = splice3(F, n);
  const [start, end] = range3;
  const width = end - start;
  const ratio = 2 / n * paddingOuter + 1 - 1 / n * paddingInner;
  const stepSum = width / ratio;
  const PI = stepSum * paddingInner / n;
  const bandWidthSum = stepSum - n * PI;
  const normalizedFlex = normalize5(flex2);
  const flexSum = normalizedFlex.reduce((sum4, value2) => sum4 + value2);
  const minBandWidth = bandWidthSum / flexSum;
  const valueBandWidth = new InternMap2(domain.map((d3, i) => {
    const bandWidth3 = normalizedFlex[i] * minBandWidth;
    return [d3, round5 ? Math.floor(bandWidth3) : bandWidth3];
  }));
  const valueStep = new InternMap2(domain.map((d3, i) => {
    const bandWidth3 = normalizedFlex[i] * minBandWidth;
    const step2 = bandWidth3 + PI;
    return [d3, round5 ? Math.floor(step2) : step2];
  }));
  const finalStepSum = Array.from(valueStep.values()).reduce((sum4, value2) => sum4 + value2);
  const outerPaddingSum = width - (finalStepSum - finalStepSum / n * paddingInner);
  const offset2 = outerPaddingSum * align;
  const bandStart = start + offset2;
  let prev = round5 ? Math.round(bandStart) : bandStart;
  const adjustedRange = new Array(n);
  for (let i = 0; i < n; i += 1) {
    adjustedRange[i] = pretty(prev);
    const value2 = domain[i];
    prev += valueStep.get(value2);
  }
  return {
    valueBandWidth,
    valueStep,
    adjustedRange
  };
}
function computeBandState(options) {
  var _a2;
  const { domain } = options;
  const n = domain.length;
  if (n === 0) {
    return {
      valueBandWidth: void 0,
      valueStep: void 0,
      adjustedRange: []
    };
  }
  const hasFlex = !!((_a2 = options.flex) === null || _a2 === void 0 ? void 0 : _a2.length);
  if (hasFlex) {
    return computeFlexBandState(options);
  }
  const { range: range3, paddingOuter, paddingInner, round: round5, align } = options;
  let step2;
  let bandWidth3;
  let rangeStart = range3[0];
  const rangeEnd = range3[1];
  const deltaRange = rangeEnd - rangeStart;
  const outerTotal = paddingOuter * 2;
  const innerTotal = n - paddingInner;
  step2 = deltaRange / Math.max(1, outerTotal + innerTotal);
  if (round5) {
    step2 = Math.floor(step2);
  }
  rangeStart += (deltaRange - step2 * (n - paddingInner)) * align;
  bandWidth3 = step2 * (1 - paddingInner);
  if (round5) {
    rangeStart = Math.round(rangeStart);
    bandWidth3 = Math.round(bandWidth3);
  }
  const adjustedRange = new Array(n).fill(0).map((_2, i) => rangeStart + i * step2);
  return {
    valueStep: step2,
    valueBandWidth: bandWidth3,
    adjustedRange
  };
}
var Band = class _Band extends Ordinal {
  // 覆盖默认配置
  getDefaultOptions() {
    return {
      domain: [],
      range: [0, 1],
      align: 0.5,
      round: false,
      paddingInner: 0,
      paddingOuter: 0,
      padding: 0,
      unknown: defaultUnknown,
      flex: []
    };
  }
  // 显示指定 options 的类型为 OrdinalOptions，从而推断出 O 的类型
  constructor(options) {
    super(options);
  }
  clone() {
    return new _Band(this.options);
  }
  getStep(x3) {
    if (this.valueStep === void 0)
      return 1;
    if (typeof this.valueStep === "number") {
      return this.valueStep;
    }
    if (x3 === void 0)
      return Array.from(this.valueStep.values())[0];
    return this.valueStep.get(x3);
  }
  getBandWidth(x3) {
    if (this.valueBandWidth === void 0)
      return 1;
    if (typeof this.valueBandWidth === "number") {
      return this.valueBandWidth;
    }
    if (x3 === void 0)
      return Array.from(this.valueBandWidth.values())[0];
    return this.valueBandWidth.get(x3);
  }
  getRange() {
    return this.adjustedRange;
  }
  getPaddingInner() {
    const { padding, paddingInner } = this.options;
    return padding > 0 ? padding : paddingInner;
  }
  getPaddingOuter() {
    const { padding, paddingOuter } = this.options;
    return padding > 0 ? padding : paddingOuter;
  }
  rescale() {
    super.rescale();
    const { align, domain, range: range3, round: round5, flex: flex2 } = this.options;
    const { adjustedRange, valueBandWidth, valueStep } = computeBandState({
      align,
      range: range3,
      round: round5,
      flex: flex2,
      paddingInner: this.getPaddingInner(),
      paddingOuter: this.getPaddingOuter(),
      domain
    });
    this.valueStep = valueStep;
    this.valueBandWidth = valueBandWidth;
    this.adjustedRange = adjustedRange;
  }
};

// node_modules/@antv/scale/esm/tick-methods/d3-ticks.js
var d3Ticks = (begin, end, count4) => {
  let n;
  let ticks2;
  let start = begin;
  let stop = end;
  if (start === stop && count4 > 0) {
    return [start];
  }
  let step2 = tickIncrement2(start, stop, count4);
  if (step2 === 0 || !Number.isFinite(step2)) {
    return [];
  }
  if (step2 > 0) {
    start = Math.ceil(start / step2);
    stop = Math.floor(stop / step2);
    ticks2 = new Array(n = Math.ceil(stop - start + 1));
    for (let i = 0; i < n; i += 1) {
      ticks2[i] = (start + i) * step2;
    }
  } else {
    step2 = -step2;
    start = Math.ceil(start * step2);
    stop = Math.floor(stop * step2);
    ticks2 = new Array(n = Math.ceil(stop - start + 1));
    for (let i = 0; i < n; i += 1) {
      ticks2[i] = (start + i) / step2;
    }
  }
  return ticks2;
};

// node_modules/@antv/scale/esm/scales/constant.js
var Constant2 = class _Constant extends Base {
  /**
   * 返回需要覆盖的默认选项
   * @returns 需要覆盖的默认选项
   */
  getDefaultOptions() {
    return {
      range: [0],
      domain: [0, 1],
      unknown: void 0,
      tickCount: 5,
      tickMethod: d3Ticks
    };
  }
  /**
   * 输入和输出满足：y = b，其中 b 是一个常量，是 options.range 的第一个元素
   * @param _ 输入值
   * @returns 输出值（常量）
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  map(_2) {
    const [v] = this.options.range;
    return v !== void 0 ? v : this.options.unknown;
  }
  /**
   * 如果 x 是该比例尺的常量（x === b），返回输入值的范围（即定义域），否者返回 []
   * @param x 输出值 (常量）
   * @returns 定义域
   */
  invert(x3) {
    const [v] = this.options.range;
    return x3 === v && v !== void 0 ? this.options.domain : [];
  }
  getTicks() {
    const { tickMethod, domain, tickCount } = this.options;
    const [a4, b] = domain;
    if (!isNumber(a4) || !isNumber(b))
      return [];
    return tickMethod(a4, b, tickCount);
  }
  /**
   * 克隆 Constant Scale
   * @returns 拥有相同选项且独立的 Constant Scale
   */
  clone() {
    return new _Constant(this.options);
  }
};

// node_modules/@antv/scale/esm/utils/pretty-number.js
function prettyNumber(n) {
  return Math.abs(n) < 1e-14 ? n : parseFloat(n.toFixed(14));
}

// node_modules/@antv/scale/esm/tick-methods/wilkinson-extended.js
var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
var eps = Number.EPSILON * 100;
function mod2(n, m3) {
  return (n % m3 + m3) % m3;
}
function round4(n) {
  return Math.round(n * 1e12) / 1e12;
}
function simplicity(q, Q, j, lmin, lmax, lstep) {
  const n = size(Q);
  const i = index_of_default(Q, q);
  let v = 0;
  const m3 = mod2(lmin, lstep);
  if ((m3 < eps || lstep - m3 < eps) && lmin <= 0 && lmax >= 0) {
    v = 1;
  }
  return 1 - i / (n - 1) - j + v;
}
function simplicityMax(q, Q, j) {
  const n = size(Q);
  const i = index_of_default(Q, q);
  const v = 1;
  return 1 - i / (n - 1) - j + v;
}
function density(k2, m3, dMin, dMax, lMin, lMax) {
  const r = (k2 - 1) / (lMax - lMin);
  const rt = (m3 - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
  return 2 - Math.max(r / rt, rt / r);
}
function densityMax(k2, m3) {
  if (k2 >= m3) {
    return 2 - (k2 - 1) / (m3 - 1);
  }
  return 1;
}
function coverage(dMin, dMax, lMin, lMax) {
  const range3 = dMax - dMin;
  return 1 - 0.5 * ((dMax - lMax) ** 2 + (dMin - lMin) ** 2) / (0.1 * range3) ** 2;
}
function coverageMax(dMin, dMax, span) {
  const range3 = dMax - dMin;
  if (span > range3) {
    const half = (span - range3) / 2;
    return 1 - half ** 2 / (0.1 * range3) ** 2;
  }
  return 1;
}
function legibility() {
  return 1;
}
var wilkinsonExtended = (dMin, dMax, n = 5, onlyLoose = true, Q = DEFAULT_Q, w = [0.25, 0.2, 0.5, 0.05]) => {
  const m3 = n < 0 ? 0 : Math.round(n);
  if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== "number" || typeof dMax !== "number" || !m3) {
    return [];
  }
  if (dMax - dMin < 1e-15 || m3 === 1) {
    return [dMin];
  }
  const best = {
    score: -2,
    lmin: 0,
    lmax: 0,
    lstep: 0
  };
  let j = 1;
  while (j < Infinity) {
    for (let i = 0; i < Q.length; i += 1) {
      const q = Q[i];
      const sm = simplicityMax(q, Q, j);
      if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {
        j = Infinity;
        break;
      }
      let k2 = 2;
      while (k2 < Infinity) {
        const dm = densityMax(k2, m3);
        if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {
          break;
        }
        const delta = (dMax - dMin) / (k2 + 1) / j / q;
        let z = Math.ceil(Math.log10(delta));
        while (z < Infinity) {
          const step2 = j * q * 10 ** z;
          const cm = coverageMax(dMin, dMax, step2 * (k2 - 1));
          if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {
            break;
          }
          const minStart = Math.floor(dMax / step2) * j - (k2 - 1) * j;
          const maxStart = Math.ceil(dMin / step2) * j;
          if (minStart <= maxStart) {
            const count4 = maxStart - minStart;
            for (let i2 = 0; i2 <= count4; i2 += 1) {
              const start = minStart + i2;
              const lMin = start * (step2 / j);
              const lMax = lMin + step2 * (k2 - 1);
              const lStep = step2;
              const s3 = simplicity(q, Q, j, lMin, lMax, lStep);
              const c5 = coverage(dMin, dMax, lMin, lMax);
              const g = density(k2, m3, dMin, dMax, lMin, lMax);
              const l = legibility();
              const score2 = w[0] * s3 + w[1] * c5 + w[2] * g + w[3] * l;
              if (score2 > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {
                best.lmin = lMin;
                best.lmax = lMax;
                best.lstep = lStep;
                best.score = score2;
              }
            }
          }
          z += 1;
        }
        k2 += 1;
      }
    }
    j += 1;
  }
  const lmax = prettyNumber(best.lmax);
  const lmin = prettyNumber(best.lmin);
  const lstep = prettyNumber(best.lstep);
  const tickCount = Math.floor(round4((lmax - lmin) / lstep)) + 1;
  const ticks2 = new Array(tickCount);
  ticks2[0] = prettyNumber(lmin);
  for (let i = 1; i < tickCount; i += 1) {
    ticks2[i] = prettyNumber(ticks2[i - 1] + lstep);
  }
  return ticks2;
};

// node_modules/@antv/scale/esm/scales/identity.js
var Identity = class _Identity extends Base {
  /**
   * 返回需要覆盖的默认选项
   * @returns 需要覆盖的默认选项
   */
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      tickCount: 5,
      unknown: void 0,
      tickMethod: wilkinsonExtended
    };
  }
  /**
   * 输入和输出满足：y = x
   * @param x 输入值
   * @returns 输出值
   */
  map(x3) {
    return isValid(x3) ? x3 : this.options.unknown;
  }
  /**
   * map 的逆运算：x = y，在这里和 map 是相同方法
   * @param x 输出值
   * @returns 输入值
   */
  invert(x3) {
    return this.map(x3);
  }
  /**
   * 克隆 Identity Scale
   * @returns 拥有相同选项且独立的 Identity Scale
   */
  clone() {
    return new _Identity(this.options);
  }
  /**
   * 根据比例尺的配置去生成 ticks，该 ticks 主要用于生成坐标轴
   * @returns 返回一个 ticks 的数组
   */
  getTicks() {
    const { domain, tickCount, tickMethod } = this.options;
    const [min10, max11] = domain;
    if (!isNumber(min10) || !isNumber(max11))
      return [];
    return tickMethod(min10, max11, tickCount);
  }
};

// node_modules/@antv/scale/esm/scales/continuous.js
var createBiMap = (domain, range3, createInterpolate) => {
  const [d0, d1] = domain;
  const [r0, r1] = range3;
  let normalize10;
  let interpolate4;
  if (d0 < d1) {
    normalize10 = createNormalize(d0, d1);
    interpolate4 = createInterpolate(r0, r1);
  } else {
    normalize10 = createNormalize(d1, d0);
    interpolate4 = createInterpolate(r1, r0);
  }
  return compose2(interpolate4, normalize10);
};
var createPolyMap = (domain, range3, createInterpolate) => {
  const len5 = Math.min(domain.length, range3.length) - 1;
  const normalizeList = new Array(len5);
  const interpolateList = new Array(len5);
  const reverse2 = domain[0] > domain[len5];
  const ascendingDomain = reverse2 ? [...domain].reverse() : domain;
  const ascendingRange = reverse2 ? [...range3].reverse() : range3;
  for (let i = 0; i < len5; i += 1) {
    normalizeList[i] = createNormalize(ascendingDomain[i], ascendingDomain[i + 1]);
    interpolateList[i] = createInterpolate(ascendingRange[i], ascendingRange[i + 1]);
  }
  return (x3) => {
    const i = bisect(domain, x3, 1, len5) - 1;
    const normalize10 = normalizeList[i];
    const interpolate4 = interpolateList[i];
    return compose2(interpolate4, normalize10)(x3);
  };
};
var choosePiecewise = (domain, range3, interpolate4, shouldRound) => {
  const n = Math.min(domain.length, range3.length);
  const createPiecewise = n > 2 ? createPolyMap : createBiMap;
  const createInterpolate = shouldRound ? createInterpolateRound : interpolate4;
  return createPiecewise(domain, range3, createInterpolate);
};
var Continuous = class extends Base {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateNumber,
      tickCount: 5
    };
  }
  /**
   * y = interpolate(normalize(clamp(transform(x))))
   */
  map(x3) {
    if (!isValid(x3))
      return this.options.unknown;
    return this.output(x3);
  }
  /**
   * x = transform(clamp(interpolate(normalize(y))))
   */
  invert(x3) {
    if (!isValid(x3))
      return this.options.unknown;
    return this.input(x3);
  }
  nice() {
    if (!this.options.nice)
      return;
    const [min10, max11, tickCount, ...rest] = this.getTickMethodOptions();
    this.options.domain = this.chooseNice()(min10, max11, tickCount, ...rest);
  }
  getTicks() {
    const { tickMethod } = this.options;
    const [min10, max11, tickCount, ...rest] = this.getTickMethodOptions();
    return tickMethod(min10, max11, tickCount, ...rest);
  }
  getTickMethodOptions() {
    const { domain, tickCount } = this.options;
    const min10 = domain[0];
    const max11 = domain[domain.length - 1];
    return [min10, max11, tickCount];
  }
  chooseNice() {
    return d3LinearNice;
  }
  rescale() {
    this.nice();
    const [transform2, untransform] = this.chooseTransforms();
    this.composeOutput(transform2, this.chooseClamp(transform2));
    this.composeInput(transform2, untransform, this.chooseClamp(untransform));
  }
  chooseClamp(transform2) {
    const { clamp: shouldClamp, range: range3 } = this.options;
    const domain = this.options.domain.map(transform2);
    const n = Math.min(domain.length, range3.length);
    return shouldClamp ? createClamp(domain[0], domain[n - 1]) : identity_default;
  }
  composeOutput(transform2, clamp3) {
    const { domain, range: range3, round: round5, interpolate: interpolate4 } = this.options;
    const piecewise2 = choosePiecewise(domain.map(transform2), range3, interpolate4, round5);
    this.output = compose2(piecewise2, clamp3, transform2);
  }
  composeInput(transform2, untransform, clamp3) {
    const { domain, range: range3 } = this.options;
    const piecewise2 = choosePiecewise(range3, domain.map(transform2), createInterpolateNumber);
    this.input = compose2(untransform, clamp3, piecewise2);
  }
};

// node_modules/@antv/scale/esm/scales/linear.js
var Linear = class _Linear extends Continuous {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateValue,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  chooseTransforms() {
    return [identity_default, identity_default];
  }
  clone() {
    return new _Linear(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/point.js
var Point = class _Point extends Band {
  // 覆盖默认配置
  getDefaultOptions() {
    return {
      domain: [],
      range: [0, 1],
      align: 0.5,
      round: false,
      padding: 0,
      unknown: defaultUnknown,
      paddingInner: 1,
      paddingOuter: 0
    };
  }
  // 能接受的参数只是 PointOptions，不能有 paddingInner 这些属性
  constructor(options) {
    super(options);
  }
  // Point 的 paddingInner 只能是1，不能被覆盖
  getPaddingInner() {
    return 1;
  }
  clone() {
    return new _Point(this.options);
  }
  update(options) {
    super.update(options);
  }
  getPaddingOuter() {
    return this.options.padding;
  }
};

// node_modules/@antv/scale/esm/scales/pow.js
var transformPow = (exponent) => {
  return (x3) => {
    return x3 < 0 ? -((-x3) ** exponent) : x3 ** exponent;
  };
};
var transformPowInvert = (exponent) => {
  return (x3) => {
    return x3 < 0 ? -((-x3) ** (1 / exponent)) : x3 ** (1 / exponent);
  };
};
var transformSqrt = (x3) => {
  return x3 < 0 ? -Math.sqrt(-x3) : Math.sqrt(x3);
};
var Pow = class _Pow extends Continuous {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      nice: false,
      clamp: false,
      round: false,
      exponent: 2,
      interpolate: createInterpolateValue,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  // 显示指定 options 的类型为 PowOptions O 的类型
  constructor(options) {
    super(options);
  }
  chooseTransforms() {
    const { exponent } = this.options;
    if (exponent === 1)
      return [identity_default, identity_default];
    const transform2 = exponent === 0.5 ? transformSqrt : transformPow(exponent);
    const untransform = transformPowInvert(exponent);
    return [transform2, untransform];
  }
  clone() {
    return new _Pow(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/sqrt.js
var Sqrt = class _Sqrt extends Pow {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateValue,
      tickMethod: d3Ticks,
      tickCount: 5,
      exponent: 0.5
    };
  }
  constructor(options) {
    super(options);
  }
  update(options) {
    super.update(options);
  }
  clone() {
    return new _Sqrt(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/threshold.js
var Threshold = class _Threshold extends Base {
  getDefaultOptions() {
    return {
      domain: [0.5],
      range: [0, 1]
    };
  }
  constructor(options) {
    super(options);
  }
  /**
   * 二分查找到输入值在哪一段，返回对应的值域中的值
   */
  map(x3) {
    if (!isValid(x3))
      return this.options.unknown;
    const index3 = bisect(this.thresholds, x3, 0, this.n);
    return this.options.range[index3];
  }
  /**
   * 在值域中找到对应的值，并返回在定义域中属于哪一段
   */
  invert(y3) {
    const { range: range3 } = this.options;
    const index3 = range3.indexOf(y3);
    const domain = this.thresholds;
    return [domain[index3 - 1], domain[index3]];
  }
  clone() {
    return new _Threshold(this.options);
  }
  rescale() {
    const { domain, range: range3 } = this.options;
    this.n = Math.min(domain.length, range3.length - 1);
    this.thresholds = domain;
  }
};

// node_modules/@antv/scale/esm/tick-methods/d3-log.js
var d3Log = (a4, b, n, base = 10) => {
  const shouldReflect = a4 < 0;
  const pow3 = pows(base, shouldReflect);
  const log2 = logs(base, shouldReflect);
  const r = b < a4;
  const min10 = r ? b : a4;
  const max11 = r ? a4 : b;
  let i = log2(min10);
  let j = log2(max11);
  let ticks2 = [];
  if (!(base % 1) && j - i < n) {
    i = Math.floor(i);
    j = Math.ceil(j);
    if (shouldReflect) {
      for (; i <= j; i += 1) {
        const p2 = pow3(i);
        for (let k2 = base - 1; k2 >= 1; k2 -= 1) {
          const t = p2 * k2;
          if (t > max11)
            break;
          if (t >= min10)
            ticks2.push(t);
        }
      }
    } else {
      for (; i <= j; i += 1) {
        const p2 = pow3(i);
        for (let k2 = 1; k2 < base; k2 += 1) {
          const t = p2 * k2;
          if (t > max11)
            break;
          if (t >= min10)
            ticks2.push(t);
        }
      }
    }
    if (ticks2.length * 2 < n)
      ticks2 = d3Ticks(min10, max11, n);
  } else {
    const count4 = n === -1 ? j - i : Math.min(j - i, n);
    ticks2 = d3Ticks(i, j, count4).map(pow3);
  }
  return r ? ticks2.reverse() : ticks2;
};

// node_modules/@antv/scale/esm/scales/log.js
var Log = class _Log extends Continuous {
  getDefaultOptions() {
    return {
      domain: [1, 10],
      range: [0, 1],
      base: 10,
      interpolate: createInterpolateValue,
      tickMethod: d3Log,
      tickCount: 5
    };
  }
  chooseNice() {
    return d3LogNice;
  }
  getTickMethodOptions() {
    const { domain, tickCount, base } = this.options;
    const min10 = domain[0];
    const max11 = domain[domain.length - 1];
    return [min10, max11, tickCount, base];
  }
  chooseTransforms() {
    const { base, domain } = this.options;
    const shouldReflect = domain[0] < 0;
    return [logs(base, shouldReflect), pows(base, shouldReflect)];
  }
  clone() {
    return new _Log(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/quantize.js
var Quantize = class _Quantize extends Threshold {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0.5],
      nice: false,
      tickCount: 5,
      tickMethod: wilkinsonExtended
    };
  }
  constructor(options) {
    super(options);
  }
  nice() {
    const { nice: nice2 } = this.options;
    if (nice2) {
      const [min10, max11, tickCount] = this.getTickMethodOptions();
      this.options.domain = d3LinearNice(min10, max11, tickCount);
    }
  }
  getTicks() {
    const { tickMethod } = this.options;
    const [min10, max11, tickCount] = this.getTickMethodOptions();
    return tickMethod(min10, max11, tickCount);
  }
  getTickMethodOptions() {
    const { domain, tickCount } = this.options;
    const min10 = domain[0];
    const max11 = domain[domain.length - 1];
    return [min10, max11, tickCount];
  }
  rescale() {
    this.nice();
    const { range: range3, domain } = this.options;
    const [x05, x12] = domain;
    this.n = range3.length - 1;
    this.thresholds = new Array(this.n);
    for (let i = 0; i < this.n; i += 1) {
      this.thresholds[i] = ((i + 1) * x12 - (i - this.n) * x05) / (this.n + 1);
    }
  }
  /**
   * 如果是在第一段后或者最后一段就把两端的值添加上
   */
  invert(y3) {
    const [a4, b] = super.invert(y3);
    const [x05, x12] = this.options.domain;
    return a4 === void 0 && b === void 0 ? [a4, b] : [a4 || x05, b || x12];
  }
  getThresholds() {
    return this.thresholds;
  }
  clone() {
    return new _Quantize(this.options);
  }
};

// node_modules/@antv/scale/esm/utils/create-quartile.js
function quantileSorted2(arr, percentage) {
  const len5 = arr.length;
  if (!len5) {
    return void 0;
  }
  if (len5 < 2) {
    return arr[len5 - 1];
  }
  const i = (len5 - 1) * percentage;
  const i0 = Math.floor(i);
  const v0 = arr[i0];
  const v1 = arr[i0 + 1];
  return v0 + (v1 - v0) * (i - i0);
}
function createQuartile(arr, n, isSorted = false) {
  const numberArr = arr;
  if (!isSorted) {
    numberArr.sort((a4, b) => a4 - b);
  }
  const tmp2 = [];
  for (let i = 1; i < n; i += 1) {
    tmp2.push(quantileSorted2(numberArr, i / n));
  }
  return tmp2;
}

// node_modules/@antv/scale/esm/scales/quantile.js
var Quantile = class _Quantile extends Threshold {
  getDefaultOptions() {
    return {
      domain: [],
      range: [],
      tickCount: 5,
      unknown: void 0,
      tickMethod: wilkinsonExtended
    };
  }
  constructor(options) {
    super(options);
  }
  rescale() {
    const { domain, range: range3 } = this.options;
    this.n = range3.length - 1;
    this.thresholds = createQuartile(domain, this.n + 1, false);
  }
  /**
   * 如果是在第一段后或者最后一段就把两端的值添加上
   */
  invert(y3) {
    const [a4, b] = super.invert(y3);
    const { domain } = this.options;
    const dMin = domain[0];
    const dMax = domain[domain.length - 1];
    return a4 === void 0 && b === void 0 ? [a4, b] : [a4 || dMin, b || dMax];
  }
  getThresholds() {
    return this.thresholds;
  }
  clone() {
    return new _Quantile(this.options);
  }
  getTicks() {
    const { tickCount, domain, tickMethod } = this.options;
    const lastIndex = domain.length - 1;
    const min10 = domain[0];
    const max11 = domain[lastIndex];
    return tickMethod(min10, max11, tickCount);
  }
};

// node_modules/fecha/lib/fecha.js
var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigitsOptional = "\\d\\d?";
var twoDigits = "\\d\\d";
var threeDigits = "\\d{3}";
var fourDigits = "\\d{4}";
var word = "[^\\s]+";
var literal = /\[([^]*?)\]/gm;
function shorten(arr, sLen) {
  var newArr = [];
  for (var i = 0, len5 = arr.length; i < len5; i++) {
    newArr.push(arr[i].substr(0, sLen));
  }
  return newArr;
}
var monthUpdate = function(arrName) {
  return function(v, i18n) {
    var lowerCaseArr = i18n[arrName].map(function(v2) {
      return v2.toLowerCase();
    });
    var index3 = lowerCaseArr.indexOf(v.toLowerCase());
    if (index3 > -1) {
      return index3;
    }
    return null;
  };
};
function assign(origObj) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
    var obj = args_1[_a2];
    for (var key in obj) {
      origObj[key] = obj[key];
    }
  }
  return origObj;
}
var dayNames = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
];
var monthNames = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthNamesShort = shorten(monthNames, 3);
var dayNamesShort = shorten(dayNames, 3);
var defaultI18n = {
  dayNamesShort,
  dayNames,
  monthNamesShort,
  monthNames,
  amPm: ["am", "pm"],
  DoFn: function(dayOfMonth) {
    return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
  }
};
var globalI18n = assign({}, defaultI18n);
var pad = function(val, len5) {
  if (len5 === void 0) {
    len5 = 2;
  }
  val = String(val);
  while (val.length < len5) {
    val = "0" + val;
  }
  return val;
};
var formatFlags = {
  D: function(dateObj) {
    return String(dateObj.getDate());
  },
  DD: function(dateObj) {
    return pad(dateObj.getDate());
  },
  Do: function(dateObj, i18n) {
    return i18n.DoFn(dateObj.getDate());
  },
  d: function(dateObj) {
    return String(dateObj.getDay());
  },
  dd: function(dateObj) {
    return pad(dateObj.getDay());
  },
  ddd: function(dateObj, i18n) {
    return i18n.dayNamesShort[dateObj.getDay()];
  },
  dddd: function(dateObj, i18n) {
    return i18n.dayNames[dateObj.getDay()];
  },
  M: function(dateObj) {
    return String(dateObj.getMonth() + 1);
  },
  MM: function(dateObj) {
    return pad(dateObj.getMonth() + 1);
  },
  MMM: function(dateObj, i18n) {
    return i18n.monthNamesShort[dateObj.getMonth()];
  },
  MMMM: function(dateObj, i18n) {
    return i18n.monthNames[dateObj.getMonth()];
  },
  YY: function(dateObj) {
    return pad(String(dateObj.getFullYear()), 4).substr(2);
  },
  YYYY: function(dateObj) {
    return pad(dateObj.getFullYear(), 4);
  },
  h: function(dateObj) {
    return String(dateObj.getHours() % 12 || 12);
  },
  hh: function(dateObj) {
    return pad(dateObj.getHours() % 12 || 12);
  },
  H: function(dateObj) {
    return String(dateObj.getHours());
  },
  HH: function(dateObj) {
    return pad(dateObj.getHours());
  },
  m: function(dateObj) {
    return String(dateObj.getMinutes());
  },
  mm: function(dateObj) {
    return pad(dateObj.getMinutes());
  },
  s: function(dateObj) {
    return String(dateObj.getSeconds());
  },
  ss: function(dateObj) {
    return pad(dateObj.getSeconds());
  },
  S: function(dateObj) {
    return String(Math.round(dateObj.getMilliseconds() / 100));
  },
  SS: function(dateObj) {
    return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
  },
  SSS: function(dateObj) {
    return pad(dateObj.getMilliseconds(), 3);
  },
  a: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
  },
  A: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
  },
  ZZ: function(dateObj) {
    var offset2 = dateObj.getTimezoneOffset();
    return (offset2 > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset2) / 60) * 100 + Math.abs(offset2) % 60, 4);
  },
  Z: function(dateObj) {
    var offset2 = dateObj.getTimezoneOffset();
    return (offset2 > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset2) / 60), 2) + ":" + pad(Math.abs(offset2) % 60, 2);
  }
};
var monthParse = function(v) {
  return +v - 1;
};
var emptyDigits = [null, twoDigitsOptional];
var emptyWord = [null, word];
var amPm = [
  "isPm",
  word,
  function(v, i18n) {
    var val = v.toLowerCase();
    if (val === i18n.amPm[0]) {
      return 0;
    } else if (val === i18n.amPm[1]) {
      return 1;
    }
    return null;
  }
];
var timezoneOffset = [
  "timezoneOffset",
  "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
  function(v) {
    var parts = (v + "").match(/([+-]|\d\d)/gi);
    if (parts) {
      var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
      return parts[0] === "+" ? minutes : -minutes;
    }
    return 0;
  }
];
var parseFlags = {
  D: ["day", twoDigitsOptional],
  DD: ["day", twoDigits],
  Do: ["day", twoDigitsOptional + word, function(v) {
    return parseInt(v, 10);
  }],
  M: ["month", twoDigitsOptional, monthParse],
  MM: ["month", twoDigits, monthParse],
  YY: [
    "year",
    twoDigits,
    function(v) {
      var now2 = /* @__PURE__ */ new Date();
      var cent = +("" + now2.getFullYear()).substr(0, 2);
      return +("" + (+v > 68 ? cent - 1 : cent) + v);
    }
  ],
  h: ["hour", twoDigitsOptional, void 0, "isPm"],
  hh: ["hour", twoDigits, void 0, "isPm"],
  H: ["hour", twoDigitsOptional],
  HH: ["hour", twoDigits],
  m: ["minute", twoDigitsOptional],
  mm: ["minute", twoDigits],
  s: ["second", twoDigitsOptional],
  ss: ["second", twoDigits],
  YYYY: ["year", fourDigits],
  S: ["millisecond", "\\d", function(v) {
    return +v * 100;
  }],
  SS: ["millisecond", twoDigits, function(v) {
    return +v * 10;
  }],
  SSS: ["millisecond", threeDigits],
  d: emptyDigits,
  dd: emptyDigits,
  ddd: emptyWord,
  dddd: emptyWord,
  MMM: ["month", word, monthUpdate("monthNamesShort")],
  MMMM: ["month", word, monthUpdate("monthNames")],
  a: amPm,
  A: amPm,
  ZZ: timezoneOffset,
  Z: timezoneOffset
};
var globalMasks = {
  default: "ddd MMM DD YYYY HH:mm:ss",
  shortDate: "M/D/YY",
  mediumDate: "MMM D, YYYY",
  longDate: "MMMM D, YYYY",
  fullDate: "dddd, MMMM D, YYYY",
  isoDate: "YYYY-MM-DD",
  isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
  shortTime: "HH:mm",
  mediumTime: "HH:mm:ss",
  longTime: "HH:mm:ss.SSS"
};
var format = function(dateObj, mask, i18n) {
  if (mask === void 0) {
    mask = globalMasks["default"];
  }
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof dateObj === "number") {
    dateObj = new Date(dateObj);
  }
  if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
    throw new Error("Invalid Date pass to format");
  }
  mask = globalMasks[mask] || mask;
  var literals = [];
  mask = mask.replace(literal, function($0, $1) {
    literals.push($1);
    return "@@@";
  });
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  mask = mask.replace(token, function($0) {
    return formatFlags[$0](dateObj, combinedI18nSettings);
  });
  return mask.replace(/@@@/g, function() {
    return literals.shift();
  });
};

// node_modules/@antv/scale/esm/tick-methods/d3-time.js
var d3Time = (min10, max11, count4, interval2, utc) => {
  const r = min10 > max11;
  const lo = r ? max11 : min10;
  const hi = r ? min10 : max11;
  const [tickInterval, step2] = findTickInterval(lo, hi, count4, interval2, utc);
  const ticks2 = tickInterval.range(lo, /* @__PURE__ */ new Date(+hi + 1), step2, true);
  return r ? ticks2.reverse() : ticks2;
};

// node_modules/@antv/scale/esm/scales/time.js
function offset(date) {
  const minuteOffset = date.getTimezoneOffset();
  const d3 = new Date(date);
  d3.setMinutes(d3.getMinutes() + minuteOffset, d3.getSeconds(), d3.getMilliseconds());
  return d3;
}
var Time = class _Time extends Continuous {
  getDefaultOptions() {
    return {
      domain: [new Date(2e3, 0, 1), new Date(2e3, 0, 2)],
      range: [0, 1],
      nice: false,
      tickCount: 5,
      tickInterval: void 0,
      unknown: void 0,
      clamp: false,
      tickMethod: d3Time,
      interpolate: createInterpolateNumber,
      mask: void 0,
      utc: false
    };
  }
  chooseTransforms() {
    const transform2 = (x3) => +x3;
    const untransform = (x3) => new Date(x3);
    return [transform2, untransform];
  }
  chooseNice() {
    return d3TimeNice;
  }
  getTickMethodOptions() {
    const { domain, tickCount, tickInterval, utc } = this.options;
    const min10 = domain[0];
    const max11 = domain[domain.length - 1];
    return [min10, max11, tickCount, tickInterval, utc];
  }
  getFormatter() {
    const { mask, utc } = this.options;
    const maskMap = utc ? utcIntervalMap : localIntervalMap;
    const time = utc ? offset : identity_default;
    return (d3) => format(time(d3), mask || chooseNiceTimeMask(d3, maskMap));
  }
  clone() {
    return new _Time(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/sequential.js
var __decorate = function(decorators, target, key, desc) {
  var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d3 = decorators[i])
        r = (c5 < 3 ? d3(r) : c5 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c5 > 3 && r && Object.defineProperty(target, key, r), r;
};
var Sequential_1;
function rangeOf(interpolator) {
  return [interpolator(0), interpolator(1)];
}
var normalizeDomain = (domain) => {
  const [d0, d1] = domain;
  const normalize10 = compose2(createInterpolateNumber(0, 1), createNormalize(d0, d1));
  return normalize10;
};
var Sequential = Sequential_1 = class Sequential2 extends Linear {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolator: identity_default,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  constructor(options) {
    super(options);
  }
  clone() {
    return new Sequential_1(this.options);
  }
};
Sequential = Sequential_1 = __decorate([
  interpolatize(rangeOf, normalizeDomain)
], Sequential);

// node_modules/@antv/scale/esm/scales/diverging.js
var __decorate2 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d3 = decorators[i])
        r = (c5 < 3 ? d3(r) : c5 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c5 > 3 && r && Object.defineProperty(target, key, r), r;
};
var Diverging_1;
function rangeOf2(interpolator) {
  return [interpolator(0), interpolator(0.5), interpolator(1)];
}
var normalizeDomain2 = (domain) => {
  const [d0, d1, d22] = domain;
  const normalizeLeft = compose2(createInterpolateNumber(0, 0.5), createNormalize(d0, d1));
  const normalizeRight = compose2(createInterpolateNumber(0.5, 1), createNormalize(d1, d22));
  return (x3) => {
    if (d0 > d22) {
      return x3 < d1 ? normalizeRight(x3) : normalizeLeft(x3);
    } else {
      return x3 < d1 ? normalizeLeft(x3) : normalizeRight(x3);
    }
  };
};
var Diverging = Diverging_1 = class Diverging2 extends Linear {
  getDefaultOptions() {
    return {
      domain: [0, 0.5, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolator: identity_default,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  constructor(options) {
    super(options);
  }
  clone() {
    return new Diverging_1(this.options);
  }
};
Diverging = Diverging_1 = __decorate2([
  interpolatize(rangeOf2, normalizeDomain2)
], Diverging);

// node_modules/@antv/g2/esm/transform/jitter.js
function rangeOf3(value2, scaleOptions, padding) {
  if (value2 === null)
    return [-0.5, 0.5];
  const domain = domainOf(value2, scaleOptions);
  const scale11 = new Band({ domain, range: [0, 1], padding });
  const step2 = scale11.getBandWidth();
  return [-step2 / 2, step2 / 2];
}
function interpolate(t, a4, b) {
  return a4 * (1 - t) + b * t;
}
var Jitter = (options = {}) => {
  const { padding = 0, paddingX = padding, paddingY = padding, random: random5 = Math.random } = options;
  return (I, mark2) => {
    const { encode, scale: scale11 } = mark2;
    const { x: scaleX2, y: scaleY2 } = scale11;
    const [X] = columnOf(encode, "x");
    const [Y] = columnOf(encode, "y");
    const rangeX = rangeOf3(X, scaleX2, paddingX);
    const rangeY = rangeOf3(Y, scaleY2, paddingY);
    const DY = I.map(() => interpolate(random5(), ...rangeY));
    const DX = I.map(() => interpolate(random5(), ...rangeX));
    return [
      I,
      deep_mix_default({
        scale: {
          x: { padding: 0.5 },
          y: { padding: 0.5 }
        }
      }, mark2, {
        encode: { dy: column(DY), dx: column(DX) }
      })
    ];
  };
};
Jitter.props = {};

// node_modules/@antv/g2/esm/transform/jitterX.js
var JitterX = (options = {}) => {
  const { padding = 0, random: random5 = Math.random } = options;
  return (I, mark2) => {
    const { encode, scale: scale11 } = mark2;
    const { x: scaleX2 } = scale11;
    const [X] = columnOf(encode, "x");
    const rangeX = rangeOf3(X, scaleX2, padding);
    const DX = I.map(() => interpolate(random5(), ...rangeX));
    return [
      I,
      deep_mix_default({ scale: { x: { padding: 0.5 } } }, mark2, {
        encode: { dx: column(DX) }
      })
    ];
  };
};
JitterX.props = {};

// node_modules/@antv/g2/esm/transform/jitterY.js
var JitterY = (options = {}) => {
  const { padding = 0, random: random5 = Math.random } = options;
  return (I, mark2) => {
    const { encode, scale: scale11 } = mark2;
    const { y: scaleY2 } = scale11;
    const [Y] = columnOf(encode, "y");
    const rangeY = rangeOf3(Y, scaleY2, padding);
    const DY = I.map(() => interpolate(random5(), ...rangeY));
    return [
      I,
      deep_mix_default({ scale: { y: { padding: 0.5 } } }, mark2, {
        encode: { dy: column(DY) }
      })
    ];
  };
};
JitterY.props = {};

// node_modules/@antv/g2/esm/transform/symmetryY.js
var __rest6 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var SymmetryY = (options = {}) => {
  const { groupBy: groupBy3 = "x" } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const { x: x3 } = encode, rest = __rest6(encode, ["x"]);
    const Yn2 = Object.entries(rest).filter(([k2]) => k2.startsWith("y")).map(([k2]) => [k2, columnOf(encode, k2)[0]]);
    const newYn = Yn2.map(([k2]) => [k2, new Array(I.length)]);
    const groups2 = createGroups(groupBy3, I, mark2);
    const MY = new Array(groups2.length);
    for (let i = 0; i < groups2.length; i++) {
      const I2 = groups2[i];
      const Y = I2.flatMap((i2) => Yn2.map(([, V]) => +V[i2]));
      const [minY, maxY2] = extent(Y);
      MY[i] = (minY + maxY2) / 2;
    }
    const maxMiddleY = Math.max(...MY);
    for (let m3 = 0; m3 < groups2.length; m3++) {
      const offset2 = maxMiddleY - MY[m3];
      const I2 = groups2[m3];
      for (const i of I2) {
        for (let j = 0; j < Yn2.length; j++) {
          const [, V] = Yn2[j];
          const [, newV] = newYn[j];
          newV[i] = +V[i] + offset2;
        }
      }
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: Object.fromEntries(newYn.map(([k2, v]) => [k2, column(v, columnOf(encode, k2)[1])]))
      })
    ];
  };
};
SymmetryY.props = {};

// node_modules/@antv/g2/esm/transform/diffY.js
var DiffY = (options = {}) => {
  const { groupBy: groupBy3 = "x", series = true } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const [Y] = columnOf(encode, "y");
    const [_2, fy1] = columnOf(encode, "y1");
    const [S] = series ? maybeColumnOf(encode, "series", "color") : columnOf(encode, "color");
    const groups2 = createGroups(groupBy3, I, mark2);
    const newY1 = new Array(I.length);
    for (const G of groups2) {
      const YG = G.map((i) => +Y[i]);
      for (let idx = 0; idx < G.length; idx++) {
        const i = G[idx];
        const max11 = Math.max(...YG.filter((_3, _i) => _i !== idx));
        newY1[i] = +Y[i] > max11 ? max11 : Y[i];
      }
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: {
          y1: column(newY1, fy1)
        }
      })
    ];
  };
};
DiffY.props = {};

// node_modules/@antv/g2/esm/transform/select.js
function first(I, V) {
  return [I[0]];
}
function last2(I, V) {
  const i = I.length - 1;
  return [I[i]];
}
function max6(I, V) {
  const i = maxIndex(I, (i2) => V[i2]);
  return [I[i]];
}
function min5(I, V) {
  const i = minIndex(I, (i2) => V[i2]);
  return [I[i]];
}
function normalizeSelector(selector) {
  if (typeof selector === "function")
    return selector;
  const registry = { first, last: last2, max: max6, min: min5 };
  return registry[selector] || first;
}
var Select = (options = {}) => {
  const { groupBy: groupBy3 = "series", channel, selector } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const groups2 = createGroups(groupBy3, I, mark2);
    const [V] = columnOf(encode, channel);
    const selectFunction = normalizeSelector(selector);
    return [groups2.flatMap((GI) => selectFunction(GI, V)), mark2];
  };
};
Select.props = {};

// node_modules/@antv/g2/esm/transform/selectX.js
var __rest7 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var SelectX = (options = {}) => {
  const { selector } = options, rest = __rest7(options, ["selector"]);
  return Select(Object.assign({ channel: "x", selector }, rest));
};
SelectX.props = {};

// node_modules/@antv/g2/esm/transform/selectY.js
var __rest8 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var SelectY = (options = {}) => {
  const { selector } = options, rest = __rest8(options, ["selector"]);
  return Select(Object.assign({ channel: "y", selector }, rest));
};
SelectY.props = {};

// node_modules/@antv/g2/esm/transform/groupN.js
var __rest9 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function builtinFormatter(summary) {
  return (d3) => d3 === null ? summary : `${summary} of ${d3}`;
}
function normalizeReducer(reducer) {
  if (typeof reducer === "function")
    return [reducer, null];
  const registry = { mean: mean2, max: max7, count: count2, first: first2, last: last3, sum: sum2, min: min6, median: median2 };
  const reducerFunction = registry[reducer];
  if (!reducerFunction)
    throw new Error(`Unknown reducer: ${reducer}.`);
  return reducerFunction();
}
function mean2() {
  const reducer = (I, V) => mean(I, (i) => +V[i]);
  const formatter2 = builtinFormatter("mean");
  return [reducer, formatter2];
}
function median2() {
  const reducer = (I, V) => median(I, (i) => +V[i]);
  const formatter2 = builtinFormatter("median");
  return [reducer, formatter2];
}
function max7() {
  const reducer = (I, V) => max5(I, (i) => +V[i]);
  const formatter2 = builtinFormatter("max");
  return [reducer, formatter2];
}
function min6() {
  const reducer = (I, V) => min4(I, (i) => +V[i]);
  const formatter2 = builtinFormatter("min");
  return [reducer, formatter2];
}
function count2() {
  const reducer = (I, V) => I.length;
  const formatter2 = builtinFormatter("count");
  return [reducer, formatter2];
}
function sum2() {
  const reducer = (I, V) => sum(I, (i) => +V[i]);
  const formatter2 = builtinFormatter("sum");
  return [reducer, formatter2];
}
function first2() {
  const reducer = (I, V) => V[I[0]];
  const formatter2 = builtinFormatter("first");
  return [reducer, formatter2];
}
function last3() {
  const reducer = (I, V) => V[I[I.length - 1]];
  const formatter2 = builtinFormatter("last");
  return [reducer, formatter2];
}
var GroupN = (options = {}) => {
  const { groupBy: groupBy3 } = options, rest = __rest9(options, ["groupBy"]);
  return (I, mark2) => {
    const { data: data2, encode } = mark2;
    const groups2 = groupBy3(I, mark2);
    if (!groups2)
      return [I, mark2];
    const maybeFrom = (field3, reducer) => {
      if (field3)
        return field3;
      const { from } = reducer;
      if (!from)
        return field3;
      const [, field1] = columnOf(encode, from);
      return field1;
    };
    const outputs = Object.entries(rest).map(([channel, reducer]) => {
      const [reducerFunction, formatter2] = normalizeReducer(reducer);
      const [V, field3] = columnOf(encode, channel);
      const field1 = maybeFrom(field3, reducer);
      const RV = groups2.map((I2) => reducerFunction(I2, V !== null && V !== void 0 ? V : data2));
      return [
        channel,
        Object.assign(Object.assign({}, nonConstantColumn(RV, (formatter2 === null || formatter2 === void 0 ? void 0 : formatter2(field1)) || field1)), { aggregate: true })
      ];
    });
    const reducedColumns = Object.keys(encode).map((key) => {
      const [V, fv] = columnOf(encode, key);
      const GV = groups2.map((I2) => V[I2[0]]);
      return [key, column(GV, fv)];
    });
    const GD = groups2.map((I2) => data2[I2[0]]);
    const GI = indexOf3(groups2);
    return [
      GI,
      deep_mix_default({}, mark2, {
        data: GD,
        encode: Object.fromEntries([...reducedColumns, ...outputs])
      })
    ];
  };
};
GroupN.props = {};

// node_modules/@antv/g2/esm/transform/group.js
var __rest10 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var Group = (options = {}) => {
  const { channels = ["x", "y"] } = options, rest = __rest10(options, ["channels"]);
  const groupBy3 = (I, mark2) => createGroups(channels, I, mark2);
  return GroupN(Object.assign(Object.assign({}, rest), { groupBy: groupBy3 }));
};
Group.props = {};

// node_modules/@antv/g2/esm/transform/groupX.js
var GroupX = (options = {}) => {
  return Group(Object.assign(Object.assign({}, options), { channels: ["x", "color", "series"] }));
};
GroupX.props = {};

// node_modules/@antv/g2/esm/transform/groupY.js
var GroupY = (options = {}) => {
  return Group(Object.assign(Object.assign({}, options), { channels: ["y", "color", "series"] }));
};
GroupY.props = {};

// node_modules/@antv/g2/esm/transform/groupColor.js
var GroupColor = (options = {}) => {
  return Group(Object.assign(Object.assign({}, options), { channels: ["color"] }));
};
GroupColor.props = {};

// node_modules/@antv/g2/esm/transform/sort.js
var __rest11 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function createReducer(channel, options, encode) {
  const { by = channel, reducer = "max" } = options;
  const [V] = columnOf(encode, by);
  if (typeof reducer === "function")
    return (GI) => reducer(GI, V);
  if (reducer === "max")
    return (GI) => max5(GI, (i) => +V[i]);
  if (reducer === "min")
    return (GI) => min4(GI, (i) => +V[i]);
  if (reducer === "sum")
    return (GI) => sum(GI, (i) => +V[i]);
  if (reducer === "median")
    return (GI) => median(GI, (i) => +V[i]);
  if (reducer === "mean")
    return (GI) => mean(GI, (i) => +V[i]);
  if (reducer === "first")
    return (GI) => V[GI[0]];
  if (reducer === "last")
    return (GI) => V[GI[GI.length - 1]];
  throw new Error(`Unknown reducer: ${reducer}`);
}
function sortQuantitative(I, mark2, options) {
  const { reverse: reverse2, channel } = options;
  const { encode } = mark2;
  const [V] = columnOf(encode, channel);
  const sortedI = sort(I, (i) => V[i]);
  if (reverse2)
    sortedI.reverse();
  return [sortedI, mark2];
}
function filterIndex(I, values4, specifiedDomain) {
  if (!Array.isArray(specifiedDomain))
    return I;
  const domain = new Set(specifiedDomain);
  return I.filter((i) => domain.has(values4[i]));
}
function sortOrdinal(I, mark2, options) {
  var _a2;
  const { reverse: reverse2, slice: slice3, channel } = options, rest = __rest11(options, ["reverse", "slice", "channel"]);
  const { encode, scale: scale11 = {} } = mark2;
  const domain = (_a2 = scale11[channel]) === null || _a2 === void 0 ? void 0 : _a2.domain;
  const [T] = columnOf(encode, channel);
  const normalizeReducer2 = createReducer(channel, rest, encode);
  const SI = filterIndex(I, T, domain);
  const sortedDomain = groupSort(SI, normalizeReducer2, (i) => T[i]);
  if (reverse2)
    sortedDomain.reverse();
  const s3 = typeof slice3 === "number" ? [0, slice3] : slice3;
  const slicedDomain = slice3 ? sortedDomain.slice(...s3) : sortedDomain;
  return [
    I,
    deep_mix_default(mark2, {
      scale: {
        [channel]: {
          domain: slicedDomain
        }
      }
    })
  ];
}
var Sort = (options = {}) => {
  const { reverse: reverse2 = false, slice: slice3, channel, ordinal = true } = options, rest = __rest11(options, ["reverse", "slice", "channel", "ordinal"]);
  return (I, mark2) => {
    if (!ordinal) {
      return sortQuantitative(I, mark2, Object.assign({
        reverse: reverse2,
        slice: slice3,
        channel
      }, rest));
    }
    return sortOrdinal(I, mark2, Object.assign({ reverse: reverse2, slice: slice3, channel }, rest));
  };
};
Sort.props = {};

// node_modules/@antv/g2/esm/transform/sortX.js
var SortX = (options = {}) => {
  return Sort(Object.assign(Object.assign({}, options), { channel: "x" }));
};
SortX.props = {};

// node_modules/@antv/g2/esm/transform/sortColor.js
var SortColor = (options = {}) => {
  return Sort(Object.assign(Object.assign({}, options), { channel: "color" }));
};
SortColor.props = {};

// node_modules/@antv/g2/esm/transform/sortY.js
var SortY = (options = {}) => {
  return Sort(Object.assign(Object.assign({}, options), { channel: "y" }));
};
SortY.props = {};

// node_modules/@antv/g2/esm/transform/flexX.js
function valueOf(data2, field3) {
  if (typeof field3 === "string")
    return data2.map((d3) => d3[field3]);
  return data2.map(field3);
}
function createReducer2(reducer, V) {
  if (typeof reducer === "function")
    return (GI) => reducer(GI, V);
  if (reducer === "sum")
    return (GI) => sum(GI, (i) => +V[i]);
  throw new Error(`Unknown reducer: ${reducer}`);
}
var FlexX = (options = {}) => {
  const { field: field3, channel = "y", reducer = "sum" } = options;
  return (I, mark2) => {
    const { data: data2, encode } = mark2;
    const [x3] = columnOf(encode, "x");
    const V = field3 ? valueOf(data2, field3) : columnOf(encode, channel)[0];
    const reducerFunction = createReducer2(reducer, V);
    const flex2 = rollups(I, reducerFunction, (i) => x3[i]).map((d3) => d3[1]);
    return [I, deep_mix_default({}, mark2, { scale: { x: { flex: flex2 } } })];
  };
};
FlexX.props = {};

// node_modules/@antv/g2/esm/utils/vector.js
function sub6([x12, y12], [x22, y22]) {
  return [x12 - x22, y12 - y22];
}
function add7([x12, y12], [x22, y22]) {
  return [x12 + x22, y12 + y22];
}
function dist4([x05, y05], [x12, y12]) {
  return Math.sqrt(Math.pow(x05 - x12, 2) + Math.pow(y05 - y12, 2));
}
function angle3([x3, y3]) {
  return Math.atan2(y3, x3);
}
function angleWithQuadrant([x3, y3]) {
  return angle3([x3, y3]) + Math.PI / 2;
}
function angleBetween2(v0, v1) {
  const a0 = angle3(v0);
  const a1 = angle3(v1);
  if (a0 < a1)
    return a1 - a0;
  return Math.PI * 2 - (a0 - a1);
}
function calcBBox(points) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY2 = -Infinity;
  for (const [x3, y3] of points) {
    minX = Math.min(x3, minX);
    maxX = Math.max(x3, maxX);
    minY = Math.min(y3, minY);
    maxY2 = Math.max(y3, maxY2);
  }
  const width = maxX - minX;
  const height = maxY2 - minY;
  return [minX, minY, width, height];
}
function mid([x12, y12], [x22, y22]) {
  return [(x12 + x22) / 2, (y12 + y22) / 2];
}

// node_modules/@antv/g2/esm/transform/pack.js
function pack(options) {
  const { padding = 0, direction: direction3 = "col" } = options;
  return (P, count4, layout) => {
    const pcount = P.length;
    if (pcount === 0)
      return [];
    const { innerWidth, innerHeight } = layout;
    const aspect = innerHeight / innerWidth;
    let col = Math.ceil(Math.sqrt(count4 / aspect));
    let size3 = innerWidth / col;
    let row2 = Math.ceil(count4 / col);
    let h0 = row2 * size3;
    while (h0 > innerHeight) {
      col = col + 1;
      size3 = innerWidth / col;
      row2 = Math.ceil(count4 / col);
      h0 = row2 * size3;
    }
    const space = innerHeight - row2 * size3;
    const intervalY = row2 <= 1 ? 0 : space / (row2 - 1);
    const [offsetX, offsetY] = row2 <= 1 ? [
      (innerWidth - pcount * size3) / (pcount - 1),
      (innerHeight - size3) / 2
    ] : [0, 0];
    return P.map((points, m3) => {
      const [x3, y3, width, height] = calcBBox(points);
      const i = direction3 === "col" ? m3 % col : Math.floor(m3 / row2);
      const j = direction3 === "col" ? Math.floor(m3 / col) : m3 % row2;
      const newX = i * size3;
      const newY = (row2 - j - 1) * size3 + space;
      const sx = (size3 - padding) / width;
      const sy = (size3 - padding) / height;
      const tx = newX - x3 + offsetX * i + 1 / 2 * padding;
      const ty = newY - y3 - intervalY * j - offsetY + 1 / 2 * padding;
      return `translate(${tx}, ${ty}) scale(${sx}, ${sy})`;
    });
  };
}
var Pack = (options) => {
  return (I, mark2) => {
    return [I, deep_mix_default({}, mark2, { modifier: pack(options), axis: false })];
  };
};
Pack.props = {};

// node_modules/@antv/g2/esm/transform/bin.js
var __rest12 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var THRESHOLD = "thresholds";
function thresholdAuto(values4) {
  const [min10, max11] = extent(values4);
  return Math.min(200, thresholdScott(values4, min10, max11));
}
var Bin = (options = {}) => {
  const { groupChannels = ["color"], binChannels = ["x", "y"] } = options, rest = __rest12(options, ["groupChannels", "binChannels"]);
  const channelIndexKey = {};
  const groupBy3 = (I, mark2) => {
    const { encode } = mark2;
    const binValues = binChannels.map((channel) => {
      const [V] = columnOf(encode, channel);
      return V;
    });
    const thresholds = subObject(rest, THRESHOLD);
    const DI = I.filter((i) => binValues.every((V) => defined(V[i])));
    const groupKeys = [
      // For discrete channels, use value as group key.
      ...groupChannels.map((d3) => {
        const [V] = columnOf(encode, d3);
        return V;
      }).filter(defined).map((V) => (i) => V[i]),
      // For quantitative channels, use extent of bin as group key.
      ...binChannels.map((d3, i) => {
        const V = binValues[i];
        const t = thresholds[d3] || thresholdAuto(V);
        const bins = bin().thresholds(t).value((i2) => +V[i2])(DI);
        const indexKey = new Map(bins.flatMap((bin2) => {
          const { x0: x05, x1: x12 } = bin2;
          const key2 = `${x05},${x12}`;
          return bin2.map((i2) => [i2, key2]);
        }));
        channelIndexKey[d3] = indexKey;
        return (i2) => indexKey.get(i2);
      })
    ];
    const key = (i) => groupKeys.map((key2) => key2(i)).join("-");
    return Array.from(group(DI, key).values());
  };
  return GroupN(Object.assign(Object.assign(Object.assign({}, Object.fromEntries(Object.entries(rest).filter(([k2]) => !k2.startsWith(THRESHOLD)))), Object.fromEntries(binChannels.flatMap((channel) => {
    const start = ([i]) => +channelIndexKey[channel].get(i).split(",")[0];
    const end = ([i]) => +channelIndexKey[channel].get(i).split(",")[1];
    end.from = channel;
    return [
      [channel, start],
      [`${channel}1`, end]
    ];
  }))), { groupBy: groupBy3 }));
};
Bin.props = {};

// node_modules/@antv/g2/esm/transform/binX.js
var BinX = (options = {}) => {
  const { thresholds } = options;
  return Bin(Object.assign(Object.assign({}, options), { thresholdsX: thresholds, groupChannels: ["color"], binChannels: ["x"] }));
};
BinX.props = {};

// node_modules/@antv/g2/esm/transform/utils/lttb.js
function lttb(I, X, Y, thresholds) {
  const length5 = I.length;
  if (thresholds >= length5 || thresholds === 0) {
    return I;
  }
  const x3 = (i) => X[I[i]] * 1;
  const y3 = (i) => Y[I[i]] * 1;
  const sampled = [];
  const every2 = (length5 - 2) / (thresholds - 2);
  let a4 = 0;
  let maxArea;
  let area2;
  let nextA;
  sampled.push(a4);
  for (let i = 0; i < thresholds - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let start = Math.floor((i + 1) * every2) + 1;
    let end = Math.floor((i + 2) * every2) + 1;
    end = Math.min(end, length5);
    const size3 = end - start;
    for (; start < end; start++) {
      avgX += x3(start);
      avgY += y3(start);
    }
    avgX /= size3;
    avgY /= size3;
    let frameStart = Math.floor((i + 0) * every2) + 1;
    const frameEnd = Math.floor((i + 1) * every2) + 1;
    const pointA = [x3(a4), y3(a4)];
    maxArea = area2 = -1;
    for (; frameStart < frameEnd; frameStart++) {
      area2 = Math.abs((pointA[0] - avgX) * (x3(frameStart) - pointA[1]) - (pointA[0] - y3(frameStart)) * (avgY - pointA[0])) * 0.5;
      if (area2 > maxArea) {
        maxArea = area2;
        nextA = frameStart;
      }
    }
    sampled.push(nextA);
    a4 = nextA;
  }
  sampled.push(length5 - 1);
  return sampled.map((a5) => I[a5]);
}

// node_modules/@antv/g2/esm/transform/sample.js
function normalizeSample(strategy) {
  if (typeof strategy === "function")
    return strategy;
  if (strategy === "lttb")
    return lttb;
  const strategies = {
    first: (f) => [f[0]],
    last: (f) => [f[f.length - 1]],
    min: (f, X, Y) => [
      f[minIndex(f, (i) => Y[i])]
    ],
    max: (f, X, Y) => [
      f[maxIndex(f, (i) => Y[i])]
    ],
    median: (f, X, Y) => [
      f[medianIndex(f, (i) => Y[i])]
    ]
  };
  const sampleFunction = strategies[strategy] || strategies.median;
  return (I, X, Y, thresholds) => {
    const frameSize = Math.max(1, Math.floor(I.length / thresholds));
    const frames = getFrames(I, frameSize);
    return frames.flatMap((frame2) => sampleFunction(frame2, X, Y));
  };
}
function getFrames(I, frameSize) {
  const size3 = I.length;
  const frames = [];
  let i = 0;
  while (i < size3) {
    frames.push(I.slice(i, i += frameSize));
  }
  return frames;
}
var Sample = (options = {}) => {
  const { strategy = "median", thresholds = 2e3, groupBy: groupBy3 = ["series", "color"] } = options;
  const sampleFunction = normalizeSample(strategy);
  return (I, mark2) => {
    const { encode } = mark2;
    const groups2 = createGroups(groupBy3, I, mark2);
    const [X] = columnOf(encode, "x");
    const [Y] = columnOf(encode, "y");
    return [
      groups2.flatMap((g) => sampleFunction(g, X, Y, thresholds)),
      mark2
    ];
  };
};
Sample.props = {};

// node_modules/@antv/g2/esm/transform/filter.js
function normalizeValue(value2) {
  if (typeof value2 === "object")
    return [value2.value, value2.ordinal];
  else
    return [value2, true];
}
function filterWhenNoElements(mark2) {
  var _a2;
  const { encode } = mark2;
  const noElementMark = Object.assign(Object.assign({}, mark2), { encode: Object.assign(Object.assign({}, mark2.encode), { y: Object.assign(Object.assign({}, mark2.encode.y), { value: [] }) }) });
  const targetField = (_a2 = encode === null || encode === void 0 ? void 0 : encode.color) === null || _a2 === void 0 ? void 0 : _a2.field;
  if (!encode || !targetField) {
    return noElementMark;
  }
  let filterObject;
  for (const [key, v] of Object.entries(encode)) {
    if ((key === "x" || key === "y") && v.field === targetField) {
      filterObject = Object.assign(Object.assign({}, filterObject), { [key]: Object.assign(Object.assign({}, v), { value: [] }) });
    }
  }
  if (!filterObject) {
    return noElementMark;
  }
  return Object.assign(Object.assign({}, mark2), { encode: Object.assign(Object.assign({}, mark2.encode), filterObject) });
}
var Filter = (options = {}) => {
  return (I, mark2) => {
    const { encode, data: data2 } = mark2;
    const filters = Object.entries(options).map(([key, v]) => {
      const [V] = columnOf(encode, key);
      if (!V)
        return null;
      const [value2, ordinal = true] = normalizeValue(v);
      if (typeof value2 === "function")
        return (i) => value2(V[i]);
      if (ordinal) {
        const expectedValues = Array.isArray(value2) ? value2 : [value2];
        if (expectedValues.length === 0)
          return null;
        return (i) => expectedValues.includes(V[i]);
      } else {
        const [start, end] = value2;
        return (i) => V[i] >= start && V[i] <= end;
      }
    }).filter(defined);
    const totalFilter = (i) => filters.every((f) => f(i));
    const FI = I.filter(totalFilter);
    const newIndex = FI.map((_2, i) => i);
    if (filters.length === 0) {
      const targetMark = filterWhenNoElements(mark2);
      return [I, targetMark];
    }
    const newEncodes = Object.entries(encode).map(([key, encode2]) => {
      return [
        key,
        Object.assign(Object.assign({}, encode2), { value: newIndex.map((i) => encode2.value[FI[i]]).filter((v) => v !== void 0) })
      ];
    });
    return [
      newIndex,
      deep_mix_default({}, mark2, {
        encode: Object.fromEntries(newEncodes),
        // Filter data for tooltip item.
        data: FI.map((i) => data2[i])
      })
    ];
  };
};
Filter.props = {};

// node_modules/d3-shape/src/constant.js
function constant_default(x3) {
  return function constant4() {
    return x3;
  };
}

// node_modules/d3-shape/src/math.js
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max8 = Math.max;
var min7 = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;
function acos(x3) {
  return x3 > 1 ? 0 : x3 < -1 ? pi : Math.acos(x3);
}
function asin(x3) {
  return x3 >= 1 ? halfPi : x3 <= -1 ? -halfPi : Math.asin(x3);
}

// node_modules/d3-path/src/path.js
var pi2 = Math.PI;
var tau2 = 2 * pi2;
var epsilon2 = 1e-6;
var tauEpsilon = tau2 - epsilon2;
function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d3 = Math.floor(digits);
  if (!(d3 >= 0))
    throw new Error(`invalid digits: ${digits}`);
  if (d3 > 15)
    return append;
  const k2 = 10 ** d3;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x3, y3) {
    this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x3, y3) {
    this._append`L${this._x1 = +x3},${this._y1 = +y3}`;
  }
  quadraticCurveTo(x12, y12, x3, y3) {
    this._append`Q${+x12},${+y12},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  bezierCurveTo(x12, y12, x22, y22, x3, y3) {
    this._append`C${+x12},${+y12},${+x22},${+y22},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x12, y12, x22, y22, r) {
    x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r = +r;
    if (r < 0)
      throw new Error(`negative radius: ${r}`);
    let x05 = this._x1, y05 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x05 - x12, y01 = y05 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x12},${this._y1 = y12}`;
    } else if (!(l01_2 > epsilon2))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r) {
      this._append`L${this._x1 = x12},${this._y1 = y12}`;
    } else {
      let x20 = x22 - x05, y20 = y22 - y05, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon2) {
        this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
      }
      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
    }
  }
  arc(x3, y3, r, a0, a1, ccw) {
    x3 = +x3, y3 = +y3, r = +r, ccw = !!ccw;
    if (r < 0)
      throw new Error(`negative radius: ${r}`);
    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x05 = x3 + dx, y05 = y3 + dy, cw2 = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x05},${y05}`;
    } else if (Math.abs(this._x1 - x05) > epsilon2 || Math.abs(this._y1 - y05) > epsilon2) {
      this._append`L${x05},${y05}`;
    }
    if (!r)
      return;
    if (da < 0)
      da = da % tau2 + tau2;
    if (da > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw2},${x3 - dx},${y3 - dy}A${r},${r},0,1,${cw2},${this._x1 = x05},${this._y1 = y05}`;
    } else if (da > epsilon2) {
      this._append`A${r},${r},0,${+(da >= pi2)},${cw2},${this._x1 = x3 + r * Math.cos(a1)},${this._y1 = y3 + r * Math.sin(a1)}`;
    }
  }
  rect(x3, y3, w, h) {
    this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;

// node_modules/d3-shape/src/path.js
function withPath(shape23) {
  let digits = 3;
  shape23.digits = function(_2) {
    if (!arguments.length)
      return digits;
    if (_2 == null) {
      digits = null;
    } else {
      const d3 = Math.floor(_2);
      if (!(d3 >= 0))
        throw new RangeError(`invalid digits: ${_2}`);
      digits = d3;
    }
    return shape23;
  };
  return () => new Path(digits);
}

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d3) {
  return d3.innerRadius;
}
function arcOuterRadius(d3) {
  return d3.outerRadius;
}
function arcStartAngle(d3) {
  return d3.startAngle;
}
function arcEndAngle(d3) {
  return d3.endAngle;
}
function arcPadAngle(d3) {
  return d3 && d3.padAngle;
}
function intersect(x05, y05, x12, y12, x22, y22, x3, y3) {
  var x10 = x12 - x05, y10 = y12 - y05, x32 = x3 - x22, y32 = y3 - y22, t = y32 * x10 - x32 * y10;
  if (t * t < epsilon)
    return;
  t = (x32 * (y05 - y22) - y32 * (x05 - x22)) / t;
  return [x05 + t * x10, y05 + t * y10];
}
function cornerTangents(x05, y05, x12, y12, r1, rc, cw2) {
  var x01 = x05 - x12, y01 = y05 - y12, lo = (cw2 ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x05 + ox, y11 = y05 + oy, x10 = x12 + ox, y10 = y12 + oy, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d22 = dx * dx + dy * dy, r = r1 - rc, D2 = x11 * y10 - x10 * y11, d3 = (dy < 0 ? -1 : 1) * sqrt(max8(0, r * r * d22 - D2 * D2)), cx0 = (D2 * dy - dx * d3) / d22, cy0 = (-D2 * dx - dy * d3) / d22, cx1 = (D2 * dy + dx * d3) / d22, cy1 = (-D2 * dx + dy * d3) / d22, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc);
  function arc() {
    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw2 = a1 > a0;
    if (!context)
      context = buffer = path2();
    if (r1 < r0)
      r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon))
      context.moveTo(0, 0);
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw2);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw2);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min7(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon)
          p0 *= cw2 ? 1 : -1, a00 += p0, a10 -= p0;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon)
          p1 *= cw2 ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x004 = r0 * cos(a00), y004 = r0 * sin(a00), oc;
        if (da < pi) {
          if (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min7(rc, (r0 - lc) / (kc - 1));
            rc1 = min7(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon))
        context.moveTo(x01, y01);
      else if (rc1 > epsilon) {
        t02 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw2);
        t12 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw2);
        context.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc1 < rc)
          context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw2);
        else {
          context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw2);
          context.arc(0, 0, r1, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), !cw2);
          context.arc(t12.cx, t12.cy, rc1, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw2);
        }
      } else
        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw2);
      if (!(r0 > epsilon) || !(da0 > epsilon))
        context.lineTo(x10, y10);
      else if (rc0 > epsilon) {
        t02 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw2);
        t12 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw2);
        context.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc0 < rc)
          context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw2);
        else {
          context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw2);
          context.arc(0, 0, r0, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), cw2);
          context.arc(t12.cx, t12.cy, rc0, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw2);
        }
      } else
        context.arc(0, 0, r0, a10, a00, cw2);
    }
    context.closePath();
    if (buffer)
      return context = null, buffer + "" || null;
  }
  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a4 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a4) * r, sin(a4) * r];
  };
  arc.innerRadius = function(_2) {
    return arguments.length ? (innerRadius = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : innerRadius;
  };
  arc.outerRadius = function(_2) {
    return arguments.length ? (outerRadius = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : outerRadius;
  };
  arc.cornerRadius = function(_2) {
    return arguments.length ? (cornerRadius = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : cornerRadius;
  };
  arc.padRadius = function(_2) {
    return arguments.length ? (padRadius = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default(+_2), arc) : padRadius;
  };
  arc.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : startAngle;
  };
  arc.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : endAngle;
  };
  arc.padAngle = function(_2) {
    return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : padAngle;
  };
  arc.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, arc) : context;
  };
  return arc;
}

// node_modules/d3-shape/src/array.js
var slice2 = Array.prototype.slice;
function array_default(x3) {
  return typeof x3 === "object" && "length" in x3 ? x3 : Array.from(x3);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear2(context) {
  this._context = context;
}
Linear2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x3, y3);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear2(context);
}

// node_modules/d3-shape/src/point.js
function x(p2) {
  return p2[0];
}
function y(p2) {
  return p2[1];
}

// node_modules/d3-shape/src/line.js
function line_default(x3, y3) {
  var defined4 = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(line4);
  x3 = typeof x3 === "function" ? x3 : x3 === void 0 ? x : constant_default(x3);
  y3 = typeof y3 === "function" ? y3 : y3 === void 0 ? y : constant_default(y3);
  function line4(data2) {
    var i, n = (data2 = array_default(data2)).length, d3, defined0 = false, buffer;
    if (context == null)
      output = curve(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined4(d3 = data2[i], i, data2)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x3(d3, i, data2), +y3(d3, i, data2));
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  line4.x = function(_2) {
    return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default(+_2), line4) : x3;
  };
  line4.y = function(_2) {
    return arguments.length ? (y3 = typeof _2 === "function" ? _2 : constant_default(+_2), line4) : y3;
  };
  line4.defined = function(_2) {
    return arguments.length ? (defined4 = typeof _2 === "function" ? _2 : constant_default(!!_2), line4) : defined4;
  };
  line4.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), line4) : curve;
  };
  line4.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line4) : context;
  };
  return line4;
}

// node_modules/d3-shape/src/area.js
function area_default(x05, y05, y12) {
  var x12 = null, defined4 = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(area2);
  x05 = typeof x05 === "function" ? x05 : x05 === void 0 ? x : constant_default(+x05);
  y05 = typeof y05 === "function" ? y05 : y05 === void 0 ? constant_default(0) : constant_default(+y05);
  y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y : constant_default(+y12);
  function area2(data2) {
    var i, j, k2, n = (data2 = array_default(data2)).length, d3, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null)
      output = curve(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined4(d3 = data2[i], i, data2)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i - 1; k2 >= j; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x05(d3, i, data2), y0z[i] = +y05(d3, i, data2);
        output.point(x12 ? +x12(d3, i, data2) : x0z[i], y12 ? +y12(d3, i, data2) : y0z[i]);
      }
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined4).curve(curve).context(context);
  }
  area2.x = function(_2) {
    return arguments.length ? (x05 = typeof _2 === "function" ? _2 : constant_default(+_2), x12 = null, area2) : x05;
  };
  area2.x0 = function(_2) {
    return arguments.length ? (x05 = typeof _2 === "function" ? _2 : constant_default(+_2), area2) : x05;
  };
  area2.x1 = function(_2) {
    return arguments.length ? (x12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default(+_2), area2) : x12;
  };
  area2.y = function(_2) {
    return arguments.length ? (y05 = typeof _2 === "function" ? _2 : constant_default(+_2), y12 = null, area2) : y05;
  };
  area2.y0 = function(_2) {
    return arguments.length ? (y05 = typeof _2 === "function" ? _2 : constant_default(+_2), area2) : y05;
  };
  area2.y1 = function(_2) {
    return arguments.length ? (y12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default(+_2), area2) : y12;
  };
  area2.lineX0 = area2.lineY0 = function() {
    return arealine().x(x05).y(y05);
  };
  area2.lineY1 = function() {
    return arealine().x(x05).y(y12);
  };
  area2.lineX1 = function() {
    return arealine().x(x12).y(y05);
  };
  area2.defined = function(_2) {
    return arguments.length ? (defined4 = typeof _2 === "function" ? _2 : constant_default(!!_2), area2) : defined4;
  };
  area2.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), area2) : curve;
  };
  area2.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), area2) : context;
  };
  return area2;
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial2(curve) {
  this._curve = curve;
}
Radial2.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a4, r) {
    this._curve.point(r * Math.sin(a4), r * -Math.cos(a4));
  }
};
function curveRadial(curve) {
  function radial(context) {
    return new Radial2(curve(context));
  }
  radial._curve = curve;
  return radial;
}

// node_modules/d3-shape/src/lineRadial.js
function lineRadial(l) {
  var c5 = l.curve;
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  l.curve = function(_2) {
    return arguments.length ? c5(curveRadial(_2)) : c5()._curve;
  };
  return l;
}
function lineRadial_default() {
  return lineRadial(line_default().curve(curveRadialLinear));
}

// node_modules/d3-shape/src/areaRadial.js
function areaRadial_default() {
  var a4 = area_default().curve(curveRadialLinear), c5 = a4.curve, x05 = a4.lineX0, x12 = a4.lineX1, y05 = a4.lineY0, y12 = a4.lineY1;
  a4.angle = a4.x, delete a4.x;
  a4.startAngle = a4.x0, delete a4.x0;
  a4.endAngle = a4.x1, delete a4.x1;
  a4.radius = a4.y, delete a4.y;
  a4.innerRadius = a4.y0, delete a4.y0;
  a4.outerRadius = a4.y1, delete a4.y1;
  a4.lineStartAngle = function() {
    return lineRadial(x05());
  }, delete a4.lineX0;
  a4.lineEndAngle = function() {
    return lineRadial(x12());
  }, delete a4.lineX1;
  a4.lineInnerRadius = function() {
    return lineRadial(y05());
  }, delete a4.lineY0;
  a4.lineOuterRadius = function() {
    return lineRadial(y12());
  }, delete a4.lineY1;
  a4.curve = function(_2) {
    return arguments.length ? c5(curveRadial(_2)) : c5()._curve;
  };
  return a4;
}

// node_modules/d3-shape/src/symbol/asterisk.js
var sqrt3 = sqrt(3);

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt(1 / 3);
var tan30_2 = tan30 * 2;

// node_modules/d3-shape/src/symbol/star.js
var kr = sin(pi / 10) / sin(7 * pi / 10);
var kx = sin(tau / 10) * kr;
var ky = -cos(tau / 10) * kr;

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt32 = sqrt(3);

// node_modules/d3-shape/src/symbol/triangle2.js
var sqrt33 = sqrt(3);

// node_modules/d3-shape/src/symbol/wye.js
var s = sqrt(3) / 2;
var k = 1 / sqrt(12);
var a = (k / 2 + 1) * 3;

// node_modules/d3-shape/src/noop.js
function noop_default2() {
}

// node_modules/d3-shape/src/curve/basis.js
function point(that, x3, y3) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x3) / 6,
    (that._y0 + 4 * that._y1 + y3) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y3;
  }
};

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x3, this._y2 = y3;
        break;
      case 1:
        this._point = 2;
        this._x3 = x3, this._y3 = y3;
        break;
      case 2:
        this._point = 3;
        this._x4 = x3, this._y4 = y3;
        this._context.moveTo((this._x0 + 4 * this._x1 + x3) / 6, (this._y0 + 4 * this._y1 + y3) / 6);
        break;
      default:
        point(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y3;
  }
};

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x05 = (this._x0 + 4 * this._x1 + x3) / 6, y05 = (this._y0 + 4 * this._y1 + y3) / 6;
        this._line ? this._context.lineTo(x05, y05) : this._context.moveTo(x05, y05);
        break;
      case 3:
        this._point = 4;
      default:
        point(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y3;
  }
};

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x3 = this._x, y3 = this._y, j = x3.length - 1;
    if (j > 0) {
      var x05 = x3[0], y05 = y3[0], dx = x3[j] - x05, dy = y3[j] - y05, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x3[i] + (1 - this._beta) * (x05 + t * dx),
          this._beta * y3[i] + (1 - this._beta) * (y05 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x3, y3) {
    this._x.push(+x3);
    this._y.push(+y3);
  }
};
var bundle_default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x3, y3) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x3),
    that._y2 + that._k * (that._y1 - y3),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point2(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
        this._x1 = x3, this._y1 = y3;
        break;
      case 2:
        this._point = 3;
      default:
        point2(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x3, this._y3 = y3;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x3, this._y4 = y3);
        break;
      case 2:
        this._point = 3;
        this._x5 = x3, this._y5 = y3;
        break;
      default:
        point2(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x3, y3) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon) {
    var a4 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a4 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y12 = (y12 * a4 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m3 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x3 * that._l12_2a) / m3;
    y22 = (y22 * b + that._y1 * that._l23_2a - y3 * that._l12_2a) / m3;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    if (this._point) {
      var x23 = this._x2 - x3, y23 = this._y2 - y3;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x3, y3);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    if (this._point) {
      var x23 = this._x2 - x3, y23 = this._y2 - y3;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x3, this._y3 = y3;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x3, this._y4 = y3);
        break;
      case 2:
        this._point = 3;
        this._x5 = x3, this._y5 = y3;
        break;
      default:
        point3(this, x3, y3);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    if (this._point) {
      var x23 = this._x2 - x3, y23 = this._y2 - y3;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x3, y3);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    if (this._point)
      this._context.lineTo(x3, y3);
    else
      this._point = 1, this._context.moveTo(x3, y3);
  }
};
function linearClosed_default(context) {
  return new LinearClosed(context);
}

// node_modules/d3-shape/src/curve/monotone.js
function sign(x3) {
  return x3 < 0 ? -1 : 1;
}
function slope3(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p2 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p2)) || 0;
}
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point4(that, t02, t12) {
  var x05 = that._x0, y05 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x05) / 3;
  that._context.bezierCurveTo(x05 + dx, y05 + dx * t02, x12 - dx, y12 - dx * t12, x12, y12);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point4(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    var t12 = NaN;
    x3 = +x3, y3 = +y3;
    if (x3 === this._x1 && y3 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point4(this, slope2(this, t12 = slope3(this, x3, y3)), t12);
        break;
      default:
        point4(this, this._t0, t12 = slope3(this, x3, y3));
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y3;
    this._t0 = t12;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x3, y3) {
  MonotoneX.prototype.point.call(this, y3, x3);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x3, y3) {
    this._context.moveTo(y3, x3);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x3, y3) {
    this._context.lineTo(y3, x3);
  },
  bezierCurveTo: function(x12, y12, x22, y22, x3, y3) {
    this._context.bezierCurveTo(y12, x12, y22, x22, y3, x3);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x3 = this._x, y3 = this._y, n = x3.length;
    if (n) {
      this._line ? this._context.lineTo(x3[0], y3[0]) : this._context.moveTo(x3[0], y3[0]);
      if (n === 2) {
        this._context.lineTo(x3[1], y3[1]);
      } else {
        var px2 = controlPoints(x3), py = controlPoints(y3);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px2[0][i0], py[0][i0], px2[1][i0], py[1][i0], x3[i1], y3[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x3, y3) {
    this._x.push(+x3);
    this._y.push(+y3);
  }
};
function controlPoints(x3) {
  var i, n = x3.length - 1, m3, a4 = new Array(n), b = new Array(n), r = new Array(n);
  a4[0] = 0, b[0] = 2, r[0] = x3[0] + 2 * x3[1];
  for (i = 1; i < n - 1; ++i)
    a4[i] = 1, b[i] = 4, r[i] = 4 * x3[i] + 2 * x3[i + 1];
  a4[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x3[n - 1] + x3[n];
  for (i = 1; i < n; ++i)
    m3 = a4[i] / b[i - 1], b[i] -= m3, r[i] -= m3 * r[i - 1];
  a4[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i)
    a4[i] = (r[i] - a4[i + 1]) / b[i];
  b[n - 1] = (x3[n] + a4[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b[i] = 2 * x3[i + 1] - a4[i + 1];
  return [a4, b];
}

// node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y3);
          this._context.lineTo(x3, y3);
        } else {
          var x12 = this._x * (1 - this._t) + x3 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y3);
        }
        break;
      }
    }
    this._x = x3, this._y = y3;
  }
};
function step_default(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}

// node_modules/@antv/g2/esm/utils/coordinate.js
function isTranspose(coordinate) {
  const { transformations } = coordinate.getOptions();
  const transposes = transformations.map(([type]) => type).filter((type) => type === "transpose");
  return transposes.length % 2 !== 0;
}
function isPolar(coordinate) {
  const { transformations } = coordinate.getOptions();
  return transformations.some(([type]) => type === "polar");
}
function isRadial(coordinate) {
  const { transformations } = coordinate.getOptions();
  return (
    // distinguish radial from theta.
    transformations.some(([type]) => type === "reflect") && transformations.some(([type]) => type.startsWith("transpose"))
  );
}
function isHelix(coordinate) {
  const { transformations } = coordinate.getOptions();
  return transformations.some(([type]) => type === "helix");
}
function isParallel(coordinate) {
  const { transformations } = coordinate.getOptions();
  return transformations.some(([type]) => type === "parallel");
}
function isFisheye(coordinate) {
  const { transformations } = coordinate.getOptions();
  return transformations.some(([type]) => type === "fisheye");
}
function isRadar(coordinate) {
  return isParallel(coordinate) && isPolar(coordinate);
}
function isCircular(coordinate) {
  return isHelix(coordinate) || isPolar(coordinate);
}
function isTheta(coordinate) {
  return isPolar(coordinate) && isTranspose(coordinate);
}
function getRadius(coordinate) {
  if (isCircular(coordinate)) {
    const [width, height] = coordinate.getSize();
    const polar2 = coordinate.getOptions().transformations.find((t) => t[0] === "polar");
    if (polar2)
      return Math.max(width, height) / 2 * polar2[4];
  }
  return 0;
}
function radiusOf(coordinate) {
  const { transformations } = coordinate.getOptions();
  const [, , , innerRadius, outerRadius] = transformations.find((d3) => d3[0] === "polar");
  return [+innerRadius, +outerRadius];
}
function angleOf(coordinate, isRadius = true) {
  const { transformations } = coordinate.getOptions();
  const [, startAngle, endAngle] = transformations.find((d3) => d3[0] === "polar");
  return isRadius ? [+startAngle * 180 / Math.PI, +endAngle * 180 / Math.PI] : [startAngle, endAngle];
}
function getTransformOptions(coordinate, type) {
  const { transformations } = coordinate.getOptions();
  const [, ...args] = transformations.find((d3) => d3[0] === type);
  return args;
}

// node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_index.default;

// node_modules/@babel/runtime/helpers/esm/superPropBase.js
function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); )
    ;
  return t;
}

// node_modules/@babel/runtime/helpers/esm/get.js
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
    var p2 = _superPropBase(e, t);
    if (p2) {
      var n = Object.getOwnPropertyDescriptor(p2, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, _get.apply(null, arguments);
}

// node_modules/@babel/runtime/helpers/esm/superPropGet.js
function _superPropGet(t, o, e, r) {
  var p2 = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e);
  return 2 & r && "function" == typeof p2 ? function(t4) {
    return p2.apply(e, t4);
  } : p2;
}

// node_modules/@antv/g-math/dist/index.esm.js
function distance4(x12, y12, x22, y22) {
  var dx = x12 - x22;
  var dy = y12 - y22;
  return Math.sqrt(dx * dx + dy * dy);
}
function getBBoxByArray(xArr, yArr) {
  var minX = Math.min.apply(Math, __spreadArray([], __read(xArr), false));
  var minY = Math.min.apply(Math, __spreadArray([], __read(yArr), false));
  var maxX = Math.max.apply(Math, __spreadArray([], __read(xArr), false));
  var maxY2 = Math.max.apply(Math, __spreadArray([], __read(yArr), false));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function xExtrema(rx, ry, xRotation) {
  return Math.atan(-ry / rx * Math.tan(xRotation));
}
function yExtrema(rx, ry, xRotation) {
  return Math.atan(ry / (rx * Math.tan(xRotation)));
}
function xAt(cx, cy, rx, ry, xRotation, angle4) {
  return rx * Math.cos(xRotation) * Math.cos(angle4) - ry * Math.sin(xRotation) * Math.sin(angle4) + cx;
}
function yAt(cx, cy, rx, ry, xRotation, angle4) {
  return rx * Math.sin(xRotation) * Math.cos(angle4) + ry * Math.cos(xRotation) * Math.sin(angle4) + cy;
}
function box$5(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
  var xDim = xExtrema(rx, ry, xRotation);
  var minX = Infinity;
  var maxX = -Infinity;
  var xs = [startAngle, endAngle];
  for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
    var xAngle = xDim + i;
    if (startAngle < endAngle) {
      if (startAngle < xAngle && xAngle < endAngle) {
        xs.push(xAngle);
      }
    } else {
      if (endAngle < xAngle && xAngle < startAngle) {
        xs.push(xAngle);
      }
    }
  }
  for (var i = 0; i < xs.length; i++) {
    var x3 = xAt(cx, cy, rx, ry, xRotation, xs[i]);
    if (x3 < minX) {
      minX = x3;
    }
    if (x3 > maxX) {
      maxX = x3;
    }
  }
  var yDim = yExtrema(rx, ry, xRotation);
  var minY = Infinity;
  var maxY2 = -Infinity;
  var ys = [startAngle, endAngle];
  for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
    var yAngle = yDim + i;
    if (startAngle < endAngle) {
      if (startAngle < yAngle && yAngle < endAngle) {
        ys.push(yAngle);
      }
    } else {
      if (endAngle < yAngle && yAngle < startAngle) {
        ys.push(yAngle);
      }
    }
  }
  for (var i = 0; i < ys.length; i++) {
    var y3 = yAt(cx, cy, rx, ry, xRotation, ys[i]);
    if (y3 < minY) {
      minY = y3;
    }
    if (y3 > maxY2) {
      maxY2 = y3;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
var EPSILON2 = 1e-4;
function nearestPoint$2(xArr, yArr, x3, y3, tCallback, length5) {
  var t = -1;
  var d3 = Infinity;
  var v0 = [x3, y3];
  var segNum = 20;
  if (length5 && length5 > 200) {
    segNum = length5 / 10;
  }
  var increaseRate = 1 / segNum;
  var interval2 = increaseRate / 10;
  for (var i = 0; i <= segNum; i++) {
    var _t = i * increaseRate;
    var v1 = [
      tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([_t])), false)),
      tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([_t])), false))
    ];
    var d1 = distance4(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d3) {
      t = _t;
      d3 = d1;
    }
  }
  if (t === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t === 1) {
    var count4 = xArr.length;
    return {
      x: xArr[count4 - 1],
      y: yArr[count4 - 1]
    };
  }
  d3 = Infinity;
  for (var i = 0; i < 32; i++) {
    if (interval2 < EPSILON2) {
      break;
    }
    var prev = t - interval2;
    var next = t + interval2;
    var v1 = [
      tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([prev])), false)),
      tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([prev])), false))
    ];
    var d1 = distance4(v0[0], v0[1], v1[0], v1[1]);
    if (prev >= 0 && d1 < d3) {
      t = prev;
      d3 = d1;
    } else {
      var v2 = [
        tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([next])), false)),
        tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([next])), false))
      ];
      var d22 = distance4(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d22 < d3) {
        t = next;
        d3 = d22;
      } else {
        interval2 *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([t])), false)),
    y: tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([t])), false))
  };
}
function length$4(x12, y12, x22, y22) {
  return distance4(x12, y12, x22, y22);
}
function pointAt$3(x12, y12, x22, y22, t) {
  return {
    x: (1 - t) * x12 + t * x22,
    y: (1 - t) * y12 + t * y22
  };
}
function pointToLine(x12, y12, x22, y22, x3, y3) {
  var d3 = [x22 - x12, y22 - y12];
  if (vec2_exports.exactEquals(d3, [0, 0])) {
    return Math.sqrt((x3 - x12) * (x3 - x12) + (y3 - y12) * (y3 - y12));
  }
  var u = [-d3[1], d3[0]];
  vec2_exports.normalize(u, u);
  var a4 = [x3 - x12, y3 - y12];
  return Math.abs(vec2_exports.dot(a4, u));
}
function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
}
function extrema$1(p0, p1, p2, p3) {
  var a4 = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b = 6 * p0 - 12 * p1 + 6 * p2;
  var c5 = 3 * p1 - 3 * p0;
  var extremas = [];
  var t12;
  var t22;
  var discSqrt;
  if (isNumberEqual(a4, 0)) {
    if (!isNumberEqual(b, 0)) {
      t12 = -c5 / b;
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
    }
  } else {
    var disc = b * b - 4 * a4 * c5;
    if (isNumberEqual(disc, 0)) {
      extremas.push(-b / (2 * a4));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t12 = (-b + discSqrt) / (2 * a4);
      t22 = (-b - discSqrt) / (2 * a4);
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
      if (t22 >= 0 && t22 <= 1) {
        extremas.push(t22);
      }
    }
  }
  return extremas;
}
function box$3(x12, y12, x22, y22, x3, y3, x4, y4) {
  var xArr = [x12, x4];
  var yArr = [y12, y4];
  var xExtrema2 = extrema$1(x12, x22, x3, x4);
  var yExtrema2 = extrema$1(y12, y22, y3, y4);
  for (var i = 0; i < xExtrema2.length; i++) {
    xArr.push(cubicAt(x12, x22, x3, x4, xExtrema2[i]));
  }
  for (var i = 0; i < yExtrema2.length; i++) {
    yArr.push(cubicAt(y12, y22, y3, y4, yExtrema2[i]));
  }
  return getBBoxByArray(xArr, yArr);
}
function nearestPoint$1(x12, y12, x22, y22, x3, y3, x4, y4, x05, y05, length5) {
  return nearestPoint$2([x12, x22, x3, x4], [y12, y22, y3, y4], x05, y05, cubicAt, length5);
}
function pointDistance$3(x12, y12, x22, y22, x3, y3, x4, y4, x05, y05, length5) {
  var point7 = nearestPoint$1(x12, y12, x22, y22, x3, y3, x4, y4, x05, y05, length5);
  return distance4(point7.x, point7.y, x05, y05);
}
function lengthOfSegment(points) {
  if (points.length < 2) {
    return 0;
  }
  var totalLength = 0;
  for (var i = 0; i < points.length - 1; i++) {
    var from = points[i];
    var to = points[i + 1];
    totalLength += distance4(from[0], from[1], to[0], to[1]);
  }
  return totalLength;
}
function length$2(points) {
  return lengthOfSegment(points);
}
function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
}
function extrema(p0, p1, p2) {
  var a4 = p0 + p2 - 2 * p1;
  if (isNumberEqual(a4, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a4;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function box(x12, y12, x22, y22, x3, y3) {
  var xExtrema2 = extrema(x12, x22, x3)[0];
  var yExtrema2 = extrema(y12, y22, y3)[0];
  var xArr = [x12, x3];
  var yArr = [y12, y3];
  if (xExtrema2 !== void 0) {
    xArr.push(quadraticAt(x12, x22, x3, xExtrema2));
  }
  if (yExtrema2 !== void 0) {
    yArr.push(quadraticAt(y12, y22, y3, yExtrema2));
  }
  return getBBoxByArray(xArr, yArr);
}
function nearestPoint(x12, y12, x22, y22, x3, y3, x05, y05) {
  return nearestPoint$2([x12, x22, x3], [y12, y22, y3], x05, y05, quadraticAt);
}
function pointDistance(x12, y12, x22, y22, x3, y3, x05, y05) {
  var point7 = nearestPoint(x12, y12, x22, y22, x3, y3, x05, y05);
  return distance4(point7.x, point7.y, x05, y05);
}

// node_modules/@antv/g-lite/dist/index.esm.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var rbush = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    function quickselect2(arr, k2, left2, right2, compare) {
      quickselectStep(arr, k2, left2 || 0, right2 || arr.length - 1, compare || defaultCompare);
    }
    function quickselectStep(arr, k2, left2, right2, compare) {
      while (right2 > left2) {
        if (right2 - left2 > 600) {
          var n = right2 - left2 + 1;
          var m3 = k2 - left2 + 1;
          var z = Math.log(n);
          var s3 = 0.5 * Math.exp(2 * z / 3);
          var sd = 0.5 * Math.sqrt(z * s3 * (n - s3) / n) * (m3 - n / 2 < 0 ? -1 : 1);
          var newLeft = Math.max(left2, Math.floor(k2 - m3 * s3 / n + sd));
          var newRight = Math.min(right2, Math.floor(k2 + (n - m3) * s3 / n + sd));
          quickselectStep(arr, k2, newLeft, newRight, compare);
        }
        var t = arr[k2];
        var i = left2;
        var j = right2;
        swap2(arr, left2, k2);
        if (compare(arr[right2], t) > 0) {
          swap2(arr, left2, right2);
        }
        while (i < j) {
          swap2(arr, i, j);
          i++;
          j--;
          while (compare(arr[i], t) < 0) {
            i++;
          }
          while (compare(arr[j], t) > 0) {
            j--;
          }
        }
        if (compare(arr[left2], t) === 0) {
          swap2(arr, left2, j);
        } else {
          j++;
          swap2(arr, j, right2);
        }
        if (j <= k2) {
          left2 = j + 1;
        }
        if (k2 <= j) {
          right2 = j - 1;
        }
      }
    }
    function swap2(arr, i, j) {
      var tmp2 = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp2;
    }
    function defaultCompare(a4, b) {
      return a4 < b ? -1 : a4 > b ? 1 : 0;
    }
    var RBush2 = function RBush3(maxEntries) {
      if (maxEntries === void 0)
        maxEntries = 9;
      this._maxEntries = Math.max(4, maxEntries);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
      this.clear();
    };
    RBush2.prototype.all = function all() {
      return this._all(this.data, []);
    };
    RBush2.prototype.search = function search2(bbox) {
      var node = this.data;
      var result = [];
      if (!intersects2(bbox, node)) {
        return result;
      }
      var toBBox = this.toBBox;
      var nodesToSearch = [];
      while (node) {
        for (var i = 0; i < node.children.length; i++) {
          var child = node.children[i];
          var childBBox = node.leaf ? toBBox(child) : child;
          if (intersects2(bbox, childBBox)) {
            if (node.leaf) {
              result.push(child);
            } else if (contains(bbox, childBBox)) {
              this._all(child, result);
            } else {
              nodesToSearch.push(child);
            }
          }
        }
        node = nodesToSearch.pop();
      }
      return result;
    };
    RBush2.prototype.collides = function collides(bbox) {
      var node = this.data;
      if (!intersects2(bbox, node)) {
        return false;
      }
      var nodesToSearch = [];
      while (node) {
        for (var i = 0; i < node.children.length; i++) {
          var child = node.children[i];
          var childBBox = node.leaf ? this.toBBox(child) : child;
          if (intersects2(bbox, childBBox)) {
            if (node.leaf || contains(bbox, childBBox)) {
              return true;
            }
            nodesToSearch.push(child);
          }
        }
        node = nodesToSearch.pop();
      }
      return false;
    };
    RBush2.prototype.load = function load(data2) {
      if (!(data2 && data2.length)) {
        return this;
      }
      if (data2.length < this._minEntries) {
        for (var i = 0; i < data2.length; i++) {
          this.insert(data2[i]);
        }
        return this;
      }
      var node = this._build(data2.slice(), 0, data2.length - 1, 0);
      if (!this.data.children.length) {
        this.data = node;
      } else if (this.data.height === node.height) {
        this._splitRoot(this.data, node);
      } else {
        if (this.data.height < node.height) {
          var tmpNode = this.data;
          this.data = node;
          node = tmpNode;
        }
        this._insert(node, this.data.height - node.height - 1, true);
      }
      return this;
    };
    RBush2.prototype.insert = function insert(item) {
      if (item) {
        this._insert(item, this.data.height - 1);
      }
      return this;
    };
    RBush2.prototype.clear = function clear() {
      this.data = createNode3([]);
      return this;
    };
    RBush2.prototype.remove = function remove2(item, equalsFn) {
      if (!item) {
        return this;
      }
      var node = this.data;
      var bbox = this.toBBox(item);
      var path2 = [];
      var indexes2 = [];
      var i, parent, goingUp;
      while (node || path2.length) {
        if (!node) {
          node = path2.pop();
          parent = path2[path2.length - 1];
          i = indexes2.pop();
          goingUp = true;
        }
        if (node.leaf) {
          var index3 = findItem(item, node.children, equalsFn);
          if (index3 !== -1) {
            node.children.splice(index3, 1);
            path2.push(node);
            this._condense(path2);
            return this;
          }
        }
        if (!goingUp && !node.leaf && contains(node, bbox)) {
          path2.push(node);
          indexes2.push(i);
          i = 0;
          parent = node;
          node = node.children[0];
        } else if (parent) {
          i++;
          node = parent.children[i];
          goingUp = false;
        } else {
          node = null;
        }
      }
      return this;
    };
    RBush2.prototype.toBBox = function toBBox(item) {
      return item;
    };
    RBush2.prototype.compareMinX = function compareMinX(a4, b) {
      return a4.minX - b.minX;
    };
    RBush2.prototype.compareMinY = function compareMinY(a4, b) {
      return a4.minY - b.minY;
    };
    RBush2.prototype.toJSON = function toJSON() {
      return this.data;
    };
    RBush2.prototype.fromJSON = function fromJSON(data2) {
      this.data = data2;
      return this;
    };
    RBush2.prototype._all = function _all(node, result) {
      var nodesToSearch = [];
      while (node) {
        if (node.leaf) {
          result.push.apply(result, node.children);
        } else {
          nodesToSearch.push.apply(nodesToSearch, node.children);
        }
        node = nodesToSearch.pop();
      }
      return result;
    };
    RBush2.prototype._build = function _build(items, left2, right2, height) {
      var N = right2 - left2 + 1;
      var M2 = this._maxEntries;
      var node;
      if (N <= M2) {
        node = createNode3(items.slice(left2, right2 + 1));
        calcBBox2(node, this.toBBox);
        return node;
      }
      if (!height) {
        height = Math.ceil(Math.log(N) / Math.log(M2));
        M2 = Math.ceil(N / Math.pow(M2, height - 1));
      }
      node = createNode3([]);
      node.leaf = false;
      node.height = height;
      var N2 = Math.ceil(N / M2);
      var N1 = N2 * Math.ceil(Math.sqrt(M2));
      multiSelect(items, left2, right2, N1, this.compareMinX);
      for (var i = left2; i <= right2; i += N1) {
        var right22 = Math.min(i + N1 - 1, right2);
        multiSelect(items, i, right22, N2, this.compareMinY);
        for (var j = i; j <= right22; j += N2) {
          var right3 = Math.min(j + N2 - 1, right22);
          node.children.push(this._build(items, j, right3, height - 1));
        }
      }
      calcBBox2(node, this.toBBox);
      return node;
    };
    RBush2.prototype._chooseSubtree = function _chooseSubtree(bbox, node, level, path2) {
      while (true) {
        path2.push(node);
        if (node.leaf || path2.length - 1 === level) {
          break;
        }
        var minArea = Infinity;
        var minEnlargement = Infinity;
        var targetNode = void 0;
        for (var i = 0; i < node.children.length; i++) {
          var child = node.children[i];
          var area2 = bboxArea(child);
          var enlargement = enlargedArea(bbox, child) - area2;
          if (enlargement < minEnlargement) {
            minEnlargement = enlargement;
            minArea = area2 < minArea ? area2 : minArea;
            targetNode = child;
          } else if (enlargement === minEnlargement) {
            if (area2 < minArea) {
              minArea = area2;
              targetNode = child;
            }
          }
        }
        node = targetNode || node.children[0];
      }
      return node;
    };
    RBush2.prototype._insert = function _insert(item, level, isNode) {
      var bbox = isNode ? item : this.toBBox(item);
      var insertPath = [];
      var node = this._chooseSubtree(bbox, this.data, level, insertPath);
      node.children.push(item);
      extend6(node, bbox);
      while (level >= 0) {
        if (insertPath[level].children.length > this._maxEntries) {
          this._split(insertPath, level);
          level--;
        } else {
          break;
        }
      }
      this._adjustParentBBoxes(bbox, insertPath, level);
    };
    RBush2.prototype._split = function _split(insertPath, level) {
      var node = insertPath[level];
      var M2 = node.children.length;
      var m3 = this._minEntries;
      this._chooseSplitAxis(node, m3, M2);
      var splitIndex = this._chooseSplitIndex(node, m3, M2);
      var newNode = createNode3(node.children.splice(splitIndex, node.children.length - splitIndex));
      newNode.height = node.height;
      newNode.leaf = node.leaf;
      calcBBox2(node, this.toBBox);
      calcBBox2(newNode, this.toBBox);
      if (level) {
        insertPath[level - 1].children.push(newNode);
      } else {
        this._splitRoot(node, newNode);
      }
    };
    RBush2.prototype._splitRoot = function _splitRoot(node, newNode) {
      this.data = createNode3([node, newNode]);
      this.data.height = node.height + 1;
      this.data.leaf = false;
      calcBBox2(this.data, this.toBBox);
    };
    RBush2.prototype._chooseSplitIndex = function _chooseSplitIndex(node, m3, M2) {
      var index3;
      var minOverlap = Infinity;
      var minArea = Infinity;
      for (var i = m3; i <= M2 - m3; i++) {
        var bbox1 = distBBox(node, 0, i, this.toBBox);
        var bbox2 = distBBox(node, i, M2, this.toBBox);
        var overlap = intersectionArea2(bbox1, bbox2);
        var area2 = bboxArea(bbox1) + bboxArea(bbox2);
        if (overlap < minOverlap) {
          minOverlap = overlap;
          index3 = i;
          minArea = area2 < minArea ? area2 : minArea;
        } else if (overlap === minOverlap) {
          if (area2 < minArea) {
            minArea = area2;
            index3 = i;
          }
        }
      }
      return index3 || M2 - m3;
    };
    RBush2.prototype._chooseSplitAxis = function _chooseSplitAxis(node, m3, M2) {
      var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
      var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
      var xMargin = this._allDistMargin(node, m3, M2, compareMinX);
      var yMargin = this._allDistMargin(node, m3, M2, compareMinY);
      if (xMargin < yMargin) {
        node.children.sort(compareMinX);
      }
    };
    RBush2.prototype._allDistMargin = function _allDistMargin(node, m3, M2, compare) {
      node.children.sort(compare);
      var toBBox = this.toBBox;
      var leftBBox = distBBox(node, 0, m3, toBBox);
      var rightBBox = distBBox(node, M2 - m3, M2, toBBox);
      var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
      for (var i = m3; i < M2 - m3; i++) {
        var child = node.children[i];
        extend6(leftBBox, node.leaf ? toBBox(child) : child);
        margin += bboxMargin(leftBBox);
      }
      for (var i$1 = M2 - m3 - 1; i$1 >= m3; i$1--) {
        var child$1 = node.children[i$1];
        extend6(rightBBox, node.leaf ? toBBox(child$1) : child$1);
        margin += bboxMargin(rightBBox);
      }
      return margin;
    };
    RBush2.prototype._adjustParentBBoxes = function _adjustParentBBoxes(bbox, path2, level) {
      for (var i = level; i >= 0; i--) {
        extend6(path2[i], bbox);
      }
    };
    RBush2.prototype._condense = function _condense(path2) {
      for (var i = path2.length - 1, siblings = void 0; i >= 0; i--) {
        if (path2[i].children.length === 0) {
          if (i > 0) {
            siblings = path2[i - 1].children;
            siblings.splice(siblings.indexOf(path2[i]), 1);
          } else {
            this.clear();
          }
        } else {
          calcBBox2(path2[i], this.toBBox);
        }
      }
    };
    function findItem(item, items, equalsFn) {
      if (!equalsFn) {
        return items.indexOf(item);
      }
      for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) {
          return i;
        }
      }
      return -1;
    }
    function calcBBox2(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
    }
    function distBBox(node, k2, p2, toBBox, destNode) {
      if (!destNode) {
        destNode = createNode3(null);
      }
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;
      for (var i = k2; i < p2; i++) {
        var child = node.children[i];
        extend6(destNode, node.leaf ? toBBox(child) : child);
      }
      return destNode;
    }
    function extend6(a4, b) {
      a4.minX = Math.min(a4.minX, b.minX);
      a4.minY = Math.min(a4.minY, b.minY);
      a4.maxX = Math.max(a4.maxX, b.maxX);
      a4.maxY = Math.max(a4.maxY, b.maxY);
      return a4;
    }
    function compareNodeMinX(a4, b) {
      return a4.minX - b.minX;
    }
    function compareNodeMinY(a4, b) {
      return a4.minY - b.minY;
    }
    function bboxArea(a4) {
      return (a4.maxX - a4.minX) * (a4.maxY - a4.minY);
    }
    function bboxMargin(a4) {
      return a4.maxX - a4.minX + (a4.maxY - a4.minY);
    }
    function enlargedArea(a4, b) {
      return (Math.max(b.maxX, a4.maxX) - Math.min(b.minX, a4.minX)) * (Math.max(b.maxY, a4.maxY) - Math.min(b.minY, a4.minY));
    }
    function intersectionArea2(a4, b) {
      var minX = Math.max(a4.minX, b.minX);
      var minY = Math.max(a4.minY, b.minY);
      var maxX = Math.min(a4.maxX, b.maxX);
      var maxY2 = Math.min(a4.maxY, b.maxY);
      return Math.max(0, maxX - minX) * Math.max(0, maxY2 - minY);
    }
    function contains(a4, b) {
      return a4.minX <= b.minX && a4.minY <= b.minY && b.maxX <= a4.maxX && b.maxY <= a4.maxY;
    }
    function intersects2(a4, b) {
      return b.minX <= a4.maxX && b.minY <= a4.maxY && b.maxX >= a4.minX && b.maxY >= a4.minY;
    }
    function createNode3(children) {
      return {
        children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
      };
    }
    function multiSelect(arr, left2, right2, n, compare) {
      var stack = [left2, right2];
      while (stack.length) {
        right2 = stack.pop();
        left2 = stack.pop();
        if (right2 - left2 <= n) {
          continue;
        }
        var mid2 = left2 + Math.ceil((right2 - left2) / n / 2) * n;
        quickselect2(arr, mid2, left2, right2, compare);
        stack.push(left2, mid2, mid2, right2);
      }
    }
    return RBush2;
  });
})(rbush);
var RBush = rbush.exports;
var Shape = function(Shape4) {
  Shape4["GROUP"] = "g";
  Shape4["FRAGMENT"] = "fragment";
  Shape4["CIRCLE"] = "circle";
  Shape4["ELLIPSE"] = "ellipse";
  Shape4["IMAGE"] = "image";
  Shape4["RECT"] = "rect";
  Shape4["LINE"] = "line";
  Shape4["POLYLINE"] = "polyline";
  Shape4["POLYGON"] = "polygon";
  Shape4["TEXT"] = "text";
  Shape4["PATH"] = "path";
  Shape4["HTML"] = "html";
  Shape4["MESH"] = "mesh";
  return Shape4;
}({});
var ClipSpaceNearZ = function(ClipSpaceNearZ2) {
  ClipSpaceNearZ2[ClipSpaceNearZ2["ZERO"] = 0] = "ZERO";
  ClipSpaceNearZ2[ClipSpaceNearZ2["NEGATIVE_ONE"] = 1] = "NEGATIVE_ONE";
  return ClipSpaceNearZ2;
}({});
var AbstractRendererPlugin = function() {
  function AbstractRendererPlugin2() {
    _classCallCheck(this, AbstractRendererPlugin2);
    this.plugins = [];
  }
  return _createClass(AbstractRendererPlugin2, [{
    key: "addRenderingPlugin",
    value: function addRenderingPlugin(plugin) {
      this.plugins.push(plugin);
      this.context.renderingPlugins.push(plugin);
    }
  }, {
    key: "removeAllRenderingPlugins",
    value: function removeAllRenderingPlugins() {
      var _this2 = this;
      this.plugins.forEach(function(plugin) {
        var index3 = _this2.context.renderingPlugins.indexOf(plugin);
        if (index3 >= 0) {
          _this2.context.renderingPlugins.splice(index3, 1);
        }
      });
    }
  }]);
}();
var AbstractRenderer = function() {
  function AbstractRenderer2(config) {
    _classCallCheck(this, AbstractRenderer2);
    this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
    this.plugins = [];
    this.config = _objectSpread2({
      /**
       * only dirty object will cause re-render
       */
      enableDirtyCheck: true,
      enableCulling: false,
      /**
       * enable auto rendering by default
       */
      enableAutoRendering: true,
      /**
       * enable dirty rectangle rendering by default
       */
      enableDirtyRectangleRendering: true,
      enableDirtyRectangleRenderingDebug: false,
      enableSizeAttenuation: true,
      enableRenderingOptimization: false
    }, config);
  }
  return _createClass(AbstractRenderer2, [{
    key: "registerPlugin",
    value: function registerPlugin(plugin) {
      var index3 = this.plugins.findIndex(function(p2) {
        return p2 === plugin;
      });
      if (index3 === -1) {
        this.plugins.push(plugin);
      }
    }
  }, {
    key: "unregisterPlugin",
    value: function unregisterPlugin(plugin) {
      var index3 = this.plugins.findIndex(function(p2) {
        return p2 === plugin;
      });
      if (index3 > -1) {
        this.plugins.splice(index3, 1);
      }
    }
  }, {
    key: "getPlugins",
    value: function getPlugins() {
      return this.plugins;
    }
  }, {
    key: "getPlugin",
    value: function getPlugin(name2) {
      return this.plugins.find(function(plugin) {
        return plugin.name === name2;
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return this.config;
    }
  }, {
    key: "setConfig",
    value: function setConfig(config) {
      Object.assign(this.config, config);
    }
  }]);
}();
var addVec3 = vec3_exports.add;
var copyVec3 = vec3_exports.copy;
var maxVec3 = vec3_exports.max;
var minVec3 = vec3_exports.min;
var scaleVec3 = vec3_exports.scale;
var subVec3 = vec3_exports.sub;
var AABB = function() {
  function AABB2() {
    _classCallCheck(this, AABB2);
    this.center = [0, 0, 0];
    this.halfExtents = [0, 0, 0];
    this.min = [0, 0, 0];
    this.max = [0, 0, 0];
  }
  return _createClass(AABB2, [{
    key: "update",
    value: function update2(center2, halfExtents) {
      copyVec3(this.center, center2);
      copyVec3(this.halfExtents, halfExtents);
      subVec3(this.min, this.center, this.halfExtents);
      addVec3(this.max, this.center, this.halfExtents);
    }
  }, {
    key: "setMinMax",
    value: function setMinMax(min10, max11) {
      addVec3(this.center, max11, min10);
      scaleVec3(this.center, this.center, 0.5);
      subVec3(this.halfExtents, max11, min10);
      scaleVec3(this.halfExtents, this.halfExtents, 0.5);
      copyVec3(this.min, min10);
      copyVec3(this.max, max11);
    }
  }, {
    key: "getMin",
    value: function getMin() {
      return this.min;
    }
  }, {
    key: "getMax",
    value: function getMax() {
      return this.max;
    }
  }, {
    key: "add",
    value: function add10(aabb) {
      if (AABB2.isEmpty(aabb)) {
        return;
      }
      if (AABB2.isEmpty(this)) {
        this.setMinMax(aabb.getMin(), aabb.getMax());
        return;
      }
      var tc = this.center;
      var tcx = tc[0];
      var tcy = tc[1];
      var tcz = tc[2];
      var th = this.halfExtents;
      var thx = th[0];
      var thy = th[1];
      var thz = th[2];
      var tminx = tcx - thx;
      var tmaxx = tcx + thx;
      var tminy = tcy - thy;
      var tmaxy = tcy + thy;
      var tminz = tcz - thz;
      var tmaxz = tcz + thz;
      var oc = aabb.center;
      var ocx = oc[0];
      var ocy = oc[1];
      var ocz = oc[2];
      var oh = aabb.halfExtents;
      var ohx = oh[0];
      var ohy = oh[1];
      var ohz = oh[2];
      var ominx = ocx - ohx;
      var omaxx = ocx + ohx;
      var ominy = ocy - ohy;
      var omaxy = ocy + ohy;
      var ominz = ocz - ohz;
      var omaxz = ocz + ohz;
      if (ominx < tminx) {
        tminx = ominx;
      }
      if (omaxx > tmaxx) {
        tmaxx = omaxx;
      }
      if (ominy < tminy) {
        tminy = ominy;
      }
      if (omaxy > tmaxy) {
        tmaxy = omaxy;
      }
      if (ominz < tminz) {
        tminz = ominz;
      }
      if (omaxz > tmaxz) {
        tmaxz = omaxz;
      }
      tc[0] = (tminx + tmaxx) * 0.5;
      tc[1] = (tminy + tmaxy) * 0.5;
      tc[2] = (tminz + tmaxz) * 0.5;
      th[0] = (tmaxx - tminx) * 0.5;
      th[1] = (tmaxy - tminy) * 0.5;
      th[2] = (tmaxz - tminz) * 0.5;
      this.min[0] = tminx;
      this.min[1] = tminy;
      this.min[2] = tminz;
      this.max[0] = tmaxx;
      this.max[1] = tmaxy;
      this.max[2] = tmaxz;
    }
  }, {
    key: "setFromTransformedAABB",
    value: function setFromTransformedAABB(aabb, m3) {
      var bc = this.center;
      var br = this.halfExtents;
      var ac = aabb.center;
      var ar = aabb.halfExtents;
      var mx0 = m3[0];
      var mx1 = m3[4];
      var mx2 = m3[8];
      var my0 = m3[1];
      var my1 = m3[5];
      var my2 = m3[9];
      var mz0 = m3[2];
      var mz1 = m3[6];
      var mz2 = m3[10];
      var mx0a = Math.abs(mx0);
      var mx1a = Math.abs(mx1);
      var mx2a = Math.abs(mx2);
      var my0a = Math.abs(my0);
      var my1a = Math.abs(my1);
      var my2a = Math.abs(my2);
      var mz0a = Math.abs(mz0);
      var mz1a = Math.abs(mz1);
      var mz2a = Math.abs(mz2);
      bc[0] = m3[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2];
      bc[1] = m3[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2];
      bc[2] = m3[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2];
      br[0] = mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2];
      br[1] = my0a * ar[0] + my1a * ar[1] + my2a * ar[2];
      br[2] = mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2];
      subVec3(this.min, bc, br);
      addVec3(this.max, bc, br);
    }
  }, {
    key: "intersects",
    value: function intersects2(aabb) {
      var aMax = this.getMax();
      var aMin = this.getMin();
      var bMax = aabb.getMax();
      var bMin = aabb.getMin();
      return aMin[0] <= bMax[0] && aMax[0] >= bMin[0] && aMin[1] <= bMax[1] && aMax[1] >= bMin[1] && aMin[2] <= bMax[2] && aMax[2] >= bMin[2];
    }
  }, {
    key: "intersection",
    value: function intersection3(aabb) {
      if (!this.intersects(aabb)) {
        return null;
      }
      var intersection4 = new AABB2();
      var min10 = maxVec3([0, 0, 0], this.getMin(), aabb.getMin());
      var max11 = minVec3([0, 0, 0], this.getMax(), aabb.getMax());
      intersection4.setMinMax(min10, max11);
      return intersection4;
    }
    /**
     * get n-vertex
     * @param plane plane of CullingVolume
     */
  }, {
    key: "getNegativeFarPoint",
    value: function getNegativeFarPoint(plane) {
      if (plane.pnVertexFlag === 273) {
        return copyVec3([0, 0, 0], this.min);
      }
      if (plane.pnVertexFlag === 272) {
        return [this.min[0], this.min[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 257) {
        return [this.min[0], this.max[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 256) {
        return [this.min[0], this.max[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 17) {
        return [this.max[0], this.min[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 16) {
        return [this.max[0], this.min[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 1) {
        return [this.max[0], this.max[1], this.min[2]];
      }
      return [this.max[0], this.max[1], this.max[2]];
    }
    /**
     * get p-vertex
     * @param plane plane of CullingVolume
     */
  }, {
    key: "getPositiveFarPoint",
    value: function getPositiveFarPoint(plane) {
      if (plane.pnVertexFlag === 273) {
        return copyVec3([0, 0, 0], this.max);
      }
      if (plane.pnVertexFlag === 272) {
        return [this.max[0], this.max[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 257) {
        return [this.max[0], this.min[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 256) {
        return [this.max[0], this.min[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 17) {
        return [this.min[0], this.max[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 16) {
        return [this.min[0], this.max[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 1) {
        return [this.min[0], this.min[1], this.max[2]];
      }
      return [this.min[0], this.min[1], this.min[2]];
    }
  }], [{
    key: "isEmpty",
    value: function isEmpty3(aabb) {
      return !aabb || aabb.halfExtents[0] === 0 && aabb.halfExtents[1] === 0 && aabb.halfExtents[2] === 0;
    }
  }]);
}();
var Plane = function() {
  function Plane2(distance7, normal) {
    _classCallCheck(this, Plane2);
    this.distance = distance7 || 0;
    this.normal = normal || vec3_exports.fromValues(0, 1, 0);
    this.updatePNVertexFlag();
  }
  return _createClass(Plane2, [{
    key: "updatePNVertexFlag",
    value: function updatePNVertexFlag() {
      this.pnVertexFlag = (Number(this.normal[0] >= 0) << 8) + (Number(this.normal[1] >= 0) << 4) + Number(this.normal[2] >= 0);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point7) {
      return vec3_exports.dot(point7, this.normal) - this.distance;
    }
  }, {
    key: "normalize",
    value: function normalize10() {
      var invLen = 1 / vec3_exports.len(this.normal);
      vec3_exports.scale(this.normal, this.normal, invLen);
      this.distance *= invLen;
    }
  }, {
    key: "intersectsLine",
    value: function intersectsLine(start, end, point7) {
      var d0 = this.distanceToPoint(start);
      var d1 = this.distanceToPoint(end);
      var t = d0 / (d0 - d1);
      var intersects2 = t >= 0 && t <= 1;
      if (intersects2 && point7) {
        vec3_exports.lerp(point7, start, end, t);
      }
      return intersects2;
    }
  }]);
}();
var Mask = function(Mask2) {
  Mask2[Mask2["OUTSIDE"] = 4294967295] = "OUTSIDE";
  Mask2[Mask2["INSIDE"] = 0] = "INSIDE";
  Mask2[Mask2["INDETERMINATE"] = 2147483647] = "INDETERMINATE";
  return Mask2;
}({});
var Frustum = function() {
  function Frustum2(planes) {
    _classCallCheck(this, Frustum2);
    this.planes = [];
    if (planes) {
      this.planes = planes;
    } else {
      for (var i = 0; i < 6; i++) {
        this.planes.push(new Plane());
      }
    }
  }
  return _createClass(Frustum2, [{
    key: "extractFromVPMatrix",
    value: function extractFromVPMatrix(projectionMatrix) {
      var _projectionMatrix = _slicedToArray(projectionMatrix, 16), m0 = _projectionMatrix[0], m1 = _projectionMatrix[1], m22 = _projectionMatrix[2], m3 = _projectionMatrix[3], m4 = _projectionMatrix[4], m5 = _projectionMatrix[5], m6 = _projectionMatrix[6], m7 = _projectionMatrix[7], m8 = _projectionMatrix[8], m9 = _projectionMatrix[9], m10 = _projectionMatrix[10], m11 = _projectionMatrix[11], m12 = _projectionMatrix[12], m13 = _projectionMatrix[13], m14 = _projectionMatrix[14], m15 = _projectionMatrix[15];
      vec3_exports.set(this.planes[0].normal, m3 - m0, m7 - m4, m11 - m8);
      this.planes[0].distance = m15 - m12;
      vec3_exports.set(this.planes[1].normal, m3 + m0, m7 + m4, m11 + m8);
      this.planes[1].distance = m15 + m12;
      vec3_exports.set(this.planes[2].normal, m3 + m1, m7 + m5, m11 + m9);
      this.planes[2].distance = m15 + m13;
      vec3_exports.set(this.planes[3].normal, m3 - m1, m7 - m5, m11 - m9);
      this.planes[3].distance = m15 - m13;
      vec3_exports.set(this.planes[4].normal, m3 - m22, m7 - m6, m11 - m10);
      this.planes[4].distance = m15 - m14;
      vec3_exports.set(this.planes[5].normal, m3 + m22, m7 + m6, m11 + m10);
      this.planes[5].distance = m15 + m14;
      this.planes.forEach(function(plane) {
        plane.normalize();
        plane.updatePNVertexFlag();
      });
    }
  }]);
}();
var Point2 = function() {
  function Point6() {
    var x3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    _classCallCheck(this, Point6);
    this.x = 0;
    this.y = 0;
    this.x = x3;
    this.y = y3;
  }
  return _createClass(Point6, [{
    key: "clone",
    value: function clone8() {
      return new Point6(this.x, this.y);
    }
  }, {
    key: "copyFrom",
    value: function copyFrom(p2) {
      this.x = p2.x;
      this.y = p2.y;
    }
  }]);
}();
var Rectangle = function() {
  function Rectangle2(x3, y3, width, height) {
    _classCallCheck(this, Rectangle2);
    this.x = x3;
    this.y = y3;
    this.width = width;
    this.height = height;
    this.left = x3;
    this.right = x3 + width;
    this.top = y3;
    this.bottom = y3 + height;
  }
  return _createClass(Rectangle2, [{
    key: "toJSON",
    value: function toJSON() {
    }
  }], [{
    key: "fromRect",
    value: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMRect/fromRect_static
       */
      function fromRect(rect4) {
        return new Rectangle2(rect4.x, rect4.y, rect4.width, rect4.height);
      }
    )
    /**
     * will return a new rect instance
     */
  }, {
    key: "applyTransform",
    value: function applyTransform2(rect4, matrix3) {
      var topLeft = vec4_exports.fromValues(rect4.x, rect4.y, 0, 1);
      var topRight = vec4_exports.fromValues(rect4.x + rect4.width, rect4.y, 0, 1);
      var bottomLeft = vec4_exports.fromValues(rect4.x, rect4.y + rect4.height, 0, 1);
      var bottomRight = vec4_exports.fromValues(rect4.x + rect4.width, rect4.y + rect4.height, 0, 1);
      var transformedTopLeft = vec4_exports.create();
      var transformedTopRight = vec4_exports.create();
      var transformedBottomLeft = vec4_exports.create();
      var transformedBottomRight = vec4_exports.create();
      vec4_exports.transformMat4(transformedTopLeft, topLeft, matrix3);
      vec4_exports.transformMat4(transformedTopRight, topRight, matrix3);
      vec4_exports.transformMat4(transformedBottomLeft, bottomLeft, matrix3);
      vec4_exports.transformMat4(transformedBottomRight, bottomRight, matrix3);
      var minX = Math.min(transformedTopLeft[0], transformedTopRight[0], transformedBottomLeft[0], transformedBottomRight[0]);
      var minY = Math.min(transformedTopLeft[1], transformedTopRight[1], transformedBottomLeft[1], transformedBottomRight[1]);
      var maxX = Math.max(transformedTopLeft[0], transformedTopRight[0], transformedBottomLeft[0], transformedBottomRight[0]);
      var maxY2 = Math.max(transformedTopLeft[1], transformedTopRight[1], transformedBottomLeft[1], transformedBottomRight[1]);
      return Rectangle2.fromRect({
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY2 - minY
      });
    }
  }]);
}();
var ERROR_MSG_METHOD_NOT_IMPLEMENTED = "Method not implemented.";
var ERROR_MSG_USE_DOCUMENT_ELEMENT = "Use document.documentElement instead.";
var ERROR_MSG_APPEND_DESTROYED_ELEMENT = "Cannot append a destroyed element.";
function getAngle2(angle4) {
  if (angle4 === void 0) {
    return 0;
  }
  if (angle4 > 360 || angle4 < -360) {
    return angle4 % 360;
  }
  return angle4;
}
var $vec3$2 = vec3_exports.create();
function createVec3(x3) {
  var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var clone8 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  if (Array.isArray(x3) && x3.length === 3) {
    return clone8 ? vec3_exports.clone(x3) : vec3_exports.copy($vec3$2, x3);
  }
  if (isNumber(x3)) {
    return clone8 ? vec3_exports.fromValues(x3, y3, z) : vec3_exports.set($vec3$2, x3, y3, z);
  }
  return clone8 ? vec3_exports.fromValues(x3[0], x3[1] || y3, x3[2] || z) : vec3_exports.set($vec3$2, x3[0], x3[1] || y3, x3[2] || z);
}
var DEG_RAD = Math.PI / 180;
function deg2rad(deg2) {
  return deg2 * DEG_RAD;
}
var RAD_DEG = 180 / Math.PI;
function rad2deg(rad2) {
  return rad2 * RAD_DEG;
}
function turn2deg(turn2) {
  return 360 * turn2;
}
var HALF_PI = Math.PI / 2;
function getEulerFromQuat(out, quat2) {
  var x3 = quat2[0];
  var y3 = quat2[1];
  var z = quat2[2];
  var w = quat2[3];
  var x22 = x3 * x3;
  var y22 = y3 * y3;
  var z2 = z * z;
  var w2 = w * w;
  var unit = x22 + y22 + z2 + w2;
  var test = x3 * w - y3 * z;
  if (test > 0.499995 * unit) {
    out[0] = HALF_PI;
    out[1] = 2 * Math.atan2(y3, x3);
    out[2] = 0;
  } else if (test < -0.499995 * unit) {
    out[0] = -HALF_PI;
    out[1] = 2 * Math.atan2(y3, x3);
    out[2] = 0;
  } else {
    out[0] = Math.asin(2 * (x3 * z - w * y3));
    out[1] = Math.atan2(2 * (x3 * w + y3 * z), 1 - 2 * (z2 + w2));
    out[2] = Math.atan2(2 * (x3 * y3 + z * w), 1 - 2 * (y22 + z2));
  }
  return out;
}
function getEulerFromMat4(out, m3) {
  var x3;
  var z;
  var _mat4$getScaling = mat4_exports.getScaling(vec3_exports.create(), m3), _mat4$getScaling2 = _slicedToArray(_mat4$getScaling, 3), sx = _mat4$getScaling2[0], sy = _mat4$getScaling2[1], sz = _mat4$getScaling2[2];
  var y3 = Math.asin(-m3[2] / sx);
  if (y3 < HALF_PI) {
    if (y3 > -HALF_PI) {
      x3 = Math.atan2(m3[6] / sy, m3[10] / sz);
      z = Math.atan2(m3[1] / sx, m3[0] / sx);
    } else {
      z = 0;
      x3 = -Math.atan2(m3[4] / sy, m3[5] / sy);
    }
  } else {
    z = 0;
    x3 = Math.atan2(m3[4] / sy, m3[5] / sy);
  }
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  return out;
}
function getEuler(out, quat2) {
  if (quat2.length === 16) {
    return getEulerFromMat4(out, quat2);
  }
  return getEulerFromQuat(out, quat2);
}
function fromRotationTranslationScale2(rotation, x3, y3, scaleX2, scaleY2) {
  var cos3 = Math.cos(rotation);
  var sin3 = Math.sin(rotation);
  return mat3_exports.fromValues(scaleX2 * cos3, scaleY2 * sin3, 0, -scaleX2 * sin3, scaleY2 * cos3, 0, x3, y3, 1);
}
function makePerspective(out, left2, right2, top, bottom, near, far) {
  var zero5 = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
  var twoNear = 2 * near;
  var rightMinusLeft = right2 - left2;
  var topMinusBottom = top - bottom;
  var x3 = twoNear / rightMinusLeft;
  var y3 = twoNear / topMinusBottom;
  var a4 = (right2 + left2) / rightMinusLeft;
  var b = (top + bottom) / topMinusBottom;
  var c5;
  var d3;
  var farMinusNear = far - near;
  var farMulNear = far * near;
  if (zero5) {
    c5 = -far / farMinusNear;
    d3 = -farMulNear / farMinusNear;
  } else {
    c5 = -(far + near) / farMinusNear;
    d3 = -2 * farMulNear / farMinusNear;
  }
  out[0] = x3;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = y3;
  out[6] = 0;
  out[7] = 0;
  out[8] = a4;
  out[9] = b;
  out[10] = c5;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = d3;
  out[15] = 0;
  return out;
}
function decompose(mat) {
  var row0x = mat[0];
  var row0y = mat[1];
  var row1x = mat[3];
  var row1y = mat[4];
  var scalingX = Math.sqrt(row0x * row0x + row0y * row0y);
  var scalingY = Math.sqrt(row1x * row1x + row1y * row1y);
  var determinant3 = row0x * row1y - row0y * row1x;
  if (determinant3 < 0) {
    if (row0x < row1y) {
      scalingX = -scalingX;
    } else {
      scalingY = -scalingY;
    }
  }
  if (scalingX) {
    var invScalingX = 1 / scalingX;
    row0x *= invScalingX;
    row0y *= invScalingX;
  }
  if (scalingY) {
    var invScalingY = 1 / scalingY;
    row1x *= invScalingY;
    row1y *= invScalingY;
  }
  var rotation = Math.atan2(row0y, row0x);
  var angle4 = rad2deg(rotation);
  return [mat[6], mat[7], scalingX, scalingY, angle4];
}
var tmp = mat4_exports.create();
var perspectiveMatrix = mat4_exports.create();
var tmpVec4 = vec4_exports.create();
var row = [vec3_exports.create(), vec3_exports.create(), vec3_exports.create()];
var pdum3 = vec3_exports.create();
function decomposeMat4(matrix3, translation, scale11, skew2, perspective2, quaternion) {
  if (!normalize6(tmp, matrix3))
    return false;
  mat4_exports.copy(perspectiveMatrix, tmp);
  perspectiveMatrix[3] = 0;
  perspectiveMatrix[7] = 0;
  perspectiveMatrix[11] = 0;
  perspectiveMatrix[15] = 1;
  if (Math.abs(mat4_exports.determinant(perspectiveMatrix)) < 1e-8)
    return false;
  var a03 = tmp[3];
  var a13 = tmp[7];
  var a23 = tmp[11];
  var a30 = tmp[12];
  var a31 = tmp[13];
  var a32 = tmp[14];
  var a33 = tmp[15];
  if (a03 !== 0 || a13 !== 0 || a23 !== 0) {
    tmpVec4[0] = a03;
    tmpVec4[1] = a13;
    tmpVec4[2] = a23;
    tmpVec4[3] = a33;
    var ret = mat4_exports.invert(perspectiveMatrix, perspectiveMatrix);
    if (!ret)
      return false;
    mat4_exports.transpose(perspectiveMatrix, perspectiveMatrix);
    vec4_exports.transformMat4(perspective2, tmpVec4, perspectiveMatrix);
  } else {
    perspective2[0] = perspective2[1] = perspective2[2] = 0;
    perspective2[3] = 1;
  }
  translation[0] = a30;
  translation[1] = a31;
  translation[2] = a32;
  mat3from4(row, tmp);
  scale11[0] = vec3_exports.length(row[0]);
  vec3_exports.normalize(row[0], row[0]);
  skew2[0] = vec3_exports.dot(row[0], row[1]);
  combine2(row[1], row[1], row[0], 1, -skew2[0]);
  scale11[1] = vec3_exports.length(row[1]);
  vec3_exports.normalize(row[1], row[1]);
  skew2[0] /= scale11[1];
  skew2[1] = vec3_exports.dot(row[0], row[2]);
  combine2(row[2], row[2], row[0], 1, -skew2[1]);
  skew2[2] = vec3_exports.dot(row[1], row[2]);
  combine2(row[2], row[2], row[1], 1, -skew2[2]);
  scale11[2] = vec3_exports.length(row[2]);
  vec3_exports.normalize(row[2], row[2]);
  skew2[1] /= scale11[2];
  skew2[2] /= scale11[2];
  vec3_exports.cross(pdum3, row[1], row[2]);
  if (vec3_exports.dot(row[0], pdum3) < 0) {
    for (var i = 0; i < 3; i++) {
      scale11[i] *= -1;
      row[i][0] *= -1;
      row[i][1] *= -1;
      row[i][2] *= -1;
    }
  }
  quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
  quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
  quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
  quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));
  if (row[2][1] > row[1][2])
    quaternion[0] = -quaternion[0];
  if (row[0][2] > row[2][0])
    quaternion[1] = -quaternion[1];
  if (row[1][0] > row[0][1])
    quaternion[2] = -quaternion[2];
  return true;
}
function normalize6(out, mat) {
  var m44 = mat[15];
  if (m44 === 0)
    return false;
  var scale11 = 1 / m44;
  for (var i = 0; i < 16; i++)
    out[i] = mat[i] * scale11;
  return true;
}
function mat3from4(out, mat4x4) {
  out[0][0] = mat4x4[0];
  out[0][1] = mat4x4[1];
  out[0][2] = mat4x4[2];
  out[1][0] = mat4x4[4];
  out[1][1] = mat4x4[5];
  out[1][2] = mat4x4[6];
  out[2][0] = mat4x4[8];
  out[2][1] = mat4x4[9];
  out[2][2] = mat4x4[10];
}
function combine2(out, a4, b, scale1, scale22) {
  out[0] = a4[0] * scale1 + b[0] * scale22;
  out[1] = a4[1] * scale1 + b[1] * scale22;
  out[2] = a4[2] * scale1 + b[2] * scale22;
}
var CameraType = function(CameraType2) {
  CameraType2[CameraType2["ORBITING"] = 0] = "ORBITING";
  CameraType2[CameraType2["EXPLORING"] = 1] = "EXPLORING";
  CameraType2[CameraType2["TRACKING"] = 2] = "TRACKING";
  return CameraType2;
}({});
var CameraTrackingMode = function(CameraTrackingMode2) {
  CameraTrackingMode2[CameraTrackingMode2["DEFAULT"] = 0] = "DEFAULT";
  CameraTrackingMode2[CameraTrackingMode2["ROTATIONAL"] = 1] = "ROTATIONAL";
  CameraTrackingMode2[CameraTrackingMode2["TRANSLATIONAL"] = 2] = "TRANSLATIONAL";
  CameraTrackingMode2[CameraTrackingMode2["CINEMATIC"] = 3] = "CINEMATIC";
  return CameraTrackingMode2;
}({});
var CameraProjectionMode = function(CameraProjectionMode2) {
  CameraProjectionMode2[CameraProjectionMode2["ORTHOGRAPHIC"] = 0] = "ORTHOGRAPHIC";
  CameraProjectionMode2[CameraProjectionMode2["PERSPECTIVE"] = 1] = "PERSPECTIVE";
  return CameraProjectionMode2;
}({});
var CameraEvent = {
  UPDATED: "updated"
};
var MIN_DISTANCE = 2e-4;
var Camera = function() {
  function Camera2() {
    _classCallCheck(this, Camera2);
    this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
    this.eventEmitter = new eventemitter3_default();
    this.matrix = mat4_exports.create();
    this.right = vec3_exports.fromValues(1, 0, 0);
    this.up = vec3_exports.fromValues(0, 1, 0);
    this.forward = vec3_exports.fromValues(0, 0, 1);
    this.position = vec3_exports.fromValues(0, 0, 1);
    this.focalPoint = vec3_exports.fromValues(0, 0, 0);
    this.distanceVector = vec3_exports.fromValues(0, 0, -1);
    this.distance = 1;
    this.azimuth = 0;
    this.elevation = 0;
    this.roll = 0;
    this.relAzimuth = 0;
    this.relElevation = 0;
    this.relRoll = 0;
    this.dollyingStep = 0;
    this.maxDistance = Infinity;
    this.minDistance = -Infinity;
    this.zoom = 1;
    this.rotateWorld = false;
    this.fov = 30;
    this.near = 0.1;
    this.far = 1e3;
    this.aspect = 1;
    this.projectionMatrix = mat4_exports.create();
    this.projectionMatrixInverse = mat4_exports.create();
    this.jitteredProjectionMatrix = void 0;
    this.enableUpdate = true;
    this.type = CameraType.EXPLORING;
    this.trackingMode = CameraTrackingMode.DEFAULT;
    this.projectionMode = CameraProjectionMode.PERSPECTIVE;
    this.frustum = new Frustum();
    this.orthoMatrix = mat4_exports.create();
  }
  return _createClass(Camera2, [{
    key: "isOrtho",
    value: (
      // constructor(type = CameraType.EXPLORING, trackingMode = CameraTrackingMode.DEFAULT) {
      //   this.setType(type, trackingMode);
      // }
      function isOrtho() {
        return this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC;
      }
    )
  }, {
    key: "getProjectionMode",
    value: function getProjectionMode() {
      return this.projectionMode;
    }
  }, {
    key: "getPerspective",
    value: function getPerspective() {
      return this.jitteredProjectionMatrix || this.projectionMatrix;
    }
  }, {
    key: "getPerspectiveInverse",
    value: function getPerspectiveInverse() {
      return this.projectionMatrixInverse;
    }
  }, {
    key: "getFrustum",
    value: function getFrustum() {
      return this.frustum;
    }
  }, {
    key: "getPosition",
    value: function getPosition() {
      return this.position;
    }
  }, {
    key: "getFocalPoint",
    value: function getFocalPoint() {
      return this.focalPoint;
    }
  }, {
    key: "getDollyingStep",
    value: function getDollyingStep() {
      return this.dollyingStep;
    }
  }, {
    key: "getNear",
    value: function getNear() {
      return this.near;
    }
  }, {
    key: "getFar",
    value: function getFar() {
      return this.far;
    }
  }, {
    key: "getZoom",
    value: function getZoom() {
      return this.zoom;
    }
  }, {
    key: "getOrthoMatrix",
    value: function getOrthoMatrix() {
      return this.orthoMatrix;
    }
  }, {
    key: "getView",
    value: function getView() {
      return this.view;
    }
  }, {
    key: "setEnableUpdate",
    value: function setEnableUpdate(enabled) {
      this.enableUpdate = enabled;
    }
  }, {
    key: "setType",
    value: function setType(type, trackingMode) {
      this.type = type;
      if (this.type === CameraType.EXPLORING) {
        this.setWorldRotation(true);
      } else {
        this.setWorldRotation(false);
      }
      this._getAngles();
      if (this.type === CameraType.TRACKING && trackingMode !== void 0) {
        this.setTrackingMode(trackingMode);
      }
      return this;
    }
  }, {
    key: "setProjectionMode",
    value: function setProjectionMode(projectionMode) {
      this.projectionMode = projectionMode;
      return this;
    }
  }, {
    key: "setTrackingMode",
    value: function setTrackingMode(trackingMode) {
      if (this.type !== CameraType.TRACKING) {
        throw new Error("Impossible to set a tracking mode if the camera is not of tracking type");
      }
      this.trackingMode = trackingMode;
      return this;
    }
    /**
     * If flag is true, it reverses the azimuth and elevation angles.
     * Subsequent calls to rotate, setAzimuth, setElevation,
     * changeAzimuth or changeElevation will cause the inverted effect.
     * setRoll or changeRoll is not affected by this method.
     *
     * This inversion is useful when one wants to simulate that the world
     * is moving, instead of the camera.
     *
     * By default the camera angles are not reversed.
     * @param {Boolean} flag the boolean flag to reverse the angles.
     */
  }, {
    key: "setWorldRotation",
    value: function setWorldRotation(flag) {
      this.rotateWorld = flag;
      this._getAngles();
      return this;
    }
    /**
     * 计算 MV 矩阵，为相机矩阵的逆矩阵
     */
  }, {
    key: "getViewTransform",
    value: function getViewTransform() {
      return mat4_exports.invert(mat4_exports.create(), this.matrix);
    }
  }, {
    key: "getWorldTransform",
    value: function getWorldTransform() {
      return this.matrix;
    }
  }, {
    key: "jitterProjectionMatrix",
    value: function jitterProjectionMatrix(x3, y3) {
      var translation = mat4_exports.fromTranslation(mat4_exports.create(), [x3, y3, 0]);
      this.jitteredProjectionMatrix = mat4_exports.multiply(mat4_exports.create(), translation, this.projectionMatrix);
    }
  }, {
    key: "clearJitterProjectionMatrix",
    value: function clearJitterProjectionMatrix() {
      this.jitteredProjectionMatrix = void 0;
    }
    /**
     * 设置相机矩阵
     */
  }, {
    key: "setMatrix",
    value: function setMatrix(matrix3) {
      this.matrix = matrix3;
      this._update();
      return this;
    }
    /**
     * Set projection matrix manually.
     */
  }, {
    key: "setProjectionMatrix",
    value: function setProjectionMatrix(matrix3) {
      this.projectionMatrix = matrix3;
    }
  }, {
    key: "setFov",
    value: function setFov(fov) {
      this.setPerspective(this.near, this.far, fov, this.aspect);
      return this;
    }
  }, {
    key: "setAspect",
    value: function setAspect(aspect) {
      this.setPerspective(this.near, this.far, this.fov, aspect);
      return this;
    }
  }, {
    key: "setNear",
    value: function setNear(near) {
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, near, this.far);
      }
      return this;
    }
  }, {
    key: "setFar",
    value: function setFar(far) {
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, far);
      }
      return this;
    }
    /**
     * Sets an offset in a larger frustum, used in PixelPicking
     */
  }, {
    key: "setViewOffset",
    value: function setViewOffset(fullWidth, fullHeight, x3, y3, width, height) {
      this.aspect = fullWidth / fullHeight;
      if (this.view === void 0) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x3;
      this.view.offsetY = y3;
      this.view.width = width;
      this.view.height = height;
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      }
      return this;
    }
  }, {
    key: "clearViewOffset",
    value: function clearViewOffset() {
      if (this.view !== void 0) {
        this.view.enabled = false;
      }
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      }
      return this;
    }
  }, {
    key: "setZoom",
    value: function setZoom(zoom) {
      this.zoom = zoom;
      if (this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      } else if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      }
      return this;
    }
    /**
     * Zoom by specified point in viewport coordinates.
     */
  }, {
    key: "setZoomByViewportPoint",
    value: function setZoomByViewportPoint(zoom, viewportPoint) {
      var _this$canvas$viewport = this.canvas.viewport2Canvas({
        x: viewportPoint[0],
        y: viewportPoint[1]
      }), ox = _this$canvas$viewport.x, oy = _this$canvas$viewport.y;
      var roll = this.roll;
      this.rotate(0, 0, -roll);
      this.setPosition(ox, oy);
      this.setFocalPoint(ox, oy);
      this.setZoom(zoom);
      this.rotate(0, 0, roll);
      var _this$canvas$viewport2 = this.canvas.viewport2Canvas({
        x: viewportPoint[0],
        y: viewportPoint[1]
      }), cx = _this$canvas$viewport2.x, cy = _this$canvas$viewport2.y;
      var dvec = vec3_exports.fromValues(cx - ox, cy - oy, 0);
      var dx = vec3_exports.dot(dvec, this.right) / vec3_exports.length(this.right);
      var dy = vec3_exports.dot(dvec, this.up) / vec3_exports.length(this.up);
      var _this$getPosition = this.getPosition(), _this$getPosition2 = _slicedToArray(_this$getPosition, 2), px2 = _this$getPosition2[0], py = _this$getPosition2[1];
      var _this$getFocalPoint = this.getFocalPoint(), _this$getFocalPoint2 = _slicedToArray(_this$getFocalPoint, 2), fx = _this$getFocalPoint2[0], fy = _this$getFocalPoint2[1];
      this.setPosition(px2 - dx, py - dy);
      this.setFocalPoint(fx - dx, fy - dy);
      return this;
    }
  }, {
    key: "setPerspective",
    value: function setPerspective(near, far, fov, aspect) {
      var _this$view;
      this.projectionMode = CameraProjectionMode.PERSPECTIVE;
      this.fov = fov;
      this.near = near;
      this.far = far;
      this.aspect = aspect;
      var top = this.near * Math.tan(deg2rad(0.5 * this.fov)) / this.zoom;
      var height = 2 * top;
      var width = this.aspect * height;
      var left2 = -0.5 * width;
      if ((_this$view = this.view) !== null && _this$view !== void 0 && _this$view.enabled) {
        var fullWidth = this.view.fullWidth;
        var fullHeight = this.view.fullHeight;
        left2 += this.view.offsetX * width / fullWidth;
        top -= this.view.offsetY * height / fullHeight;
        width *= this.view.width / fullWidth;
        height *= this.view.height / fullHeight;
      }
      makePerspective(this.projectionMatrix, left2, left2 + width, top - height, top, near, this.far, this.clipSpaceNearZ === ClipSpaceNearZ.ZERO);
      mat4_exports.invert(this.projectionMatrixInverse, this.projectionMatrix);
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "setOrthographic",
    value: function setOrthographic(l, r, t, b, near, far) {
      var _this$view2;
      this.projectionMode = CameraProjectionMode.ORTHOGRAPHIC;
      this.rright = r;
      this.left = l;
      this.top = t;
      this.bottom = b;
      this.near = near;
      this.far = far;
      var dx = (this.rright - this.left) / (2 * this.zoom);
      var dy = (this.top - this.bottom) / (2 * this.zoom);
      var cx = (this.rright + this.left) / 2;
      var cy = (this.top + this.bottom) / 2;
      var left2 = cx - dx;
      var right2 = cx + dx;
      var top = cy + dy;
      var bottom = cy - dy;
      if ((_this$view2 = this.view) !== null && _this$view2 !== void 0 && _this$view2.enabled) {
        var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;
        var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        left2 += scaleW * this.view.offsetX;
        right2 = left2 + scaleW * this.view.width;
        top -= scaleH * this.view.offsetY;
        bottom = top - scaleH * this.view.height;
      }
      if (this.clipSpaceNearZ === ClipSpaceNearZ.NEGATIVE_ONE) {
        mat4_exports.ortho(this.projectionMatrix, left2, right2, top, bottom, near, far);
      } else {
        mat4_exports.orthoZO(this.projectionMatrix, left2, right2, top, bottom, near, far);
      }
      mat4_exports.invert(this.projectionMatrixInverse, this.projectionMatrix);
      this._getOrthoMatrix();
      this.triggerUpdate();
      return this;
    }
    /**
     * Move the camera in world coordinates.
     * It will keep looking at the current focal point.
     *
     * support scalars or vectors.
     * @example
     * setPosition(1, 2, 3);
     * setPosition([1, 2, 3]);
     */
  }, {
    key: "setPosition",
    value: function setPosition(x3) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.position[1];
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.position[2];
      var position = createVec3(x3, y3, z);
      this._setPosition(position);
      this.setFocalPoint(this.focalPoint);
      this.triggerUpdate();
      return this;
    }
    /**
     * Sets the focal point of this camera in world coordinates.
     *
     * support scalars or vectors.
     * @example
     * setFocalPoint(1, 2, 3);
     * setFocalPoint([1, 2, 3]);
     */
  }, {
    key: "setFocalPoint",
    value: function setFocalPoint(x3) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.focalPoint[1];
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.focalPoint[2];
      var up = vec3_exports.fromValues(0, 1, 0);
      this.focalPoint = createVec3(x3, y3, z);
      if (this.trackingMode === CameraTrackingMode.CINEMATIC) {
        var d3 = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
        x3 = d3[0];
        y3 = d3[1];
        z = d3[2];
        var r = vec3_exports.length(d3);
        var el = rad2deg(Math.asin(y3 / r));
        var az = 90 + rad2deg(Math.atan2(z, x3));
        var m3 = mat4_exports.create();
        mat4_exports.rotateY(m3, m3, deg2rad(az));
        mat4_exports.rotateX(m3, m3, deg2rad(el));
        up = vec3_exports.transformMat4(vec3_exports.create(), [0, 1, 0], m3);
      }
      mat4_exports.invert(this.matrix, mat4_exports.lookAt(mat4_exports.create(), this.position, this.focalPoint, up));
      this._getAxes();
      this._getDistance();
      this._getAngles();
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "getDistance",
    value: function getDistance() {
      return this.distance;
    }
  }, {
    key: "getDistanceVector",
    value: function getDistanceVector() {
      return this.distanceVector;
    }
    /**
     * Moves the camera towards/from the focal point.
     */
  }, {
    key: "setDistance",
    value: function setDistance(d3) {
      if (this.distance === d3 || d3 < 0) {
        return this;
      }
      this.distance = d3;
      if (this.distance < MIN_DISTANCE) {
        this.distance = MIN_DISTANCE;
      }
      this.dollyingStep = this.distance / 100;
      var pos = vec3_exports.create();
      d3 = this.distance;
      var n = this.forward;
      var f = this.focalPoint;
      pos[0] = d3 * n[0] + f[0];
      pos[1] = d3 * n[1] + f[1];
      pos[2] = d3 * n[2] + f[2];
      this._setPosition(pos);
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "setMaxDistance",
    value: function setMaxDistance(d3) {
      this.maxDistance = d3;
      return this;
    }
  }, {
    key: "setMinDistance",
    value: function setMinDistance(d3) {
      this.minDistance = d3;
      return this;
    }
    /**
     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
     * the azimuth in degrees
     */
  }, {
    key: "setAzimuth",
    value: function setAzimuth(az) {
      this.azimuth = getAngle2(az);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "getAzimuth",
    value: function getAzimuth() {
      return this.azimuth;
    }
    /**
     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
     */
  }, {
    key: "setElevation",
    value: function setElevation(el) {
      this.elevation = getAngle2(el);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "getElevation",
    value: function getElevation() {
      return this.elevation;
    }
    /**
     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
     */
  }, {
    key: "setRoll",
    value: function setRoll(angle4) {
      this.roll = getAngle2(angle4);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "getRoll",
    value: function getRoll() {
      return this.roll;
    }
    /**
     * 根据相机矩阵重新计算各种相机参数
     */
  }, {
    key: "_update",
    value: function _update() {
      this._getAxes();
      this._getPosition();
      this._getDistance();
      this._getAngles();
      this._getOrthoMatrix();
      this.triggerUpdate();
    }
    /**
     * 计算相机矩阵
     */
  }, {
    key: "computeMatrix",
    value: function computeMatrix() {
      var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], deg2rad(this.roll));
      mat4_exports.identity(this.matrix);
      var rotX = quat_exports.setAxisAngle(quat_exports.create(), [1, 0, 0], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.elevation));
      var rotY = quat_exports.setAxisAngle(quat_exports.create(), [0, 1, 0], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.azimuth));
      var rotQ = quat_exports.multiply(quat_exports.create(), rotY, rotX);
      rotQ = quat_exports.multiply(quat_exports.create(), rotQ, rotZ);
      var rotMatrix = mat4_exports.fromQuat(mat4_exports.create(), rotQ);
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        mat4_exports.translate(this.matrix, this.matrix, this.focalPoint);
        mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
        mat4_exports.translate(this.matrix, this.matrix, [0, 0, this.distance]);
      } else if (this.type === CameraType.TRACKING) {
        mat4_exports.translate(this.matrix, this.matrix, this.position);
        mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
      }
    }
    /**
     * Sets the camera position in the camera matrix
     */
  }, {
    key: "_setPosition",
    value: function _setPosition(x3, y3, z) {
      this.position = createVec3(x3, y3, z);
      var m3 = this.matrix;
      m3[12] = this.position[0];
      m3[13] = this.position[1];
      m3[14] = this.position[2];
      m3[15] = 1;
      this._getOrthoMatrix();
    }
    /**
     * Recalculates axes based on the current matrix
     */
  }, {
    key: "_getAxes",
    value: function _getAxes() {
      vec3_exports.copy(this.right, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [1, 0, 0, 0], this.matrix)));
      vec3_exports.copy(this.up, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 1, 0, 0], this.matrix)));
      vec3_exports.copy(this.forward, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 1, 0], this.matrix)));
      vec3_exports.normalize(this.right, this.right);
      vec3_exports.normalize(this.up, this.up);
      vec3_exports.normalize(this.forward, this.forward);
    }
    /**
     * Recalculates euler angles based on the current state
     */
  }, {
    key: "_getAngles",
    value: function _getAngles() {
      var x3 = this.distanceVector[0];
      var y3 = this.distanceVector[1];
      var z = this.distanceVector[2];
      var r = vec3_exports.length(this.distanceVector);
      if (r === 0) {
        this.elevation = 0;
        this.azimuth = 0;
        return;
      }
      if (this.type === CameraType.TRACKING) {
        this.elevation = rad2deg(Math.asin(y3 / r));
        this.azimuth = rad2deg(Math.atan2(-x3, -z));
      } else if (this.rotateWorld) {
        this.elevation = rad2deg(Math.asin(y3 / r));
        this.azimuth = rad2deg(Math.atan2(-x3, -z));
      } else {
        this.elevation = -rad2deg(Math.asin(y3 / r));
        this.azimuth = -rad2deg(Math.atan2(-x3, -z));
      }
    }
    /**
     * 重新计算相机位置，只有 ORBITING 模式相机位置才会发生变化
     */
  }, {
    key: "_getPosition",
    value: function _getPosition() {
      vec3_exports.copy(this.position, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 0, 1], this.matrix)));
      this._getDistance();
    }
    /**
     * 重新计算视点，只有 TRACKING 模式视点才会发生变化
     */
  }, {
    key: "_getFocalPoint",
    value: function _getFocalPoint() {
      vec3_exports.transformMat3(this.distanceVector, [0, 0, -this.distance], mat3_exports.fromMat4(mat3_exports.create(), this.matrix));
      vec3_exports.add(this.focalPoint, this.position, this.distanceVector);
      this._getDistance();
    }
    /**
     * 重新计算视距
     */
  }, {
    key: "_getDistance",
    value: function _getDistance() {
      this.distanceVector = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
      this.distance = vec3_exports.length(this.distanceVector);
      this.dollyingStep = this.distance / 100;
    }
  }, {
    key: "_getOrthoMatrix",
    value: function _getOrthoMatrix() {
      if (this.projectionMode !== CameraProjectionMode.ORTHOGRAPHIC) {
        return;
      }
      var position = this.position;
      var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], -this.roll * Math.PI / 180);
      mat4_exports.fromRotationTranslationScaleOrigin(this.orthoMatrix, rotZ, vec3_exports.fromValues((this.rright - this.left) / 2 - position[0], (this.top - this.bottom) / 2 - position[1], 0), vec3_exports.fromValues(this.zoom, this.zoom, 1), position);
    }
  }, {
    key: "triggerUpdate",
    value: function triggerUpdate() {
      if (this.enableUpdate) {
        var viewMatrix = this.getViewTransform();
        var vpMatrix = mat4_exports.multiply(mat4_exports.create(), this.getPerspective(), viewMatrix);
        this.getFrustum().extractFromVPMatrix(vpMatrix);
        this.eventEmitter.emit(CameraEvent.UPDATED);
      }
    }
  }, {
    key: "rotate",
    value: function rotate7(azimuth, elevation, roll) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "pan",
    value: function pan(tx, ty) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "dolly",
    value: function dolly(value2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "createLandmark",
    value: function createLandmark(name2, params) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "gotoLandmark",
    value: function gotoLandmark(name2, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "cancelLandmarkAnimation",
    value: function cancelLandmarkAnimation() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }]);
}();
var Strategy = function(Strategy2) {
  Strategy2[Strategy2["Standard"] = 0] = "Standard";
  return Strategy2;
}({});
var SortReason = function(SortReason2) {
  SortReason2[SortReason2["ADDED"] = 0] = "ADDED";
  SortReason2[SortReason2["REMOVED"] = 1] = "REMOVED";
  SortReason2[SortReason2["Z_INDEX_CHANGED"] = 2] = "Z_INDEX_CHANGED";
  return SortReason2;
}({});
var EMPTY_PARSED_PATH = {
  absolutePath: [],
  hasArc: false,
  segments: [],
  polygons: [],
  polylines: [],
  curve: null,
  totalLength: 0,
  rect: new Rectangle(0, 0, 0, 0)
};
var PropertySyntax = function(PropertySyntax2) {
  PropertySyntax2["COORDINATE"] = "<coordinate>";
  PropertySyntax2["COLOR"] = "<color>";
  PropertySyntax2["PAINT"] = "<paint>";
  PropertySyntax2["NUMBER"] = "<number>";
  PropertySyntax2["ANGLE"] = "<angle>";
  PropertySyntax2["OPACITY_VALUE"] = "<opacity-value>";
  PropertySyntax2["SHADOW_BLUR"] = "<shadow-blur>";
  PropertySyntax2["LENGTH"] = "<length>";
  PropertySyntax2["PERCENTAGE"] = "<percentage>";
  PropertySyntax2["LENGTH_PERCENTAGE"] = "<length> | <percentage>";
  PropertySyntax2["LENGTH_PERCENTAGE_12"] = "[<length> | <percentage>]{1,2}";
  PropertySyntax2["LENGTH_PERCENTAGE_14"] = "[<length> | <percentage>]{1,4}";
  PropertySyntax2["LIST_OF_POINTS"] = "<list-of-points>";
  PropertySyntax2["PATH"] = "<path>";
  PropertySyntax2["FILTER"] = "<filter>";
  PropertySyntax2["Z_INDEX"] = "<z-index>";
  PropertySyntax2["OFFSET_DISTANCE"] = "<offset-distance>";
  PropertySyntax2["DEFINED_PATH"] = "<defined-path>";
  PropertySyntax2["MARKER"] = "<marker>";
  PropertySyntax2["TRANSFORM"] = "<transform>";
  PropertySyntax2["TRANSFORM_ORIGIN"] = "<transform-origin>";
  PropertySyntax2["TEXT"] = "<text>";
  PropertySyntax2["TEXT_TRANSFORM"] = "<text-transform>";
  return PropertySyntax2;
}({});
function define2(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define2(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format3) {
  var m3, l;
  format3 = (format3 + "").trim().toLowerCase();
  return (m3 = reHex.exec(format3)) ? (l = m3[1].length, m3 = parseInt(m3[1], 16), l === 6 ? rgbn(m3) : l === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format3)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format3)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format3)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format3)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a4) {
  if (a4 <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a4);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define2(Rgb, rgb, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a4 = clampa(this.opacity);
  return `${a4 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a4 === 1 ? ")" : `, ${a4})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value2) {
  return Math.max(0, Math.min(255, Math.round(value2) || 0));
}
function hex(value2) {
  value2 = clampi(value2);
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla(h, s3, l, a4) {
  if (a4 <= 0)
    h = s3 = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s3 = NaN;
  else if (s3 <= 0)
    h = NaN;
  return new Hsl(h, s3, l, a4);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min10 = Math.min(r, g, b), max11 = Math.max(r, g, b), h = NaN, s3 = max11 - min10, l = (max11 + min10) / 2;
  if (s3) {
    if (r === max11)
      h = (g - b) / s3 + (g < b) * 6;
    else if (g === max11)
      h = (b - r) / s3 + 2;
    else
      h = (r - g) / s3 + 4;
    s3 /= l < 0.5 ? max11 + min10 : 2 - max11 - min10;
    h *= 60;
  } else {
    s3 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s3, l, o.opacity);
}
function hsl(h, s3, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s3, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s3, l, opacity) {
  this.h = +h;
  this.s = +s3;
  this.l = +l;
  this.opacity = +opacity;
}
define2(Hsl, hsl, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s3 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m22 = l + (l < 0.5 ? l : 1 - l) * s3, m1 = 2 * l - m22;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m22),
      hsl2rgb(h, m1, m22),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m22),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a4 = clampa(this.opacity);
    return `${a4 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a4 === 1 ? ")" : `, ${a4})`}`;
  }
}));
function clamph(value2) {
  value2 = (value2 || 0) % 360;
  return value2 < 0 ? value2 + 360 : value2;
}
function clampt(value2) {
  return Math.max(0, Math.min(1, value2 || 0));
}
function hsl2rgb(h, m1, m22) {
  return (h < 60 ? m1 + (m22 - m1) * h / 60 : h < 180 ? m22 : h < 240 ? m1 + (m22 - m1) * (240 - h) / 60 : m1) * 255;
}
function memoize2(func, resolver) {
  if (typeof func !== "function" || resolver != null && typeof resolver !== "function") {
    throw new TypeError("Expected a function");
  }
  var _memoized = function memoized() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache2 = _memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    _memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  _memoized.cache = new (memoize2.Cache || Map)();
  memoize2.cacheList.push(_memoized.cache);
  return _memoized;
}
memoize2.Cache = Map;
memoize2.cacheList = [];
memoize2.clearCache = function() {
  memoize2.cacheList.forEach(function(cache2) {
    return cache2.clear();
  });
};
var UnitType = function(UnitType2) {
  UnitType2[UnitType2["kUnknown"] = 0] = "kUnknown";
  UnitType2[UnitType2["kNumber"] = 1] = "kNumber";
  UnitType2[UnitType2["kPercentage"] = 2] = "kPercentage";
  UnitType2[UnitType2["kEms"] = 3] = "kEms";
  UnitType2[UnitType2["kPixels"] = 4] = "kPixels";
  UnitType2[UnitType2["kRems"] = 5] = "kRems";
  UnitType2[UnitType2["kDegrees"] = 6] = "kDegrees";
  UnitType2[UnitType2["kRadians"] = 7] = "kRadians";
  UnitType2[UnitType2["kGradians"] = 8] = "kGradians";
  UnitType2[UnitType2["kTurns"] = 9] = "kTurns";
  UnitType2[UnitType2["kMilliseconds"] = 10] = "kMilliseconds";
  UnitType2[UnitType2["kSeconds"] = 11] = "kSeconds";
  UnitType2[UnitType2["kInteger"] = 12] = "kInteger";
  return UnitType2;
}({});
var UnitCategory = function(UnitCategory2) {
  UnitCategory2[UnitCategory2["kUNumber"] = 0] = "kUNumber";
  UnitCategory2[UnitCategory2["kUPercent"] = 1] = "kUPercent";
  UnitCategory2[UnitCategory2["kULength"] = 2] = "kULength";
  UnitCategory2[UnitCategory2["kUAngle"] = 3] = "kUAngle";
  UnitCategory2[UnitCategory2["kUTime"] = 4] = "kUTime";
  UnitCategory2[UnitCategory2["kUOther"] = 5] = "kUOther";
  return UnitCategory2;
}({});
var Nested = function(Nested2) {
  Nested2[Nested2["kYes"] = 0] = "kYes";
  Nested2[Nested2["kNo"] = 1] = "kNo";
  return Nested2;
}({});
var ParenLess = function(ParenLess2) {
  ParenLess2[ParenLess2["kYes"] = 0] = "kYes";
  ParenLess2[ParenLess2["kNo"] = 1] = "kNo";
  return ParenLess2;
}({});
var data = [
  {
    name: "em",
    unit_type: UnitType.kEms
  },
  // {
  //   name: 'ex',
  //   unit_type: UnitType.kExs,
  // },
  {
    name: "px",
    unit_type: UnitType.kPixels
  },
  // {
  //   name: "cm",
  //   unit_type: UnitType.kCentimeters,
  // },
  // {
  //   name: "mm",
  //   unit_type: UnitType.kMillimeters,
  // },
  // {
  //   name: "q",
  //   unit_type: UnitType.kQuarterMillimeters,
  // },
  // {
  //   name: "in",
  //   unit_type: UnitType.kInches,
  // },
  // {
  //   name: "pt",
  //   unit_type: UnitType.kPoints,
  // },
  // {
  //   name: "pc",
  //   unit_type: UnitType.kPicas,
  // },
  {
    name: "deg",
    unit_type: UnitType.kDegrees
  },
  {
    name: "rad",
    unit_type: UnitType.kRadians
  },
  {
    name: "grad",
    unit_type: UnitType.kGradians
  },
  {
    name: "ms",
    unit_type: UnitType.kMilliseconds
  },
  {
    name: "s",
    unit_type: UnitType.kSeconds
  },
  // {
  //   name: "hz",
  //   unit_type: UnitType.kHertz,
  // },
  // {
  //   name: "khz",
  //   unit_type: UnitType.kKilohertz,
  // },
  // {
  //   name: "dpi",
  //   unit_type: "kDotsPerInch",
  // },
  // {
  //   name: "dpcm",
  //   unit_type: "kDotsPerCentimeter",
  // },
  // {
  //   name: "dppx",
  //   unit_type: "kDotsPerPixel",
  // },
  // {
  //   name: "x",
  //   unit_type: "kDotsPerPixel",
  // },
  // {
  //   name: "vw",
  //   unit_type: "kViewportWidth",
  // },
  // {
  //   name: "vh",
  //   unit_type: "kViewportHeight",
  // },
  // {
  //   name: "vi",
  //   unit_type: "kViewportInlineSize",
  // },
  // {
  //   name: "vb",
  //   unit_type: "kViewportBlockSize",
  // },
  // {
  //   name: "vmin",
  //   unit_type: UnitType.kViewportMin,
  // },
  // {
  //   name: "vmax",
  //   unit_type: UnitType.kViewportMax,
  // },
  // {
  //   name: "svw",
  //   unit_type: "kSmallViewportWidth",
  // },
  // {
  //   name: "svh",
  //   unit_type: "kSmallViewportHeight",
  // },
  // {
  //   name: "svi",
  //   unit_type: "kSmallViewportInlineSize",
  // },
  // {
  //   name: "svb",
  //   unit_type: "kSmallViewportBlockSize",
  // },
  // {
  //   name: "svmin",
  //   unit_type: "kSmallViewportMin",
  // },
  // {
  //   name: "svmax",
  //   unit_type: "kSmallViewportMax",
  // },
  // {
  //   name: "lvw",
  //   unit_type: "kLargeViewportWidth",
  // },
  // {
  //   name: "lvh",
  //   unit_type: "kLargeViewportHeight",
  // },
  // {
  //   name: "lvi",
  //   unit_type: "kLargeViewportInlineSize",
  // },
  // {
  //   name: "lvb",
  //   unit_type: "kLargeViewportBlockSize",
  // },
  // {
  //   name: "lvmin",
  //   unit_type: UnitType.kLargeViewportMin,
  // },
  // {
  //   name: "lvmax",
  //   unit_type: UnitType.kLargeViewportMax,
  // },
  // {
  //   name: "dvw",
  //   unit_type: UnitType.kDynamicViewportWidth,
  // },
  // {
  //   name: "dvh",
  //   unit_type: UnitType.kDynamicViewportHeight,
  // },
  // {
  //   name: "dvi",
  //   unit_type: UnitType.kDynamicViewportInlineSize,
  // },
  // {
  //   name: "dvb",
  //   unit_type: UnitType.kDynamicViewportBlockSize,
  // },
  // {
  //   name: "dvmin",
  //   unit_type: UnitType.kDynamicViewportMin,
  // },
  // {
  //   name: "dvmax",
  //   unit_type: UnitType.kDynamicViewportMax,
  // },
  // {
  //   name: "cqw",
  //   unit_type: UnitType.kContainerWidth,
  // },
  // {
  //   name: "cqh",
  //   unit_type: UnitType.kContainerHeight,
  // },
  // {
  //   name: "cqi",
  //   unit_type: UnitType.kContainerInlineSize,
  // },
  // {
  //   name: "cqb",
  //   unit_type: UnitType.kContainerBlockSize,
  // },
  // {
  //   name: "cqmin",
  //   unit_type: UnitType.kContainerMin,
  // },
  // {
  //   name: "cqmax",
  //   unit_type: UnitType.kContainerMax,
  // },
  {
    name: "rem",
    unit_type: UnitType.kRems
  },
  // {
  //   name: 'fr',
  //   unit_type: UnitType.kFraction,
  // },
  {
    name: "turn",
    unit_type: UnitType.kTurns
  }
  // {
  //   name: 'ch',
  //   unit_type: UnitType.kChs,
  // },
  // {
  //   name: '__qem',
  //   unit_type: UnitType.kQuirkyEms,
  // },
];
var CSSStyleValueType = function(CSSStyleValueType2) {
  CSSStyleValueType2[CSSStyleValueType2["kUnknownType"] = 0] = "kUnknownType";
  CSSStyleValueType2[CSSStyleValueType2["kUnparsedType"] = 1] = "kUnparsedType";
  CSSStyleValueType2[CSSStyleValueType2["kKeywordType"] = 2] = "kKeywordType";
  CSSStyleValueType2[CSSStyleValueType2["kUnitType"] = 3] = "kUnitType";
  CSSStyleValueType2[CSSStyleValueType2["kSumType"] = 4] = "kSumType";
  CSSStyleValueType2[CSSStyleValueType2["kProductType"] = 5] = "kProductType";
  CSSStyleValueType2[CSSStyleValueType2["kNegateType"] = 6] = "kNegateType";
  CSSStyleValueType2[CSSStyleValueType2["kInvertType"] = 7] = "kInvertType";
  CSSStyleValueType2[CSSStyleValueType2["kMinType"] = 8] = "kMinType";
  CSSStyleValueType2[CSSStyleValueType2["kMaxType"] = 9] = "kMaxType";
  CSSStyleValueType2[CSSStyleValueType2["kClampType"] = 10] = "kClampType";
  CSSStyleValueType2[CSSStyleValueType2["kTransformType"] = 11] = "kTransformType";
  CSSStyleValueType2[CSSStyleValueType2["kPositionType"] = 12] = "kPositionType";
  CSSStyleValueType2[CSSStyleValueType2["kURLImageType"] = 13] = "kURLImageType";
  CSSStyleValueType2[CSSStyleValueType2["kColorType"] = 14] = "kColorType";
  CSSStyleValueType2[CSSStyleValueType2["kUnsupportedColorType"] = 15] = "kUnsupportedColorType";
  return CSSStyleValueType2;
}({});
var stringToUnitType = function stringToUnitType2(name2) {
  return data.find(function(item) {
    return item.name === name2;
  }).unit_type;
};
var unitFromName = function unitFromName2(name2) {
  if (!name2) {
    return UnitType.kUnknown;
  }
  if (name2 === "number") {
    return UnitType.kNumber;
  }
  if (name2 === "percent" || name2 === "%") {
    return UnitType.kPercentage;
  }
  return stringToUnitType(name2);
};
var unitTypeToUnitCategory = function unitTypeToUnitCategory2(type) {
  switch (type) {
    case UnitType.kNumber:
    case UnitType.kInteger:
      return UnitCategory.kUNumber;
    case UnitType.kPercentage:
      return UnitCategory.kUPercent;
    case UnitType.kPixels:
      return UnitCategory.kULength;
    case UnitType.kMilliseconds:
    case UnitType.kSeconds:
      return UnitCategory.kUTime;
    case UnitType.kDegrees:
    case UnitType.kRadians:
    case UnitType.kGradians:
    case UnitType.kTurns:
      return UnitCategory.kUAngle;
    default:
      return UnitCategory.kUOther;
  }
};
var canonicalUnitTypeForCategory = function canonicalUnitTypeForCategory2(category) {
  switch (category) {
    case UnitCategory.kUNumber:
      return UnitType.kNumber;
    case UnitCategory.kULength:
      return UnitType.kPixels;
    case UnitCategory.kUPercent:
      return UnitType.kPercentage;
    case UnitCategory.kUTime:
      return UnitType.kSeconds;
    case UnitCategory.kUAngle:
      return UnitType.kDegrees;
    default:
      return UnitType.kUnknown;
  }
};
var conversionToCanonicalUnitsScaleFactor = function conversionToCanonicalUnitsScaleFactor2(unit_type) {
  var factor = 1;
  switch (unit_type) {
    case UnitType.kPixels:
    case UnitType.kDegrees:
    case UnitType.kSeconds:
      break;
    case UnitType.kMilliseconds:
      factor = 1e-3;
      break;
    case UnitType.kRadians:
      factor = 180 / Math.PI;
      break;
    case UnitType.kGradians:
      factor = 0.9;
      break;
    case UnitType.kTurns:
      factor = 360;
      break;
  }
  return factor;
};
var unitTypeToString = function unitTypeToString2(type) {
  switch (type) {
    case UnitType.kNumber:
    case UnitType.kInteger:
      return "";
    case UnitType.kPercentage:
      return "%";
    case UnitType.kEms:
      return "em";
    case UnitType.kRems:
      return "rem";
    case UnitType.kPixels:
      return "px";
    case UnitType.kDegrees:
      return "deg";
    case UnitType.kRadians:
      return "rad";
    case UnitType.kGradians:
      return "grad";
    case UnitType.kMilliseconds:
      return "ms";
    case UnitType.kSeconds:
      return "s";
    case UnitType.kTurns:
      return "turn";
  }
  return "";
};
var CSSStyleValue = function() {
  function CSSStyleValue2() {
    _classCallCheck(this, CSSStyleValue2);
  }
  return _createClass(CSSStyleValue2, [{
    key: "toString",
    value: (
      // protected abstract toCSSValue(): CSSValue;
      function toString5() {
        return this.buildCSSText(Nested.kNo, ParenLess.kNo, "");
      }
    )
  }, {
    key: "isNumericValue",
    value: function isNumericValue() {
      return this.getType() >= CSSStyleValueType.kUnitType && this.getType() <= CSSStyleValueType.kClampType;
    }
  }], [{
    key: "isAngle",
    value: (
      // static parse(propertyName: string, value: string): CSSStyleValue {
      //   return parseCSSStyleValue(propertyName, value)[0];
      // }
      // static parseAll(propertyName: string, value: string): CSSStyleValue[] {
      //   return parseCSSStyleValue(propertyName, value);
      // }
      function isAngle(unit) {
        return unit === UnitType.kDegrees || unit === UnitType.kRadians || unit === UnitType.kGradians || unit === UnitType.kTurns;
      }
    )
    // static isViewportPercentageLength(type: UnitType) {
    //   return type >= UnitType.kViewportWidth && type <= UnitType.kDynamicViewportMax;
    // }
    // static isContainerPercentageLength(type: UnitType) {
    //   return type >= UnitType.kContainerWidth && type <= UnitType.kContainerMax;
    // }
  }, {
    key: "isLength",
    value: function isLength(type) {
      return type >= UnitType.kEms && type < UnitType.kDegrees;
    }
  }, {
    key: "isRelativeUnit",
    value: function isRelativeUnit(type) {
      return type === UnitType.kPercentage || type === UnitType.kEms || // type === UnitType.kExs ||
      type === UnitType.kRems;
    }
  }, {
    key: "isTime",
    value: function isTime(unit) {
      return unit === UnitType.kSeconds || unit === UnitType.kMilliseconds;
    }
    // static isFrequency(unit: UnitType) {
    //   return unit == UnitType.kHertz || unit == UnitType.kKilohertz;
    // }
    // static isResolution(type: UnitType) {
    //   return type >= UnitType.kDotsPerPixel && type <= UnitType.kDotsPerCentimeter;
    // }
    // static isFlex(unit: UnitType) {
    //   return unit === UnitType.kFraction;
    // }
  }]);
}();
var CSSColorValue = function(_CSSStyleValue) {
  function CSSColorValue2(colorSpace) {
    var _this2;
    _classCallCheck(this, CSSColorValue2);
    _this2 = _callSuper(this, CSSColorValue2);
    _this2.colorSpace = colorSpace;
    return _this2;
  }
  _inherits(CSSColorValue2, _CSSStyleValue);
  return _createClass(CSSColorValue2, [{
    key: "getType",
    value: function getType2() {
      return CSSStyleValueType.kColorType;
    }
    /**
     * @see https://drafts.css-houdini.org/css-typed-om-1/#dom-csscolorvalue-to
     */
  }, {
    key: "to",
    value: function to(colorSpace) {
      return this;
    }
  }]);
}(CSSStyleValue);
var GradientType = function(GradientType2) {
  GradientType2[GradientType2["Constant"] = 0] = "Constant";
  GradientType2[GradientType2["LinearGradient"] = 1] = "LinearGradient";
  GradientType2[GradientType2["RadialGradient"] = 2] = "RadialGradient";
  return GradientType2;
}({});
var CSSGradientValue = function(_CSSStyleValue) {
  function CSSGradientValue2(type, value2) {
    var _this2;
    _classCallCheck(this, CSSGradientValue2);
    _this2 = _callSuper(this, CSSGradientValue2);
    _this2.type = type;
    _this2.value = value2;
    return _this2;
  }
  _inherits(CSSGradientValue2, _CSSStyleValue);
  return _createClass(CSSGradientValue2, [{
    key: "clone",
    value: function clone8() {
      return new CSSGradientValue2(this.type, this.value);
    }
  }, {
    key: "buildCSSText",
    value: function buildCSSText(n, p2, result) {
      return result;
    }
  }, {
    key: "getType",
    value: function getType2() {
      return CSSStyleValueType.kColorType;
    }
  }]);
}(CSSStyleValue);
var CSSKeywordValue = function(_CSSStyleValue) {
  function CSSKeywordValue2(value2) {
    var _this2;
    _classCallCheck(this, CSSKeywordValue2);
    _this2 = _callSuper(this, CSSKeywordValue2);
    _this2.value = value2;
    return _this2;
  }
  _inherits(CSSKeywordValue2, _CSSStyleValue);
  return _createClass(CSSKeywordValue2, [{
    key: "clone",
    value: function clone8() {
      return new CSSKeywordValue2(this.value);
    }
  }, {
    key: "getType",
    value: function getType2() {
      return CSSStyleValueType.kKeywordType;
    }
  }, {
    key: "buildCSSText",
    value: function buildCSSText(n, p2, result) {
      return result + this.value;
    }
  }]);
}(CSSStyleValue);
var formatInfinityOrNaN = function formatInfinityOrNaN2(number3) {
  var suffix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  var result = "";
  if (!Number.isFinite(number3)) {
    if (number3 > 0)
      result = "infinity";
    else
      result = "-infinity";
  } else {
    result = "NaN";
  }
  return result += suffix;
};
var toCanonicalUnit = function toCanonicalUnit2(unit) {
  return canonicalUnitTypeForCategory(unitTypeToUnitCategory(unit));
};
var CSSUnitValue = function(_CSSStyleValue) {
  function CSSUnitValue2(value2) {
    var _this2;
    var unitOrName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UnitType.kNumber;
    _classCallCheck(this, CSSUnitValue2);
    _this2 = _callSuper(this, CSSUnitValue2);
    var unit;
    if (typeof unitOrName === "string") {
      unit = unitFromName(unitOrName);
    } else {
      unit = unitOrName;
    }
    _this2.unit = unit;
    _this2.value = value2;
    return _this2;
  }
  _inherits(CSSUnitValue2, _CSSStyleValue);
  return _createClass(CSSUnitValue2, [{
    key: "clone",
    value: function clone8() {
      return new CSSUnitValue2(this.value, this.unit);
    }
  }, {
    key: "equals",
    value: function equals7(other) {
      var other_unit_value = other;
      return this.value === other_unit_value.value && this.unit === other_unit_value.unit;
    }
  }, {
    key: "getType",
    value: function getType2() {
      return CSSStyleValueType.kUnitType;
    }
  }, {
    key: "convertTo",
    value: function convertTo(target_unit) {
      if (this.unit === target_unit) {
        return new CSSUnitValue2(this.value, this.unit);
      }
      var canonical_unit = toCanonicalUnit(this.unit);
      if (canonical_unit !== toCanonicalUnit(target_unit) || canonical_unit === UnitType.kUnknown) {
        return null;
      }
      var scale_factor = conversionToCanonicalUnitsScaleFactor(this.unit) / conversionToCanonicalUnitsScaleFactor(target_unit);
      return new CSSUnitValue2(this.value * scale_factor, target_unit);
    }
  }, {
    key: "buildCSSText",
    value: function buildCSSText(n, p2, result) {
      var text;
      switch (this.unit) {
        case UnitType.kUnknown:
          break;
        case UnitType.kInteger:
          text = Number(this.value).toFixed(0);
          break;
        case UnitType.kNumber:
        case UnitType.kPercentage:
        case UnitType.kEms:
        case UnitType.kRems:
        case UnitType.kPixels:
        case UnitType.kDegrees:
        case UnitType.kRadians:
        case UnitType.kGradians:
        case UnitType.kMilliseconds:
        case UnitType.kSeconds:
        case UnitType.kTurns: {
          var kMinInteger = -999999;
          var kMaxInteger = 999999;
          var value2 = this.value;
          var unit = unitTypeToString(this.unit);
          if (value2 < kMinInteger || value2 > kMaxInteger) {
            var _unit = unitTypeToString(this.unit);
            if (!Number.isFinite(value2) || Number.isNaN(value2)) {
              text = formatInfinityOrNaN(value2, _unit);
            } else {
              text = value2 + (_unit || "");
            }
          } else {
            text = "".concat(value2).concat(unit);
          }
        }
      }
      result += text;
      return result;
    }
  }]);
}(CSSStyleValue);
var Opx = new CSSUnitValue(0, "px");
new CSSUnitValue(1, "px");
var Odeg = new CSSUnitValue(0, "deg");
var CSSRGB = function(_CSSColorValue) {
  function CSSRGB2(r, g, b) {
    var _this2;
    var alpha = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    var isNone = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
    _classCallCheck(this, CSSRGB2);
    _this2 = _callSuper(this, CSSRGB2, ["rgb"]);
    _this2.r = r;
    _this2.g = g;
    _this2.b = b;
    _this2.alpha = alpha;
    _this2.isNone = isNone;
    return _this2;
  }
  _inherits(CSSRGB2, _CSSColorValue);
  return _createClass(CSSRGB2, [{
    key: "clone",
    value: function clone8() {
      return new CSSRGB2(this.r, this.g, this.b, this.alpha);
    }
  }, {
    key: "buildCSSText",
    value: function buildCSSText(n, p2, result) {
      return "".concat(result, "rgba(").concat(this.r, ",").concat(this.g, ",").concat(this.b, ",").concat(this.alpha, ")");
    }
  }]);
}(CSSColorValue);
var unsetKeywordValue = new CSSKeywordValue("unset");
var initialKeywordValue = new CSSKeywordValue("initial");
var inheritKeywordValue = new CSSKeywordValue("inherit");
var keywordCache = {
  "": unsetKeywordValue,
  unset: unsetKeywordValue,
  initial: initialKeywordValue,
  inherit: inheritKeywordValue
};
var getOrCreateKeyword = function getOrCreateKeyword2(name2) {
  if (!keywordCache[name2]) {
    keywordCache[name2] = new CSSKeywordValue(name2);
  }
  return keywordCache[name2];
};
var noneColor = new CSSRGB(0, 0, 0, 0, true);
var transparentColor = new CSSRGB(0, 0, 0, 0);
var getOrCreateRGBA = memoize2(function(r, g, b, a4) {
  return new CSSRGB(r, g, b, a4);
}, function(r, g, b, a4) {
  return "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a4, ")");
});
var getOrCreateUnitValue = function getOrCreateUnitValue2(value2) {
  var unitOrName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UnitType.kNumber;
  return new CSSUnitValue(value2, unitOrName);
};
new CSSUnitValue(50, "%");
function colorStopToString(colorStop) {
  var type = colorStop.type, value2 = colorStop.value;
  if (type === "hex") {
    return "#".concat(value2);
  }
  if (type === "literal") {
    return value2;
  }
  if (type === "rgb") {
    return "rgb(".concat(value2.join(","), ")");
  }
  return "rgba(".concat(value2.join(","), ")");
}
var parseGradient$1 = function() {
  var tokens4 = {
    linearGradient: /^(linear\-gradient)/i,
    repeatingLinearGradient: /^(repeating\-linear\-gradient)/i,
    radialGradient: /^(radial\-gradient)/i,
    repeatingRadialGradient: /^(repeating\-radial\-gradient)/i,
    /**
     * @see https://projects.verou.me/conic-gradient/
     */
    conicGradient: /^(conic\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^\#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    rgbaColor: /^rgba/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  var input = "";
  function error3(msg) {
    throw new Error("".concat(input, ": ").concat(msg));
  }
  function getAST() {
    var ast = matchListDefinitions();
    if (input.length > 0) {
      error3("Invalid input not EOF");
    }
    return ast;
  }
  function matchListDefinitions() {
    return matchListing(matchDefinition);
  }
  function matchDefinition() {
    return matchGradient("linear-gradient", tokens4.linearGradient, matchLinearOrientation) || matchGradient("repeating-linear-gradient", tokens4.repeatingLinearGradient, matchLinearOrientation) || matchGradient("radial-gradient", tokens4.radialGradient, matchListRadialOrientations) || matchGradient("repeating-radial-gradient", tokens4.repeatingRadialGradient, matchListRadialOrientations) || matchGradient("conic-gradient", tokens4.conicGradient, matchListRadialOrientations);
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return matchCall(pattern, function(captures) {
      var orientation = orientationMatcher();
      if (orientation) {
        if (!scan2(tokens4.comma)) {
          error3("Missing comma before color stops");
        }
      }
      return {
        type: gradientType,
        orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchCall(pattern, callback) {
    var captures = scan2(pattern);
    if (captures) {
      if (!scan2(tokens4.startCall)) {
        error3("Missing (");
      }
      var result = callback(captures);
      if (!scan2(tokens4.endCall)) {
        error3("Missing )");
      }
      return result;
    }
  }
  function matchLinearOrientation() {
    return matchSideOrCorner() || matchAngle();
  }
  function matchSideOrCorner() {
    return match("directional", tokens4.sideOrCorner, 1);
  }
  function matchAngle() {
    return match("angular", tokens4.angleValue, 1);
  }
  function matchListRadialOrientations() {
    var radialOrientations;
    var radialOrientation = matchRadialOrientation();
    var lookaheadCache;
    if (radialOrientation) {
      radialOrientations = [];
      radialOrientations.push(radialOrientation);
      lookaheadCache = input;
      if (scan2(tokens4.comma)) {
        radialOrientation = matchRadialOrientation();
        if (radialOrientation) {
          radialOrientations.push(radialOrientation);
        } else {
          input = lookaheadCache;
        }
      }
    }
    return radialOrientations;
  }
  function matchRadialOrientation() {
    var radialType = matchCircle() || matchEllipse();
    if (radialType) {
      radialType.at = matchAtPosition();
    } else {
      var extent2 = matchExtentKeyword();
      if (extent2) {
        radialType = extent2;
        var positionAt = matchAtPosition();
        if (positionAt) {
          radialType.at = positionAt;
        }
      } else {
        var defaultPosition = matchPositioning();
        if (defaultPosition) {
          radialType = {
            type: "default-radial",
            // @ts-ignore
            at: defaultPosition
          };
        }
      }
    }
    return radialType;
  }
  function matchCircle() {
    var circle3 = match("shape", /^(circle)/i, 0);
    if (circle3) {
      circle3.style = matchLength() || matchExtentKeyword();
    }
    return circle3;
  }
  function matchEllipse() {
    var ellipse = match("shape", /^(ellipse)/i, 0);
    if (ellipse) {
      ellipse.style = matchDistance() || matchExtentKeyword();
    }
    return ellipse;
  }
  function matchExtentKeyword() {
    return match("extent-keyword", tokens4.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match("position", /^at/, 0)) {
      var positioning = matchPositioning();
      if (!positioning) {
        error3("Missing positioning value");
      }
      return positioning;
    }
  }
  function matchPositioning() {
    var location = matchCoordinates();
    if (location.x || location.y) {
      return {
        type: "position",
        value: location
      };
    }
  }
  function matchCoordinates() {
    return {
      x: matchDistance(),
      y: matchDistance()
    };
  }
  function matchListing(matcher) {
    var captures = matcher();
    var result = [];
    if (captures) {
      result.push(captures);
      while (scan2(tokens4.comma)) {
        captures = matcher();
        if (captures) {
          result.push(captures);
        } else {
          error3("One extra comma");
        }
      }
    }
    return result;
  }
  function matchColorStop() {
    var color3 = matchColor();
    if (!color3) {
      error3("Expected color definition");
    }
    color3.length = matchDistance();
    return color3;
  }
  function matchColor() {
    return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
  }
  function matchLiteralColor() {
    return match("literal", tokens4.literalColor, 0);
  }
  function matchHexColor() {
    return match("hex", tokens4.hexColor, 1);
  }
  function matchRGBColor() {
    return matchCall(tokens4.rgbColor, function() {
      return {
        type: "rgb",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchRGBAColor() {
    return matchCall(tokens4.rgbaColor, function() {
      return {
        type: "rgba",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchNumber() {
    return scan2(tokens4.number)[1];
  }
  function matchDistance() {
    return match("%", tokens4.percentageValue, 1) || matchPositionKeyword() || matchLength();
  }
  function matchPositionKeyword() {
    return match("position-keyword", tokens4.positionKeywords, 1);
  }
  function matchLength() {
    return match("px", tokens4.pixelValue, 1) || match("em", tokens4.emValue, 1);
  }
  function match(type, pattern, captureIndex) {
    var captures = scan2(pattern);
    if (captures) {
      return {
        type,
        value: captures[captureIndex]
      };
    }
  }
  function scan2(regexp) {
    var blankCaptures = /^[\n\r\t\s]+/.exec(input);
    if (blankCaptures) {
      consume(blankCaptures[0].length);
    }
    var captures = regexp.exec(input);
    if (captures) {
      consume(captures[0].length);
    }
    return captures;
  }
  function consume(size3) {
    input = input.substring(size3);
  }
  return function(code) {
    input = code;
    return getAST();
  };
}();
function computeLinearGradient(min10, width, height, angle4) {
  var rad2 = deg2rad(angle4.value);
  var rx = 0;
  var ry = 0;
  var rcx = rx + width / 2;
  var rcy = ry + height / 2;
  var length5 = Math.abs(width * Math.cos(rad2)) + Math.abs(height * Math.sin(rad2));
  var x12 = min10[0] + rcx - Math.cos(rad2) * length5 / 2;
  var y12 = min10[1] + rcy - Math.sin(rad2) * length5 / 2;
  var x22 = min10[0] + rcx + Math.cos(rad2) * length5 / 2;
  var y22 = min10[1] + rcy + Math.sin(rad2) * length5 / 2;
  return {
    x1: x12,
    y1: y12,
    x2: x22,
    y2: y22
  };
}
function computeRadialGradient(min10, width, height, cx, cy, size3) {
  var x3 = cx.value;
  var y3 = cy.value;
  if (cx.unit === UnitType.kPercentage) {
    x3 = cx.value / 100 * width;
  }
  if (cy.unit === UnitType.kPercentage) {
    y3 = cy.value / 100 * height;
  }
  var r = Math.max(distanceSquareRoot([0, 0], [x3, y3]), distanceSquareRoot([0, height], [x3, y3]), distanceSquareRoot([width, height], [x3, y3]), distanceSquareRoot([width, 0], [x3, y3]));
  if (size3) {
    if (size3 instanceof CSSUnitValue) {
      r = size3.value;
    } else if (size3 instanceof CSSKeywordValue) {
      if (size3.value === "closest-side") {
        r = Math.min(x3, width - x3, y3, height - y3);
      } else if (size3.value === "farthest-side") {
        r = Math.max(x3, width - x3, y3, height - y3);
      } else if (size3.value === "closest-corner") {
        r = Math.min(distanceSquareRoot([0, 0], [x3, y3]), distanceSquareRoot([0, height], [x3, y3]), distanceSquareRoot([width, height], [x3, y3]), distanceSquareRoot([width, 0], [x3, y3]));
      }
    }
  }
  return {
    x: x3 + min10[0],
    y: y3 + min10[1],
    r
  };
}
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function spaceColorStops(colorStops) {
  var _colorStops$length;
  var length5 = colorStops.length;
  colorStops[length5 - 1].length = (_colorStops$length = colorStops[length5 - 1].length) !== null && _colorStops$length !== void 0 ? _colorStops$length : {
    type: "%",
    value: "100"
  };
  if (length5 > 1) {
    var _colorStops$0$length;
    colorStops[0].length = (_colorStops$0$length = colorStops[0].length) !== null && _colorStops$0$length !== void 0 ? _colorStops$0$length : {
      type: "%",
      value: "0"
    };
  }
  var previousIndex = 0;
  var previousOffset = Number(colorStops[0].length.value);
  for (var i = 1; i < length5; i++) {
    var _colorStops$i$length;
    var offset2 = (_colorStops$i$length = colorStops[i].length) === null || _colorStops$i$length === void 0 ? void 0 : _colorStops$i$length.value;
    if (!isNil(offset2) && !isNil(previousOffset)) {
      for (var j = 1; j < i - previousIndex; j++)
        colorStops[previousIndex + j].length = {
          type: "%",
          value: "".concat(previousOffset + (Number(offset2) - previousOffset) * j / (i - previousIndex))
        };
      previousIndex = i;
      previousOffset = Number(offset2);
    }
  }
}
var SideOrCornerToDegMap = {
  left: 270 - 90,
  top: 0 - 90,
  bottom: 180 - 90,
  right: 90 - 90,
  "left top": 315 - 90,
  "top left": 315 - 90,
  "left bottom": 225 - 90,
  "bottom left": 225 - 90,
  "right top": 45 - 90,
  "top right": 45 - 90,
  "right bottom": 135 - 90,
  "bottom right": 135 - 90
};
var angleToDeg = memoize2(function(orientation) {
  var angle4;
  if (orientation.type === "angular") {
    angle4 = Number(orientation.value);
  } else {
    angle4 = SideOrCornerToDegMap[orientation.value] || 0;
  }
  return getOrCreateUnitValue(angle4, "deg");
});
var positonToCSSUnitValue = memoize2(function(position) {
  var cx = 50;
  var cy = 50;
  var unitX = "%";
  var unitY = "%";
  if ((position === null || position === void 0 ? void 0 : position.type) === "position") {
    var _position$value = position.value, x3 = _position$value.x, y3 = _position$value.y;
    if ((x3 === null || x3 === void 0 ? void 0 : x3.type) === "position-keyword") {
      if (x3.value === "left") {
        cx = 0;
      } else if (x3.value === "center") {
        cx = 50;
      } else if (x3.value === "right") {
        cx = 100;
      } else if (x3.value === "top") {
        cy = 0;
      } else if (x3.value === "bottom") {
        cy = 100;
      }
    }
    if ((y3 === null || y3 === void 0 ? void 0 : y3.type) === "position-keyword") {
      if (y3.value === "left") {
        cx = 0;
      } else if (y3.value === "center") {
        cy = 50;
      } else if (y3.value === "right") {
        cx = 100;
      } else if (y3.value === "top") {
        cy = 0;
      } else if (y3.value === "bottom") {
        cy = 100;
      }
    }
    if ((x3 === null || x3 === void 0 ? void 0 : x3.type) === "px" || (x3 === null || x3 === void 0 ? void 0 : x3.type) === "%" || (x3 === null || x3 === void 0 ? void 0 : x3.type) === "em") {
      unitX = x3 === null || x3 === void 0 ? void 0 : x3.type;
      cx = Number(x3.value);
    }
    if ((y3 === null || y3 === void 0 ? void 0 : y3.type) === "px" || (y3 === null || y3 === void 0 ? void 0 : y3.type) === "%" || (y3 === null || y3 === void 0 ? void 0 : y3.type) === "em") {
      unitY = y3 === null || y3 === void 0 ? void 0 : y3.type;
      cy = Number(y3.value);
    }
  }
  return {
    cx: getOrCreateUnitValue(cx, unitX),
    cy: getOrCreateUnitValue(cy, unitY)
  };
});
var parseGradient = memoize2(function(colorStr) {
  if (colorStr.indexOf("linear") > -1 || colorStr.indexOf("radial") > -1) {
    var ast = parseGradient$1(colorStr);
    return ast.map(function(_ref) {
      var type2 = _ref.type, orientation = _ref.orientation, colorStops = _ref.colorStops;
      spaceColorStops(colorStops);
      var steps2 = colorStops.map(function(colorStop) {
        return {
          offset: getOrCreateUnitValue(Number(colorStop.length.value), "%"),
          color: colorStopToString(colorStop)
        };
      });
      if (type2 === "linear-gradient") {
        return new CSSGradientValue(GradientType.LinearGradient, {
          angle: orientation ? angleToDeg(orientation) : Odeg,
          steps: steps2
        });
      }
      if (type2 === "radial-gradient") {
        if (!orientation) {
          orientation = [{
            type: "shape",
            value: "circle"
          }];
        }
        if (orientation[0].type === "shape" && orientation[0].value === "circle") {
          var _positonToCSSUnitValu = positonToCSSUnitValue(orientation[0].at), cx = _positonToCSSUnitValu.cx, cy = _positonToCSSUnitValu.cy;
          var size3;
          if (orientation[0].style) {
            var _orientation$0$style = orientation[0].style, _type = _orientation$0$style.type, value2 = _orientation$0$style.value;
            if (_type === "extent-keyword") {
              size3 = getOrCreateKeyword(value2);
            } else {
              size3 = getOrCreateUnitValue(value2, _type);
            }
          }
          return new CSSGradientValue(GradientType.RadialGradient, {
            cx,
            cy,
            size: size3,
            steps: steps2
          });
        }
      }
      return void 0;
    });
  }
  var type = colorStr[0];
  if (colorStr[1] === "(" || colorStr[2] === "(") {
    if (type === "l") {
      var arr = regexLG.exec(colorStr);
      if (arr) {
        var _arr$2$match;
        var steps = ((_arr$2$match = arr[2].match(regexColorStop)) === null || _arr$2$match === void 0 ? void 0 : _arr$2$match.map(function(stop) {
          return stop.split(":");
        })) || [];
        return [new CSSGradientValue(GradientType.LinearGradient, {
          angle: getOrCreateUnitValue(parseFloat(arr[1]), "deg"),
          steps: steps.map(function(_ref2) {
            var _ref3 = _slicedToArray(_ref2, 2), offset2 = _ref3[0], color3 = _ref3[1];
            return {
              offset: getOrCreateUnitValue(Number(offset2) * 100, "%"),
              color: color3
            };
          })
        })];
      }
    } else if (type === "r") {
      var parsedRadialGradient = parseRadialGradient(colorStr);
      if (parsedRadialGradient) {
        if (isString(parsedRadialGradient)) {
          colorStr = parsedRadialGradient;
        } else {
          return [new CSSGradientValue(GradientType.RadialGradient, parsedRadialGradient)];
        }
      }
    } else if (type === "p") {
      return parsePattern(colorStr);
    }
  }
});
function parseRadialGradient(gradientStr) {
  var arr = regexRG.exec(gradientStr);
  if (arr) {
    var _arr$4$match;
    var steps = ((_arr$4$match = arr[4].match(regexColorStop)) === null || _arr$4$match === void 0 ? void 0 : _arr$4$match.map(function(stop) {
      return stop.split(":");
    })) || [];
    return {
      cx: getOrCreateUnitValue(50, "%"),
      cy: getOrCreateUnitValue(50, "%"),
      steps: steps.map(function(_ref4) {
        var _ref5 = _slicedToArray(_ref4, 2), offset2 = _ref5[0], color3 = _ref5[1];
        return {
          offset: getOrCreateUnitValue(Number(offset2) * 100, "%"),
          color: color3
        };
      })
    };
  }
  return null;
}
function parsePattern(patternStr) {
  var arr = regexPR.exec(patternStr);
  if (arr) {
    var repetition = arr[1];
    var src = arr[2];
    switch (repetition) {
      case "a":
        repetition = "repeat";
        break;
      case "x":
        repetition = "repeat-x";
        break;
      case "y":
        repetition = "repeat-y";
        break;
      case "n":
        repetition = "no-repeat";
        break;
      default:
        repetition = "no-repeat";
    }
    return {
      image: src,
      // @ts-ignore
      repetition
    };
  }
  return null;
}
function isPattern(object) {
  return object && !!object.image;
}
function isCSSRGB(object) {
  return object && !isNil(object.r) && !isNil(object.g) && !isNil(object.b);
}
var parseColor = memoize2(function(colorStr) {
  if (isPattern(colorStr)) {
    return _objectSpread2({
      repetition: "repeat"
    }, colorStr);
  }
  if (isNil(colorStr)) {
    colorStr = "";
  }
  if (colorStr === "transparent") {
    return transparentColor;
  }
  if (colorStr === "currentColor") {
    colorStr = "black";
  } else if (colorStr === "none") {
    return noneColor;
  }
  var g = parseGradient(colorStr);
  if (g) {
    return g;
  }
  var color$1 = color(colorStr);
  var rgba3 = [0, 0, 0, 0];
  if (color$1 !== null) {
    rgba3[0] = color$1.r || 0;
    rgba3[1] = color$1.g || 0;
    rgba3[2] = color$1.b || 0;
    rgba3[3] = color$1.opacity;
  }
  return getOrCreateRGBA.apply(void 0, rgba3);
});
function mergeColors(left2, right2) {
  if (!isCSSRGB(left2) || !isCSSRGB(right2)) {
    return;
  }
  return [[Number(left2.r), Number(left2.g), Number(left2.b), Number(left2.alpha)], [Number(right2.r), Number(right2.g), Number(right2.b), Number(right2.alpha)], function(color3) {
    var rgba3 = color3.slice();
    if (rgba3[3]) {
      for (var i = 0; i < 3; i++)
        rgba3[i] = Math.round(clamp_default(rgba3[i], 0, 255));
    }
    rgba3[3] = clamp_default(rgba3[3], 0, 1);
    return "rgba(".concat(rgba3.join(","), ")");
  }];
}
function parseDimension(unitRegExp, string) {
  if (isNil(string)) {
    return getOrCreateUnitValue(0, "px");
  }
  string = "".concat(string).trim().toLowerCase();
  if (isFinite(Number(string))) {
    if ("px".search(unitRegExp) >= 0) {
      return getOrCreateUnitValue(Number(string), "px");
    }
    if ("deg".search(unitRegExp) >= 0) {
      return getOrCreateUnitValue(Number(string), "deg");
    }
  }
  var matchedUnits = [];
  string = string.replace(unitRegExp, function(match) {
    matchedUnits.push(match);
    return "U".concat(match);
  });
  var taggedUnitRegExp = "U(".concat(unitRegExp.source, ")");
  return matchedUnits.map(function(unit) {
    return getOrCreateUnitValue(Number(string.replace(new RegExp("U".concat(unit), "g"), "").replace(new RegExp(taggedUnitRegExp, "g"), "*0")), unit);
  })[0];
}
var parseLengthUnmemoize = function parseLengthUnmemoize2(css) {
  return parseDimension(new RegExp("px", "g"), css);
};
var parseLength = memoize2(parseLengthUnmemoize);
var parserPercentageUnmemoize = function parserPercentageUnmemoize2(css) {
  return parseDimension(new RegExp("%", "g"), css);
};
memoize2(parserPercentageUnmemoize);
var parseLengthOrPercentageUnmemoize = function parseLengthOrPercentageUnmemoize2(css) {
  if (isNumber(css) || isFinite(Number(css))) {
    return getOrCreateUnitValue(Number(css) || 0, "px");
  }
  return parseDimension(new RegExp("px|%|em|rem", "g"), css);
};
var parseLengthOrPercentage = memoize2(parseLengthOrPercentageUnmemoize);
var parseAngleUnmemoize = function parseAngleUnmemoize2(css) {
  return parseDimension(new RegExp("deg|rad|grad|turn", "g"), css);
};
var parseAngle = memoize2(parseAngleUnmemoize);
function mergeDimensions(left2, right2, target, nonNegative) {
  var index3 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  var unit = "";
  var leftValue = left2.value || 0;
  var rightValue = right2.value || 0;
  var canonicalUnit = toCanonicalUnit(left2.unit);
  var leftCanonicalUnitValue = left2.convertTo(canonicalUnit);
  var rightCanonicalUnitValue = right2.convertTo(canonicalUnit);
  if (leftCanonicalUnitValue && rightCanonicalUnitValue) {
    leftValue = leftCanonicalUnitValue.value;
    rightValue = rightCanonicalUnitValue.value;
    unit = unitTypeToString(left2.unit);
  } else if (CSSUnitValue.isLength(left2.unit) || CSSUnitValue.isLength(right2.unit)) {
    leftValue = convertPercentUnit(left2, index3, target);
    rightValue = convertPercentUnit(right2, index3, target);
    unit = "px";
  }
  return [leftValue, rightValue, function(value2) {
    if (nonNegative) {
      value2 = Math.max(value2, 0);
    }
    return value2 + unit;
  }];
}
function convertAngleUnit(value2) {
  var deg2 = 0;
  if (value2.unit === UnitType.kDegrees) {
    deg2 = value2.value;
  } else if (value2.unit === UnitType.kRadians) {
    deg2 = rad2deg(Number(value2.value));
  } else if (value2.unit === UnitType.kTurns) {
    deg2 = turn2deg(Number(value2.value));
  } else if (value2.value) {
    deg2 = value2.value;
  }
  return deg2;
}
function parseDimensionArrayFormat(string, size3) {
  var parsed;
  if (Array.isArray(string)) {
    parsed = string.map(function(segment) {
      return Number(segment);
    });
  } else if (isString(string)) {
    parsed = string.split(" ").map(function(segment) {
      return Number(segment);
    });
  } else if (isNumber(string)) {
    parsed = [string];
  }
  if (size3 === 2) {
    if (parsed.length === 1) {
      return [parsed[0], parsed[0]];
    }
    return [parsed[0], parsed[1]];
  }
  if (size3 === 4) {
    if (parsed.length === 1) {
      return [parsed[0], parsed[0], parsed[0], parsed[0]];
    }
    if (parsed.length === 2) {
      return [parsed[0], parsed[1], parsed[0], parsed[1]];
    }
    if (parsed.length === 3) {
      return [parsed[0], parsed[1], parsed[2], parsed[1]];
    }
    return [parsed[0], parsed[1], parsed[2], parsed[3]];
  }
  if (size3 === "even" && parsed.length % 2 === 1) {
    return [].concat(_toConsumableArray(parsed), _toConsumableArray(parsed));
  }
  return parsed;
}
function convertPercentUnit(valueWithUnit, vec3Index, target) {
  var useMin = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (valueWithUnit.unit === UnitType.kPixels) {
    return Number(valueWithUnit.value);
  }
  if (valueWithUnit.unit === UnitType.kPercentage && target) {
    var bounds = target.nodeName === Shape.GROUP ? target.getLocalBounds() : target.getGeometryBounds();
    return (useMin ? bounds.min[vec3Index] : 0) + valueWithUnit.value / 100 * bounds.halfExtents[vec3Index] * 2;
  }
  return 0;
}
var parseParam = function parseParam2(css) {
  return parseDimension(/deg|rad|grad|turn|px|%/g, css);
};
var supportedFilters = ["blur", "brightness", "drop-shadow", "contrast", "grayscale", "sepia", "saturate", "hue-rotate", "invert"];
function parseFilter() {
  var filterStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  filterStr = filterStr.toLowerCase().trim();
  if (filterStr === "none") {
    return [];
  }
  var filterRegExp = /\s*([\w-]+)\(([^)]*)\)/g;
  var result = [];
  var match;
  var prevLastIndex = 0;
  while (match = filterRegExp.exec(filterStr)) {
    if (match.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match.index + match[0].length;
    if (supportedFilters.indexOf(match[1]) > -1) {
      result.push({
        name: match[1],
        params: match[2].split(" ").map(function(p2) {
          return parseParam(p2) || parseColor(p2);
        })
      });
    }
    if (filterRegExp.lastIndex === filterStr.length) {
      return result;
    }
  }
  return [];
}
function numberToString(x3) {
  return x3.toString();
}
var parseNumberUnmemoize = function parseNumberUnmemoize2(string) {
  if (typeof string === "number") {
    return getOrCreateUnitValue(string);
  }
  if (/^\s*[-+]?(\d*\.)?\d+\s*$/.test(string)) {
    return getOrCreateUnitValue(Number(string));
  }
  return getOrCreateUnitValue(0);
};
var parseNumber = memoize2(parseNumberUnmemoize);
memoize2(function(string) {
  if (isString(string)) {
    return string.split(" ").map(parseNumber);
  }
  return string.map(parseNumber);
});
function mergeNumbers(left2, right2) {
  return [left2, right2, numberToString];
}
function clampedMergeNumbers(min10, max11) {
  return function(left2, right2) {
    return [left2, right2, function(x3) {
      return numberToString(clamp_default(x3, min10, max11));
    }];
  };
}
function mergeNumberLists(left2, right2) {
  if (left2.length !== right2.length) {
    return;
  }
  return [left2, right2, function(numberList) {
    return numberList;
  }];
}
function getOrCalculatePathTotalLength(path2) {
  if (path2.parsedStyle.d.totalLength === 0) {
    path2.parsedStyle.d.totalLength = getTotalLength(path2.parsedStyle.d.absolutePath);
  }
  return path2.parsedStyle.d.totalLength;
}
function getOrCalculatePolylineTotalLength(polyline) {
  if (polyline.parsedStyle.points.totalLength === 0) {
    polyline.parsedStyle.points.totalLength = length$2(polyline.parsedStyle.points.points);
  }
  return polyline.parsedStyle.points.totalLength;
}
function removeRedundantMCommand(path2) {
  for (var i = 0; i < path2.length; i++) {
    var prevSegment = path2[i - 1];
    var segment = path2[i];
    var cmd = segment[0];
    if (cmd === "M") {
      if (prevSegment) {
        var prevCmd = prevSegment[0];
        var srcPoint = [segment[1], segment[2]];
        var destPoint = void 0;
        if (prevCmd === "L" || prevCmd === "M") {
          destPoint = [prevSegment[1], prevSegment[2]];
        } else if (prevCmd === "C" || prevCmd === "A" || prevCmd === "Q") {
          destPoint = [prevSegment[prevSegment.length - 2], prevSegment[prevSegment.length - 1]];
        }
        if (destPoint && isSamePoint(srcPoint, destPoint)) {
          path2.splice(i, 1);
          i--;
        }
      }
    }
  }
}
function hasArcOrBezier(path2) {
  var hasArc = false;
  var count4 = path2.length;
  for (var i = 0; i < count4; i++) {
    var params = path2[i];
    var cmd = params[0];
    if (cmd === "C" || cmd === "A" || cmd === "Q") {
      hasArc = true;
      break;
    }
  }
  return hasArc;
}
function extractPolygons(pathArray) {
  var polygons = [];
  var polylines = [];
  var points = [];
  for (var i = 0; i < pathArray.length; i++) {
    var params = pathArray[i];
    var cmd = params[0];
    if (cmd === "M") {
      if (points.length) {
        polylines.push(points);
        points = [];
      }
      points.push([params[1], params[2]]);
    } else if (cmd === "Z") {
      if (points.length) {
        polygons.push(points);
        points = [];
      }
    } else {
      points.push([params[1], params[2]]);
    }
  }
  if (points.length > 0) {
    polylines.push(points);
  }
  return {
    polygons,
    polylines
  };
}
function isSamePoint(point1, point22) {
  return point1[0] === point22[0] && point1[1] === point22[1];
}
function getPathBBox2(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
    var box2 = void 0;
    switch (segment.command) {
      case "Q":
        box2 = box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case "C":
        box2 = box$3(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case "A":
        var arcParams = segment.arcParams;
        box2 = box$5(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box2) {
      segment.box = box2;
      xArr.push(box2.x, box2.x + box2.width);
      yArr.push(box2.y, box2.y + box2.height);
    }
    if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  }
  xArr = xArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  yArr = yArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  var minX = min_default(xArr);
  var minY = min_default(yArr);
  var maxX = max(xArr);
  var maxY2 = max(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY2 - minY
    };
  }
  for (var _i = 0; _i < segmentsWithAngle.length; _i++) {
    var _segment = segmentsWithAngle[_i];
    var _currentPoint = _segment.currentPoint;
    var extra = void 0;
    if (_currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      minX -= extra.xExtra;
    } else if (_currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      maxX += extra.xExtra;
    }
    if (_currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      minY -= extra.yExtra;
    } else if (_currentPoint[1] === maxY2) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      maxY2 += extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  var extra = {
    // 水平方向投影
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    // 垂直方向投影
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
function toSymmetry(point7, center2) {
  return [center2[0] + (center2[0] - point7[0]), center2[1] + (center2[1] - point7[1])];
}
var angleBetween3 = function angleBetween4(v0, v1) {
  var p2 = v0.x * v1.x + v0.y * v1.y;
  var n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));
  var sign3 = v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1;
  var angle4 = sign3 * Math.acos(p2 / n);
  return angle4;
};
var pointOnEllipticalArc = function pointOnEllipticalArc2(p0, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p1, t) {
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  xAxisRotation = mod_default(xAxisRotation, 360);
  var xAxisRotationRadians = deg2rad(xAxisRotation);
  if (p0.x === p1.x && p0.y === p1.y) {
    return {
      x: p0.x,
      y: p0.y,
      ellipticalArcAngle: 0
    };
  }
  if (rx === 0 || ry === 0) {
    return {
      x: 0,
      y: 0,
      ellipticalArcAngle: 0
    };
  }
  var dx = (p0.x - p1.x) / 2;
  var dy = (p0.y - p1.y) / 2;
  var transformedPoint = {
    x: Math.cos(xAxisRotationRadians) * dx + Math.sin(xAxisRotationRadians) * dy,
    y: -Math.sin(xAxisRotationRadians) * dx + Math.cos(xAxisRotationRadians) * dy
  };
  var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
  if (radiiCheck > 1) {
    rx *= Math.sqrt(radiiCheck);
    ry *= Math.sqrt(radiiCheck);
  }
  var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  var cCoef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);
  var transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  var center2 = {
    x: Math.cos(xAxisRotationRadians) * transformedCenter.x - Math.sin(xAxisRotationRadians) * transformedCenter.y + (p0.x + p1.x) / 2,
    y: Math.sin(xAxisRotationRadians) * transformedCenter.x + Math.cos(xAxisRotationRadians) * transformedCenter.y + (p0.y + p1.y) / 2
  };
  var startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  var startAngle = angleBetween3({
    x: 1,
    y: 0
  }, startVector);
  var endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  var sweepAngle = angleBetween3(startVector, endVector);
  if (!sweepFlag && sweepAngle > 0) {
    sweepAngle -= 2 * Math.PI;
  } else if (sweepFlag && sweepAngle < 0) {
    sweepAngle += 2 * Math.PI;
  }
  sweepAngle %= 2 * Math.PI;
  var angle4 = startAngle + sweepAngle * t;
  var ellipseComponentX = rx * Math.cos(angle4);
  var ellipseComponentY = ry * Math.sin(angle4);
  var point7 = {
    x: Math.cos(xAxisRotationRadians) * ellipseComponentX - Math.sin(xAxisRotationRadians) * ellipseComponentY + center2.x,
    y: Math.sin(xAxisRotationRadians) * ellipseComponentX + Math.cos(xAxisRotationRadians) * ellipseComponentY + center2.y,
    ellipticalArcStartAngle: startAngle,
    ellipticalArcEndAngle: startAngle + sweepAngle,
    ellipticalArcAngle: angle4,
    ellipticalArcCenter: center2,
    resultantRx: rx,
    resultantRy: ry
  };
  return point7;
};
function path2Segments(path2) {
  var segments = [];
  var currentPoint = null;
  var nextParams = null;
  var startMovePoint = null;
  var lastStartMovePointIndex = 0;
  var count4 = path2.length;
  for (var i = 0; i < count4; i++) {
    var params = path2[i];
    nextParams = path2[i + 1];
    var command = params[0];
    var segment = {
      command,
      prePoint: currentPoint,
      params,
      startTangent: null,
      endTangent: null,
      currentPoint: null,
      nextPoint: null,
      arcParams: null,
      box: null,
      cubicParams: null
    };
    switch (command) {
      case "M":
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i;
        break;
      case "A":
        var arcParams = getArcParams(currentPoint, params);
        segment.arcParams = arcParams;
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
      nextParams = path2[lastStartMovePointIndex + 1];
    } else {
      var len5 = params.length;
      currentPoint = [params[len5 - 2], params[len5 - 1]];
    }
    if (nextParams && nextParams[0] === "Z") {
      nextParams = path2[lastStartMovePointIndex];
      if (segments[lastStartMovePointIndex]) {
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }
    segment.currentPoint = currentPoint;
    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }
    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment.nextPoint = nextPoint;
    var prePoint = segment.prePoint;
    if (["L", "H", "V"].includes(command)) {
      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
    } else if (command === "Q") {
      var cp = [params[1], params[2]];
      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === "T") {
      var preSegment = segments[i - 1];
      var _cp = toSymmetry(preSegment.currentPoint, prePoint);
      if (preSegment.command === "Q") {
        segment.command = "Q";
        segment.startTangent = [prePoint[0] - _cp[0], prePoint[1] - _cp[1]];
        segment.endTangent = [currentPoint[0] - _cp[0], currentPoint[1] - _cp[1]];
      } else {
        segment.command = "TL";
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      }
    } else if (command === "C") {
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      }
      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
      }
    } else if (command === "S") {
      var _preSegment = segments[i - 1];
      var _cp2 = toSymmetry(_preSegment.currentPoint, prePoint);
      var _cp3 = [params[1], params[2]];
      if (_preSegment.command === "C") {
        segment.command = "C";
        segment.startTangent = [prePoint[0] - _cp2[0], prePoint[1] - _cp2[1]];
        segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
      } else {
        segment.command = "SQ";
        segment.startTangent = [prePoint[0] - _cp3[0], prePoint[1] - _cp3[1]];
        segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
      }
    } else if (command === "A") {
      var _getTangentAtRatio = getTangentAtRatio(segment, 0), dx1 = _getTangentAtRatio.x, dy1 = _getTangentAtRatio.y;
      var _getTangentAtRatio2 = getTangentAtRatio(segment, 1, false), dx2 = _getTangentAtRatio2.x, dy2 = _getTangentAtRatio2.y;
      segment.startTangent = [dx1, dy1];
      segment.endTangent = [dx2, dy2];
    }
    segments.push(segment);
  }
  return segments;
}
function getTangentAtRatio(segment, ratio) {
  var sign3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var _segment$arcParams = segment.arcParams, _segment$arcParams$rx = _segment$arcParams.rx, rx = _segment$arcParams$rx === void 0 ? 0 : _segment$arcParams$rx, _segment$arcParams$ry = _segment$arcParams.ry, ry = _segment$arcParams$ry === void 0 ? 0 : _segment$arcParams$ry, xRotation = _segment$arcParams.xRotation, arcFlag = _segment$arcParams.arcFlag, sweepFlag = _segment$arcParams.sweepFlag;
  var p1 = pointOnEllipticalArc({
    x: segment.prePoint[0],
    y: segment.prePoint[1]
  }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
    x: segment.currentPoint[0],
    y: segment.currentPoint[1]
  }, ratio);
  var p2 = pointOnEllipticalArc({
    x: segment.prePoint[0],
    y: segment.prePoint[1]
  }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
    x: segment.currentPoint[0],
    y: segment.currentPoint[1]
  }, sign3 ? ratio + 5e-3 : ratio - 5e-3);
  var xDist = p2.x - p1.x;
  var yDist = p2.y - p1.y;
  var dist5 = Math.sqrt(xDist * xDist + yDist * yDist);
  return {
    x: -xDist / dist5,
    y: -yDist / dist5
  };
}
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}
function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod_default(deg2rad(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x12 = startPoint[0];
  var y12 = startPoint[1];
  var x22 = params[6];
  var y22 = params[7];
  var xp = Math.cos(xRotation) * (x12 - x22) / 2 + Math.sin(xRotation) * (y12 - y22) / 2;
  var yp = -1 * Math.sin(xRotation) * (x12 - x22) / 2 + Math.cos(xRotation) * (y12 - y22) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  var cx = (x12 + x22) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y12 + y22) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle([1, 0], u);
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta -= 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta += 2 * Math.PI;
  }
  return {
    cx,
    cy,
    // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理
    rx: isSamePoint(startPoint, [x22, y22]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x22, y22]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}
function commandsToPathString(commands, object, transform2) {
  return commands.reduce(function(prev, cur) {
    var path2 = "";
    if (cur[0] === "M" || cur[0] === "L") {
      var p2 = vec3_exports.fromValues(cur[1], cur[2], 0);
      if (transform2) {
        vec3_exports.transformMat4(p2, p2, transform2);
      }
      path2 = "".concat(cur[0]).concat(p2[0], ",").concat(p2[1]);
    } else if (cur[0] === "Z") {
      path2 = cur[0];
    } else if (cur[0] === "C") {
      var p1 = vec3_exports.fromValues(cur[1], cur[2], 0);
      var p22 = vec3_exports.fromValues(cur[3], cur[4], 0);
      var p3 = vec3_exports.fromValues(cur[5], cur[6], 0);
      if (transform2) {
        vec3_exports.transformMat4(p1, p1, transform2);
        vec3_exports.transformMat4(p22, p22, transform2);
        vec3_exports.transformMat4(p3, p3, transform2);
      }
      path2 = "".concat(cur[0]).concat(p1[0], ",").concat(p1[1], ",").concat(p22[0], ",").concat(p22[1], ",").concat(p3[0], ",").concat(p3[1]);
    } else if (cur[0] === "A") {
      var c5 = vec3_exports.fromValues(cur[6], cur[7], 0);
      if (transform2) {
        vec3_exports.transformMat4(c5, c5, transform2);
      }
      path2 = "".concat(cur[0]).concat(cur[1], ",").concat(cur[2], ",").concat(cur[3], ",").concat(cur[4], ",").concat(cur[5], ",").concat(c5[0], ",").concat(c5[1]);
    } else if (cur[0] === "Q") {
      var _p = vec3_exports.fromValues(cur[1], cur[2], 0);
      var _p2 = vec3_exports.fromValues(cur[3], cur[4], 0);
      if (transform2) {
        vec3_exports.transformMat4(_p, _p, transform2);
        vec3_exports.transformMat4(_p2, _p2, transform2);
      }
      path2 = "".concat(cur[0]).concat(cur[1], ",").concat(cur[2], ",").concat(cur[3], ",").concat(cur[4], "}");
    }
    return prev += path2;
  }, "");
}
function lineToCommands(x12, y12, x22, y22) {
  return [["M", x12, y12], ["L", x22, y22]];
}
function ellipseToCommands(rx, ry, cx, cy) {
  var factor = (-1 + Math.sqrt(2)) / 3 * 4;
  var dx = rx * factor;
  var dy = ry * factor;
  var left2 = cx - rx;
  var right2 = cx + rx;
  var top = cy - ry;
  var bottom = cy + ry;
  return [["M", left2, cy], ["C", left2, cy - dy, cx - dx, top, cx, top], ["C", cx + dx, top, right2, cy - dy, right2, cy], ["C", right2, cy + dy, cx + dx, bottom, cx, bottom], ["C", cx - dx, bottom, left2, cy + dy, left2, cy], ["Z"]];
}
function polygonToCommands(points, closed) {
  var result = points.map(function(point7, i) {
    return [i === 0 ? "M" : "L", point7[0], point7[1]];
  });
  if (closed) {
    result.push(["Z"]);
  }
  return result;
}
function rectToCommands(width, height, x3, y3, radius) {
  if (radius) {
    var _radius = _slicedToArray(radius, 4), tlr = _radius[0], trr = _radius[1], brr = _radius[2], blr = _radius[3];
    var signX = width > 0 ? 1 : -1;
    var signY = height > 0 ? 1 : -1;
    var sweepFlag = signX + signY !== 0 ? 1 : 0;
    return [["M", signX * tlr + x3, y3], ["L", width - signX * trr + x3, y3], trr ? ["A", trr, trr, 0, 0, sweepFlag, width + x3, signY * trr + y3] : null, ["L", width + x3, height - signY * brr + y3], brr ? ["A", brr, brr, 0, 0, sweepFlag, width + x3 - signX * brr, height + y3] : null, ["L", x3 + signX * blr, height + y3], blr ? ["A", blr, blr, 0, 0, sweepFlag, x3, height + y3 - signY * blr] : null, ["L", x3, signY * tlr + y3], tlr ? ["A", tlr, tlr, 0, 0, sweepFlag, signX * tlr + x3, y3] : null, ["Z"]].filter(function(command) {
      return command;
    });
  }
  return [["M", x3, y3], ["L", x3 + width, y3], ["L", x3 + width, y3 + height], ["L", x3, y3 + height], ["Z"]];
}
function convertToPath(object) {
  var transform2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : object.getLocalTransform();
  var commands = [];
  switch (object.nodeName) {
    case Shape.LINE:
      var _parsedStyle = object.parsedStyle, _parsedStyle$x = _parsedStyle.x1, x12 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = _parsedStyle.y1, y12 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, _parsedStyle$x2 = _parsedStyle.x2, x22 = _parsedStyle$x2 === void 0 ? 0 : _parsedStyle$x2, _parsedStyle$y2 = _parsedStyle.y2, y22 = _parsedStyle$y2 === void 0 ? 0 : _parsedStyle$y2;
      commands = lineToCommands(x12, y12, x22, y22);
      break;
    case Shape.CIRCLE: {
      var _parsedStyle2 = object.parsedStyle, _parsedStyle2$r = _parsedStyle2.r, r = _parsedStyle2$r === void 0 ? 0 : _parsedStyle2$r, _parsedStyle2$cx = _parsedStyle2.cx, cx = _parsedStyle2$cx === void 0 ? 0 : _parsedStyle2$cx, _parsedStyle2$cy = _parsedStyle2.cy, cy = _parsedStyle2$cy === void 0 ? 0 : _parsedStyle2$cy;
      commands = ellipseToCommands(r, r, cx, cy);
      break;
    }
    case Shape.ELLIPSE: {
      var _parsedStyle3 = object.parsedStyle, _parsedStyle3$rx = _parsedStyle3.rx, rx = _parsedStyle3$rx === void 0 ? 0 : _parsedStyle3$rx, _parsedStyle3$ry = _parsedStyle3.ry, ry = _parsedStyle3$ry === void 0 ? 0 : _parsedStyle3$ry, _parsedStyle3$cx = _parsedStyle3.cx, _cx = _parsedStyle3$cx === void 0 ? 0 : _parsedStyle3$cx, _parsedStyle3$cy = _parsedStyle3.cy, _cy = _parsedStyle3$cy === void 0 ? 0 : _parsedStyle3$cy;
      commands = ellipseToCommands(rx, ry, _cx, _cy);
      break;
    }
    case Shape.POLYLINE:
    case Shape.POLYGON:
      var points = object.parsedStyle.points;
      commands = polygonToCommands(points.points, object.nodeName === Shape.POLYGON);
      break;
    case Shape.RECT:
      var _parsedStyle4 = object.parsedStyle, _parsedStyle4$width = _parsedStyle4.width, width = _parsedStyle4$width === void 0 ? 0 : _parsedStyle4$width, _parsedStyle4$height = _parsedStyle4.height, height = _parsedStyle4$height === void 0 ? 0 : _parsedStyle4$height, _parsedStyle4$x = _parsedStyle4.x, x3 = _parsedStyle4$x === void 0 ? 0 : _parsedStyle4$x, _parsedStyle4$y = _parsedStyle4.y, y3 = _parsedStyle4$y === void 0 ? 0 : _parsedStyle4$y, radius = _parsedStyle4.radius;
      var hasRadius = radius && radius.some(function(r2) {
        return r2 !== 0;
      });
      commands = rectToCommands(width, height, x3, y3, hasRadius && radius.map(function(r2) {
        return clamp_default(r2, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
      }));
      break;
    case Shape.PATH:
      var absolutePath = object.parsedStyle.d.absolutePath;
      commands = _toConsumableArray(absolutePath);
      break;
  }
  if (commands.length) {
    return commandsToPathString(commands, object, transform2);
  }
}
var internalParsePath = function internalParsePath2(path2) {
  if (path2 === "" || Array.isArray(path2) && path2.length === 0) {
    return {
      absolutePath: [],
      hasArc: false,
      segments: [],
      polygons: [],
      polylines: [],
      curve: null,
      totalLength: 0,
      rect: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }
    };
  }
  var absolutePath;
  try {
    absolutePath = normalizePath(path2);
  } catch (_unused) {
    absolutePath = normalizePath("");
    console.error("[g]: Invalid SVG Path definition: ".concat(path2));
  }
  removeRedundantMCommand(absolutePath);
  var hasArc = hasArcOrBezier(absolutePath);
  var _extractPolygons = extractPolygons(absolutePath), polygons = _extractPolygons.polygons, polylines = _extractPolygons.polylines;
  var segments = path2Segments(absolutePath);
  var _getPathBBox = getPathBBox2(segments, 0), x3 = _getPathBBox.x, y3 = _getPathBBox.y, width = _getPathBBox.width, height = _getPathBBox.height;
  return {
    absolutePath,
    hasArc,
    segments,
    polygons,
    polylines,
    // curve,
    // Delay the calculation of length.
    totalLength: 0,
    rect: {
      x: Number.isFinite(x3) ? x3 : 0,
      y: Number.isFinite(y3) ? y3 : 0,
      width: Number.isFinite(width) ? width : 0,
      height: Number.isFinite(height) ? height : 0
    }
  };
};
var memoizedParsePath = memoize2(internalParsePath);
function parsePath(path2) {
  return isString(path2) ? memoizedParsePath(path2) : internalParsePath(path2);
}
function mergePaths(left2, right2, object) {
  var curve1 = left2.curve;
  var curve2 = right2.curve;
  if (!curve1 || curve1.length === 0) {
    curve1 = path2Curve(left2.absolutePath, false);
    left2.curve = curve1;
  }
  if (!curve2 || curve2.length === 0) {
    curve2 = path2Curve(right2.absolutePath, false);
    right2.curve = curve2;
  }
  var curves = [curve1, curve2];
  if (curve1.length !== curve2.length) {
    curves = equalizeSegments(curve1, curve2);
  }
  var curve0 = getDrawDirection(curves[0]) !== getDrawDirection(curves[1]) ? reverseCurve(curves[0]) : clonePath(curves[0]);
  return [curve0, getRotatedCurve(curves[1], curve0), function(pathArray) {
    return pathArray;
  }];
}
function parsePoints(pointsOrStr, object) {
  var points;
  if (isString(pointsOrStr)) {
    points = pointsOrStr.split(" ").map(function(pointStr) {
      var _pointStr$split = pointStr.split(","), _pointStr$split2 = _slicedToArray(_pointStr$split, 2), x3 = _pointStr$split2[0], y3 = _pointStr$split2[1];
      return [Number(x3), Number(y3)];
    });
  } else {
    points = pointsOrStr;
  }
  return {
    points,
    totalLength: 0,
    segments: []
  };
}
function mergePoints(left2, right2) {
  return [left2.points, right2.points, function(points) {
    return points;
  }];
}
var _ = null;
var TRANSFORM_REGEXP = /\s*(\w+)\(([^)]*)\)/g;
function cast(pattern) {
  return function(contents) {
    var i = 0;
    return pattern.map(function(x3) {
      return x3 === _ ? contents[i++] : x3;
    });
  };
}
function id(x3) {
  return x3;
}
var transformFunctions = {
  // @ts-ignore
  matrix: ["NNNNNN", [_, _, 0, 0, _, _, 0, 0, 0, 0, 1, 0, _, _, 0, 1], id],
  matrix3d: ["NNNNNNNNNNNNNNNN", id],
  rotate: ["A"],
  rotateX: ["A"],
  rotateY: ["A"],
  rotateZ: ["A"],
  rotate3d: ["NNNA"],
  perspective: ["L"],
  scale: ["Nn", cast([_, _, new CSSUnitValue(1)]), id],
  scaleX: ["N", cast([_, new CSSUnitValue(1), new CSSUnitValue(1)]), cast([_, new CSSUnitValue(1)])],
  scaleY: ["N", cast([new CSSUnitValue(1), _, new CSSUnitValue(1)]), cast([new CSSUnitValue(1), _])],
  scaleZ: ["N", cast([new CSSUnitValue(1), new CSSUnitValue(1), _])],
  scale3d: ["NNN", id],
  skew: ["Aa", null, id],
  skewX: ["A", null, cast([_, Odeg])],
  skewY: ["A", null, cast([Odeg, _])],
  translate: ["Tt", cast([_, _, Opx]), id],
  translateX: ["T", cast([_, Opx, Opx]), cast([_, Opx])],
  translateY: ["T", cast([Opx, _, Opx]), cast([Opx, _])],
  translateZ: ["L", cast([Opx, Opx, _])],
  translate3d: ["TTL", id]
};
function parseArrayTransform(transform2) {
  var result = [];
  var length5 = transform2.length;
  for (var i = 0; i < length5; i++) {
    var item = transform2[i];
    var name2 = item[0];
    var args = item.slice(1);
    if (name2 === "translate" || name2 === "skew") {
      if (args.length === 1)
        args.push(0);
    } else if (name2 === "scale") {
      if (args.length === 1)
        args.push(args[0]);
    }
    var functionData = transformFunctions[name2];
    if (!functionData)
      return [];
    var parsedArgs = args.map(function(value2) {
      return getOrCreateUnitValue(value2);
    });
    result.push({
      t: name2,
      d: parsedArgs
    });
  }
  return result;
}
function parseTransform(transform2) {
  if (Array.isArray(transform2)) {
    return parseArrayTransform(transform2);
  }
  transform2 = (transform2 || "none").trim();
  if (transform2 === "none") {
    return [];
  }
  var result = [];
  var match;
  var prevLastIndex = 0;
  TRANSFORM_REGEXP.lastIndex = 0;
  while (match = TRANSFORM_REGEXP.exec(transform2)) {
    if (match.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match.index + match[0].length;
    var functionName = match[1];
    var functionData = transformFunctions[functionName];
    if (!functionData) {
      return [];
    }
    var args = match[2].split(",");
    var argTypes = functionData[0];
    if (argTypes.length < args.length) {
      return [];
    }
    var parsedArgs = [];
    for (var i = 0; i < argTypes.length; i++) {
      var arg = args[i];
      var type = argTypes[i];
      var parsedArg = void 0;
      if (!arg) {
        parsedArg = {
          a: Odeg,
          n: parsedArgs[0],
          t: Opx
        }[type];
      } else {
        parsedArg = {
          A: function A6(s3) {
            return s3.trim() === "0" ? Odeg : parseAngle(s3);
          },
          N: parseNumber,
          T: parseLengthOrPercentage,
          L: parseLength
        }[type.toUpperCase()](arg);
      }
      if (parsedArg === void 0) {
        return [];
      }
      parsedArgs.push(parsedArg);
    }
    result.push({
      t: functionName,
      d: parsedArgs
    });
    if (TRANSFORM_REGEXP.lastIndex === transform2.length) {
      return result;
    }
  }
  return [];
}
function parseTransformUnmemoize(transform2) {
  if (Array.isArray(transform2)) {
    return parseArrayTransform(transform2);
  }
  transform2 = (transform2 || "none").trim();
  if (transform2 === "none") {
    return [];
  }
  var result = [];
  var match;
  var prevLastIndex = 0;
  TRANSFORM_REGEXP.lastIndex = 0;
  while (match = TRANSFORM_REGEXP.exec(transform2)) {
    if (match.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match.index + match[0].length;
    var functionName = match[1];
    var functionData = transformFunctions[functionName];
    if (!functionData) {
      return [];
    }
    var args = match[2].split(",");
    var argTypes = functionData[0];
    if (argTypes.length < args.length) {
      return [];
    }
    var parsedArgs = [];
    for (var i = 0; i < argTypes.length; i++) {
      var arg = args[i];
      var type = argTypes[i];
      var parsedArg = void 0;
      if (!arg) {
        parsedArg = {
          a: Odeg,
          n: parsedArgs[0],
          t: Opx
        }[type];
      } else {
        parsedArg = {
          A: function A6(s3) {
            return s3.trim() === "0" ? Odeg : parseAngleUnmemoize(s3);
          },
          N: parseNumberUnmemoize,
          T: parseLengthOrPercentageUnmemoize,
          L: parseLengthUnmemoize
        }[type.toUpperCase()](arg);
      }
      if (parsedArg === void 0) {
        return [];
      }
      parsedArgs.push(parsedArg);
    }
    result.push({
      t: functionName,
      d: parsedArgs
    });
    if (TRANSFORM_REGEXP.lastIndex === transform2.length) {
      return result;
    }
  }
  return [];
}
function convertItemToMatrix(item) {
  var x3;
  var y3;
  var z;
  var angle4;
  switch (item.t) {
    case "rotateX":
      angle4 = deg2rad(convertAngleUnit(item.d[0]));
      return [1, 0, 0, 0, 0, Math.cos(angle4), Math.sin(angle4), 0, 0, -Math.sin(angle4), Math.cos(angle4), 0, 0, 0, 0, 1];
    case "rotateY":
      angle4 = deg2rad(convertAngleUnit(item.d[0]));
      return [Math.cos(angle4), 0, -Math.sin(angle4), 0, 0, 1, 0, 0, Math.sin(angle4), 0, Math.cos(angle4), 0, 0, 0, 0, 1];
    case "rotate":
    case "rotateZ":
      angle4 = deg2rad(convertAngleUnit(item.d[0]));
      return [Math.cos(angle4), Math.sin(angle4), 0, 0, -Math.sin(angle4), Math.cos(angle4), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "rotate3d":
      x3 = item.d[0].value;
      y3 = item.d[1].value;
      z = item.d[2].value;
      angle4 = deg2rad(convertAngleUnit(item.d[3]));
      var sqrLength = x3 * x3 + y3 * y3 + z * z;
      if (sqrLength === 0) {
        x3 = 1;
        y3 = 0;
        z = 0;
      } else if (sqrLength !== 1) {
        var length5 = Math.sqrt(sqrLength);
        x3 /= length5;
        y3 /= length5;
        z /= length5;
      }
      var s3 = Math.sin(angle4 / 2);
      var sc = s3 * Math.cos(angle4 / 2);
      var sq = s3 * s3;
      return [1 - 2 * (y3 * y3 + z * z) * sq, 2 * (x3 * y3 * sq + z * sc), 2 * (x3 * z * sq - y3 * sc), 0, 2 * (x3 * y3 * sq - z * sc), 1 - 2 * (x3 * x3 + z * z) * sq, 2 * (y3 * z * sq + x3 * sc), 0, 2 * (x3 * z * sq + y3 * sc), 2 * (y3 * z * sq - x3 * sc), 1 - 2 * (x3 * x3 + y3 * y3) * sq, 0, 0, 0, 0, 1];
    case "scale":
      return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scaleX":
      return [item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scaleY":
      return [1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scaleZ":
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1];
    case "scale3d":
      return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, item.d[2].value, 0, 0, 0, 0, 1];
    case "skew":
      var xAngle = deg2rad(convertAngleUnit(item.d[0]));
      var yAngle = deg2rad(convertAngleUnit(item.d[1]));
      return [1, Math.tan(yAngle), 0, 0, Math.tan(xAngle), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "skewX":
      angle4 = deg2rad(convertAngleUnit(item.d[0]));
      return [1, 0, 0, 0, Math.tan(angle4), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "skewY":
      angle4 = deg2rad(convertAngleUnit(item.d[0]));
      return [1, Math.tan(angle4), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "translate":
      x3 = convertPercentUnit(item.d[0], 0, null) || 0;
      y3 = convertPercentUnit(item.d[1], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, y3, 0, 1];
    case "translateX":
      x3 = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, 0, 0, 1];
    case "translateY":
      y3 = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, y3, 0, 1];
    case "translateZ":
      z = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, z, 1];
    case "translate3d":
      x3 = convertPercentUnit(item.d[0], 0, null) || 0;
      y3 = convertPercentUnit(item.d[1], 0, null) || 0;
      z = convertPercentUnit(item.d[2], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, y3, z, 1];
    case "perspective":
      var t = convertPercentUnit(item.d[0], 0, null) || 0;
      var p2 = t ? -1 / t : 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, p2, 0, 0, 0, 1];
    case "matrix":
      return [item.d[0].value, item.d[1].value, 0, 0, item.d[2].value, item.d[3].value, 0, 0, 0, 0, 1, 0, item.d[4].value, item.d[5].value, 0, 1];
    case "matrix3d":
      return item.d.map(function(d3) {
        return d3.value;
      });
  }
}
function multiplyMatrices(a4, b) {
  return [a4[0] * b[0] + a4[4] * b[1] + a4[8] * b[2] + a4[12] * b[3], a4[1] * b[0] + a4[5] * b[1] + a4[9] * b[2] + a4[13] * b[3], a4[2] * b[0] + a4[6] * b[1] + a4[10] * b[2] + a4[14] * b[3], a4[3] * b[0] + a4[7] * b[1] + a4[11] * b[2] + a4[15] * b[3], a4[0] * b[4] + a4[4] * b[5] + a4[8] * b[6] + a4[12] * b[7], a4[1] * b[4] + a4[5] * b[5] + a4[9] * b[6] + a4[13] * b[7], a4[2] * b[4] + a4[6] * b[5] + a4[10] * b[6] + a4[14] * b[7], a4[3] * b[4] + a4[7] * b[5] + a4[11] * b[6] + a4[15] * b[7], a4[0] * b[8] + a4[4] * b[9] + a4[8] * b[10] + a4[12] * b[11], a4[1] * b[8] + a4[5] * b[9] + a4[9] * b[10] + a4[13] * b[11], a4[2] * b[8] + a4[6] * b[9] + a4[10] * b[10] + a4[14] * b[11], a4[3] * b[8] + a4[7] * b[9] + a4[11] * b[10] + a4[15] * b[11], a4[0] * b[12] + a4[4] * b[13] + a4[8] * b[14] + a4[12] * b[15], a4[1] * b[12] + a4[5] * b[13] + a4[9] * b[14] + a4[13] * b[15], a4[2] * b[12] + a4[6] * b[13] + a4[10] * b[14] + a4[14] * b[15], a4[3] * b[12] + a4[7] * b[13] + a4[11] * b[14] + a4[15] * b[15]];
}
function convertToMatrix(transformList) {
  if (transformList.length === 0) {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  return transformList.map(convertItemToMatrix).reduce(multiplyMatrices);
}
function makeMatrixDecomposition(transformList) {
  var translate6 = [0, 0, 0];
  var scale11 = [1, 1, 1];
  var skew2 = [0, 0, 0];
  var perspective2 = [0, 0, 0, 1];
  var quaternion = [0, 0, 0, 1];
  decomposeMat4(
    // @ts-ignore
    convertToMatrix(transformList),
    translate6,
    scale11,
    skew2,
    perspective2,
    quaternion
  );
  return [[translate6, scale11, skew2, quaternion, perspective2]];
}
var composeMatrix = function() {
  function multiply7(a4, b) {
    var result = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
    for (var i = 0; i < 4; i++) {
      for (var j = 0; j < 4; j++) {
        for (var k2 = 0; k2 < 4; k2++) {
          result[i][j] += b[i][k2] * a4[k2][j];
        }
      }
    }
    return result;
  }
  function is2D(m3) {
    return m3[0][2] === 0 && m3[0][3] === 0 && m3[1][2] === 0 && m3[1][3] === 0 && m3[2][0] === 0 && m3[2][1] === 0 && m3[2][2] === 1 && m3[2][3] === 0 && m3[3][2] === 0 && m3[3][3] === 1;
  }
  function composeMatrix2(translate6, scale11, skew2, quat2, perspective2) {
    var matrix3 = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    for (var i = 0; i < 4; i++) {
      matrix3[i][3] = perspective2[i];
    }
    for (var _i = 0; _i < 3; _i++) {
      for (var j = 0; j < 3; j++) {
        matrix3[3][_i] += translate6[j] * matrix3[j][_i];
      }
    }
    var x3 = quat2[0];
    var y3 = quat2[1];
    var z = quat2[2];
    var w = quat2[3];
    var rotMatrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    rotMatrix[0][0] = 1 - 2 * (y3 * y3 + z * z);
    rotMatrix[0][1] = 2 * (x3 * y3 - z * w);
    rotMatrix[0][2] = 2 * (x3 * z + y3 * w);
    rotMatrix[1][0] = 2 * (x3 * y3 + z * w);
    rotMatrix[1][1] = 1 - 2 * (x3 * x3 + z * z);
    rotMatrix[1][2] = 2 * (y3 * z - x3 * w);
    rotMatrix[2][0] = 2 * (x3 * z - y3 * w);
    rotMatrix[2][1] = 2 * (y3 * z + x3 * w);
    rotMatrix[2][2] = 1 - 2 * (x3 * x3 + y3 * y3);
    matrix3 = multiply7(matrix3, rotMatrix);
    var temp = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    if (skew2[2]) {
      temp[2][1] = skew2[2];
      matrix3 = multiply7(matrix3, temp);
    }
    if (skew2[1]) {
      temp[2][1] = 0;
      temp[2][0] = skew2[0];
      matrix3 = multiply7(matrix3, temp);
    }
    if (skew2[0]) {
      temp[2][0] = 0;
      temp[1][0] = skew2[0];
      matrix3 = multiply7(matrix3, temp);
    }
    for (var _i2 = 0; _i2 < 3; _i2++) {
      for (var _j = 0; _j < 3; _j++) {
        matrix3[_i2][_j] *= scale11[_i2];
      }
    }
    if (is2D(matrix3)) {
      return [matrix3[0][0], matrix3[0][1], matrix3[1][0], matrix3[1][1], matrix3[3][0], matrix3[3][1]];
    }
    return matrix3[0].concat(matrix3[1], matrix3[2], matrix3[3]);
  }
  return composeMatrix2;
}();
function numberToLongString(x3) {
  return x3.toFixed(6).replace(".000000", "");
}
function mergeMatrices(left2, right2) {
  var leftArgs;
  var rightArgs;
  if (left2.decompositionPair !== right2) {
    left2.decompositionPair = right2;
    leftArgs = makeMatrixDecomposition(left2);
  }
  if (right2.decompositionPair !== left2) {
    right2.decompositionPair = left2;
    rightArgs = makeMatrixDecomposition(right2);
  }
  if (leftArgs[0] === null || rightArgs[0] === null)
    return [
      // @ts-ignore
      [false],
      // @ts-ignore
      [true],
      // @ts-ignore
      function(x3) {
        return x3 ? right2[0].d : left2[0].d;
      }
    ];
  leftArgs[0].push(0);
  rightArgs[0].push(1);
  return [
    leftArgs,
    rightArgs,
    // @ts-ignore
    function(list) {
      var q = quat(leftArgs[0][3], rightArgs[0][3], list[5]);
      var mat = composeMatrix(list[0], list[1], list[2], q, list[4]);
      var stringifiedArgs = mat.map(numberToLongString).join(",");
      return stringifiedArgs;
    }
  ];
}
function dot5(v1, v2) {
  var result = 0;
  for (var i = 0; i < v1.length; i++) {
    result += v1[i] * v2[i];
  }
  return result;
}
function quat(fromQ, toQ, f) {
  var product = dot5(fromQ, toQ);
  product = clamp_default(product, -1, 1);
  var quat2 = [];
  if (product === 1) {
    quat2 = fromQ;
  } else {
    var theta = Math.acos(product);
    var w = Math.sin(f * theta) * 1 / Math.sqrt(1 - product * product);
    for (var i = 0; i < 4; i++) {
      quat2.push(fromQ[i] * (Math.cos(f * theta) - product * w) + toQ[i] * w);
    }
  }
  return quat2;
}
function typeTo2D(type) {
  return type.replace(/[XY]/, "");
}
function typeTo3D(type) {
  return type.replace(/(X|Y|Z|3d)?$/, "3d");
}
var isMatrixOrPerspective = function isMatrixOrPerspective2(lt, rt) {
  return lt === "perspective" && rt === "perspective" || (lt === "matrix" || lt === "matrix3d") && (rt === "matrix" || rt === "matrix3d");
};
function mergeTransforms(left2, right2, target) {
  var flipResults = false;
  if (!left2.length || !right2.length) {
    if (!left2.length) {
      flipResults = true;
      left2 = right2;
      right2 = [];
    }
    var _loop = function _loop2() {
      var _left$i = left2[i], type2 = _left$i.t, args = _left$i.d;
      var defaultValue = type2.substring(0, 5) === "scale" ? 1 : 0;
      right2.push({
        t: type2,
        d: args.map(function(arg) {
          if (typeof arg === "number") {
            return getOrCreateUnitValue(defaultValue);
          }
          return getOrCreateUnitValue(defaultValue, arg.unit);
        })
      });
    };
    for (var i = 0; i < left2.length; i++) {
      _loop();
    }
  }
  var leftResult = [];
  var rightResult = [];
  var types = [];
  if (left2.length !== right2.length) {
    var merged = mergeMatrices(left2, right2);
    leftResult = [merged[0]];
    rightResult = [merged[1]];
    types = [["matrix", [merged[2]]]];
  } else {
    for (var _i3 = 0; _i3 < left2.length; _i3++) {
      var leftType = left2[_i3].t;
      var rightType = right2[_i3].t;
      var leftArgs = left2[_i3].d;
      var rightArgs = right2[_i3].d;
      var leftFunctionData = transformFunctions[leftType];
      var rightFunctionData = transformFunctions[rightType];
      var type = void 0;
      if (isMatrixOrPerspective(leftType, rightType)) {
        var _merged = mergeMatrices([left2[_i3]], [right2[_i3]]);
        leftResult.push(_merged[0]);
        rightResult.push(_merged[1]);
        types.push(["matrix", [_merged[2]]]);
        continue;
      } else if (leftType === rightType) {
        type = leftType;
      } else if (leftFunctionData[2] && rightFunctionData[2] && typeTo2D(leftType) === typeTo2D(rightType)) {
        type = typeTo2D(leftType);
        leftArgs = leftFunctionData[2](leftArgs);
        rightArgs = rightFunctionData[2](rightArgs);
      } else if (leftFunctionData[1] && rightFunctionData[1] && typeTo3D(leftType) === typeTo3D(rightType)) {
        type = typeTo3D(leftType);
        leftArgs = leftFunctionData[1](leftArgs);
        rightArgs = rightFunctionData[1](rightArgs);
      } else {
        var _merged2 = mergeMatrices(left2, right2);
        leftResult = [_merged2[0]];
        rightResult = [_merged2[1]];
        types = [["matrix", [_merged2[2]]]];
        break;
      }
      var leftArgsCopy = [];
      var rightArgsCopy = [];
      var stringConversions = [];
      for (var j = 0; j < leftArgs.length; j++) {
        var _merged3 = mergeDimensions(leftArgs[j], rightArgs[j], target, false, j);
        leftArgsCopy[j] = _merged3[0];
        rightArgsCopy[j] = _merged3[1];
        stringConversions.push(_merged3[2]);
      }
      leftResult.push(leftArgsCopy);
      rightResult.push(rightArgsCopy);
      types.push([type, stringConversions]);
    }
  }
  if (flipResults) {
    var tmp2 = leftResult;
    leftResult = rightResult;
    rightResult = tmp2;
  }
  return [leftResult, rightResult, function(list) {
    return list.map(function(args, i2) {
      var stringifiedArgs = args.map(function(arg, j2) {
        return types[i2][1][j2](arg);
      }).join(",");
      if (types[i2][0] === "matrix" && stringifiedArgs.split(",").length === 16) {
        types[i2][0] = "matrix3d";
      }
      if (types[i2][0] === "matrix3d" && stringifiedArgs.split(",").length === 6) {
        types[i2][0] = "matrix";
      }
      return "".concat(types[i2][0], "(").concat(stringifiedArgs, ")");
    }).join(" ");
  }];
}
var parseTransformOrigin = memoize2(function(value2) {
  if (isString(value2)) {
    if (value2 === "text-anchor") {
      return [getOrCreateUnitValue(0, "px"), getOrCreateUnitValue(0, "px")];
    }
    var values4 = value2.split(" ");
    if (values4.length === 1) {
      if (values4[0] === "top" || values4[0] === "bottom") {
        values4[1] = values4[0];
        values4[0] = "center";
      } else {
        values4[1] = "center";
      }
    }
    if (values4.length !== 2) {
      return null;
    }
    return [parseLengthOrPercentage(convertKeyword2Percent(values4[0])), parseLengthOrPercentage(convertKeyword2Percent(values4[1]))];
  }
  return [getOrCreateUnitValue(value2[0] || 0, "px"), getOrCreateUnitValue(value2[1] || 0, "px")];
});
function convertKeyword2Percent(keyword) {
  if (keyword === "center") {
    return "50%";
  }
  if (keyword === "left" || keyword === "top") {
    return "0%";
  }
  if (keyword === "right" || keyword === "bottom") {
    return "100%";
  }
  return keyword;
}
var BUILT_IN_PROPERTIES = [
  {
    /**
     * used in CSS Layout API
     * eg. `display: 'flex'`
     */
    n: "display",
    k: ["none"]
  },
  {
    /**
     * range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
     */
    n: "opacity",
    "int": true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * inheritable, range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity
     * @see https://svgwg.org/svg2-draft/painting.html#FillOpacity
     */
    n: "fillOpacity",
    "int": true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * inheritable, range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-opacity
     * @see https://svgwg.org/svg2-draft/painting.html#StrokeOpacity
     */
    n: "strokeOpacity",
    "int": true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * background-color is not inheritable
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes
     */
    n: "fill",
    "int": true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.PAINT
  },
  {
    n: "fillRule",
    k: ["nonzero", "evenodd"],
    d: "nonzero"
  },
  /**
   * default to none
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke#usage_notes
   */
  {
    n: "stroke",
    "int": true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.PAINT,
    /**
     * Stroke 'none' won't affect geometry but others will.
     */
    l: true
  },
  {
    n: "shadowType",
    k: ["inner", "outer", "both"],
    d: "outer",
    l: true
  },
  {
    n: "shadowColor",
    "int": true,
    syntax: PropertySyntax.COLOR
  },
  {
    n: "shadowOffsetX",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "shadowOffsetY",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "shadowBlur",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.SHADOW_BLUR
  },
  {
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width
     */
    n: "lineWidth",
    "int": true,
    inh: true,
    d: "1",
    l: true,
    a: ["strokeWidth"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "increasedLineWidthForHitTesting",
    inh: true,
    d: "0",
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "lineJoin",
    inh: true,
    l: true,
    a: ["strokeLinejoin"],
    k: ["miter", "bevel", "round"],
    d: "miter"
  },
  {
    n: "lineCap",
    inh: true,
    l: true,
    a: ["strokeLinecap"],
    k: ["butt", "round", "square"],
    d: "butt"
  },
  {
    n: "lineDash",
    "int": true,
    inh: true,
    k: ["none"],
    a: ["strokeDasharray"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE_12
  },
  {
    n: "lineDashOffset",
    "int": true,
    inh: true,
    d: "0",
    a: ["strokeDashoffset"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "offsetPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "offsetDistance",
    "int": true,
    syntax: PropertySyntax.OFFSET_DISTANCE
  },
  {
    n: "dx",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "dy",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "zIndex",
    ind: true,
    "int": true,
    d: "0",
    k: ["auto"],
    syntax: PropertySyntax.Z_INDEX
  },
  {
    n: "visibility",
    k: ["visible", "hidden"],
    ind: true,
    inh: true,
    /**
     * support interpolation
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#interpolation
     */
    "int": true,
    d: "visible"
  },
  {
    n: "pointerEvents",
    inh: true,
    k: [
      "none",
      "auto",
      "stroke",
      "fill",
      "painted",
      "visible",
      "visiblestroke",
      "visiblefill",
      "visiblepainted",
      // 'bounding-box',
      "all"
    ],
    d: "auto"
  },
  {
    n: "filter",
    ind: true,
    l: true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.FILTER
  },
  {
    n: "clipPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "textPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "textPathSide",
    k: ["left", "right"],
    d: "left"
  },
  {
    n: "textPathStartOffset",
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "transform",
    p: 100,
    "int": true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.TRANSFORM
  },
  {
    n: "transformOrigin",
    p: 100,
    d: "0 0",
    // // int: true,
    // d: (nodeName: string) => {
    //   if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
    //     return 'center';
    //   }
    //   if (nodeName === Shape.TEXT) {
    //     return 'text-anchor';
    //   }
    //   return 'left top';
    // },
    l: true,
    syntax: PropertySyntax.TRANSFORM_ORIGIN
  },
  {
    n: "cx",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "cy",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "cz",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "r",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "rx",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "ry",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  // Rect Image Group
  {
    // x in local space
    n: "x",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    // y in local space
    n: "y",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    // z in local space
    n: "z",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "width",
    "int": true,
    l: true,
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/width
     */
    k: ["auto", "fit-content", "min-content", "max-content"],
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "height",
    "int": true,
    l: true,
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/height
     */
    k: ["auto", "fit-content", "min-content", "max-content"],
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "radius",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE_14
  },
  // Line
  {
    n: "x1",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "y1",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "z1",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "x2",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "y2",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "z2",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  // Path
  {
    n: "d",
    "int": true,
    l: true,
    d: "",
    syntax: PropertySyntax.PATH,
    p: 50
  },
  // Polyline & Polygon
  {
    n: "points",
    /**
     * support interpolation
     */
    "int": true,
    l: true,
    syntax: PropertySyntax.LIST_OF_POINTS,
    p: 50
  },
  // Text
  {
    n: "text",
    l: true,
    d: "",
    syntax: PropertySyntax.TEXT,
    p: 50
  },
  {
    n: "textTransform",
    l: true,
    inh: true,
    k: ["capitalize", "uppercase", "lowercase", "none"],
    d: "none",
    syntax: PropertySyntax.TEXT_TRANSFORM,
    p: 51
    // it must get parsed after text
  },
  {
    n: "font",
    l: true
  },
  {
    n: "fontSize",
    "int": true,
    inh: true,
    /**
     * @see https://www.w3schools.com/css/css_font_size.asp
     */
    d: "16px",
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "fontFamily",
    l: true,
    inh: true,
    d: "sans-serif"
  },
  {
    n: "fontStyle",
    l: true,
    inh: true,
    k: ["normal", "italic", "oblique"],
    d: "normal"
  },
  {
    n: "fontWeight",
    l: true,
    inh: true,
    k: ["normal", "bold", "bolder", "lighter"],
    d: "normal"
  },
  {
    n: "fontVariant",
    l: true,
    inh: true,
    k: ["normal", "small-caps"],
    d: "normal"
  },
  {
    n: "lineHeight",
    l: true,
    syntax: PropertySyntax.LENGTH,
    "int": true,
    d: "0"
  },
  {
    n: "letterSpacing",
    l: true,
    syntax: PropertySyntax.LENGTH,
    "int": true,
    d: "0"
  },
  {
    n: "miterLimit",
    l: true,
    syntax: PropertySyntax.NUMBER,
    d: function d(nodeName) {
      if (nodeName === Shape.PATH || nodeName === Shape.POLYGON || nodeName === Shape.POLYLINE) {
        return "4";
      }
      return "10";
    }
  },
  {
    n: "wordWrap",
    l: true
  },
  {
    n: "wordWrapWidth",
    l: true
  },
  {
    n: "maxLines",
    l: true
  },
  {
    n: "textOverflow",
    l: true,
    d: "clip"
  },
  {
    n: "leading",
    l: true
  },
  {
    n: "textBaseline",
    l: true,
    inh: true,
    k: ["top", "hanging", "middle", "alphabetic", "ideographic", "bottom"],
    d: "alphabetic"
  },
  {
    n: "textAlign",
    l: true,
    inh: true,
    k: ["start", "center", "middle", "end", "left", "right"],
    d: "start"
  },
  // {
  //   n: 'whiteSpace',
  //   l: true,
  // },
  {
    n: "markerStart",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerEnd",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerMid",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerStartOffset",
    syntax: PropertySyntax.LENGTH,
    l: true,
    "int": true,
    d: "0"
  },
  {
    n: "markerEndOffset",
    syntax: PropertySyntax.LENGTH,
    l: true,
    "int": true,
    d: "0"
  }
];
var GEOMETRY_ATTRIBUTE_NAMES = new Set(BUILT_IN_PROPERTIES.filter(function(n) {
  return !!n.l;
}).map(function(n) {
  return n.n;
}));
var propertyMetadataCache = {};
var DefaultStyleValueRegistry = function() {
  function DefaultStyleValueRegistry2(runtime2) {
    var _this2 = this;
    _classCallCheck(this, DefaultStyleValueRegistry2);
    this.runtime = runtime2;
    BUILT_IN_PROPERTIES.forEach(function(property) {
      _this2.registerMetadata(property);
    });
  }
  return _createClass(DefaultStyleValueRegistry2, [{
    key: "registerMetadata",
    value: function registerMetadata(metadata) {
      [metadata.n].concat(_toConsumableArray(metadata.a || [])).forEach(function(name2) {
        propertyMetadataCache[name2] = metadata;
      });
    }
  }, {
    key: "getPropertySyntax",
    value: function getPropertySyntax(syntax) {
      return this.runtime.CSSPropertySyntaxFactory[syntax];
    }
    /**
     * * parse value, eg.
     * fill: 'red' => CSSRGB
     * translateX: '10px' => CSSUnitValue { unit: 'px', value: 10 }
     * fontSize: '2em' => { unit: 'px', value: 32 }
     *
     * * calculate used value
     * * post process
     */
  }, {
    key: "processProperties",
    value: function processProperties(object, attributes) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        skipUpdateAttribute: false,
        skipParse: false,
        forceUpdateGeometry: false,
        usedAttributes: [],
        memoize: true
      };
      Object.assign(object.attributes, attributes);
      var oldClipPath = object.parsedStyle.clipPath;
      var oldOffsetPath = object.parsedStyle.offsetPath;
      assignParsedStyle(object, attributes);
      var needUpdateGeometry = !!options.forceUpdateGeometry;
      if (!needUpdateGeometry) {
        for (var i in attributes) {
          if (GEOMETRY_ATTRIBUTE_NAMES.has(i)) {
            needUpdateGeometry = true;
            break;
          }
        }
      }
      var list = getParsedStyleListOf(object);
      if (list.has("fill") && attributes.fill) {
        object.parsedStyle.fill = parseColor(attributes.fill);
      }
      if (list.has("stroke") && attributes.stroke) {
        object.parsedStyle.stroke = parseColor(attributes.stroke);
      }
      if (list.has("shadowColor") && attributes.shadowColor) {
        object.parsedStyle.shadowColor = parseColor(attributes.shadowColor);
      }
      if (list.has("filter") && attributes.filter) {
        object.parsedStyle.filter = parseFilter(attributes.filter);
      }
      if (list.has("radius") && !isNil(attributes.radius)) {
        object.parsedStyle.radius = parseDimensionArrayFormat(
          // @ts-ignore
          attributes.radius,
          4
        );
      }
      if (list.has("lineDash") && !isNil(attributes.lineDash)) {
        object.parsedStyle.lineDash = parseDimensionArrayFormat(attributes.lineDash, "even");
      }
      if (list.has("points") && attributes.points) {
        object.parsedStyle.points = parsePoints(attributes.points);
      }
      if (list.has("d") && attributes.d === "") {
        object.parsedStyle.d = _objectSpread2({}, EMPTY_PARSED_PATH);
      }
      if (list.has("d") && attributes.d) {
        object.parsedStyle.d = parsePath(
          // @ts-ignore
          attributes.d
        );
      }
      if (list.has("textTransform") && attributes.textTransform) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TEXT_TRANSFORM].calculator(null, null, {
          value: attributes.textTransform
        }, object, null);
      }
      if (list.has("clipPath") && !is_undefined_default(attributes.clipPath)) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.DEFINED_PATH].calculator("clipPath", oldClipPath, attributes.clipPath, object, this.runtime);
      }
      if (list.has("offsetPath") && attributes.offsetPath) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.DEFINED_PATH].calculator("offsetPath", oldOffsetPath, attributes.offsetPath, object, this.runtime);
      }
      if (list.has("transform") && attributes.transform) {
        object.parsedStyle.transform = parseTransform(attributes.transform);
      }
      if (list.has("transformOrigin") && attributes.transformOrigin) {
        object.parsedStyle.transformOrigin = parseTransformOrigin(attributes.transformOrigin);
      }
      if (list.has("markerStart") && attributes.markerStart) {
        object.parsedStyle.markerStart = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
          null,
          // @ts-ignore
          attributes.markerStart,
          // @ts-ignore
          attributes.markerStart,
          null,
          null
        );
      }
      if (list.has("markerEnd") && attributes.markerEnd) {
        object.parsedStyle.markerEnd = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
          null,
          // @ts-ignore
          attributes.markerEnd,
          // @ts-ignore
          attributes.markerEnd,
          null,
          null
        );
      }
      if (list.has("markerMid") && attributes.markerMid) {
        object.parsedStyle.markerMid = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
          "",
          // @ts-ignore
          attributes.markerMid,
          // @ts-ignore
          attributes.markerMid,
          null,
          null
        );
      }
      if (list.has("zIndex") && !isNil(attributes.zIndex)) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.Z_INDEX].postProcessor(object);
      }
      if (list.has("offsetDistance") && !isNil(attributes.offsetDistance)) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.OFFSET_DISTANCE].postProcessor(object);
      }
      if (list.has("transform") && attributes.transform) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TRANSFORM].postProcessor(object);
      }
      if (list.has("transformOrigin") && attributes.transformOrigin) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TRANSFORM_ORIGIN].postProcessor(object);
      }
      if (needUpdateGeometry) {
        object.geometry.dirty = true;
        object.renderable.boundsDirty = true;
        object.renderable.renderBoundsDirty = true;
        if (!options.forceUpdateGeometry) {
          this.runtime.sceneGraphService.dirtifyToRoot(object);
        }
      }
    }
    /**
     * update geometry when relative props changed,
     * eg. r of Circle, width/height of Rect
     */
  }, {
    key: "updateGeometry",
    value: function updateGeometry(object) {
      var nodeName = object.nodeName;
      var geometryUpdater = this.runtime.geometryUpdaterFactory[nodeName];
      if (geometryUpdater) {
        var geometry = object.geometry;
        if (!geometry.contentBounds) {
          geometry.contentBounds = new AABB();
        }
        if (!geometry.renderBounds) {
          geometry.renderBounds = new AABB();
        }
        var parsedStyle = object.parsedStyle;
        var _geometryUpdater$upda = geometryUpdater.update(parsedStyle, object), _geometryUpdater$upda2 = _geometryUpdater$upda.cx, cx = _geometryUpdater$upda2 === void 0 ? 0 : _geometryUpdater$upda2, _geometryUpdater$upda3 = _geometryUpdater$upda.cy, cy = _geometryUpdater$upda3 === void 0 ? 0 : _geometryUpdater$upda3, _geometryUpdater$upda4 = _geometryUpdater$upda.cz, cz = _geometryUpdater$upda4 === void 0 ? 0 : _geometryUpdater$upda4, _geometryUpdater$upda5 = _geometryUpdater$upda.hwidth, hwidth = _geometryUpdater$upda5 === void 0 ? 0 : _geometryUpdater$upda5, _geometryUpdater$upda6 = _geometryUpdater$upda.hheight, hheight = _geometryUpdater$upda6 === void 0 ? 0 : _geometryUpdater$upda6, _geometryUpdater$upda7 = _geometryUpdater$upda.hdepth, hdepth = _geometryUpdater$upda7 === void 0 ? 0 : _geometryUpdater$upda7;
        var halfExtents = [Math.abs(hwidth), Math.abs(hheight), hdepth];
        var stroke2 = parsedStyle.stroke, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$increase = parsedStyle.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _parsedStyle$increase === void 0 ? 0 : _parsedStyle$increase, _parsedStyle$shadowTy = parsedStyle.shadowType, shadowType = _parsedStyle$shadowTy === void 0 ? "outer" : _parsedStyle$shadowTy, shadowColor = parsedStyle.shadowColor, _parsedStyle$filter = parsedStyle.filter, filter3 = _parsedStyle$filter === void 0 ? [] : _parsedStyle$filter, transformOrigin = parsedStyle.transformOrigin;
        var center2 = [cx, cy, cz];
        geometry.contentBounds.update(center2, halfExtents);
        var expansion = nodeName === Shape.POLYLINE || nodeName === Shape.POLYGON || nodeName === Shape.PATH ? Math.SQRT2 : 0.5;
        var hasStroke = stroke2 && !stroke2.isNone;
        if (hasStroke) {
          var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) * expansion;
          halfExtents[0] += halfLineWidth;
          halfExtents[1] += halfLineWidth;
        }
        geometry.renderBounds.update(center2, halfExtents);
        if (shadowColor && shadowType && shadowType !== "inner") {
          var _geometry$renderBound = geometry.renderBounds, min10 = _geometry$renderBound.min, max11 = _geometry$renderBound.max;
          var shadowBlur = parsedStyle.shadowBlur, shadowOffsetX = parsedStyle.shadowOffsetX, shadowOffsetY = parsedStyle.shadowOffsetY;
          var shadowBlurInPixels = shadowBlur || 0;
          var shadowOffsetXInPixels = shadowOffsetX || 0;
          var shadowOffsetYInPixels = shadowOffsetY || 0;
          var shadowLeft = min10[0] - shadowBlurInPixels + shadowOffsetXInPixels;
          var shadowRight = max11[0] + shadowBlurInPixels + shadowOffsetXInPixels;
          var shadowTop = min10[1] - shadowBlurInPixels + shadowOffsetYInPixels;
          var shadowBottom = max11[1] + shadowBlurInPixels + shadowOffsetYInPixels;
          min10[0] = Math.min(min10[0], shadowLeft);
          max11[0] = Math.max(max11[0], shadowRight);
          min10[1] = Math.min(min10[1], shadowTop);
          max11[1] = Math.max(max11[1], shadowBottom);
          geometry.renderBounds.setMinMax(min10, max11);
        }
        filter3.forEach(function(_ref) {
          var name2 = _ref.name, params = _ref.params;
          if (name2 === "blur") {
            var blurRadius = params[0].value;
            geometry.renderBounds.update(geometry.renderBounds.center, vec3_exports.add(geometry.renderBounds.halfExtents, geometry.renderBounds.halfExtents, [blurRadius, blurRadius, 0]));
          } else if (name2 === "drop-shadow") {
            var _shadowOffsetX = params[0].value;
            var _shadowOffsetY = params[1].value;
            var _shadowBlur = params[2].value;
            var _geometry$renderBound2 = geometry.renderBounds, _min = _geometry$renderBound2.min, _max = _geometry$renderBound2.max;
            var _shadowLeft = _min[0] - _shadowBlur + _shadowOffsetX;
            var _shadowRight = _max[0] + _shadowBlur + _shadowOffsetX;
            var _shadowTop = _min[1] - _shadowBlur + _shadowOffsetY;
            var _shadowBottom = _max[1] + _shadowBlur + _shadowOffsetY;
            _min[0] = Math.min(_min[0], _shadowLeft);
            _max[0] = Math.max(_max[0], _shadowRight);
            _min[1] = Math.min(_min[1], _shadowTop);
            _max[1] = Math.max(_max[1], _shadowBottom);
            geometry.renderBounds.setMinMax(_min, _max);
          }
        });
        object.geometry.dirty = false;
        var flipY = hwidth < 0;
        var flipX = hheight < 0;
        var usedOriginXValue = (flipY ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[0], 0, object, true) : 0);
        var usedOriginYValue = (flipX ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[1], 1, object, true) : 0);
        if (usedOriginXValue || usedOriginYValue) {
          object.setOrigin(usedOriginXValue, usedOriginYValue);
        }
      }
    }
  }, {
    key: "updateSizeAttenuation",
    value: function updateSizeAttenuation(node, zoom) {
      if (node.style.isSizeAttenuation) {
        if (!node.style.rawLineWidth) {
          node.style.rawLineWidth = node.style.lineWidth;
        }
        node.style.lineWidth = (node.style.rawLineWidth || 1) / zoom;
        if (node.nodeName === Shape.CIRCLE) {
          if (!node.style.rawR) {
            node.style.rawR = node.style.r;
          }
          node.style.r = (node.style.rawR || 1) / zoom;
        }
      } else {
        if (node.style.rawLineWidth) {
          node.style.lineWidth = node.style.rawLineWidth;
          delete node.style.rawLineWidth;
        }
        if (node.nodeName === Shape.CIRCLE) {
          if (node.style.rawR) {
            node.style.r = node.style.rawR;
            delete node.style.rawR;
          }
        }
      }
    }
  }]);
}();
function assignParsedStyle(object, attributes) {
  var list = getParsedStyleListOf(object);
  for (var key in attributes) {
    if (list.has(key)) {
      object.parsedStyle[key] = attributes[key];
    }
  }
}
function getParsedStyleListOf(object) {
  return object.constructor.PARSED_STYLE_LIST;
}
var CSSPropertyAngle = function() {
  function CSSPropertyAngle2() {
    _classCallCheck(this, CSSPropertyAngle2);
    this.mixer = mergeNumbers;
  }
  return _createClass(CSSPropertyAngle2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, parsed, object) {
      return convertAngleUnit(parsed);
    }
  }]);
}();
var CSSPropertyClipPath = function() {
  function CSSPropertyClipPath2() {
    _classCallCheck(this, CSSPropertyClipPath2);
  }
  return _createClass(CSSPropertyClipPath2, [{
    key: "calculator",
    value: function calculator(name2, oldPath, newPath, object, runtime2) {
      if (newPath instanceof CSSKeywordValue) {
        newPath = null;
      }
      runtime2.sceneGraphService.updateDisplayObjectDependency(name2, oldPath, newPath, object);
      if (name2 === "clipPath") {
        object.forEach(function(leaf) {
          if (leaf.childNodes.length === 0) {
            runtime2.sceneGraphService.dirtifyToRoot(leaf);
          }
        });
      }
      return newPath;
    }
  }]);
}();
var CSSPropertyColor = function() {
  function CSSPropertyColor2() {
    _classCallCheck(this, CSSPropertyColor2);
    this.parser = parseColor;
    this.mixer = mergeColors;
  }
  return _createClass(CSSPropertyColor2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, parsed, object) {
      if (parsed instanceof CSSKeywordValue) {
        return parsed.value === "none" ? noneColor : transparentColor;
      }
      return parsed;
    }
  }]);
}();
var CSSPropertyFilter = function() {
  function CSSPropertyFilter2() {
    _classCallCheck(this, CSSPropertyFilter2);
  }
  return _createClass(CSSPropertyFilter2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, parsed) {
      if (parsed instanceof CSSKeywordValue) {
        return [];
      }
      return parsed;
    }
  }]);
}();
function getFontSize(object) {
  var _ref = object.parsedStyle, fontSize = _ref.fontSize;
  return isNil(fontSize) ? null : fontSize;
}
var CSSPropertyLengthOrPercentage = function() {
  function CSSPropertyLengthOrPercentage2() {
    _classCallCheck(this, CSSPropertyLengthOrPercentage2);
    this.mixer = mergeNumbers;
  }
  return _createClass(CSSPropertyLengthOrPercentage2, [{
    key: "calculator",
    value: (
      /**
       * according to parent's bounds
       *
       * @example
       * CSS.percent(50) -> CSS.px(0.5 * parent.width)
       */
      function calculator(name2, oldParsed, computed, object, runtime2) {
        if (isNumber(computed)) {
          return computed;
        }
        if (CSSUnitValue.isRelativeUnit(computed.unit)) {
          if (computed.unit === UnitType.kPercentage) {
            return 0;
          }
          if (computed.unit === UnitType.kEms) {
            if (object.parentNode) {
              var fontSize = getFontSize(object.parentNode);
              if (fontSize) {
                fontSize *= computed.value;
                return fontSize;
              }
            }
            return 0;
          }
          if (computed.unit === UnitType.kRems) {
            var _object$ownerDocument;
            if (object !== null && object !== void 0 && (_object$ownerDocument = object.ownerDocument) !== null && _object$ownerDocument !== void 0 && _object$ownerDocument.documentElement) {
              var _fontSize = getFontSize(object.ownerDocument.documentElement);
              if (_fontSize) {
                _fontSize *= computed.value;
                return _fontSize;
              }
            }
            return 0;
          }
        } else {
          return computed.value;
        }
      }
    )
  }]);
}();
var CSSPropertyLengthOrPercentage12 = function() {
  function CSSPropertyLengthOrPercentage122() {
    _classCallCheck(this, CSSPropertyLengthOrPercentage122);
    this.mixer = mergeNumberLists;
  }
  return _createClass(CSSPropertyLengthOrPercentage122, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, computed) {
      return computed.map(function(c5) {
        return c5.value;
      });
    }
  }]);
}();
var CSSPropertyLengthOrPercentage14 = function() {
  function CSSPropertyLengthOrPercentage142() {
    _classCallCheck(this, CSSPropertyLengthOrPercentage142);
    this.mixer = mergeNumberLists;
  }
  return _createClass(CSSPropertyLengthOrPercentage142, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, computed) {
      return computed.map(function(c5) {
        return c5.value;
      });
    }
  }]);
}();
var CSSPropertyMarker = function() {
  function CSSPropertyMarker2() {
    _classCallCheck(this, CSSPropertyMarker2);
  }
  return _createClass(CSSPropertyMarker2, [{
    key: "calculator",
    value: function calculator(name2, oldMarker, newMarker, object) {
      var _newMarker;
      if (newMarker instanceof CSSKeywordValue) {
        newMarker = null;
      }
      var cloned = (_newMarker = newMarker) === null || _newMarker === void 0 ? void 0 : _newMarker.cloneNode(true);
      if (cloned) {
        cloned.style.isMarker = true;
      }
      return cloned;
    }
  }]);
}();
var CSSPropertyNumber = function() {
  function CSSPropertyNumber2() {
    _classCallCheck(this, CSSPropertyNumber2);
    this.mixer = mergeNumbers;
  }
  return _createClass(CSSPropertyNumber2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, computed) {
      return computed.value;
    }
  }]);
}();
var CSSPropertyOffsetDistance = function() {
  function CSSPropertyOffsetDistance2() {
    _classCallCheck(this, CSSPropertyOffsetDistance2);
    this.mixer = clampedMergeNumbers(0, 1);
  }
  return _createClass(CSSPropertyOffsetDistance2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, computed) {
      return computed.value;
    }
  }, {
    key: "postProcessor",
    value: function postProcessor(object) {
      var _object$parsedStyle = object.parsedStyle, offsetPath = _object$parsedStyle.offsetPath, offsetDistance = _object$parsedStyle.offsetDistance;
      if (!offsetPath) {
        return;
      }
      var nodeName = offsetPath.nodeName;
      if (nodeName === Shape.LINE || nodeName === Shape.PATH || nodeName === Shape.POLYLINE) {
        var point7 = offsetPath.getPoint(offsetDistance);
        if (point7) {
          object.setLocalPosition(point7.x, point7.y);
        }
      }
    }
  }]);
}();
var CSSPropertyOpacity = function() {
  function CSSPropertyOpacity2() {
    _classCallCheck(this, CSSPropertyOpacity2);
    this.mixer = clampedMergeNumbers(0, 1);
  }
  return _createClass(CSSPropertyOpacity2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, computed) {
      return computed.value;
    }
  }]);
}();
var CSSPropertyPath = function() {
  function CSSPropertyPath2() {
    _classCallCheck(this, CSSPropertyPath2);
    this.parser = parsePath;
    this.mixer = mergePaths;
  }
  return _createClass(CSSPropertyPath2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, parsed) {
      if (parsed instanceof CSSKeywordValue && parsed.value === "unset") {
        return {
          absolutePath: [],
          hasArc: false,
          segments: [],
          polygons: [],
          polylines: [],
          curve: null,
          totalLength: 0,
          rect: new Rectangle(0, 0, 0, 0)
        };
      }
      return parsed;
    }
  }]);
}();
var CSSPropertyPoints = _createClass(function CSSPropertyPoints2() {
  _classCallCheck(this, CSSPropertyPoints2);
  this.mixer = mergePoints;
});
var CSSPropertyShadowBlur = function(_CSSPropertyLengthOrP) {
  function CSSPropertyShadowBlur2() {
    var _this2;
    _classCallCheck(this, CSSPropertyShadowBlur2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, CSSPropertyShadowBlur2, [].concat(args));
    _this2.mixer = clampedMergeNumbers(0, Infinity);
    return _this2;
  }
  _inherits(CSSPropertyShadowBlur2, _CSSPropertyLengthOrP);
  return _createClass(CSSPropertyShadowBlur2);
}(CSSPropertyLengthOrPercentage);
var CSSPropertyText = function() {
  function CSSPropertyText2() {
    _classCallCheck(this, CSSPropertyText2);
  }
  return _createClass(CSSPropertyText2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, parsed, object) {
      if (parsed instanceof CSSKeywordValue) {
        if (parsed.value === "unset") {
          return "";
        }
        return parsed.value;
      }
      return "".concat(parsed);
    }
  }, {
    key: "postProcessor",
    value: function postProcessor(object) {
      object.nodeValue = "".concat(object.parsedStyle.text) || "";
    }
  }]);
}();
var CSSPropertyTextTransform = function() {
  function CSSPropertyTextTransform2() {
    _classCallCheck(this, CSSPropertyTextTransform2);
  }
  return _createClass(CSSPropertyTextTransform2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, parsed, object) {
      var rawText = object.getAttribute("text");
      if (rawText) {
        var transformedText = rawText;
        if (parsed.value === "capitalize") {
          transformedText = rawText.charAt(0).toUpperCase() + rawText.slice(1);
        } else if (parsed.value === "lowercase") {
          transformedText = rawText.toLowerCase();
        } else if (parsed.value === "uppercase") {
          transformedText = rawText.toUpperCase();
        }
        object.parsedStyle.text = transformedText;
      }
      return parsed.value;
    }
  }]);
}();
var CANVAS_Map = /* @__PURE__ */ new WeakMap();
function cleanExistedCanvas(container, canvas, cleanUp) {
  if (container) {
    var $dom = typeof container === "string" ? document.getElementById(container) : container;
    if (CANVAS_Map.has($dom))
      CANVAS_Map.get($dom).destroy(cleanUp);
    CANVAS_Map.set($dom, canvas);
  }
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
function isElement2(target) {
  return !!target.getAttribute;
}
function sortedIndex(array2, value2) {
  var low = 0;
  var high = array2.length;
  while (low < high) {
    var mid2 = low + high >>> 1;
    if (sortByZIndex(array2[mid2], value2) < 0) {
      low = mid2 + 1;
    } else {
      high = mid2;
    }
  }
  return low;
}
function sortByZIndex(o1, o2) {
  var zIndex1 = Number(o1.parsedStyle.zIndex || 0);
  var zIndex2 = Number(o2.parsedStyle.zIndex || 0);
  if (zIndex1 === zIndex2) {
    var parent = o1.parentNode;
    if (parent) {
      var children = parent.childNodes || [];
      return children.indexOf(o1) - children.indexOf(o2);
    }
  }
  return zIndex1 - zIndex2;
}
function findClosestClipPathTarget(object) {
  var el = object;
  do {
    var _el$parsedStyle;
    var clipPath = (_el$parsedStyle = el.parsedStyle) === null || _el$parsedStyle === void 0 ? void 0 : _el$parsedStyle.clipPath;
    if (clipPath)
      return el;
    el = el.parentElement;
  } while (el !== null);
  return null;
}
var PX_SUFFIX = "px";
function setDOMSize($el, width, height) {
  if (isBrowser && $el.style) {
    $el.style.width = width + PX_SUFFIX;
    $el.style.height = height + PX_SUFFIX;
  }
}
function getStyle($el, property) {
  if (isBrowser) {
    return document.defaultView.getComputedStyle($el, null).getPropertyValue(property);
  }
}
function getWidth($el) {
  var width = getStyle($el, "width");
  if (width === "auto") {
    return $el.offsetWidth;
  }
  return parseFloat(width);
}
function getHeight($el) {
  var height = getStyle($el, "height");
  if (height === "auto") {
    return $el.offsetHeight;
  }
  return parseFloat(height);
}
var MOUSE_POINTER_ID = 1;
var TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
var clock = typeof performance === "object" && performance.now ? performance : Date;
function isInFragment(node) {
  if (node.nodeName === Shape.FRAGMENT)
    return true;
  return node.getRootNode().nodeName === Shape.FRAGMENT;
}
function isFillOrStrokeAffected() {
  var pointerEvents = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "auto";
  var fill = arguments.length > 1 ? arguments[1] : void 0;
  var stroke2 = arguments.length > 2 ? arguments[2] : void 0;
  var hasFill = false;
  var hasStroke = false;
  var isFillOtherThanNone = !!fill && !fill.isNone;
  var isStrokeOtherThanNone = !!stroke2 && !stroke2.isNone;
  if (pointerEvents === "visiblepainted" || pointerEvents === "painted" || pointerEvents === "auto") {
    hasFill = isFillOtherThanNone;
    hasStroke = isStrokeOtherThanNone;
  } else if (pointerEvents === "visiblefill" || pointerEvents === "fill") {
    hasFill = true;
  } else if (pointerEvents === "visiblestroke" || pointerEvents === "stroke") {
    hasStroke = true;
  } else if (pointerEvents === "visible" || pointerEvents === "all") {
    hasFill = true;
    hasStroke = true;
  }
  return [hasFill, hasStroke];
}
var uId = 1;
var uniqueId = function uniqueId2() {
  return uId++;
};
var root = (
  // eslint-disable-next-line no-nested-ternary
  typeof self === "object" && self.self === self ? self : (
    // @ts-ignore
    typeof global === "object" && global.global === global ? (
      // @ts-ignore
      global
    ) : {}
  )
);
var nowOffset = Date.now();
var pnow = function pnow2() {
  if (root.performance && typeof root.performance.now === "function") {
    return root.performance.now();
  }
  return Date.now() - nowOffset;
};
var reservedCBs = {};
var lastTime = Date.now();
var polyfillRaf = function polyfillRaf2(callback) {
  if (typeof callback !== "function") {
    throw new TypeError("".concat(callback, " is not a function"));
  }
  var currentTime = Date.now();
  var gap = currentTime - lastTime;
  var delay = gap > 16 ? 0 : 16 - gap;
  var id4 = uniqueId();
  reservedCBs[id4] = callback;
  if (Object.keys(reservedCBs).length > 1)
    return id4;
  setTimeout(function() {
    lastTime = currentTime;
    var copied = reservedCBs;
    reservedCBs = {};
    Object.keys(copied).forEach(function(key) {
      return copied[key](pnow());
    });
  }, delay);
  return id4;
};
var polyfillCaf = function polyfillCaf2(id4) {
  delete reservedCBs[id4];
};
var vendorPrefixes = ["", "webkit", "moz", "ms", "o"];
var getRequestAnimationFrame = function getRequestAnimationFrame2(vp2) {
  if (typeof vp2 !== "string")
    return polyfillRaf;
  if (vp2 === "")
    return root.requestAnimationFrame;
  return root["".concat(vp2, "RequestAnimationFrame")];
};
var getCancelAnimationFrame = function getCancelAnimationFrame2(vp2) {
  if (typeof vp2 !== "string")
    return polyfillCaf;
  if (vp2 === "")
    return root.cancelAnimationFrame;
  return root["".concat(vp2, "CancelAnimationFrame")] || root["".concat(vp2, "CancelRequestAnimationFrame")];
};
var find2 = function find3(arr, predicate) {
  var i = 0;
  while (arr[i] !== void 0) {
    if (predicate(arr[i]))
      return arr[i];
    i += 1;
  }
};
var vp = find2(vendorPrefixes, function(vp2) {
  return !!getRequestAnimationFrame(vp2);
});
var raf = getRequestAnimationFrame(vp);
var caf = getCancelAnimationFrame(vp);
root.requestAnimationFrame = raf;
root.cancelAnimationFrame = caf;
var AsyncParallelHook = function() {
  function AsyncParallelHook2() {
    _classCallCheck(this, AsyncParallelHook2);
    this.callbacks = [];
  }
  return _createClass(AsyncParallelHook2, [{
    key: "getCallbacksNum",
    value: function getCallbacksNum() {
      return this.callbacks.length;
    }
  }, {
    key: "tapPromise",
    value: function tapPromise(options, fn) {
      this.callbacks.push(fn);
    }
  }, {
    key: "promise",
    value: function promise() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return Promise.all(this.callbacks.map(function(callback) {
        return callback.apply(void 0, args);
      }));
    }
  }]);
}();
var AsyncSeriesWaterfallHook = function() {
  function AsyncSeriesWaterfallHook2() {
    _classCallCheck(this, AsyncSeriesWaterfallHook2);
    this.callbacks = [];
  }
  return _createClass(AsyncSeriesWaterfallHook2, [{
    key: "tapPromise",
    value: function tapPromise(options, fn) {
      this.callbacks.push(fn);
    }
  }, {
    key: "promise",
    value: function() {
      var _promise = _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
        var _this$callbacks, result, i, callback, _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.callbacks.length) {
                  _context.next = 14;
                  break;
                }
                _context.next = 3;
                return (_this$callbacks = this.callbacks)[0].apply(_this$callbacks, _args);
              case 3:
                result = _context.sent;
                i = 0;
              case 5:
                if (!(i < this.callbacks.length - 1)) {
                  _context.next = 13;
                  break;
                }
                callback = this.callbacks[i];
                _context.next = 9;
                return callback(result);
              case 9:
                result = _context.sent;
              case 10:
                i++;
                _context.next = 5;
                break;
              case 13:
                return _context.abrupt("return", result);
              case 14:
                return _context.abrupt("return", null);
              case 15:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function promise() {
        return _promise.apply(this, arguments);
      }
      return promise;
    }()
  }]);
}();
var SyncHook = function() {
  function SyncHook2() {
    _classCallCheck(this, SyncHook2);
    this.callbacks = [];
  }
  return _createClass(SyncHook2, [{
    key: "tap",
    value: function tap(options, fn) {
      this.callbacks.push(fn);
    }
  }, {
    key: "call",
    value: function call() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var argsArr = arguments;
      this.callbacks.forEach(function(callback) {
        callback.apply(void 0, argsArr);
      });
    }
  }]);
}();
var SyncWaterfallHook = function() {
  function SyncWaterfallHook2() {
    _classCallCheck(this, SyncWaterfallHook2);
    this.callbacks = [];
  }
  return _createClass(SyncWaterfallHook2, [{
    key: "tap",
    value: function tap(options, fn) {
      this.callbacks.push(fn);
    }
  }, {
    key: "call",
    value: function call() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (this.callbacks.length) {
        var argsArr = arguments;
        var result = this.callbacks[0].apply(void 0, argsArr);
        for (var i = 0; i < this.callbacks.length - 1; i++) {
          var callback = this.callbacks[i];
          result = callback(result);
        }
        return result;
      }
      return null;
    }
  }]);
}();
var genericFontFamilies = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"];
var stringRegExp = /([\"\'])[^\'\"]+\1/;
function toFontString(attributes) {
  var _attributes$fontSize = attributes.fontSize, fontSize = _attributes$fontSize === void 0 ? 16 : _attributes$fontSize, _attributes$fontFamil = attributes.fontFamily, fontFamily = _attributes$fontFamil === void 0 ? "sans-serif" : _attributes$fontFamil, _attributes$fontStyle = attributes.fontStyle, fontStyle = _attributes$fontStyle === void 0 ? "normal" : _attributes$fontStyle, _attributes$fontVaria = attributes.fontVariant, fontVariant = _attributes$fontVaria === void 0 ? "normal" : _attributes$fontVaria, _attributes$fontWeigh = attributes.fontWeight, fontWeight = _attributes$fontWeigh === void 0 ? "normal" : _attributes$fontWeigh;
  var fontSizeString = isNumber(fontSize) && "".concat(fontSize, "px") || "16px";
  var fontFamilies = fontFamily.split(",");
  for (var i = fontFamilies.length - 1; i >= 0; i--) {
    var _fontFamily = fontFamilies[i].trim();
    if (!stringRegExp.test(_fontFamily) && genericFontFamilies.indexOf(_fontFamily) < 0) {
      _fontFamily = '"'.concat(_fontFamily, '"');
    }
    fontFamilies[i] = _fontFamily;
  }
  return "".concat(fontStyle, " ").concat(fontVariant, " ").concat(fontWeight, " ").concat(fontSizeString, " ").concat(fontFamilies.join(","));
}
function createSkewMatrix(skewMatrix, skewX2, skewY2) {
  mat4_exports.identity(skewMatrix);
  skewMatrix[4] = Math.tan(skewX2);
  skewMatrix[1] = Math.tan(skewY2);
  return skewMatrix;
}
var $mat4_1 = mat4_exports.create();
var $mat4_2 = mat4_exports.create();
var parser = {
  scale: function scale7(d3) {
    mat4_exports.fromScaling($mat4_1, [d3[0].value, d3[1].value, 1]);
  },
  scaleX: function scaleX(d3) {
    mat4_exports.fromScaling($mat4_1, [d3[0].value, 1, 1]);
  },
  scaleY: function scaleY(d3) {
    mat4_exports.fromScaling($mat4_1, [1, d3[0].value, 1]);
  },
  scaleZ: function scaleZ(d3) {
    mat4_exports.fromScaling($mat4_1, [1, 1, d3[0].value]);
  },
  scale3d: function scale3d(d3) {
    mat4_exports.fromScaling($mat4_1, [d3[0].value, d3[1].value, d3[2].value]);
  },
  translate: function translate3(d3) {
    mat4_exports.fromTranslation($mat4_1, [d3[0].value, d3[1].value, 0]);
  },
  translateX: function translateX(d3) {
    mat4_exports.fromTranslation($mat4_1, [d3[0].value, 0, 0]);
  },
  translateY: function translateY(d3) {
    mat4_exports.fromTranslation($mat4_1, [0, d3[0].value, 0]);
  },
  translateZ: function translateZ(d3) {
    mat4_exports.fromTranslation($mat4_1, [0, 0, d3[0].value]);
  },
  translate3d: function translate3d(d3) {
    mat4_exports.fromTranslation($mat4_1, [d3[0].value, d3[1].value, d3[2].value]);
  },
  rotate: function rotate4(d3) {
    mat4_exports.fromZRotation($mat4_1, deg2rad(convertAngleUnit(d3[0])));
  },
  rotateX: function rotateX4(d3) {
    mat4_exports.fromXRotation($mat4_1, deg2rad(convertAngleUnit(d3[0])));
  },
  rotateY: function rotateY4(d3) {
    mat4_exports.fromYRotation($mat4_1, deg2rad(convertAngleUnit(d3[0])));
  },
  rotateZ: function rotateZ4(d3) {
    mat4_exports.fromZRotation($mat4_1, deg2rad(convertAngleUnit(d3[0])));
  },
  rotate3d: function rotate3d(d3) {
    mat4_exports.fromRotation($mat4_1, deg2rad(convertAngleUnit(d3[3])), [d3[0].value, d3[1].value, d3[2].value]);
  },
  skew: function skew(d3) {
    createSkewMatrix($mat4_1, deg2rad(d3[0].value), deg2rad(d3[1].value));
  },
  skewX: function skewX(d3) {
    createSkewMatrix($mat4_1, deg2rad(d3[0].value), 0);
  },
  skewY: function skewY(d3) {
    createSkewMatrix($mat4_1, 0, deg2rad(d3[0].value));
  },
  matrix: function matrix(d3) {
    mat4_exports.set($mat4_1, d3[0].value, d3[1].value, 0, 0, d3[2].value, d3[3].value, 0, 0, 0, 0, 1, 0, d3[4].value, d3[5].value, 0, 1);
  },
  matrix3d: function matrix3d(d3) {
    mat4_exports.set.apply(mat4_exports, [$mat4_1].concat(_toConsumableArray(d3.map(function(s3) {
      return s3.value;
    }))));
  }
};
var $vec3One$1 = vec3_exports.fromValues(1, 1, 1);
var $vec3Zero$1 = vec3_exports.create();
var optimizer = {
  translate: function translate4(object, d3) {
    runtime.sceneGraphService.setLocalScale(object, $vec3One$1, false);
    runtime.sceneGraphService.setLocalEulerAngles(object, $vec3Zero$1, void 0, void 0, false);
    runtime.sceneGraphService.setLocalPosition(object, [d3[0].value, d3[1].value, 0], false);
    runtime.sceneGraphService.dirtifyLocal(object, object.transformable);
  }
};
function parsedTransformToMat4(transform2, object) {
  if (transform2.length) {
    if (transform2.length === 1 && optimizer[transform2[0].t]) {
      optimizer[transform2[0].t](object, transform2[0].d);
      return;
    }
    var m3 = mat4_exports.identity($mat4_2);
    for (var i = 0; i < transform2.length; i++) {
      var _transform$i = transform2[i], t = _transform$i.t, d3 = _transform$i.d;
      var p2 = parser[t];
      if (p2) {
        p2(d3);
        mat4_exports.mul(m3, m3, $mat4_1);
      }
    }
    object.setLocalTransform(m3);
  } else {
    object.resetLocalTransform();
  }
  return object.getLocalTransform();
}
var CSSPropertyTransform = function() {
  function CSSPropertyTransform2() {
    _classCallCheck(this, CSSPropertyTransform2);
    this.parser = parseTransformUnmemoize;
    this.mixer = mergeTransforms;
  }
  return _createClass(CSSPropertyTransform2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, parsed, object) {
      if (parsed instanceof CSSKeywordValue) {
        return [];
      }
      return parsed;
    }
  }, {
    key: "postProcessor",
    value: function postProcessor(object) {
      parsedTransformToMat4(object.parsedStyle.transform, object);
    }
  }]);
}();
var CSSPropertyTransformOrigin = function() {
  function CSSPropertyTransformOrigin2() {
    _classCallCheck(this, CSSPropertyTransformOrigin2);
  }
  return _createClass(CSSPropertyTransformOrigin2, [{
    key: "postProcessor",
    value: function postProcessor(object) {
      var transformOrigin = object.parsedStyle.transformOrigin;
      if (transformOrigin[0].unit === UnitType.kPixels && transformOrigin[1].unit === UnitType.kPixels) {
        object.setOrigin(transformOrigin[0].value, transformOrigin[1].value);
      } else {
        object.getGeometryBounds();
      }
    }
  }]);
}();
var CSSPropertyZIndex = function() {
  function CSSPropertyZIndex2() {
    _classCallCheck(this, CSSPropertyZIndex2);
  }
  return _createClass(CSSPropertyZIndex2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, computed, object) {
      return computed.value;
    }
  }, {
    key: "postProcessor",
    value: function postProcessor(object) {
      if (object.parentNode) {
        var parentEntity = object.parentNode;
        var parentRenderable = parentEntity.renderable;
        var parentSortable = parentEntity.sortable;
        if (parentRenderable) {
          parentRenderable.dirty = true;
        }
        if (parentSortable) {
          parentSortable.dirty = true;
          parentSortable.dirtyReason = SortReason.Z_INDEX_CHANGED;
        }
      }
    }
  }]);
}();
var CircleUpdater = function() {
  function CircleUpdater2() {
    _classCallCheck(this, CircleUpdater2);
  }
  return _createClass(CircleUpdater2, [{
    key: "update",
    value: function update2(parsedStyle, object) {
      var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, _parsedStyle$r = parsedStyle.r, r = _parsedStyle$r === void 0 ? 0 : _parsedStyle$r;
      return {
        cx,
        cy,
        hwidth: r,
        hheight: r
      };
    }
  }]);
}();
var EllipseUpdater = function() {
  function EllipseUpdater2() {
    _classCallCheck(this, EllipseUpdater2);
  }
  return _createClass(EllipseUpdater2, [{
    key: "update",
    value: function update2(parsedStyle, object) {
      var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, _parsedStyle$rx = parsedStyle.rx, rx = _parsedStyle$rx === void 0 ? 0 : _parsedStyle$rx, _parsedStyle$ry = parsedStyle.ry, ry = _parsedStyle$ry === void 0 ? 0 : _parsedStyle$ry;
      return {
        cx,
        cy,
        hwidth: rx,
        hheight: ry
      };
    }
  }]);
}();
var LineUpdater = function() {
  function LineUpdater2() {
    _classCallCheck(this, LineUpdater2);
  }
  return _createClass(LineUpdater2, [{
    key: "update",
    value: function update2(parsedStyle) {
      var x12 = parsedStyle.x1, y12 = parsedStyle.y1, x22 = parsedStyle.x2, y22 = parsedStyle.y2;
      var minX = Math.min(x12, x22);
      var maxX = Math.max(x12, x22);
      var minY = Math.min(y12, y22);
      var maxY2 = Math.max(y12, y22);
      var width = maxX - minX;
      var height = maxY2 - minY;
      var hwidth = width / 2;
      var hheight = height / 2;
      return {
        cx: minX + hwidth,
        cy: minY + hheight,
        hwidth,
        hheight
      };
    }
  }]);
}();
var PathUpdater = function() {
  function PathUpdater2() {
    _classCallCheck(this, PathUpdater2);
  }
  return _createClass(PathUpdater2, [{
    key: "update",
    value: function update2(parsedStyle) {
      var d3 = parsedStyle.d;
      var _d$rect = d3.rect, x3 = _d$rect.x, y3 = _d$rect.y, width = _d$rect.width, height = _d$rect.height;
      var hwidth = width / 2;
      var hheight = height / 2;
      return {
        cx: x3 + hwidth,
        cy: y3 + hheight,
        hwidth,
        hheight
      };
    }
  }]);
}();
var PolylineUpdater = function() {
  function PolylineUpdater2() {
    _classCallCheck(this, PolylineUpdater2);
  }
  return _createClass(PolylineUpdater2, [{
    key: "update",
    value: function update2(parsedStyle) {
      if (parsedStyle.points && isArray(parsedStyle.points.points)) {
        var points = parsedStyle.points.points;
        var minX = Math.min.apply(Math, _toConsumableArray(points.map(function(point7) {
          return point7[0];
        })));
        var maxX = Math.max.apply(Math, _toConsumableArray(points.map(function(point7) {
          return point7[0];
        })));
        var minY = Math.min.apply(Math, _toConsumableArray(points.map(function(point7) {
          return point7[1];
        })));
        var maxY2 = Math.max.apply(Math, _toConsumableArray(points.map(function(point7) {
          return point7[1];
        })));
        var width = maxX - minX;
        var height = maxY2 - minY;
        var hwidth = width / 2;
        var hheight = height / 2;
        return {
          cx: minX + hwidth,
          cy: minY + hheight,
          hwidth,
          hheight
        };
      }
      return {
        cx: 0,
        cy: 0,
        hwidth: 0,
        hheight: 0
      };
    }
  }]);
}();
var RectUpdater = function() {
  function RectUpdater2() {
    _classCallCheck(this, RectUpdater2);
  }
  return _createClass(RectUpdater2, [{
    key: "update",
    value: function update2(parsedStyle, object) {
      var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, src = parsedStyle.src, _parsedStyle$width = parsedStyle.width, width = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
      var contentWidth = width;
      var contentHeight = height;
      if (src && !isString(src)) {
        if (!contentWidth) {
          contentWidth = src.width;
          parsedStyle.width = contentWidth;
        }
        if (!contentHeight) {
          contentHeight = src.height;
          parsedStyle.height = contentHeight;
        }
      }
      return {
        cx: x3 + contentWidth / 2,
        cy: y3 + contentHeight / 2,
        hwidth: contentWidth / 2,
        hheight: contentHeight / 2
      };
    }
  }]);
}();
var TextUpdater = function() {
  function TextUpdater2(globalRuntime) {
    _classCallCheck(this, TextUpdater2);
    this.globalRuntime = globalRuntime;
  }
  return _createClass(TextUpdater2, [{
    key: "isReadyToMeasure",
    value: function isReadyToMeasure(parsedStyle, object) {
      var text = parsedStyle.text;
      return text;
    }
  }, {
    key: "update",
    value: function update2(parsedStyle, object) {
      var _object$ownerDocument;
      var text = parsedStyle.text, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$dx = parsedStyle.dx, dx = _parsedStyle$dx === void 0 ? 0 : _parsedStyle$dx, _parsedStyle$dy = parsedStyle.dy, dy = _parsedStyle$dy === void 0 ? 0 : _parsedStyle$dy, _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y;
      if (!this.isReadyToMeasure(parsedStyle, object)) {
        parsedStyle.metrics = {
          font: "",
          width: 0,
          height: 0,
          lines: [],
          lineWidths: [],
          lineHeight: 0,
          maxLineWidth: 0,
          fontProperties: {
            ascent: 0,
            descent: 0,
            fontSize: 0
          },
          lineMetrics: []
        };
        return {
          hwidth: 0,
          hheight: 0,
          cx: 0,
          cy: 0
        };
      }
      var _ref = (object === null || object === void 0 || (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.defaultView) === null || _object$ownerDocument === void 0 ? void 0 : _object$ownerDocument.getConfig()) || {}, offscreenCanvas = _ref.offscreenCanvas;
      var metrics = this.globalRuntime.textService.measureText(text, parsedStyle, offscreenCanvas);
      parsedStyle.metrics = metrics;
      var width = metrics.width, height = metrics.height;
      var hwidth = width / 2;
      var hheight = height / 2;
      var lineXOffset = x3 + hwidth;
      if (textAlign === "center" || textAlign === "middle") {
        lineXOffset += lineWidth / 2 - hwidth;
      } else if (textAlign === "right" || textAlign === "end") {
        lineXOffset += lineWidth - hwidth * 2;
      }
      var lineYOffset = y3 - hheight;
      if (textBaseline === "middle") {
        lineYOffset += hheight;
      } else if (textBaseline === "top" || textBaseline === "hanging") {
        lineYOffset += hheight * 2;
      } else if (textBaseline === "alphabetic")
        ;
      else if (textBaseline === "bottom" || textBaseline === "ideographic") {
        lineYOffset += 0;
      }
      if (dx) {
        lineXOffset += dx;
      }
      if (dy) {
        lineYOffset += dy;
      }
      return {
        cx: lineXOffset,
        cy: lineYOffset,
        hwidth,
        hheight
      };
    }
  }]);
}();
var GroupUpdater = function() {
  function GroupUpdater2() {
    _classCallCheck(this, GroupUpdater2);
  }
  return _createClass(GroupUpdater2, [{
    key: "update",
    value: function update2(parsedStyle, object) {
      return {
        cx: 0,
        cy: 0,
        hwidth: 0,
        hheight: 0
      };
    }
  }]);
}();
var HTMLUpdater = function() {
  function HTMLUpdater2() {
    _classCallCheck(this, HTMLUpdater2);
  }
  return _createClass(HTMLUpdater2, [{
    key: "update",
    value: function update2(parsedStyle, object) {
      var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, _parsedStyle$width = parsedStyle.width, width = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
      return {
        cx: x3 + width / 2,
        cy: y3 + height / 2,
        hwidth: width / 2,
        hheight: height / 2
      };
    }
  }]);
}();
var FederatedEvent = function() {
  function FederatedEvent2(manager) {
    _classCallCheck(this, FederatedEvent2);
    this.eventPhase = FederatedEvent2.prototype.NONE;
    this.bubbles = true;
    this.cancelBubble = true;
    this.cancelable = false;
    this.defaultPrevented = false;
    this.propagationStopped = false;
    this.propagationImmediatelyStopped = false;
    this.layer = new Point2();
    this.page = new Point2();
    this.canvas = new Point2();
    this.viewport = new Point2();
    this.composed = false;
    this.NONE = 0;
    this.CAPTURING_PHASE = 1;
    this.AT_TARGET = 2;
    this.BUBBLING_PHASE = 3;
    this.manager = manager;
  }
  return _createClass(FederatedEvent2, [{
    key: "name",
    get: (
      /**
       * The type of event, supports the following:
       * * pointerdown
       * * touchstart
       * * mousedown
       * * rightdown
       * * ...
       */
      /**
       * @deprecated
       */
      function get4() {
        return this.type;
      }
    )
  }, {
    key: "layerX",
    get: function get4() {
      return this.layer.x;
    }
  }, {
    key: "layerY",
    get: function get4() {
      return this.layer.y;
    }
  }, {
    key: "pageX",
    get: function get4() {
      return this.page.x;
    }
  }, {
    key: "pageY",
    get: function get4() {
      return this.page.y;
    }
  }, {
    key: "x",
    get: function get4() {
      return this.canvas.x;
    }
  }, {
    key: "y",
    get: function get4() {
      return this.canvas.y;
    }
  }, {
    key: "canvasX",
    get: function get4() {
      return this.canvas.x;
    }
  }, {
    key: "canvasY",
    get: function get4() {
      return this.canvas.y;
    }
  }, {
    key: "viewportX",
    get: function get4() {
      return this.viewport.x;
    }
  }, {
    key: "viewportY",
    get: function get4() {
      return this.viewport.y;
    }
  }, {
    key: "composedPath",
    value: (
      /**
       * The propagation path for this event
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/composedPath
       *
       * So composedPath()[0] represents the original target.
       * @see https://polymer-library.polymer-project.org/3.0/docs/devguide/events#retargeting
       */
      function composedPath() {
        if (this.manager && (!this.path || this.path[0] !== this.target)) {
          this.path = this.target ? this.manager.propagationPath(this.target) : [];
        }
        return this.path;
      }
    )
    /**
     * @deprecated
     */
  }, {
    key: "propagationPath",
    get: function get4() {
      return this.composedPath();
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault
     */
  }, {
    key: "preventDefault",
    value: function preventDefault() {
      if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
        this.nativeEvent.preventDefault();
      }
      this.defaultPrevented = true;
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation
     */
  }, {
    key: "stopImmediatePropagation",
    value: function stopImmediatePropagation() {
      this.propagationImmediatelyStopped = true;
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation
     */
  }, {
    key: "stopPropagation",
    value: function stopPropagation() {
      this.propagationStopped = true;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view
     */
  }, {
    key: "initEvent",
    value: (
      /**
       * added for compatibility with DOM Event,
       * deprecated props and methods
       */
      function initEvent() {
      }
    )
  }, {
    key: "initUIEvent",
    value: function initUIEvent() {
    }
  }, {
    key: "clone",
    value: function clone8() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }]);
}();
var FederatedMouseEvent = function(_ref) {
  function FederatedMouseEvent2() {
    var _this2;
    _classCallCheck(this, FederatedMouseEvent2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, FederatedMouseEvent2, [].concat(args));
    _this2.client = new Point2();
    _this2.movement = new Point2();
    _this2.offset = new Point2();
    _this2.global = new Point2();
    _this2.screen = new Point2();
    return _this2;
  }
  _inherits(FederatedMouseEvent2, _ref);
  return _createClass(FederatedMouseEvent2, [{
    key: "clientX",
    get: function get4() {
      return this.client.x;
    }
  }, {
    key: "clientY",
    get: function get4() {
      return this.client.y;
    }
  }, {
    key: "movementX",
    get: function get4() {
      return this.movement.x;
    }
  }, {
    key: "movementY",
    get: function get4() {
      return this.movement.y;
    }
  }, {
    key: "offsetX",
    get: function get4() {
      return this.offset.x;
    }
  }, {
    key: "offsetY",
    get: function get4() {
      return this.offset.y;
    }
  }, {
    key: "globalX",
    get: function get4() {
      return this.global.x;
    }
  }, {
    key: "globalY",
    get: function get4() {
      return this.global.y;
    }
  }, {
    key: "screenX",
    get: function get4() {
      return this.screen.x;
    }
  }, {
    key: "screenY",
    get: function get4() {
      return this.screen.y;
    }
  }, {
    key: "getModifierState",
    value: function getModifierState(key) {
      return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
    }
  }, {
    key: "initMouseEvent",
    value: function initMouseEvent() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }]);
}(FederatedEvent);
var FederatedPointerEvent = function(_FederatedMouseEvent) {
  function FederatedPointerEvent2() {
    var _this2;
    _classCallCheck(this, FederatedPointerEvent2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, FederatedPointerEvent2, [].concat(args));
    _this2.width = 0;
    _this2.height = 0;
    _this2.isPrimary = false;
    return _this2;
  }
  _inherits(FederatedPointerEvent2, _FederatedMouseEvent);
  return _createClass(FederatedPointerEvent2, [{
    key: "getCoalescedEvents",
    value: (
      /**
       * The type of pointer that triggered the event.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType
       */
      /**
       * Pressure applied by the pointing device during the event.
       *s
       * A Touch's force property will be represented by this value.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure
       */
      /**
       * Barrel pressure on a stylus pointer.
       *
       * @see https://w3c.github.io/pointerevents/#pointerevent-interface
       */
      /**
       * The angle, in degrees, between the pointer device and the screen.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX
       */
      /**
       * The angle, in degrees, between the pointer device and the screen.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY
       */
      /**
       * Twist of a stylus pointer.
       *
       * @see https://w3c.github.io/pointerevents/#pointerevent-interface
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/getCoalescedEvents
       */
      function getCoalescedEvents() {
        if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
          return [this];
        }
        return [];
      }
    )
    /**
     * @see https://chromestatus.com/feature/5765569655603200
     */
  }, {
    key: "getPredictedEvents",
    value: function getPredictedEvents() {
      throw new Error("getPredictedEvents is not supported!");
    }
    /**
     * @see https://github.com/antvis/G/issues/1115
     * We currently reuses event objects in the event system,
     * avoiding the creation of a large number of event objects.
     * Reused objects are only used to carry different data,
     * such as coordinate information, native event objects,
     * and therefore the lifecycle is limited to the event handler,
     * which can lead to unintended consequences if an attempt is made to cache the entire event object.
     *
     * Therefore, while keeping the above performance considerations in mind, it is possible to provide a clone method that creates a new object when the user really wants to cache it, e.g.
     */
  }, {
    key: "clone",
    value: function clone8() {
      return this.manager.clonePointerEvent(this);
    }
  }]);
}(FederatedMouseEvent);
var FederatedWheelEvent = function(_FederatedMouseEvent) {
  function FederatedWheelEvent2() {
    _classCallCheck(this, FederatedWheelEvent2);
    return _callSuper(this, FederatedWheelEvent2, arguments);
  }
  _inherits(FederatedWheelEvent2, _FederatedMouseEvent);
  return _createClass(FederatedWheelEvent2, [{
    key: "clone",
    value: (
      /**
       * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,
       * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.
       */
      /** Horizontal scroll amount */
      /** Vertical scroll amount */
      /** z-axis scroll amount. */
      function clone8() {
        return this.manager.cloneWheelEvent(this);
      }
    )
  }]);
}(FederatedMouseEvent);
var CustomEvent = function(_FederatedEvent) {
  function CustomEvent2(eventName, object) {
    var _this2;
    _classCallCheck(this, CustomEvent2);
    _this2 = _callSuper(this, CustomEvent2, [null]);
    _this2.type = eventName;
    _this2.detail = object;
    Object.assign(_this2, object);
    return _this2;
  }
  _inherits(CustomEvent2, _FederatedEvent);
  return _createClass(CustomEvent2);
}(FederatedEvent);
var CANVAS_CACHE = /* @__PURE__ */ new WeakMap();
var EventTarget = function() {
  function EventTarget2() {
    _classCallCheck(this, EventTarget2);
    this.emitter = new eventemitter3_default();
  }
  return _createClass(EventTarget2, [{
    key: "on",
    value: (
      /**
       * @deprecated
       * @alias addEventListener
       */
      function on(type, listener, options) {
        this.addEventListener(type, listener, options);
        return this;
      }
    )
    /**
     * support `capture` & `once` in options
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener
     */
  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener, options) {
      var capture = false;
      var once = false;
      if (is_boolean_default(options))
        capture = options;
      else if (options) {
        var _options$capture = options.capture;
        capture = _options$capture === void 0 ? false : _options$capture;
        var _options$once = options.once;
        once = _options$once === void 0 ? false : _options$once;
      }
      if (capture)
        type += "capture";
      listener = isFunction(listener) ? listener : listener.handleEvent;
      var context = isFunction(listener) ? void 0 : listener;
      if (once)
        this.emitter.once(type, listener, context);
      else
        this.emitter.on(type, listener, context);
      return this;
    }
    /**
     * @deprecated
     * @alias removeEventListener
     */
  }, {
    key: "off",
    value: function off(type, listener, options) {
      if (type) {
        this.removeEventListener(type, listener, options);
      } else {
        this.removeAllEventListeners();
      }
      return this;
    }
  }, {
    key: "removeAllEventListeners",
    value: function removeAllEventListeners() {
      var _this$emitter;
      (_this$emitter = this.emitter) === null || _this$emitter === void 0 || _this$emitter.removeAllListeners();
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener, options) {
      var _listener;
      if (!this.emitter)
        return this;
      var capture = is_boolean_default(options) ? options : options === null || options === void 0 ? void 0 : options.capture;
      if (capture)
        type += "capture";
      listener = isFunction(listener) ? listener : (_listener = listener) === null || _listener === void 0 ? void 0 : _listener.handleEvent;
      var context = isFunction(listener) ? void 0 : listener;
      this.emitter.off(type, listener, context);
      return this;
    }
    /**
     * @deprecated
     * @alias dispatchEvent
     */
  }, {
    key: "emit",
    value: function emit(eventName, object) {
      this.dispatchEvent(new CustomEvent(eventName, object));
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent
     */
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(e) {
      var skipPropagate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var canvas = CANVAS_CACHE.get(this);
      if (!canvas) {
        var _ownerDocument;
        if (this.document)
          canvas = this;
        else if (this.defaultView)
          canvas = this.defaultView;
        else
          canvas = (_ownerDocument = this.ownerDocument) === null || _ownerDocument === void 0 ? void 0 : _ownerDocument.defaultView;
        if (canvas)
          CANVAS_CACHE.set(this, canvas);
      }
      if (canvas) {
        e.manager = canvas.getEventService();
        if (!e.manager)
          return false;
        e.defaultPrevented = false;
        if (e.path)
          e.path.length = 0;
        else
          e.page = [];
        if (!skipPropagate)
          e.target = this;
        e.manager.dispatchEvent(e, e.type, skipPropagate);
      } else {
        this.emitter.emit(e.type, e);
      }
      return !e.defaultPrevented;
    }
  }]);
}();
var Node = function(_EventTarget) {
  function Node5() {
    var _this2;
    _classCallCheck(this, Node5);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Node5, [].concat(args));
    _this2.shadow = false;
    _this2.ownerDocument = null;
    _this2.isConnected = false;
    _this2.baseURI = "";
    _this2.childNodes = [];
    _this2.nodeType = 0;
    _this2.nodeName = "";
    _this2.nodeValue = null;
    _this2.parentNode = null;
    return _this2;
  }
  _inherits(Node5, _EventTarget);
  return _createClass(Node5, [{
    key: "textContent",
    get: (
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent
       */
      function get4() {
        var out = "";
        if (this.nodeName === Shape.TEXT) {
          out += this.style.text;
        }
        var _iterator = _createForOfIteratorHelper(this.childNodes), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _child = _step.value;
            if (_child.nodeName === Shape.TEXT) {
              out += _child.nodeValue;
            } else {
              out += _child.textContent;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return out;
      }
    ),
    set: function set9(content) {
      var _this2 = this;
      this.childNodes.slice().forEach(function(child) {
        _this2.removeChild(child);
      });
      if (this.nodeName === Shape.TEXT) {
        this.style.text = "".concat(content);
      }
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/getRootNode
     */
  }, {
    key: "getRootNode",
    value: function getRootNode() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (this.parentNode) {
        return this.parentNode.getRootNode(opts);
      }
      if (opts.composed && this.host) {
        return this.host.getRootNode(opts);
      }
      return this;
    }
  }, {
    key: "hasChildNodes",
    value: function hasChildNodes() {
      return this.childNodes.length > 0;
    }
  }, {
    key: "isDefaultNamespace",
    value: function isDefaultNamespace(namespace) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "lookupNamespaceURI",
    value: function lookupNamespaceURI(prefix) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "lookupPrefix",
    value: function lookupPrefix(namespace) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "normalize",
    value: function normalize10() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isEqualNode
     */
  }, {
    key: "isEqualNode",
    value: function isEqualNode(otherNode) {
      return this === otherNode;
    }
  }, {
    key: "isSameNode",
    value: function isSameNode(otherNode) {
      return this.isEqualNode(otherNode);
    }
  }, {
    key: "parent",
    get: (
      /**
       * @deprecated
       * @alias parentNode
       */
      function get4() {
        return this.parentNode;
      }
    )
  }, {
    key: "parentElement",
    get: function get4() {
      return null;
    }
  }, {
    key: "nextSibling",
    get: function get4() {
      return null;
    }
  }, {
    key: "previousSibling",
    get: function get4() {
      return null;
    }
  }, {
    key: "firstChild",
    get: function get4() {
      return this.childNodes.length > 0 ? this.childNodes[0] : null;
    }
  }, {
    key: "lastChild",
    get: function get4() {
      return this.childNodes.length > 0 ? this.childNodes[this.childNodes.length - 1] : null;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
     * @see https://github.com/b-fuze/deno-dom/blob/master/src/dom/node.ts#L338
     */
  }, {
    key: "compareDocumentPosition",
    value: function compareDocumentPosition(other) {
      if (other === this) {
        return 0;
      }
      var node1Root = other;
      var node2Root = this;
      var node1Hierarchy = [node1Root];
      var node2Hierarchy = [node2Root];
      while ((_node1Root$parentNode = node1Root.parentNode) !== null && _node1Root$parentNode !== void 0 ? _node1Root$parentNode : node2Root.parentNode) {
        var _node1Root$parentNode;
        node1Root = node1Root.parentNode ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode) : node1Root;
        node2Root = node2Root.parentNode ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode) : node2Root;
      }
      if (node1Root !== node2Root) {
        return Node5.DOCUMENT_POSITION_DISCONNECTED | Node5.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node5.DOCUMENT_POSITION_PRECEDING;
      }
      var longerHierarchy = node1Hierarchy.length > node2Hierarchy.length ? node1Hierarchy : node2Hierarchy;
      var shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy;
      if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] === shorterHierarchy[0]) {
        return longerHierarchy === node1Hierarchy ? (
          // other is a child of this
          Node5.DOCUMENT_POSITION_CONTAINED_BY | Node5.DOCUMENT_POSITION_FOLLOWING
        ) : (
          // this is a child of other
          Node5.DOCUMENT_POSITION_CONTAINS | Node5.DOCUMENT_POSITION_PRECEDING
        );
      }
      var longerStart = longerHierarchy.length - shorterHierarchy.length;
      for (var i = shorterHierarchy.length - 1; i >= 0; i--) {
        var shorterHierarchyNode = shorterHierarchy[i];
        var longerHierarchyNode = longerHierarchy[longerStart + i];
        if (longerHierarchyNode !== shorterHierarchyNode) {
          var siblings = shorterHierarchyNode.parentNode.childNodes;
          if (siblings.indexOf(shorterHierarchyNode) < siblings.indexOf(longerHierarchyNode)) {
            if (shorterHierarchy === node1Hierarchy) {
              return Node5.DOCUMENT_POSITION_PRECEDING;
            }
            return Node5.DOCUMENT_POSITION_FOLLOWING;
          }
          if (longerHierarchy === node1Hierarchy) {
            return Node5.DOCUMENT_POSITION_PRECEDING;
          }
          return Node5.DOCUMENT_POSITION_FOLLOWING;
        }
      }
      return Node5.DOCUMENT_POSITION_FOLLOWING;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode
     */
  }, {
    key: "contain",
    value: (
      /**
       * @deprecated
       * @alias contains
       */
      function contain2(other) {
        return this.contains(other);
      }
    )
  }, {
    key: "contains",
    value: function contains(other) {
      var tmp2 = other;
      while (tmp2 && this !== tmp2) {
        tmp2 = tmp2.parentNode;
      }
      return !!tmp2;
    }
  }, {
    key: "getAncestor",
    value: function getAncestor(n) {
      var temp = this;
      while (n > 0 && temp) {
        temp = temp.parentNode;
        n--;
      }
      return temp;
    }
  }, {
    key: "forEach",
    value: function forEach4(callback) {
      var stack = [this];
      while (stack.length > 0) {
        var node = stack.pop();
        var result = callback(node);
        if (result === false) {
          break;
        }
        for (var i = node.childNodes.length - 1; i >= 0; i--) {
          stack.push(node.childNodes[i]);
        }
      }
    }
  }], [{
    key: "isNode",
    value: function isNode(target) {
      return !!target.childNodes;
    }
  }]);
}(EventTarget);
Node.DOCUMENT_POSITION_DISCONNECTED = 1;
Node.DOCUMENT_POSITION_PRECEDING = 2;
Node.DOCUMENT_POSITION_FOLLOWING = 4;
Node.DOCUMENT_POSITION_CONTAINS = 8;
Node.DOCUMENT_POSITION_CONTAINED_BY = 16;
Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
var PROPAGATION_LIMIT = 2048;
var EventService = function() {
  function EventService2(globalRuntime, context) {
    var _this2 = this;
    _classCallCheck(this, EventService2);
    this.nativeHTMLMap = /* @__PURE__ */ new WeakMap();
    this.cursor = "default";
    this.mappingTable = {};
    this.mappingState = {
      trackingData: {}
    };
    this.eventPool = /* @__PURE__ */ new Map();
    this.tmpMatrix = mat4_exports.create();
    this.tmpVec3 = vec3_exports.create();
    this.onPointerDown = function(from) {
      var e = _this2.createPointerEvent(from);
      _this2.dispatchEvent(e, "pointerdown");
      if (e.pointerType === "touch") {
        _this2.dispatchEvent(e, "touchstart");
      } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
        var isRightButton = e.button === 2;
        _this2.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
      }
      var trackingData = _this2.trackingData(from.pointerId);
      trackingData.pressTargetsByButton[from.button] = e.composedPath();
      _this2.freeEvent(e);
    };
    this.onPointerUp = function(from) {
      var now2 = clock.now();
      var e = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
      _this2.dispatchEvent(e, "pointerup");
      if (e.pointerType === "touch") {
        _this2.dispatchEvent(e, "touchend");
      } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
        var isRightButton = e.button === 2;
        _this2.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
      }
      var trackingData = _this2.trackingData(from.pointerId);
      var pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
      var clickTarget = pressTarget;
      if (pressTarget && !e.composedPath().includes(pressTarget)) {
        var currentTarget = pressTarget;
        while (currentTarget && !e.composedPath().includes(currentTarget)) {
          e.currentTarget = currentTarget;
          _this2.notifyTarget(e, "pointerupoutside");
          if (e.pointerType === "touch") {
            _this2.notifyTarget(e, "touchendoutside");
          } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
            var _isRightButton = e.button === 2;
            _this2.notifyTarget(e, _isRightButton ? "rightupoutside" : "mouseupoutside");
          }
          if (Node.isNode(currentTarget)) {
            currentTarget = currentTarget.parentNode;
          }
        }
        delete trackingData.pressTargetsByButton[from.button];
        clickTarget = currentTarget;
      }
      if (clickTarget) {
        var _e$detail;
        var clickEvent = _this2.clonePointerEvent(e, "click");
        clickEvent.target = clickTarget;
        clickEvent.path = [];
        if (!trackingData.clicksByButton[from.button]) {
          trackingData.clicksByButton[from.button] = {
            clickCount: 0,
            target: clickEvent.target,
            timeStamp: now2
          };
        }
        var canvas = _this2.context.renderingContext.root.ownerDocument.defaultView;
        var clickHistory = trackingData.clicksByButton[from.button];
        if (clickHistory.target === clickEvent.target && now2 - clickHistory.timeStamp < canvas.getConfig().dblClickSpeed) {
          ++clickHistory.clickCount;
        } else {
          clickHistory.clickCount = 1;
        }
        clickHistory.target = clickEvent.target;
        clickHistory.timeStamp = now2;
        clickEvent.detail = clickHistory.clickCount;
        if (!((_e$detail = e.detail) !== null && _e$detail !== void 0 && _e$detail.preventClick)) {
          if (!_this2.context.config.useNativeClickEvent && (clickEvent.pointerType === "mouse" || clickEvent.pointerType === "touch")) {
            _this2.dispatchEvent(clickEvent, "click");
          }
          _this2.dispatchEvent(clickEvent, "pointertap");
        }
        _this2.freeEvent(clickEvent);
      }
      _this2.freeEvent(e);
    };
    this.onPointerMove = function(from) {
      var e = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
      var isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
      var trackingData = _this2.trackingData(from.pointerId);
      var outTarget = _this2.findMountedTarget(trackingData.overTargets);
      if (trackingData.overTargets && outTarget !== e.target) {
        var outType = from.type === "mousemove" ? "mouseout" : "pointerout";
        var outEvent = _this2.createPointerEvent(from, outType, outTarget || void 0);
        _this2.dispatchEvent(outEvent, "pointerout");
        if (isMouse)
          _this2.dispatchEvent(outEvent, "mouseout");
        if (!e.composedPath().includes(outTarget)) {
          var leaveEvent = _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
          leaveEvent.eventPhase = leaveEvent.AT_TARGET;
          while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
            leaveEvent.currentTarget = leaveEvent.target;
            _this2.notifyTarget(leaveEvent);
            if (isMouse) {
              _this2.notifyTarget(leaveEvent, "mouseleave");
            }
            if (Node.isNode(leaveEvent.target)) {
              leaveEvent.target = leaveEvent.target.parentNode;
            }
          }
          _this2.freeEvent(leaveEvent);
        }
        _this2.freeEvent(outEvent);
      }
      if (outTarget !== e.target) {
        var overType = from.type === "mousemove" ? "mouseover" : "pointerover";
        var overEvent = _this2.clonePointerEvent(e, overType);
        _this2.dispatchEvent(overEvent, "pointerover");
        if (isMouse)
          _this2.dispatchEvent(overEvent, "mouseover");
        var overTargetAncestor = outTarget && Node.isNode(outTarget) && outTarget.parentNode;
        while (overTargetAncestor && overTargetAncestor !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
          if (overTargetAncestor === e.target)
            break;
          overTargetAncestor = overTargetAncestor.parentNode;
        }
        var didPointerEnter = !overTargetAncestor || overTargetAncestor === (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode);
        if (didPointerEnter) {
          var enterEvent = _this2.clonePointerEvent(e, "pointerenter");
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
            enterEvent.currentTarget = enterEvent.target;
            _this2.notifyTarget(enterEvent);
            if (isMouse)
              _this2.notifyTarget(enterEvent, "mouseenter");
            if (Node.isNode(enterEvent.target)) {
              enterEvent.target = enterEvent.target.parentNode;
            }
          }
          _this2.freeEvent(enterEvent);
        }
        _this2.freeEvent(overEvent);
      }
      _this2.dispatchEvent(e, "pointermove");
      if (e.pointerType === "touch")
        _this2.dispatchEvent(e, "touchmove");
      if (isMouse) {
        _this2.dispatchEvent(e, "mousemove");
        _this2.cursor = _this2.getCursor(e.target);
      }
      trackingData.overTargets = e.composedPath();
      _this2.freeEvent(e);
    };
    this.onPointerOut = function(from) {
      var trackingData = _this2.trackingData(from.pointerId);
      if (trackingData.overTargets) {
        var isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
        var outTarget = _this2.findMountedTarget(trackingData.overTargets);
        var outEvent = _this2.createPointerEvent(from, "pointerout", outTarget || void 0);
        _this2.dispatchEvent(outEvent);
        if (isMouse)
          _this2.dispatchEvent(outEvent, "mouseout");
        var leaveEvent = _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
        leaveEvent.eventPhase = leaveEvent.AT_TARGET;
        while (leaveEvent.target && leaveEvent.target !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
          leaveEvent.currentTarget = leaveEvent.target;
          _this2.notifyTarget(leaveEvent);
          if (isMouse) {
            _this2.notifyTarget(leaveEvent, "mouseleave");
          }
          if (Node.isNode(leaveEvent.target)) {
            leaveEvent.target = leaveEvent.target.parentNode;
          }
        }
        trackingData.overTargets = null;
        _this2.freeEvent(outEvent);
        _this2.freeEvent(leaveEvent);
      }
      _this2.cursor = null;
    };
    this.onPointerOver = function(from) {
      var trackingData = _this2.trackingData(from.pointerId);
      var e = _this2.createPointerEvent(from);
      var isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
      _this2.dispatchEvent(e, "pointerover");
      if (isMouse)
        _this2.dispatchEvent(e, "mouseover");
      if (e.pointerType === "mouse")
        _this2.cursor = _this2.getCursor(e.target);
      var enterEvent = _this2.clonePointerEvent(e, "pointerenter");
      enterEvent.eventPhase = enterEvent.AT_TARGET;
      while (enterEvent.target && enterEvent.target !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
        enterEvent.currentTarget = enterEvent.target;
        _this2.notifyTarget(enterEvent);
        if (isMouse) {
          _this2.notifyTarget(enterEvent, "mouseenter");
        }
        if (Node.isNode(enterEvent.target)) {
          enterEvent.target = enterEvent.target.parentNode;
        }
      }
      trackingData.overTargets = e.composedPath();
      _this2.freeEvent(e);
      _this2.freeEvent(enterEvent);
    };
    this.onPointerUpOutside = function(from) {
      var trackingData = _this2.trackingData(from.pointerId);
      var pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
      var e = _this2.createPointerEvent(from);
      if (pressTarget) {
        var currentTarget = pressTarget;
        while (currentTarget) {
          e.currentTarget = currentTarget;
          _this2.notifyTarget(e, "pointerupoutside");
          if (e.pointerType === "touch")
            ;
          else if (e.pointerType === "mouse" || e.pointerType === "pen") {
            _this2.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");
          }
          if (Node.isNode(currentTarget)) {
            currentTarget = currentTarget.parentNode;
          }
        }
        delete trackingData.pressTargetsByButton[from.button];
      }
      _this2.freeEvent(e);
    };
    this.onWheel = function(from) {
      var wheelEvent = _this2.createWheelEvent(from);
      _this2.dispatchEvent(wheelEvent);
      _this2.freeEvent(wheelEvent);
    };
    this.onClick = function(from) {
      if (_this2.context.config.useNativeClickEvent) {
        var e = _this2.createPointerEvent(from);
        _this2.dispatchEvent(e);
        _this2.freeEvent(e);
      }
    };
    this.onPointerCancel = function(from) {
      var e = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
      _this2.dispatchEvent(e);
      _this2.freeEvent(e);
    };
    this.globalRuntime = globalRuntime;
    this.context = context;
  }
  return _createClass(EventService2, [{
    key: "init",
    value: function init() {
      this.rootTarget = this.context.renderingContext.root.parentNode;
      this.addEventMapping("pointerdown", this.onPointerDown);
      this.addEventMapping("pointerup", this.onPointerUp);
      this.addEventMapping("pointermove", this.onPointerMove);
      this.addEventMapping("pointerout", this.onPointerOut);
      this.addEventMapping("pointerleave", this.onPointerOut);
      this.addEventMapping("pointercancel", this.onPointerCancel);
      this.addEventMapping("pointerover", this.onPointerOver);
      this.addEventMapping("pointerupoutside", this.onPointerUpOutside);
      this.addEventMapping("wheel", this.onWheel);
      this.addEventMapping("click", this.onClick);
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      this.mappingTable = {};
      this.mappingState = {};
      this.eventPool.clear();
    }
  }, {
    key: "getScale",
    value: function getScale() {
      var bbox = this.context.contextService.getBoundingClientRect();
      var scaleX2 = 1;
      var scaleY2 = 1;
      var $el = this.context.contextService.getDomElement();
      if ($el && bbox) {
        var offsetWidth = $el.offsetWidth, offsetHeight = $el.offsetHeight;
        if (offsetWidth && offsetHeight) {
          scaleX2 = bbox.width / offsetWidth;
          scaleY2 = bbox.height / offsetHeight;
        }
      }
      return {
        scaleX: scaleX2,
        scaleY: scaleY2,
        bbox
      };
    }
    /**
     * Should account for CSS Transform applied on container.
     * @see https://github.com/antvis/G/issues/1161
     * @see https://github.com/antvis/G/issues/1677
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/offsetX
     */
  }, {
    key: "client2Viewport",
    value: function client2Viewport(client) {
      var _this$getScale = this.getScale(), scaleX2 = _this$getScale.scaleX, scaleY2 = _this$getScale.scaleY, bbox = _this$getScale.bbox;
      return new Point2((client.x - ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) / scaleX2, (client.y - ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) / scaleY2);
    }
  }, {
    key: "viewport2Client",
    value: function viewport2Client(canvas) {
      var _this$getScale2 = this.getScale(), scaleX2 = _this$getScale2.scaleX, scaleY2 = _this$getScale2.scaleY, bbox = _this$getScale2.bbox;
      return new Point2((canvas.x + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) * scaleX2, (canvas.y + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) * scaleY2);
    }
  }, {
    key: "viewport2Canvas",
    value: function viewport2Canvas(_ref) {
      var x3 = _ref.x, y3 = _ref.y;
      var canvas = this.rootTarget.defaultView;
      var camera = canvas.getCamera();
      var _this$context$config = this.context.config, width = _this$context$config.width, height = _this$context$config.height;
      var projectionMatrixInverse = camera.getPerspectiveInverse();
      var worldMatrix = camera.getWorldTransform();
      var vpMatrix = mat4_exports.multiply(this.tmpMatrix, worldMatrix, projectionMatrixInverse);
      var viewport = vec3_exports.set(this.tmpVec3, x3 / width * 2 - 1, (1 - y3 / height) * 2 - 1, 0);
      vec3_exports.transformMat4(viewport, viewport, vpMatrix);
      return new Point2(viewport[0], viewport[1]);
    }
  }, {
    key: "canvas2Viewport",
    value: function canvas2Viewport(canvasP) {
      var canvas = this.rootTarget.defaultView;
      var camera = canvas.getCamera();
      var projectionMatrix = camera.getPerspective();
      var viewMatrix = camera.getViewTransform();
      var vpMatrix = mat4_exports.multiply(this.tmpMatrix, projectionMatrix, viewMatrix);
      var clip = vec3_exports.set(this.tmpVec3, canvasP.x, canvasP.y, 0);
      vec3_exports.transformMat4(this.tmpVec3, this.tmpVec3, vpMatrix);
      var _this$context$config2 = this.context.config, width = _this$context$config2.width, height = _this$context$config2.height;
      return new Point2((clip[0] + 1) / 2 * width, (1 - (clip[1] + 1) / 2) * height);
    }
  }, {
    key: "setPickHandler",
    value: function setPickHandler(pickHandler) {
      this.pickHandler = pickHandler;
    }
  }, {
    key: "addEventMapping",
    value: function addEventMapping(type, fn) {
      if (!this.mappingTable[type]) {
        this.mappingTable[type] = [];
      }
      this.mappingTable[type].push({
        fn,
        priority: 0
      });
      this.mappingTable[type].sort(function(a4, b) {
        return a4.priority - b.priority;
      });
    }
  }, {
    key: "mapEvent",
    value: function mapEvent(e) {
      if (!this.rootTarget) {
        return;
      }
      var mappers = this.mappingTable[e.type];
      if (mappers) {
        for (var i = 0, j = mappers.length; i < j; i++) {
          mappers[i].fn(e);
        }
      } else {
        console.warn("[EventService]: Event mapping not defined for ".concat(e.type));
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(e, type, skipPropagate) {
      if (!skipPropagate) {
        e.propagationStopped = false;
        e.propagationImmediatelyStopped = false;
        this.propagate(e, type);
      } else {
        e.eventPhase = e.AT_TARGET;
        var canvas = this.rootTarget.defaultView || null;
        e.currentTarget = canvas;
        this.notifyListeners(e, type);
      }
    }
  }, {
    key: "propagate",
    value: function propagate(e, type) {
      if (!e.target) {
        return;
      }
      var composedPath = e.composedPath();
      e.eventPhase = e.CAPTURING_PHASE;
      for (var i = composedPath.length - 1; i >= 1; i--) {
        e.currentTarget = composedPath[i];
        this.notifyTarget(e, type);
        if (e.propagationStopped || e.propagationImmediatelyStopped)
          return;
      }
      e.eventPhase = e.AT_TARGET;
      e.currentTarget = e.target;
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped)
        return;
      var index3 = composedPath.indexOf(e.currentTarget);
      e.eventPhase = e.BUBBLING_PHASE;
      for (var _i = index3 + 1; _i < composedPath.length; _i++) {
        e.currentTarget = composedPath[_i];
        this.notifyTarget(e, type);
        if (e.propagationStopped || e.propagationImmediatelyStopped)
          return;
      }
    }
  }, {
    key: "propagationPath",
    value: function propagationPath(target) {
      var propagationPath2 = [target];
      var canvas = this.rootTarget.defaultView || null;
      if (canvas && canvas === target) {
        propagationPath2.unshift(canvas.document);
        return propagationPath2;
      }
      for (var i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
        if (Node.isNode(target) && target.parentNode) {
          propagationPath2.push(target.parentNode);
          target = target.parentNode;
        }
      }
      if (canvas) {
        propagationPath2.push(canvas);
      }
      return propagationPath2;
    }
  }, {
    key: "hitTest",
    value: function hitTest(position) {
      var viewportX = position.viewportX, viewportY = position.viewportY;
      var _this$context$config3 = this.context.config, width = _this$context$config3.width, height = _this$context$config3.height, disableHitTesting = _this$context$config3.disableHitTesting;
      if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
        return null;
      }
      return !disableHitTesting && this.pickHandler(position) || this.rootTarget || // return Document
      null;
    }
    /**
     * whether the native event trigger came from Canvas,
     * should account for HTML shape
     */
  }, {
    key: "isNativeEventFromCanvas",
    value: function isNativeEventFromCanvas($el, nativeEvent) {
      var _target;
      var target = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.target;
      if ((_target = target) !== null && _target !== void 0 && _target.shadowRoot) {
        target = nativeEvent.composedPath()[0];
      }
      if (target) {
        if (target === $el) {
          return true;
        }
        if ($el && $el.contains) {
          return $el.contains(target);
        }
      }
      if (nativeEvent !== null && nativeEvent !== void 0 && nativeEvent.composedPath) {
        return nativeEvent.composedPath().indexOf($el) > -1;
      }
      return false;
    }
    /**
     * Find HTML from composed path in native UI event.
     */
  }, {
    key: "getExistedHTML",
    value: function getExistedHTML(event) {
      if (event.nativeEvent.composedPath) {
        for (var _i2 = 0, _arr = event.nativeEvent.composedPath(); _i2 < _arr.length; _i2++) {
          var eventTarget = _arr[_i2];
          var existed = this.nativeHTMLMap.get(eventTarget);
          if (existed) {
            return existed;
          }
        }
      }
      return null;
    }
  }, {
    key: "pickTarget",
    value: function pickTarget(event) {
      return this.hitTest({
        clientX: event.clientX,
        clientY: event.clientY,
        viewportX: event.viewportX,
        viewportY: event.viewportY,
        x: event.canvasX,
        y: event.canvasY
      });
    }
  }, {
    key: "createPointerEvent",
    value: function createPointerEvent(from, type, target, fallbackTarget) {
      var event = this.allocateEvent(FederatedPointerEvent);
      this.copyPointerData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from;
      var existedHTML = this.getExistedHTML(event);
      var $el = this.context.contextService.getDomElement();
      event.target = target !== null && target !== void 0 ? target : existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event) || fallbackTarget;
      if (typeof type === "string") {
        event.type = type;
      }
      return event;
    }
  }, {
    key: "createWheelEvent",
    value: function createWheelEvent(from) {
      var event = this.allocateEvent(FederatedWheelEvent);
      this.copyWheelData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from;
      var existedHTML = this.getExistedHTML(event);
      var $el = this.context.contextService.getDomElement();
      event.target = existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event);
      return event;
    }
  }, {
    key: "trackingData",
    value: function trackingData(id4) {
      if (!this.mappingState.trackingData[id4]) {
        this.mappingState.trackingData[id4] = {
          pressTargetsByButton: {},
          clicksByButton: {},
          overTarget: null
        };
      }
      return this.mappingState.trackingData[id4];
    }
  }, {
    key: "cloneWheelEvent",
    value: function cloneWheelEvent(from) {
      var event = this.allocateEvent(FederatedWheelEvent);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from.originalEvent;
      this.copyWheelData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.target = from.target;
      event.path = from.composedPath().slice();
      event.type = from.type;
      return event;
    }
  }, {
    key: "clonePointerEvent",
    value: function clonePointerEvent(from, type) {
      var event = this.allocateEvent(FederatedPointerEvent);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from.originalEvent;
      this.copyPointerData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.target = from.target;
      event.path = from.composedPath().slice();
      event.type = type !== null && type !== void 0 ? type : event.type;
      return event;
    }
  }, {
    key: "copyPointerData",
    value: function copyPointerData(from, to) {
      to.pointerId = from.pointerId;
      to.width = from.width;
      to.height = from.height;
      to.isPrimary = from.isPrimary;
      to.pointerType = from.pointerType;
      to.pressure = from.pressure;
      to.tangentialPressure = from.tangentialPressure;
      to.tiltX = from.tiltX;
      to.tiltY = from.tiltY;
      to.twist = from.twist;
    }
  }, {
    key: "copyMouseData",
    value: function copyMouseData(from, to) {
      to.altKey = from.altKey;
      to.button = from.button;
      to.buttons = from.buttons;
      to.ctrlKey = from.ctrlKey;
      to.metaKey = from.metaKey;
      to.shiftKey = from.shiftKey;
      to.client.copyFrom(from.client);
      to.movement.copyFrom(from.movement);
      to.canvas.copyFrom(from.canvas);
      to.screen.copyFrom(from.screen);
      to.global.copyFrom(from.global);
      to.offset.copyFrom(from.offset);
    }
  }, {
    key: "copyWheelData",
    value: function copyWheelData(from, to) {
      to.deltaMode = from.deltaMode;
      to.deltaX = from.deltaX;
      to.deltaY = from.deltaY;
      to.deltaZ = from.deltaZ;
    }
  }, {
    key: "copyData",
    value: function copyData2(from, to) {
      to.isTrusted = from.isTrusted;
      to.timeStamp = clock.now();
      to.type = from.type;
      to.detail = from.detail;
      to.view = from.view;
      to.page.copyFrom(from.page);
      to.viewport.copyFrom(from.viewport);
    }
  }, {
    key: "allocateEvent",
    value: function allocateEvent(constructor) {
      if (!this.eventPool.has(constructor)) {
        this.eventPool.set(constructor, []);
      }
      var event = this.eventPool.get(constructor).pop() || new constructor(this);
      event.eventPhase = event.NONE;
      event.currentTarget = null;
      event.path = [];
      event.target = null;
      return event;
    }
  }, {
    key: "freeEvent",
    value: function freeEvent(event) {
      if (event.manager !== this)
        throw new Error("It is illegal to free an event not managed by this EventBoundary!");
      var constructor = event.constructor;
      if (!this.eventPool.has(constructor)) {
        this.eventPool.set(constructor, []);
      }
      this.eventPool.get(constructor).push(event);
    }
  }, {
    key: "notifyTarget",
    value: function notifyTarget(e, type) {
      type = type !== null && type !== void 0 ? type : e.type;
      var key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? "".concat(type, "capture") : type;
      this.notifyListeners(e, key);
      if (e.eventPhase === e.AT_TARGET) {
        this.notifyListeners(e, type);
      }
    }
  }, {
    key: "notifyListeners",
    value: function notifyListeners(e, type) {
      var emitter = e.currentTarget.emitter;
      var listeners = emitter._events[type];
      if (!listeners)
        return;
      if ("fn" in listeners) {
        if (listeners.once) {
          emitter.removeListener(type, listeners.fn, void 0, true);
        }
        listeners.fn.call(e.currentTarget || listeners.context, e);
      } else {
        for (var i = 0; i < listeners.length && !e.propagationImmediatelyStopped; i++) {
          if (listeners[i].once) {
            emitter.removeListener(type, listeners[i].fn, void 0, true);
          }
          listeners[i].fn.call(e.currentTarget || listeners[i].context, e);
        }
      }
    }
    /**
     * some detached nodes may exist in propagation path, need to skip them
     */
  }, {
    key: "findMountedTarget",
    value: function findMountedTarget(propagationPath) {
      if (!propagationPath) {
        return null;
      }
      var currentTarget = propagationPath[propagationPath.length - 1];
      for (var i = propagationPath.length - 2; i >= 0; i--) {
        var target = propagationPath[i];
        if (target === this.rootTarget || Node.isNode(target) && target.parentNode === currentTarget) {
          currentTarget = propagationPath[i];
        } else {
          break;
        }
      }
      return currentTarget;
    }
  }, {
    key: "getCursor",
    value: function getCursor(target) {
      var tmp2 = target;
      while (tmp2) {
        var cursor = isElement2(tmp2) && tmp2.getAttribute("cursor");
        if (cursor) {
          return cursor;
        }
        tmp2 = Node.isNode(tmp2) && tmp2.parentNode;
      }
    }
  }]);
}();
var OffscreenCanvasCreator = function() {
  function OffscreenCanvasCreator2() {
    _classCallCheck(this, OffscreenCanvasCreator2);
  }
  return _createClass(OffscreenCanvasCreator2, [{
    key: "getOrCreateCanvas",
    value: function getOrCreateCanvas(offscreenCanvas, contextAttributes) {
      if (this.canvas) {
        return this.canvas;
      }
      if (offscreenCanvas || runtime.offscreenCanvas) {
        this.canvas = offscreenCanvas || runtime.offscreenCanvas;
        this.context = this.canvas.getContext("2d", _objectSpread2({
          willReadFrequently: true
        }, contextAttributes));
      } else {
        try {
          this.canvas = new window.OffscreenCanvas(0, 0);
          this.context = this.canvas.getContext("2d", _objectSpread2({
            willReadFrequently: true
          }, contextAttributes));
          if (!this.context || !this.context.measureText) {
            this.canvas = document.createElement("canvas");
            this.context = this.canvas.getContext("2d");
          }
        } catch (_unused) {
          this.canvas = document.createElement("canvas");
          this.context = this.canvas.getContext("2d", _objectSpread2({
            willReadFrequently: true
          }, contextAttributes));
        }
      }
      this.canvas.width = 10;
      this.canvas.height = 10;
      return this.canvas;
    }
  }, {
    key: "getOrCreateContext",
    value: function getOrCreateContext(offscreenCanvas, contextAttributes) {
      if (this.context) {
        return this.context;
      }
      this.getOrCreateCanvas(offscreenCanvas, contextAttributes);
      return this.context;
    }
  }], [{
    key: "createCanvas",
    value: (
      /**
       * @returns new canvas instance
       */
      function createCanvas() {
        try {
          return new window.OffscreenCanvas(0, 0);
        } catch (_unused2) {
        }
        try {
          return document.createElement("canvas");
        } catch (_unused3) {
        }
        return null;
      }
    )
  }]);
}();
var RenderReason = function(RenderReason2) {
  RenderReason2[RenderReason2["CAMERA_CHANGED"] = 0] = "CAMERA_CHANGED";
  RenderReason2[RenderReason2["DISPLAY_OBJECT_CHANGED"] = 1] = "DISPLAY_OBJECT_CHANGED";
  RenderReason2[RenderReason2["NONE"] = 2] = "NONE";
  return RenderReason2;
}({});
var RenderingService = function() {
  function RenderingService2(globalRuntime, context) {
    _classCallCheck(this, RenderingService2);
    this.inited = false;
    this.stats = {
      /**
       * total display objects in scenegraph
       */
      total: 0,
      /**
       * number of display objects need to render in current frame
       */
      rendered: 0
    };
    this.zIndexCounter = 0;
    this.hooks = {
      /**
       * called before any frame rendered
       */
      init: new SyncHook(),
      initAsync: new AsyncParallelHook(),
      /**
       * only dirty object which has sth changed will be rendered
       */
      dirtycheck: new SyncWaterfallHook(),
      /**
       * do culling
       */
      cull: new SyncWaterfallHook(),
      /**
       * called at beginning of each frame, won't get called if nothing to re-render
       */
      beginFrame: new SyncHook(),
      /**
       * called before every dirty object get rendered
       */
      beforeRender: new SyncHook(),
      /**
       * called when every dirty object rendering even it's culled
       */
      render: new SyncHook(),
      /**
       * called after every dirty object get rendered
       */
      afterRender: new SyncHook(),
      endFrame: new SyncHook(),
      destroy: new SyncHook(),
      /**
       * use async but faster method such as GPU-based picking in `g-plugin-device-renderer`
       */
      pick: new AsyncSeriesWaterfallHook(),
      /**
       * Unsafe but sync version of pick.
       */
      pickSync: new SyncWaterfallHook(),
      /**
       * used in event system
       */
      pointerDown: new SyncHook(),
      pointerUp: new SyncHook(),
      pointerMove: new SyncHook(),
      pointerOut: new SyncHook(),
      pointerOver: new SyncHook(),
      pointerWheel: new SyncHook(),
      pointerCancel: new SyncHook(),
      click: new SyncHook()
    };
    this.globalRuntime = globalRuntime;
    this.context = context;
  }
  return _createClass(RenderingService2, [{
    key: "init",
    value: function init(callback) {
      var _this2 = this;
      var context = _objectSpread2(_objectSpread2({}, this.globalRuntime), this.context);
      this.context.renderingPlugins.forEach(function(plugin) {
        plugin.apply(context, _this2.globalRuntime);
      });
      this.hooks.init.call();
      if (this.hooks.initAsync.getCallbacksNum() === 0) {
        this.inited = true;
        callback();
      } else {
        this.hooks.initAsync.promise().then(function() {
          _this2.inited = true;
          callback();
        })["catch"](function(err) {
        });
      }
    }
  }, {
    key: "getStats",
    value: function getStats() {
      return this.stats;
    }
    /**
     * Meet the following conditions:
     * * disable DirtyRectangleRendering
     * * camera changed
     */
  }, {
    key: "disableDirtyRectangleRendering",
    value: function disableDirtyRectangleRendering() {
      var renderer = this.context.config.renderer;
      var _renderer$getConfig = renderer.getConfig(), enableDirtyRectangleRendering = _renderer$getConfig.enableDirtyRectangleRendering;
      return !enableDirtyRectangleRendering || this.context.renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
    }
  }, {
    key: "render",
    value: function render3(canvasConfig, frame2, rerenderCallback) {
      var _this2 = this;
      this.stats.total = 0;
      this.stats.rendered = 0;
      this.zIndexCounter = 0;
      var renderingContext = this.context.renderingContext;
      this.globalRuntime.sceneGraphService.syncHierarchy(renderingContext.root);
      this.globalRuntime.sceneGraphService.triggerPendingEvents();
      if (renderingContext.renderReasons.size && this.inited) {
        renderingContext.dirtyRectangleRenderingDisabled = this.disableDirtyRectangleRendering();
        var onlyCameraChanged = renderingContext.renderReasons.size === 1 && renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
        var shouldTriggerRenderHooks = !canvasConfig.disableRenderHooks || !(canvasConfig.disableRenderHooks && onlyCameraChanged);
        if (shouldTriggerRenderHooks) {
          this.renderDisplayObject(renderingContext.root, canvasConfig, renderingContext);
        }
        this.hooks.beginFrame.call(frame2);
        if (shouldTriggerRenderHooks) {
          renderingContext.renderListCurrentFrame.forEach(function(object) {
            _this2.hooks.beforeRender.call(object);
            _this2.hooks.render.call(object);
            _this2.hooks.afterRender.call(object);
          });
        }
        this.hooks.endFrame.call(frame2);
        renderingContext.renderListCurrentFrame = [];
        renderingContext.renderReasons.clear();
        rerenderCallback();
      }
    }
  }, {
    key: "renderDisplayObject",
    value: function renderDisplayObject(displayObject, canvasConfig, renderingContext) {
      var self2 = this;
      var _canvasConfig$rendere = canvasConfig.renderer.getConfig(), enableDirtyCheck = _canvasConfig$rendere.enableDirtyCheck, enableCulling = _canvasConfig$rendere.enableCulling;
      function internalRenderSingleDisplayObject(object) {
        var renderable = object.renderable, sortable = object.sortable;
        var objectChanged = enableDirtyCheck ? (
          // @ts-ignore
          renderable.dirty || renderingContext.dirtyRectangleRenderingDisabled ? object : null
        ) : object;
        if (objectChanged) {
          var objectToRender = enableCulling ? self2.hooks.cull.call(objectChanged, self2.context.camera) : objectChanged;
          if (objectToRender) {
            self2.stats.rendered += 1;
            renderingContext.renderListCurrentFrame.push(objectToRender);
          }
        }
        renderable.dirty = false;
        sortable.renderOrder = self2.zIndexCounter;
        self2.zIndexCounter += 1;
        self2.stats.total += 1;
        if (sortable.dirty) {
          self2.sort(object, sortable);
          sortable.dirty = false;
          sortable.dirtyChildren = [];
          sortable.dirtyReason = void 0;
        }
      }
      var stack = [displayObject];
      while (stack.length > 0) {
        var currentObject = stack.pop();
        internalRenderSingleDisplayObject(currentObject);
        var objects = currentObject.sortable.sorted || currentObject.childNodes;
        for (var i = objects.length - 1; i >= 0; i--) {
          stack.push(objects[i]);
        }
      }
    }
  }, {
    key: "sort",
    value: function sort2(displayObject, sortable) {
      if (sortable.sorted && sortable.dirtyReason !== SortReason.Z_INDEX_CHANGED) {
        sortable.dirtyChildren.forEach(function(child) {
          var index3 = displayObject.childNodes.indexOf(child);
          if (index3 === -1) {
            var _index = sortable.sorted.indexOf(child);
            if (_index >= 0) {
              sortable.sorted.splice(_index, 1);
            }
          } else if (sortable.sorted.length === 0) {
            sortable.sorted.push(child);
          } else {
            var _index2 = sortedIndex(sortable.sorted, child);
            sortable.sorted.splice(_index2, 0, child);
          }
        });
      } else {
        sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex);
      }
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      this.inited = false;
      this.hooks.destroy.call();
      this.globalRuntime.sceneGraphService.clearPendingEvents();
    }
  }, {
    key: "dirtify",
    value: function dirtify() {
      this.context.renderingContext.renderReasons.add(RenderReason.DISPLAY_OBJECT_CHANGED);
    }
  }]);
}();
var ATTRIBUTE_REGEXP = /\[\s*(.*)=(.*)\s*\]/;
var DefaultSceneGraphSelector = function() {
  function DefaultSceneGraphSelector2() {
    _classCallCheck(this, DefaultSceneGraphSelector2);
  }
  return _createClass(DefaultSceneGraphSelector2, [{
    key: "selectOne",
    value: function selectOne(query, root2) {
      var _this2 = this;
      if (query.startsWith(".")) {
        return root2.find(function(node) {
          return ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
        });
      }
      if (query.startsWith("#")) {
        return root2.find(function(node) {
          return node.id === _this2.getIdOrClassname(query);
        });
      }
      if (query.startsWith("[")) {
        var _this$getAttribute = this.getAttribute(query), name2 = _this$getAttribute.name, value2 = _this$getAttribute.value;
        if (name2) {
          return root2.find(function(node) {
            return root2 !== node && (name2 === "name" ? node.name === value2 : _this2.attributeToString(node, name2) === value2);
          });
        }
        return null;
      }
      return root2.find(function(node) {
        return root2 !== node && node.nodeName === query;
      });
    }
  }, {
    key: "selectAll",
    value: function selectAll(query, root2) {
      var _this2 = this;
      if (query.startsWith(".")) {
        return root2.findAll(function(node) {
          return root2 !== node && ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
        });
      }
      if (query.startsWith("#")) {
        return root2.findAll(function(node) {
          return root2 !== node && node.id === _this2.getIdOrClassname(query);
        });
      }
      if (query.startsWith("[")) {
        var _this$getAttribute2 = this.getAttribute(query), name2 = _this$getAttribute2.name, value2 = _this$getAttribute2.value;
        if (name2) {
          return root2.findAll(function(node) {
            return root2 !== node && (name2 === "name" ? node.name === value2 : _this2.attributeToString(node, name2) === value2);
          });
        }
        return [];
      }
      return root2.findAll(function(node) {
        return root2 !== node && node.nodeName === query;
      });
    }
  }, {
    key: "is",
    value: function is(query, node) {
      if (query.startsWith(".")) {
        return node.className === this.getIdOrClassname(query);
      }
      if (query.startsWith("#")) {
        return node.id === this.getIdOrClassname(query);
      }
      if (query.startsWith("[")) {
        var _this$getAttribute3 = this.getAttribute(query), name2 = _this$getAttribute3.name, value2 = _this$getAttribute3.value;
        return name2 === "name" ? node.name === value2 : this.attributeToString(node, name2) === value2;
      }
      return node.nodeName === query;
    }
  }, {
    key: "getIdOrClassname",
    value: function getIdOrClassname(query) {
      return query.substring(1);
    }
  }, {
    key: "getAttribute",
    value: function getAttribute(query) {
      var matches = query.match(ATTRIBUTE_REGEXP);
      var name2 = "";
      var value2 = "";
      if (matches && matches.length > 2) {
        name2 = matches[1].replace(/"/g, "");
        value2 = matches[2].replace(/"/g, "");
      }
      return {
        name: name2,
        value: value2
      };
    }
  }, {
    key: "attributeToString",
    value: function attributeToString(node, name2) {
      if (!node.getAttribute) {
        return "";
      }
      var value2 = node.getAttribute(name2);
      if (isNil(value2)) {
        return "";
      }
      if (value2.toString) {
        return value2.toString();
      }
      return "";
    }
  }]);
}();
var ElementEvent = function(ElementEvent2) {
  ElementEvent2["ATTR_MODIFIED"] = "DOMAttrModified";
  ElementEvent2["INSERTED"] = "DOMNodeInserted";
  ElementEvent2["MOUNTED"] = "DOMNodeInsertedIntoDocument";
  ElementEvent2["REMOVED"] = "removed";
  ElementEvent2["UNMOUNTED"] = "DOMNodeRemovedFromDocument";
  ElementEvent2["REPARENT"] = "reparent";
  ElementEvent2["DESTROY"] = "destroy";
  ElementEvent2["BOUNDS_CHANGED"] = "bounds-changed";
  ElementEvent2["CULLED"] = "culled";
  return ElementEvent2;
}({});
var MutationEvent = function(_FederatedEvent) {
  function MutationEvent2(typeArg, relatedNode, prevValue, newValue, attrName, attrChange, prevParsedValue, newParsedValue) {
    var _this2;
    _classCallCheck(this, MutationEvent2);
    _this2 = _callSuper(this, MutationEvent2, [null]);
    _this2.relatedNode = relatedNode;
    _this2.prevValue = prevValue;
    _this2.newValue = newValue;
    _this2.attrName = attrName;
    _this2.attrChange = attrChange;
    _this2.prevParsedValue = prevParsedValue;
    _this2.newParsedValue = newParsedValue;
    _this2.type = typeArg;
    return _this2;
  }
  _inherits(MutationEvent2, _FederatedEvent);
  return _createClass(MutationEvent2);
}(FederatedEvent);
MutationEvent.ADDITION = 2;
MutationEvent.MODIFICATION = 1;
MutationEvent.REMOVAL = 3;
function markRenderableDirty(e) {
  var renderable = e.renderable;
  if (renderable) {
    renderable.renderBoundsDirty = true;
    renderable.boundsDirty = true;
  }
}
var reparentEvent = new MutationEvent(ElementEvent.REPARENT, null, "", "", "", 0, "", "");
var $vec2Zero = vec2_exports.create();
var $vec3Zero = vec3_exports.create();
var $vec3One = vec3_exports.fromValues(1, 1, 1);
var $mat4Identity = mat4_exports.create();
var $vec2 = vec2_exports.create();
var $vec3$1 = vec3_exports.create();
var $mat4 = mat4_exports.create();
var $quat$1 = quat_exports.create();
var $setLocalTransform_1 = vec3_exports.create();
var $setLocalTransform_2 = quat_exports.create();
var $setLocalTransform_3 = vec3_exports.create();
var $setLocalPosition = vec3_exports.create();
var $setPosition_1 = vec3_exports.create();
var $setPosition_ParentInvertMatrix = mat4_exports.create();
var $setEulerAngles_InvParentRot = quat_exports.create();
var $rotateLocal = quat_exports.create();
var $rotate_ParentInvertRotation = quat_exports.create();
var $triggerPendingEvents_detail = {
  affectChildren: true
};
var DefaultSceneGraphService = function() {
  function DefaultSceneGraphService2(runtime2) {
    _classCallCheck(this, DefaultSceneGraphService2);
    this.pendingEvents = /* @__PURE__ */ new Map();
    this.boundsChangedEvent = new CustomEvent(ElementEvent.BOUNDS_CHANGED);
    this.displayObjectDependencyMap = /* @__PURE__ */ new WeakMap();
    this.runtime = runtime2;
  }
  return _createClass(DefaultSceneGraphService2, [{
    key: "matches",
    value: function matches(query, root2) {
      return this.runtime.sceneGraphSelector.is(query, root2);
    }
  }, {
    key: "querySelector",
    value: function querySelector(query, root2) {
      return this.runtime.sceneGraphSelector.selectOne(query, root2);
    }
  }, {
    key: "querySelectorAll",
    value: function querySelectorAll(query, root2) {
      return this.runtime.sceneGraphSelector.selectAll(query, root2);
    }
  }, {
    key: "attach",
    value: function attach(child, parent, index3) {
      var _sortable$sorted;
      var detached = false;
      if (child.parentNode) {
        detached = child.parentNode !== parent;
        this.detach(child);
      }
      var isChildFragment = child.nodeName === Shape.FRAGMENT;
      var isAttachToFragment = isInFragment(parent);
      child.parentNode = parent;
      var nodes = isChildFragment ? child.childNodes : [child];
      if (isNumber(index3)) {
        nodes.forEach(function(node) {
          parent.childNodes.splice(index3, 0, node);
          node.parentNode = parent;
        });
      } else {
        nodes.forEach(function(node) {
          parent.childNodes.push(node);
          node.parentNode = parent;
        });
      }
      var _ref = parent, sortable = _ref.sortable;
      if (sortable !== null && sortable !== void 0 && (_sortable$sorted = sortable.sorted) !== null && _sortable$sorted !== void 0 && _sortable$sorted.length || child.parsedStyle.zIndex) {
        if (sortable.dirtyChildren.indexOf(child) === -1) {
          sortable.dirtyChildren.push(child);
        }
        sortable.dirty = true;
        sortable.dirtyReason = SortReason.ADDED;
      }
      if (isAttachToFragment)
        return;
      if (isChildFragment)
        this.dirtifyFragment(child);
      else {
        var transform2 = child.transformable;
        if (transform2) {
          this.dirtifyWorld(child, transform2);
        }
      }
      if (detached) {
        child.dispatchEvent(reparentEvent);
      }
    }
  }, {
    key: "detach",
    value: function detach(child) {
      if (child.parentNode) {
        var _sortable$sorted2, _style;
        var transform2 = child.transformable;
        var _ref2 = child.parentNode, sortable = _ref2.sortable;
        if (sortable !== null && sortable !== void 0 && (_sortable$sorted2 = sortable.sorted) !== null && _sortable$sorted2 !== void 0 && _sortable$sorted2.length || (_style = child.style) !== null && _style !== void 0 && _style.zIndex) {
          if (sortable.dirtyChildren.indexOf(child) === -1) {
            sortable.dirtyChildren.push(child);
          }
          sortable.dirty = true;
          sortable.dirtyReason = SortReason.REMOVED;
        }
        var index3 = child.parentNode.childNodes.indexOf(child);
        if (index3 > -1) {
          child.parentNode.childNodes.splice(index3, 1);
        }
        if (transform2) {
          this.dirtifyWorld(child, transform2);
        }
        child.parentNode = null;
      }
    }
  }, {
    key: "getOrigin",
    value: function getOrigin2(element) {
      element.getGeometryBounds();
      return element.transformable.origin;
    }
    /**
     * same as pivot in Pixi.js
     *
     * @see https://stackoverflow.com/questions/40748452/how-to-change-css-transform-origin-but-preserve-transformation
     */
  }, {
    key: "setOrigin",
    value: function setOrigin(element, origin) {
      var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof origin === "number") {
        origin = [origin, y3, z];
      }
      var transform2 = element.transformable;
      if (origin[0] === transform2.origin[0] && origin[1] === transform2.origin[1] && origin[2] === transform2.origin[2]) {
        return;
      }
      var originVec = transform2.origin;
      originVec[0] = origin[0];
      originVec[1] = origin[1];
      originVec[2] = origin[2] || 0;
      this.dirtifyLocal(element, transform2);
    }
    /**
     * rotate in world space
     */
  }, {
    key: "rotate",
    value: function rotate7(element, degrees4) {
      var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof degrees4 === "number") {
        degrees4 = vec3_exports.fromValues(degrees4, y3, z);
      }
      var transform2 = element.transformable;
      if (element.parentNode === null || !element.parentNode.transformable) {
        this.rotateLocal(element, degrees4);
      } else {
        var rotation = $quat$1;
        quat_exports.fromEuler(rotation, degrees4[0], degrees4[1], degrees4[2]);
        var rot = this.getRotation(element);
        var parentRot = this.getRotation(element.parentNode);
        quat_exports.copy($rotate_ParentInvertRotation, parentRot);
        quat_exports.invert($rotate_ParentInvertRotation, $rotate_ParentInvertRotation);
        quat_exports.multiply(rotation, $rotate_ParentInvertRotation, rotation);
        quat_exports.multiply(transform2.localRotation, rotation, rot);
        quat_exports.normalize(transform2.localRotation, transform2.localRotation);
        this.dirtifyLocal(element, transform2);
      }
    }
    /**
     * rotate in local space
     * @see @see https://docs.microsoft.com/en-us/windows/win32/api/directxmath/nf-directxmath-xmquaternionrotationrollpitchyaw
     */
  }, {
    key: "rotateLocal",
    value: function rotateLocal(element, degrees4) {
      var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof degrees4 === "number") {
        degrees4 = vec3_exports.fromValues(degrees4, y3, z);
      }
      var transform2 = element.transformable;
      quat_exports.fromEuler($rotateLocal, degrees4[0], degrees4[1], degrees4[2]);
      quat_exports.mul(transform2.localRotation, transform2.localRotation, $rotateLocal);
      this.dirtifyLocal(element, transform2);
    }
    /**
     * set euler angles(degrees) in world space
     */
  }, {
    key: "setEulerAngles",
    value: function setEulerAngles(element, degrees4) {
      var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof degrees4 === "number") {
        degrees4 = vec3_exports.fromValues(degrees4, y3, z);
      }
      var transform2 = element.transformable;
      if (element.parentNode === null || !element.parentNode.transformable) {
        this.setLocalEulerAngles(element, degrees4);
      } else {
        quat_exports.fromEuler(transform2.localRotation, degrees4[0], degrees4[1], degrees4[2]);
        var parentRotation = this.getRotation(element.parentNode);
        quat_exports.copy($setEulerAngles_InvParentRot, quat_exports.invert($quat$1, parentRotation));
        quat_exports.mul(transform2.localRotation, transform2.localRotation, $setEulerAngles_InvParentRot);
        this.dirtifyLocal(element, transform2);
      }
    }
    /**
     * set euler angles(degrees) in local space
     */
  }, {
    key: "setLocalEulerAngles",
    value: function setLocalEulerAngles(element, degrees4) {
      var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var dirtify = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
      if (typeof degrees4 === "number") {
        degrees4 = vec3_exports.fromValues(degrees4, y3, z);
      }
      var transform2 = element.transformable;
      quat_exports.fromEuler(transform2.localRotation, degrees4[0], degrees4[1], degrees4[2]);
      if (dirtify) {
        this.dirtifyLocal(element, transform2);
      }
    }
    /**
     * translate in local space
     *
     * @example
     * ```
     * translateLocal(x, y, z)
     * translateLocal(vec3(x, y, z))
     * ```
     */
  }, {
    key: "translateLocal",
    value: function translateLocal(element, translation) {
      var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof translation === "number") {
        translation = vec3_exports.fromValues(translation, y3, z);
      }
      var transform2 = element.transformable;
      if (vec3_exports.equals(translation, $vec3Zero))
        return;
      vec3_exports.transformQuat(translation, translation, transform2.localRotation);
      vec3_exports.add(transform2.localPosition, transform2.localPosition, translation);
      this.dirtifyLocal(element, transform2);
    }
    /**
     * move to position in world space
     *
     * 对应 g 原版的 move/moveTo
     * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L684-L689
     */
  }, {
    key: "setPosition",
    value: function setPosition(element, position) {
      var _position$;
      var transform2 = element.transformable;
      $setPosition_1[0] = position[0];
      $setPosition_1[1] = position[1];
      $setPosition_1[2] = (_position$ = position[2]) !== null && _position$ !== void 0 ? _position$ : 0;
      if (vec3_exports.equals(this.getPosition(element), $setPosition_1)) {
        return;
      }
      vec3_exports.copy(transform2.position, $setPosition_1);
      if (element.parentNode === null || !element.parentNode.transformable) {
        vec3_exports.copy(transform2.localPosition, $setPosition_1);
      } else {
        var parentTransform = element.parentNode.transformable;
        mat4_exports.copy($setPosition_ParentInvertMatrix, parentTransform.worldTransform);
        mat4_exports.invert($setPosition_ParentInvertMatrix, $setPosition_ParentInvertMatrix);
        vec3_exports.transformMat4(transform2.localPosition, $setPosition_1, $setPosition_ParentInvertMatrix);
      }
      this.dirtifyLocal(element, transform2);
    }
    /**
     * move to position in local space
     */
  }, {
    key: "setLocalPosition",
    value: function setLocalPosition(element, position) {
      var _position$2;
      var dirtify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var transform2 = element.transformable;
      $setLocalPosition[0] = position[0];
      $setLocalPosition[1] = position[1];
      $setLocalPosition[2] = (_position$2 = position[2]) !== null && _position$2 !== void 0 ? _position$2 : 0;
      if (vec3_exports.equals(transform2.localPosition, $setLocalPosition)) {
        return;
      }
      vec3_exports.copy(transform2.localPosition, $setLocalPosition);
      if (dirtify) {
        this.dirtifyLocal(element, transform2);
      }
    }
    /**
     * scale in local space
     */
  }, {
    key: "scaleLocal",
    value: function scaleLocal(element, scaling) {
      var _scaling$;
      var transform2 = element.transformable;
      vec3_exports.multiply(transform2.localScale, transform2.localScale, vec3_exports.set($vec3$1, scaling[0], scaling[1], (_scaling$ = scaling[2]) !== null && _scaling$ !== void 0 ? _scaling$ : 1));
      this.dirtifyLocal(element, transform2);
    }
  }, {
    key: "setLocalScale",
    value: function setLocalScale(element, scaling) {
      var _scaling$2;
      var dirtify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var transform2 = element.transformable;
      vec3_exports.set($vec3$1, scaling[0], scaling[1], (_scaling$2 = scaling[2]) !== null && _scaling$2 !== void 0 ? _scaling$2 : transform2.localScale[2]);
      if (vec3_exports.equals($vec3$1, transform2.localScale)) {
        return;
      }
      vec3_exports.copy(transform2.localScale, $vec3$1);
      if (dirtify) {
        this.dirtifyLocal(element, transform2);
      }
    }
    /**
     * translate in world space
     *
     * @example
     * ```
     * translate(x, y, z)
     * translate(vec3(x, y, z))
     * ```
     *
     * 对应 g 原版的 translate 2D
     * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L665-L676
     */
  }, {
    key: "translate",
    value: function translate6(element, translation) {
      var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof translation === "number") {
        translation = vec3_exports.set($vec3$1, translation, y3, z);
      }
      if (vec3_exports.equals(translation, $vec3Zero))
        return;
      vec3_exports.add($vec3$1, this.getPosition(element), translation);
      this.setPosition(element, $vec3$1);
    }
  }, {
    key: "setRotation",
    value: function setRotation(element, rotation, y3, z, w) {
      var transform2 = element.transformable;
      if (typeof rotation === "number") {
        rotation = quat_exports.fromValues(rotation, y3, z, w);
      }
      if (element.parentNode === null || !element.parentNode.transformable) {
        this.setLocalRotation(element, rotation);
      } else {
        var parentRot = this.getRotation(element.parentNode);
        quat_exports.copy($quat$1, parentRot);
        quat_exports.invert($quat$1, $quat$1);
        quat_exports.multiply(transform2.localRotation, $quat$1, rotation);
        quat_exports.normalize(transform2.localRotation, transform2.localRotation);
        this.dirtifyLocal(element, transform2);
      }
    }
  }, {
    key: "setLocalRotation",
    value: function setLocalRotation(element, rotation, y3, z, w) {
      var dirtify = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
      if (typeof rotation === "number") {
        rotation = quat_exports.set($quat$1, rotation, y3, z, w);
      }
      var transform2 = element.transformable;
      quat_exports.copy(transform2.localRotation, rotation);
      if (dirtify) {
        this.dirtifyLocal(element, transform2);
      }
    }
  }, {
    key: "setLocalSkew",
    value: function setLocalSkew(element, skew2, y3) {
      var dirtify = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      if (typeof skew2 === "number") {
        skew2 = vec2_exports.set($vec2, skew2, y3);
      }
      var transform2 = element.transformable;
      vec2_exports.copy(transform2.localSkew, skew2);
      if (dirtify) {
        this.dirtifyLocal(element, transform2);
      }
    }
  }, {
    key: "dirtifyLocal",
    value: function dirtifyLocal(element, transform2) {
      if (isInFragment(element))
        return;
      if (!transform2.localDirtyFlag) {
        transform2.localDirtyFlag = true;
        if (!transform2.dirtyFlag) {
          this.dirtifyWorld(element, transform2);
        }
      }
    }
  }, {
    key: "dirtifyWorld",
    value: function dirtifyWorld(element, transform2) {
      if (!transform2.dirtyFlag) {
        this.unfreezeParentToRoot(element);
      }
      this.dirtifyWorldInternal(element, transform2);
      this.dirtifyToRoot(element, true);
    }
  }, {
    key: "dirtifyFragment",
    value: function dirtifyFragment(element) {
      var transform2 = element.transformable;
      if (transform2) {
        transform2.frozen = false;
        transform2.dirtyFlag = true;
        transform2.localDirtyFlag = true;
      }
      var renderable = element.renderable;
      if (renderable) {
        renderable.renderBoundsDirty = true;
        renderable.boundsDirty = true;
        renderable.dirty = true;
      }
      var length5 = element.childNodes.length;
      for (var i = 0; i < length5; i++) {
        this.dirtifyFragment(element.childNodes[i]);
      }
      if (element.nodeName === Shape.FRAGMENT) {
        this.pendingEvents.set(element, false);
      }
    }
  }, {
    key: "triggerPendingEvents",
    value: function triggerPendingEvents() {
      var _this2 = this;
      var triggered = /* @__PURE__ */ new Set();
      var trigger = function trigger2(element, detail) {
        if (!element.isConnected || triggered.has(element) || element.nodeName === Shape.FRAGMENT) {
          return;
        }
        _this2.boundsChangedEvent.detail = detail;
        _this2.boundsChangedEvent.target = element;
        if (element.isMutationObserved) {
          element.dispatchEvent(_this2.boundsChangedEvent);
        } else {
          element.ownerDocument.defaultView.dispatchEvent(_this2.boundsChangedEvent, true);
        }
        triggered.add(element);
      };
      this.pendingEvents.forEach(function(affectChildren, element) {
        if (element.nodeName === Shape.FRAGMENT) {
          return;
        }
        $triggerPendingEvents_detail.affectChildren = affectChildren;
        if (affectChildren) {
          element.forEach(function(e) {
            trigger(e, $triggerPendingEvents_detail);
          });
        } else
          trigger(element, $triggerPendingEvents_detail);
      });
      triggered.clear();
      this.clearPendingEvents();
    }
  }, {
    key: "clearPendingEvents",
    value: function clearPendingEvents() {
      this.pendingEvents.clear();
    }
  }, {
    key: "dirtifyToRoot",
    value: function dirtifyToRoot(element) {
      var affectChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var p2 = element;
      if (p2.renderable) {
        p2.renderable.dirty = true;
      }
      while (p2) {
        markRenderableDirty(p2);
        p2 = p2.parentNode;
      }
      if (affectChildren) {
        element.forEach(function(e) {
          markRenderableDirty(e);
        });
      }
      this.informDependentDisplayObjects(element);
      this.pendingEvents.set(element, affectChildren);
    }
  }, {
    key: "updateDisplayObjectDependency",
    value: function updateDisplayObjectDependency(name2, oldPath, newPath, object) {
      if (oldPath && oldPath !== newPath) {
        var oldDependencyMap = this.displayObjectDependencyMap.get(oldPath);
        if (oldDependencyMap && oldDependencyMap[name2]) {
          var index3 = oldDependencyMap[name2].indexOf(object);
          oldDependencyMap[name2].splice(index3, 1);
        }
      }
      if (newPath) {
        var newDependencyMap = this.displayObjectDependencyMap.get(newPath);
        if (!newDependencyMap) {
          this.displayObjectDependencyMap.set(newPath, {});
          newDependencyMap = this.displayObjectDependencyMap.get(newPath);
        }
        if (!newDependencyMap[name2]) {
          newDependencyMap[name2] = [];
        }
        newDependencyMap[name2].push(object);
      }
    }
  }, {
    key: "informDependentDisplayObjects",
    value: function informDependentDisplayObjects(object) {
      var _this2 = this;
      var dependencyMap = this.displayObjectDependencyMap.get(object);
      if (!dependencyMap) {
        return;
      }
      Object.keys(dependencyMap).forEach(function(name2) {
        dependencyMap[name2].forEach(function(target) {
          _this2.dirtifyToRoot(target, true);
          target.dispatchEvent(new MutationEvent(ElementEvent.ATTR_MODIFIED, target, _this2, _this2, name2, MutationEvent.MODIFICATION, _this2, _this2));
          if (target.isCustomElement && target.isConnected) {
            if (target.attributeChangedCallback) {
              target.attributeChangedCallback(name2, _this2, _this2);
            }
          }
        });
      });
    }
  }, {
    key: "getPosition",
    value: function getPosition(element) {
      var transform2 = element.transformable;
      return mat4_exports.getTranslation(transform2.position, this.getWorldTransform(element, transform2));
    }
  }, {
    key: "getRotation",
    value: function getRotation2(element) {
      var transform2 = element.transformable;
      return mat4_exports.getRotation(transform2.rotation, this.getWorldTransform(element, transform2));
    }
  }, {
    key: "getScale",
    value: function getScale(element) {
      var transform2 = element.transformable;
      return mat4_exports.getScaling(transform2.scaling, this.getWorldTransform(element, transform2));
    }
  }, {
    key: "getWorldTransform",
    value: function getWorldTransform(element) {
      var transform2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : element.transformable;
      if (!transform2.localDirtyFlag && !transform2.dirtyFlag) {
        return transform2.worldTransform;
      }
      if (element.parentNode && element.parentNode.transformable) {
        this.getWorldTransform(element.parentNode);
      }
      this.sync(element, transform2);
      return transform2.worldTransform;
    }
  }, {
    key: "getLocalPosition",
    value: function getLocalPosition(element) {
      return element.transformable.localPosition;
    }
  }, {
    key: "getLocalRotation",
    value: function getLocalRotation(element) {
      return element.transformable.localRotation;
    }
  }, {
    key: "getLocalScale",
    value: function getLocalScale(element) {
      return element.transformable.localScale;
    }
  }, {
    key: "getLocalSkew",
    value: function getLocalSkew(element) {
      return element.transformable.localSkew;
    }
  }, {
    key: "calcLocalTransform",
    value: function calcLocalTransform(transform2) {
      var hasSkew = transform2.localSkew[0] !== 0 || transform2.localSkew[1] !== 0;
      if (hasSkew) {
        mat4_exports.fromRotationTranslationScaleOrigin(transform2.localTransform, transform2.localRotation, transform2.localPosition, vec3_exports.fromValues(1, 1, 1), transform2.origin);
        if (transform2.localSkew[0] !== 0 || transform2.localSkew[1] !== 0) {
          mat4_exports.identity($mat4);
          $mat4[4] = Math.tan(transform2.localSkew[0]);
          $mat4[1] = Math.tan(transform2.localSkew[1]);
          mat4_exports.multiply(transform2.localTransform, transform2.localTransform, $mat4);
        }
        var scaling = mat4_exports.fromRotationTranslationScaleOrigin($mat4, quat_exports.set($quat$1, 0, 0, 0, 1), vec3_exports.set($vec3$1, 1, 1, 1), transform2.localScale, transform2.origin);
        mat4_exports.multiply(transform2.localTransform, transform2.localTransform, scaling);
      } else {
        var localTransform = transform2.localTransform, localPosition = transform2.localPosition, localRotation = transform2.localRotation, localScale = transform2.localScale, origin = transform2.origin;
        var hasPosition = localPosition[0] !== 0 || localPosition[1] !== 0 || localPosition[2] !== 0;
        var hasRotation = localRotation[3] !== 1 || localRotation[0] !== 0 || localRotation[1] !== 0 || localRotation[2] !== 0;
        var hasScale = localScale[0] !== 1 || localScale[1] !== 1 || localScale[2] !== 1;
        var hasOrigin = origin[0] !== 0 || origin[1] !== 0 || origin[2] !== 0;
        if (!hasRotation && !hasScale && !hasOrigin) {
          if (hasPosition) {
            mat4_exports.fromTranslation(localTransform, localPosition);
          } else {
            mat4_exports.identity(localTransform);
          }
        } else {
          mat4_exports.fromRotationTranslationScaleOrigin(localTransform, localRotation, localPosition, localScale, origin);
        }
      }
    }
  }, {
    key: "getLocalTransform",
    value: function getLocalTransform(element) {
      var transform2 = element.transformable;
      if (transform2.localDirtyFlag) {
        this.calcLocalTransform(transform2);
        transform2.localDirtyFlag = false;
      }
      return transform2.localTransform;
    }
  }, {
    key: "setLocalTransform",
    value: function setLocalTransform(element, transform2) {
      var t = mat4_exports.getTranslation($setLocalTransform_1, transform2);
      var r = mat4_exports.getRotation($setLocalTransform_2, transform2);
      var s3 = mat4_exports.getScaling($setLocalTransform_3, transform2);
      this.setLocalScale(element, s3, false);
      this.setLocalPosition(element, t, false);
      this.setLocalRotation(element, r, void 0, void 0, void 0, false);
      this.dirtifyLocal(element, element.transformable);
    }
  }, {
    key: "resetLocalTransform",
    value: function resetLocalTransform(element) {
      this.setLocalScale(element, $vec3One, false);
      this.setLocalPosition(element, $vec3Zero, false);
      this.setLocalEulerAngles(element, $vec3Zero, void 0, void 0, false);
      this.setLocalSkew(element, $vec2Zero, void 0, false);
      this.dirtifyLocal(element, element.transformable);
    }
  }, {
    key: "getTransformedGeometryBounds",
    value: function getTransformedGeometryBounds(element) {
      var render3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var existedAABB = arguments.length > 2 ? arguments[2] : void 0;
      var bounds = this.getGeometryBounds(element, render3);
      if (!AABB.isEmpty(bounds)) {
        var aabb = existedAABB || new AABB();
        aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
        return aabb;
      }
      return null;
    }
    /**
     * won't account for children
     */
  }, {
    key: "getGeometryBounds",
    value: function getGeometryBounds(element) {
      var render3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _ref3 = element, geometry = _ref3.geometry;
      if (geometry.dirty) {
        runtime.styleValueRegistry.updateGeometry(element);
      }
      var bounds = render3 ? geometry.renderBounds : geometry.contentBounds || null;
      return bounds || new AABB();
    }
    /**
     * account for children in world space
     */
  }, {
    key: "getBounds",
    value: function getBounds2(element) {
      var _this3 = this;
      var render3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _ref4 = element, renderable = _ref4.renderable;
      if (!renderable.boundsDirty && !render3 && renderable.bounds) {
        return renderable.bounds;
      }
      if (!renderable.renderBoundsDirty && render3 && renderable.renderBounds) {
        return renderable.renderBounds;
      }
      var existedAABB = render3 ? renderable.renderBounds : renderable.bounds;
      var aabb = this.getTransformedGeometryBounds(element, render3, existedAABB);
      var children = element.childNodes;
      children.forEach(function(child) {
        var childBounds = _this3.getBounds(child, render3);
        if (childBounds) {
          if (!aabb) {
            aabb = existedAABB || new AABB();
            aabb.update(childBounds.center, childBounds.halfExtents);
          } else {
            aabb.add(childBounds);
          }
        }
      });
      if (!aabb) {
        aabb = new AABB();
      }
      if (render3) {
        var clipped = findClosestClipPathTarget(element);
        if (clipped) {
          var clipPathBounds = clipped.parsedStyle.clipPath.getBounds(render3);
          if (!aabb) {
            aabb.update(clipPathBounds.center, clipPathBounds.halfExtents);
          } else if (clipPathBounds) {
            aabb = clipPathBounds.intersection(aabb);
          }
        }
      }
      if (render3) {
        renderable.renderBounds = aabb;
        renderable.renderBoundsDirty = false;
      } else {
        renderable.bounds = aabb;
        renderable.boundsDirty = false;
      }
      return aabb;
    }
    /**
     * account for children in local space
     */
  }, {
    key: "getLocalBounds",
    value: function getLocalBounds2(element) {
      if (element.parentNode) {
        var parentInvert = $mat4Identity;
        if (element.parentNode.transformable) {
          parentInvert = mat4_exports.invert($mat4, this.getWorldTransform(element.parentNode));
        }
        var bounds = this.getBounds(element);
        if (!AABB.isEmpty(bounds)) {
          var localBounds = new AABB();
          localBounds.setFromTransformedAABB(bounds, parentInvert);
          return localBounds;
        }
      }
      return this.getBounds(element);
    }
  }, {
    key: "getBoundingClientRect",
    value: function getBoundingClientRect(element) {
      var _element$ownerDocumen;
      var aabb;
      var bounds = this.getGeometryBounds(element);
      if (!AABB.isEmpty(bounds)) {
        aabb = new AABB();
        aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
      }
      var bbox = (_element$ownerDocumen = element.ownerDocument) === null || _element$ownerDocumen === void 0 || (_element$ownerDocumen = _element$ownerDocumen.defaultView) === null || _element$ownerDocumen === void 0 ? void 0 : _element$ownerDocumen.getContextService().getBoundingClientRect();
      if (aabb) {
        var _aabb$getMin = aabb.getMin(), _aabb$getMin2 = _slicedToArray(_aabb$getMin, 2), left2 = _aabb$getMin2[0], top = _aabb$getMin2[1];
        var _aabb$getMax = aabb.getMax(), _aabb$getMax2 = _slicedToArray(_aabb$getMax, 2), right2 = _aabb$getMax2[0], bottom = _aabb$getMax2[1];
        return new Rectangle(left2 + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), top + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0), right2 - left2, bottom - top);
      }
      return new Rectangle((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0, (bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0, 0, 0);
    }
  }, {
    key: "dirtifyWorldInternal",
    value: function dirtifyWorldInternal(element, transform2) {
      var _this4 = this;
      if (!transform2.dirtyFlag) {
        transform2.dirtyFlag = true;
        transform2.frozen = false;
        element.childNodes.forEach(function(child) {
          var childTransform = child.transformable;
          if (!childTransform.dirtyFlag) {
            _this4.dirtifyWorldInternal(child, childTransform);
          }
        });
        var _ref5 = element, renderable = _ref5.renderable;
        if (renderable) {
          renderable.renderBoundsDirty = true;
          renderable.boundsDirty = true;
          renderable.dirty = true;
        }
      }
    }
  }, {
    key: "syncHierarchy",
    value: function syncHierarchy(element) {
      var transform2 = element.transformable;
      if (transform2.frozen) {
        return;
      }
      transform2.frozen = true;
      if (transform2.localDirtyFlag || transform2.dirtyFlag) {
        this.sync(element, transform2);
      }
      var children = element.childNodes;
      for (var i = 0; i < children.length; i++) {
        this.syncHierarchy(children[i]);
      }
    }
  }, {
    key: "sync",
    value: function sync(element, transform2) {
      if (transform2.localDirtyFlag) {
        this.calcLocalTransform(transform2);
        transform2.localDirtyFlag = false;
      }
      if (transform2.dirtyFlag) {
        var parent = element.parentNode;
        var parentTransform = parent && parent.transformable;
        if (parent === null || !parentTransform) {
          mat4_exports.copy(transform2.worldTransform, transform2.localTransform);
        } else {
          mat4_exports.multiply(transform2.worldTransform, parentTransform.worldTransform, transform2.localTransform);
        }
        transform2.dirtyFlag = false;
      }
    }
  }, {
    key: "unfreezeParentToRoot",
    value: function unfreezeParentToRoot(child) {
      var p2 = child.parentNode;
      while (p2) {
        var transform2 = p2.transformable;
        if (transform2) {
          transform2.frozen = false;
        }
        p2 = p2.parentNode;
      }
    }
  }]);
}();
var TEXT_METRICS = {
  MetricsString: "|ÉqÅ",
  BaselineSymbol: "M",
  BaselineMultiplier: 1.4,
  HeightMultiplier: 2,
  Newlines: [
    10,
    // line feed
    13
    // carriage return
  ],
  BreakingSpaces: [
    9,
    // character tabulation
    32,
    // space
    8192,
    // en quad
    8193,
    // em quad
    8194,
    // en space
    8195,
    // em space
    8196,
    // three-per-em space
    8197,
    // four-per-em space
    8198,
    // six-per-em space
    8200,
    // punctuation space
    8201,
    // thin space
    8202,
    // hair space
    8287,
    // medium mathematical space
    12288
    // ideographic space
  ]
};
var LATIN_REGEX = /[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff!"#$%&'()*+,-./:;]/;
var regexCannotStartZhCn = /[!%),.:;?\]}¢°·'""†‡›℃∶、。〃〆〕〗〞﹚﹜！＂％＇），．：；？！］｝～]/;
var regexCannotEndZhCn = /[$(£¥·'"〈《「『【〔〖〝﹙﹛＄（．［｛￡￥]/;
var regexCannotStartZhTw = /[!),.:;?\]}¢·–—'"•"、。〆〞〕〉》」︰︱︲︳﹐﹑﹒﹓﹔﹕﹖﹘﹚﹜！），．：；？︶︸︺︼︾﹀﹂﹗］｜｝､]/;
var regexCannotEndZhTw = /[([{£¥'"‵〈《「『〔〝︴﹙﹛（｛︵︷︹︻︽︿﹁﹃﹏]/;
var regexCannotStartJaJp = /[)\]｝〕〉》」』】〙〗〟'"｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠–〜?!‼⁇⁈⁉・、:;,。.]/;
var regexCannotEndJaJp = /[([｛〔〈《「『【〘〖〝'"｟«—...‥〳〴〵]/;
var regexCannotStartKoKr = /[!%),.:;?\]}¢°'"†‡℃〆〈《「『〕！％），．：；？］｝]/;
var regexCannotEndKoKr = /[$([{£¥'"々〇〉》」〔＄（［｛｠￥￦#]/;
var regexCannotStart = new RegExp("".concat(regexCannotStartZhCn.source, "|").concat(regexCannotStartZhTw.source, "|").concat(regexCannotStartJaJp.source, "|").concat(regexCannotStartKoKr.source));
var regexCannotEnd = new RegExp("".concat(regexCannotEndZhCn.source, "|").concat(regexCannotEndZhTw.source, "|").concat(regexCannotEndJaJp.source, "|").concat(regexCannotEndKoKr.source));
var TextService = function() {
  function TextService2(runtime2) {
    var _this2 = this;
    _classCallCheck(this, TextService2);
    this.fontMetricsCache = {};
    this.shouldBreakByKinsokuShorui = function(_char, nextChar) {
      if (_this2.isBreakingSpace(nextChar))
        return false;
      if (_char) {
        if (regexCannotEnd.exec(nextChar) || regexCannotStart.exec(_char)) {
          return true;
        }
      }
      return false;
    };
    this.trimByKinsokuShorui = function(prev) {
      var next = _toConsumableArray(prev);
      var prevLine = next[next.length - 2];
      if (!prevLine) {
        return prev;
      }
      var lastChar = prevLine[prevLine.length - 1];
      next[next.length - 2] = prevLine.slice(0, -1);
      next[next.length - 1] = lastChar + next[next.length - 1];
      return next;
    };
    this.runtime = runtime2;
  }
  return _createClass(TextService2, [{
    key: "measureFont",
    value: (
      /**
       * Calculates the ascent, descent and fontSize of a given font-style.
       */
      function measureFont(font, offscreenCanvas) {
        if (this.fontMetricsCache[font]) {
          return this.fontMetricsCache[font];
        }
        var properties = {
          ascent: 0,
          descent: 0,
          fontSize: 0
        };
        var canvas = this.runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
        var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {
          willReadFrequently: true
        });
        context.font = font;
        var metricsString = TEXT_METRICS.MetricsString + TEXT_METRICS.BaselineSymbol;
        var width = Math.ceil(context.measureText(metricsString).width);
        var baseline = Math.ceil(context.measureText(TEXT_METRICS.BaselineSymbol).width);
        var height = TEXT_METRICS.HeightMultiplier * baseline;
        baseline = baseline * TEXT_METRICS.BaselineMultiplier | 0;
        canvas.width = width;
        canvas.height = height;
        context.fillStyle = "#f00";
        context.fillRect(0, 0, width, height);
        context.font = font;
        context.textBaseline = "alphabetic";
        context.fillStyle = "#000";
        context.fillText(metricsString, 0, baseline);
        var imagedata = context.getImageData(0, 0, width || 1, height || 1).data;
        var pixels = imagedata.length;
        var line4 = width * 4;
        var i = 0;
        var idx = 0;
        var stop = false;
        for (i = 0; i < baseline; ++i) {
          for (var j = 0; j < line4; j += 4) {
            if (imagedata[idx + j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx += line4;
          } else {
            break;
          }
        }
        properties.ascent = baseline - i;
        idx = pixels - line4;
        stop = false;
        for (i = height; i > baseline; --i) {
          for (var _j = 0; _j < line4; _j += 4) {
            if (imagedata[idx + _j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx -= line4;
          } else {
            break;
          }
        }
        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;
        this.fontMetricsCache[font] = properties;
        return properties;
      }
    )
  }, {
    key: "measureText",
    value: function measureText2(text, parsedStyle, offscreenCanvas) {
      var _parsedStyle$fontSize = parsedStyle.fontSize, fontSize = _parsedStyle$fontSize === void 0 ? 16 : _parsedStyle$fontSize, _parsedStyle$wordWrap = parsedStyle.wordWrap, wordWrap = _parsedStyle$wordWrap === void 0 ? false : _parsedStyle$wordWrap, strokeHeight = parsedStyle.lineHeight, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$letterSp = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp === void 0 ? 0 : _parsedStyle$letterSp, textPath = parsedStyle.textPath;
      parsedStyle.textPathSide;
      parsedStyle.textPathStartOffset;
      var _parsedStyle$leading = parsedStyle.leading, leading = _parsedStyle$leading === void 0 ? 0 : _parsedStyle$leading;
      var font = toFontString(parsedStyle);
      var fontProperties = this.measureFont(font, offscreenCanvas);
      if (fontProperties.fontSize === 0) {
        fontProperties.fontSize = fontSize;
        fontProperties.ascent = fontSize;
      }
      var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
      context.font = font;
      parsedStyle.isOverflowing = false;
      var outputText = wordWrap ? this.wordWrap(text, parsedStyle, offscreenCanvas) : text;
      var lines = outputText.split(/(?:\r\n|\r|\n)/);
      var lineWidths = new Array(lines.length);
      var maxLineWidth = 0;
      if (textPath) {
        textPath.getTotalLength();
        for (var i = 0; i < lines.length; i++) {
          context.measureText(lines[i]).width + (lines[i].length - 1) * letterSpacing;
        }
      } else {
        for (var _i = 0; _i < lines.length; _i++) {
          var _lineWidth = context.measureText(lines[_i]).width + (lines[_i].length - 1) * letterSpacing;
          lineWidths[_i] = _lineWidth;
          maxLineWidth = Math.max(maxLineWidth, _lineWidth);
        }
        var _width = maxLineWidth + lineWidth;
        var lineHeight = strokeHeight || fontProperties.fontSize + lineWidth;
        var height = Math.max(lineHeight, fontProperties.fontSize + lineWidth) + (lines.length - 1) * (lineHeight + leading);
        lineHeight += leading;
        var offsetY = 0;
        if (textBaseline === "middle") {
          offsetY = -height / 2;
        } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
          offsetY = -height;
        } else if (textBaseline === "top" || textBaseline === "hanging") {
          offsetY = 0;
        }
        return {
          font,
          width: _width,
          height,
          lines,
          lineWidths,
          lineHeight,
          maxLineWidth,
          fontProperties,
          lineMetrics: lineWidths.map(function(width, i2) {
            var offsetX = 0;
            if (textAlign === "center" || textAlign === "middle") {
              offsetX -= width / 2;
            } else if (textAlign === "right" || textAlign === "end") {
              offsetX -= width;
            }
            return new Rectangle(offsetX - lineWidth / 2, offsetY + i2 * lineHeight, width + lineWidth, lineHeight);
          })
        };
      }
    }
  }, {
    key: "wordWrap",
    value: function wordWrap(text, parsedStyle, offscreenCanvas) {
      var _this2 = this;
      var self2 = this;
      var _parsedStyle$wordWrap2 = parsedStyle.wordWrapWidth, wordWrapWidth = _parsedStyle$wordWrap2 === void 0 ? 0 : _parsedStyle$wordWrap2, _parsedStyle$letterSp2 = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp2 === void 0 ? 0 : _parsedStyle$letterSp2, _parsedStyle$maxLines = parsedStyle.maxLines, maxLines = _parsedStyle$maxLines === void 0 ? Infinity : _parsedStyle$maxLines, textOverflow = parsedStyle.textOverflow;
      var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
      var maxWidth = wordWrapWidth + letterSpacing;
      var ellipsis = "";
      if (textOverflow === "ellipsis") {
        ellipsis = "...";
      } else if (textOverflow && textOverflow !== "clip") {
        ellipsis = textOverflow;
      }
      var chars = Array.from(text);
      var lines = [];
      var currentLineIndex = 0;
      var currentLineWidth = 0;
      var prevLineLastCharIndex = 0;
      var cache2 = {};
      var calcWidth = function calcWidth2(txt) {
        return _this2.getFromCache(txt, letterSpacing, cache2, context);
      };
      var ellipsisWidth = calcWidth(ellipsis);
      function findCharIndexClosestWidthThreshold(lineTxt, txtLastCharIndex, txtStartCharIndex, widthThreshold) {
        while (calcWidth(lineTxt) < widthThreshold && txtLastCharIndex < chars.length - 1) {
          if (self2.isNewline(chars[txtLastCharIndex + 1])) {
            break;
          }
          txtLastCharIndex += 1;
          lineTxt += chars[txtLastCharIndex];
        }
        while (calcWidth(lineTxt) > widthThreshold && txtLastCharIndex > txtStartCharIndex) {
          txtLastCharIndex -= 1;
          lineTxt = lineTxt.slice(0, -1);
        }
        return {
          lineTxt,
          txtLastCharIndex
        };
      }
      function appendEllipsis(lineIndex, textCharIndex) {
        if (ellipsisWidth <= 0 || ellipsisWidth > maxWidth) {
          return;
        }
        if (!lines[lineIndex]) {
          lines[lineIndex] = ellipsis;
          return;
        }
        var result2 = findCharIndexClosestWidthThreshold(lines[lineIndex], textCharIndex, prevLineLastCharIndex + 1, maxWidth - ellipsisWidth);
        lines[lineIndex] = result2.lineTxt + ellipsis;
      }
      for (var i = 0; i < chars.length; i++) {
        var _char2 = chars[i];
        var prevChar = chars[i - 1];
        var nextChar = chars[i + 1];
        var charWidth = calcWidth(_char2);
        if (this.isNewline(_char2)) {
          if (currentLineIndex + 1 >= maxLines) {
            parsedStyle.isOverflowing = true;
            if (i < chars.length - 1) {
              appendEllipsis(currentLineIndex, i - 1);
            }
            break;
          }
          prevLineLastCharIndex = i - 1;
          currentLineIndex += 1;
          currentLineWidth = 0;
          lines[currentLineIndex] = "";
          continue;
        }
        if (currentLineWidth > 0 && currentLineWidth + charWidth > maxWidth) {
          var result = findCharIndexClosestWidthThreshold(lines[currentLineIndex], i - 1, prevLineLastCharIndex + 1, maxWidth);
          if (result.txtLastCharIndex !== i - 1) {
            lines[currentLineIndex] = result.lineTxt;
            if (result.txtLastCharIndex === chars.length - 1) {
              break;
            }
            i = result.txtLastCharIndex + 1;
            _char2 = chars[i];
            prevChar = chars[i - 1];
            nextChar = chars[i + 1];
            charWidth = calcWidth(_char2);
          }
          if (currentLineIndex + 1 >= maxLines) {
            parsedStyle.isOverflowing = true;
            appendEllipsis(currentLineIndex, i - 1);
            break;
          }
          prevLineLastCharIndex = i - 1;
          currentLineIndex += 1;
          currentLineWidth = 0;
          lines[currentLineIndex] = "";
          if (this.isBreakingSpace(_char2)) {
            continue;
          }
          if (!this.canBreakInLastChar(_char2)) {
            lines = this.trimToBreakable(lines);
            currentLineWidth = this.sumTextWidthByCache(lines[currentLineIndex] || "", calcWidth);
          }
          if (this.shouldBreakByKinsokuShorui(_char2, nextChar)) {
            lines = this.trimByKinsokuShorui(lines);
            currentLineWidth += calcWidth(prevChar || "");
          }
        }
        currentLineWidth += charWidth;
        lines[currentLineIndex] = (lines[currentLineIndex] || "") + _char2;
      }
      return lines.join("\n");
    }
  }, {
    key: "isBreakingSpace",
    value: function isBreakingSpace(_char3) {
      if (typeof _char3 !== "string") {
        return false;
      }
      return TEXT_METRICS.BreakingSpaces.indexOf(_char3.charCodeAt(0)) >= 0;
    }
  }, {
    key: "isNewline",
    value: function isNewline(_char4) {
      if (typeof _char4 !== "string") {
        return false;
      }
      return TEXT_METRICS.Newlines.indexOf(_char4.charCodeAt(0)) >= 0;
    }
  }, {
    key: "trimToBreakable",
    value: function trimToBreakable(prev) {
      var next = _toConsumableArray(prev);
      var prevLine = next[next.length - 2];
      var index3 = this.findBreakableIndex(prevLine);
      if (index3 === -1 || !prevLine)
        return next;
      var trimmedChar = prevLine.slice(index3, index3 + 1);
      var isTrimmedWithSpace = this.isBreakingSpace(trimmedChar);
      var trimFrom = index3 + 1;
      var trimTo = index3 + (isTrimmedWithSpace ? 0 : 1);
      next[next.length - 1] += prevLine.slice(trimFrom, prevLine.length);
      next[next.length - 2] = prevLine.slice(0, trimTo);
      return next;
    }
  }, {
    key: "canBreakInLastChar",
    value: function canBreakInLastChar(_char5) {
      if (_char5 && LATIN_REGEX.test(_char5))
        return false;
      return true;
    }
  }, {
    key: "sumTextWidthByCache",
    value: function sumTextWidthByCache(text, calcWidthWithCache) {
      return text.split("").reduce(function(sum4, c5) {
        return sum4 + calcWidthWithCache(c5);
      }, 0);
    }
  }, {
    key: "findBreakableIndex",
    value: function findBreakableIndex(line4) {
      for (var i = line4.length - 1; i >= 0; i--) {
        if (!LATIN_REGEX.test(line4[i]))
          return i;
      }
      return -1;
    }
  }, {
    key: "getFromCache",
    value: function getFromCache(key, letterSpacing, cache2, context) {
      var width = cache2[key];
      if (typeof width !== "number") {
        var spacing = key.length * letterSpacing;
        var metrics = context.measureText(key);
        width = metrics.width + spacing;
        cache2[key] = width;
      }
      return width;
    }
  }]);
}();
var runtime = {};
var geometryUpdaterFactory = function(_ref) {
  var rectUpdater = new RectUpdater();
  var polylineUpdater = new PolylineUpdater();
  return _ref = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref, Shape.FRAGMENT, null), Shape.CIRCLE, new CircleUpdater()), Shape.ELLIPSE, new EllipseUpdater()), Shape.RECT, rectUpdater), Shape.IMAGE, rectUpdater), Shape.GROUP, new GroupUpdater()), Shape.LINE, new LineUpdater()), Shape.TEXT, new TextUpdater(runtime)), Shape.POLYLINE, polylineUpdater), Shape.POLYGON, polylineUpdater), _defineProperty(_defineProperty(_defineProperty(_ref, Shape.PATH, new PathUpdater()), Shape.HTML, new HTMLUpdater()), Shape.MESH, null);
}();
var CSSPropertySyntaxFactory = function(_ref2) {
  var color3 = new CSSPropertyColor();
  var length5 = new CSSPropertyLengthOrPercentage();
  return _ref2 = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref2, PropertySyntax.PERCENTAGE, null), PropertySyntax.NUMBER, new CSSPropertyNumber()), PropertySyntax.ANGLE, new CSSPropertyAngle()), PropertySyntax.DEFINED_PATH, new CSSPropertyClipPath()), PropertySyntax.PAINT, color3), PropertySyntax.COLOR, color3), PropertySyntax.FILTER, new CSSPropertyFilter()), PropertySyntax.LENGTH, length5), PropertySyntax.LENGTH_PERCENTAGE, length5), PropertySyntax.LENGTH_PERCENTAGE_12, new CSSPropertyLengthOrPercentage12()), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref2, PropertySyntax.LENGTH_PERCENTAGE_14, new CSSPropertyLengthOrPercentage14()), PropertySyntax.COORDINATE, new CSSPropertyLengthOrPercentage()), PropertySyntax.OFFSET_DISTANCE, new CSSPropertyOffsetDistance()), PropertySyntax.OPACITY_VALUE, new CSSPropertyOpacity()), PropertySyntax.PATH, new CSSPropertyPath()), PropertySyntax.LIST_OF_POINTS, new CSSPropertyPoints()), PropertySyntax.SHADOW_BLUR, new CSSPropertyShadowBlur()), PropertySyntax.TEXT, new CSSPropertyText()), PropertySyntax.TEXT_TRANSFORM, new CSSPropertyTextTransform()), PropertySyntax.TRANSFORM, new CSSPropertyTransform()), _defineProperty(_defineProperty(_defineProperty(_ref2, PropertySyntax.TRANSFORM_ORIGIN, new CSSPropertyTransformOrigin()), PropertySyntax.Z_INDEX, new CSSPropertyZIndex()), PropertySyntax.MARKER, new CSSPropertyMarker());
}();
var getGlobalThis = function getGlobalThis2() {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  return {};
};
runtime.CameraContribution = Camera;
runtime.AnimationTimeline = null;
runtime.EasingFunction = null;
runtime.offscreenCanvasCreator = new OffscreenCanvasCreator();
runtime.sceneGraphSelector = new DefaultSceneGraphSelector();
runtime.sceneGraphService = new DefaultSceneGraphService(runtime);
runtime.textService = new TextService(runtime);
runtime.geometryUpdaterFactory = geometryUpdaterFactory;
runtime.CSSPropertySyntaxFactory = CSSPropertySyntaxFactory;
runtime.styleValueRegistry = new DefaultStyleValueRegistry(runtime);
runtime.layoutRegistry = null;
runtime.globalThis = getGlobalThis();
runtime.enableStyleSyntax = true;
runtime.enableSizeAttenuation = false;
var entityCounter = 0;
var insertedEvent = new MutationEvent(ElementEvent.INSERTED, null, "", "", "", 0, "", "");
var removedEvent = new MutationEvent(ElementEvent.REMOVED, null, "", "", "", 0, "", "");
var destroyEvent = new CustomEvent(ElementEvent.DESTROY);
var Element2 = function(_Node) {
  function Element3() {
    var _this2;
    _classCallCheck(this, Element3);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Element3, [].concat(args));
    _this2.entity = entityCounter++;
    _this2.renderable = {
      bounds: void 0,
      boundsDirty: true,
      renderBounds: void 0,
      renderBoundsDirty: true,
      dirtyRenderBounds: void 0,
      dirty: false
    };
    _this2.cullable = {
      strategy: Strategy.Standard,
      visibilityPlaneMask: -1,
      visible: true,
      enable: true
    };
    _this2.transformable = {
      dirtyFlag: false,
      localDirtyFlag: false,
      frozen: false,
      localPosition: [0, 0, 0],
      localRotation: [0, 0, 0, 1],
      localScale: [1, 1, 1],
      localTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
      localSkew: [0, 0],
      position: [0, 0, 0],
      rotation: [0, 0, 0, 1],
      scaling: [1, 1, 1],
      worldTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
      origin: [0, 0, 0]
    };
    _this2.sortable = {
      dirty: false,
      sorted: void 0,
      renderOrder: 0,
      dirtyChildren: [],
      dirtyReason: void 0
    };
    _this2.geometry = {
      contentBounds: void 0,
      renderBounds: void 0,
      dirty: true
    };
    _this2.rBushNode = {
      aabb: void 0
    };
    _this2.namespaceURI = "g";
    _this2.scrollLeft = 0;
    _this2.scrollTop = 0;
    _this2.clientTop = 0;
    _this2.clientLeft = 0;
    _this2.destroyed = false;
    _this2.style = {};
    _this2.computedStyle = {};
    _this2.parsedStyle = {
      // opacity: '',
      // fillOpacity: '',
      // strokeOpacity: '',
      // transformOrigin: '',
      // visibility: '',
      // pointerEvents: '',
      // lineWidth: '',
      // lineCap: '',
      // lineJoin: '',
      // increasedLineWidthForHitTesting: '',
      // fontSize: '',
      // fontFamily: '',
      // fontStyle: '',
      // fontWeight: '',
      // fontVariant: '',
      // textAlign: '',
      // textBaseline: '',
      // textTransform: '',
    };
    _this2.attributes = {};
    return _this2;
  }
  _inherits(Element3, _Node);
  return _createClass(Element3, [{
    key: "className",
    get: (
      /**
       * used with `getElementById()`
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/id
       */
      /**
       * used in `getElementsByClassName`
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       */
      function get4() {
        return this.getAttribute("class") || "";
      }
    ),
    set: function set9(className2) {
      this.setAttribute("class", className2);
    }
    /**
     * used in `getElementsByName`
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName
     */
  }, {
    key: "classList",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/classList
       */
      function get4() {
        return this.className.split(" ").filter(function(c5) {
          return c5 !== "";
        });
      }
    )
  }, {
    key: "tagName",
    get: function get4() {
      return this.nodeName;
    }
  }, {
    key: "children",
    get: function get4() {
      return this.childNodes;
    }
  }, {
    key: "childElementCount",
    get: function get4() {
      return this.childNodes.length;
    }
  }, {
    key: "firstElementChild",
    get: function get4() {
      return this.firstChild;
    }
  }, {
    key: "lastElementChild",
    get: function get4() {
      return this.lastChild;
    }
  }, {
    key: "parentElement",
    get: function get4() {
      return this.parentNode;
    }
  }, {
    key: "nextSibling",
    get: function get4() {
      if (this.parentNode) {
        var index3 = this.parentNode.childNodes.indexOf(this);
        return this.parentNode.childNodes[index3 + 1] || null;
      }
      return null;
    }
  }, {
    key: "previousSibling",
    get: function get4() {
      if (this.parentNode) {
        var index3 = this.parentNode.childNodes.indexOf(this);
        return this.parentNode.childNodes[index3 - 1] || null;
      }
      return null;
    }
  }, {
    key: "cloneNode",
    value: function cloneNode(deep2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "appendChild",
    value: function appendChild(child, index3) {
      var _this$ownerDocument;
      if (child.destroyed) {
        throw new Error(ERROR_MSG_APPEND_DESTROYED_ELEMENT);
      }
      runtime.sceneGraphService.attach(child, this, index3);
      if ((_this$ownerDocument = this.ownerDocument) !== null && _this$ownerDocument !== void 0 && _this$ownerDocument.defaultView) {
        if (!isInFragment(this) && child.nodeName === Shape.FRAGMENT) {
          this.ownerDocument.defaultView.mountFragment(child);
        } else {
          this.ownerDocument.defaultView.mountChildren(child);
        }
      }
      if (this.isMutationObserved) {
        insertedEvent.relatedNode = this;
        child.dispatchEvent(insertedEvent);
      }
      return child;
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(newChild, refChild) {
      if (!refChild) {
        this.appendChild(newChild);
      } else {
        if (newChild.parentElement) {
          newChild.parentElement.removeChild(newChild);
        }
        var index3 = this.childNodes.indexOf(refChild);
        if (index3 === -1) {
          this.appendChild(newChild);
        } else {
          this.appendChild(newChild, index3);
        }
      }
      return newChild;
    }
  }, {
    key: "replaceChild",
    value: function replaceChild2(newChild, oldChild) {
      var index3 = this.childNodes.indexOf(oldChild);
      this.removeChild(oldChild);
      this.appendChild(newChild, index3);
      return oldChild;
    }
  }, {
    key: "removeChild",
    value: function removeChild(child) {
      var _child$ownerDocument;
      removedEvent.relatedNode = this;
      child.dispatchEvent(removedEvent);
      if ((_child$ownerDocument = child.ownerDocument) !== null && _child$ownerDocument !== void 0 && _child$ownerDocument.defaultView) {
        child.ownerDocument.defaultView.unmountChildren(child);
      }
      runtime.sceneGraphService.detach(child);
      return child;
    }
    /**
     * Remove all children which can be appended to its original parent later again.
     */
  }, {
    key: "removeChildren",
    value: function removeChildren() {
      for (var i = this.childNodes.length - 1; i >= 0; i--) {
        var child = this.childNodes[i];
        this.removeChild(child);
      }
    }
    /**
     * Recursively destroy all children which can not be appended to its original parent later again.
     */
  }, {
    key: "destroyChildren",
    value: function destroyChildren() {
      for (var i = this.childNodes.length - 1; i >= 0; i--) {
        var child = this.childNodes[i];
        if (child.childNodes.length > 0) {
          child.destroyChildren();
        }
        child.destroy();
      }
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
     */
  }, {
    key: "matches",
    value: function matches(selector) {
      return runtime.sceneGraphService.matches(selector, this);
    }
  }, {
    key: "getElementById",
    value: function getElementById(id4) {
      return runtime.sceneGraphService.querySelector("#".concat(id4), this);
    }
  }, {
    key: "getElementsByName",
    value: function getElementsByName(name2) {
      return runtime.sceneGraphService.querySelectorAll('[name="'.concat(name2, '"]'), this);
    }
  }, {
    key: "getElementsByClassName",
    value: function getElementsByClassName(className2) {
      return runtime.sceneGraphService.querySelectorAll(".".concat(className2), this);
    }
  }, {
    key: "getElementsByTagName",
    value: function getElementsByTagName(tagName) {
      return runtime.sceneGraphService.querySelectorAll(tagName, this);
    }
  }, {
    key: "querySelector",
    value: function querySelector(selectors) {
      return runtime.sceneGraphService.querySelector(selectors, this);
    }
  }, {
    key: "querySelectorAll",
    value: function querySelectorAll(selectors) {
      return runtime.sceneGraphService.querySelectorAll(selectors, this);
    }
    /**
     * should traverses the element and its parents (heading toward the document root)
     * until it finds a node that matches the specified CSS selector.
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/closest
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#polyfill
     */
  }, {
    key: "closest",
    value: function closest(selectors) {
      var el = this;
      do {
        if (runtime.sceneGraphService.matches(selectors, el))
          return el;
        el = el.parentElement;
      } while (el !== null);
      return null;
    }
    /**
     * search in scene group, but should not include itself
     */
  }, {
    key: "find",
    value: function find6(filter3) {
      var _this2 = this;
      var target = null;
      this.forEach(function(object) {
        if (object !== _this2 && filter3(object)) {
          target = object;
          return false;
        }
        return true;
      });
      return target;
    }
  }, {
    key: "findAll",
    value: function findAll(filter3) {
      var _this3 = this;
      var objects = [];
      this.forEach(function(object) {
        if (object !== _this3 && filter3(object)) {
          objects.push(object);
        }
      });
      return objects;
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/after
     */
  }, {
    key: "after",
    value: function after() {
      var _this4 = this;
      if (this.parentNode) {
        var index3 = this.parentNode.childNodes.indexOf(this);
        for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          nodes[_key2] = arguments[_key2];
        }
        nodes.forEach(function(node, i) {
          var _this4$parentNode;
          return (_this4$parentNode = _this4.parentNode) === null || _this4$parentNode === void 0 ? void 0 : _this4$parentNode.appendChild(node, index3 + i + 1);
        });
      }
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/before
     */
  }, {
    key: "before",
    value: function before() {
      if (this.parentNode) {
        var _ref;
        var index3 = this.parentNode.childNodes.indexOf(this);
        for (var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          nodes[_key3] = arguments[_key3];
        }
        var first3 = nodes[0], rest = nodes.slice(1);
        this.parentNode.appendChild(first3, index3);
        (_ref = first3).after.apply(_ref, _toConsumableArray(rest));
      }
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceWith
     */
  }, {
    key: "replaceWith",
    value: function replaceWith() {
      this.after.apply(this, arguments);
      this.remove();
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/append
     */
  }, {
    key: "append",
    value: function append3() {
      var _this5 = this;
      for (var _len4 = arguments.length, nodes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        nodes[_key4] = arguments[_key4];
      }
      nodes.forEach(function(node) {
        return _this5.appendChild(node);
      });
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/prepend
     */
  }, {
    key: "prepend",
    value: function prepend() {
      var _this6 = this;
      for (var _len5 = arguments.length, nodes = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        nodes[_key5] = arguments[_key5];
      }
      nodes.forEach(function(node, i) {
        return _this6.appendChild(node, i);
      });
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceChildren
     */
  }, {
    key: "replaceChildren",
    value: function replaceChildren2() {
      while (this.childNodes.length && this.firstChild) {
        this.removeChild(this.firstChild);
      }
      this.append.apply(this, arguments);
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/remove
     */
  }, {
    key: "remove",
    value: function remove2() {
      if (this.parentNode) {
        return this.parentNode.removeChild(this);
      }
      return this;
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      this.destroyChildren();
      this.dispatchEvent(destroyEvent);
      this.remove();
      this.emitter.removeAllListeners();
      this.destroyed = true;
    }
  }, {
    key: "getGeometryBounds",
    value: function getGeometryBounds() {
      return runtime.sceneGraphService.getGeometryBounds(this);
    }
  }, {
    key: "getRenderBounds",
    value: function getRenderBounds() {
      return runtime.sceneGraphService.getBounds(this, true);
    }
    /**
     * get bounds in world space, account for children
     */
  }, {
    key: "getBounds",
    value: function getBounds2() {
      return runtime.sceneGraphService.getBounds(this);
    }
    /**
     * get bounds in local space, account for children
     */
  }, {
    key: "getLocalBounds",
    value: function getLocalBounds2() {
      return runtime.sceneGraphService.getLocalBounds(this);
    }
    /**
     * account for context's bounds in client space,
     * but not accounting for children
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
     */
  }, {
    key: "getBoundingClientRect",
    value: function getBoundingClientRect() {
      return runtime.sceneGraphService.getBoundingClientRect(this);
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects
     */
  }, {
    key: "getClientRects",
    value: function getClientRects() {
      return [this.getBoundingClientRect()];
    }
  }, {
    key: "computedStyleMap",
    value: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/computedStyleMap
       * eg. circle.computedStyleMap().get('fill');
       */
      function computedStyleMap() {
        return new Map(Object.entries(this.computedStyle));
      }
    )
  }, {
    key: "getAttributeNames",
    value: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNames
       */
      function getAttributeNames() {
        return Object.keys(this.attributes);
      }
    )
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute
     */
  }, {
    key: "getAttribute",
    value: function getAttribute(name2) {
      if (typeof name2 === "symbol") {
        return void 0;
      }
      var value2 = this.attributes[name2];
      if (value2 === void 0) {
        return value2;
      }
      return value2;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttribute
     */
  }, {
    key: "hasAttribute",
    value: function hasAttribute(qualifiedName) {
      return this.getAttributeNames().includes(qualifiedName);
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttributes
     */
  }, {
    key: "hasAttributes",
    value: function hasAttributes() {
      return !!this.getAttributeNames().length;
    }
    /**
     * should use removeAttribute() instead of setting the attribute value to null either directly or using setAttribute(). Many attributes will not behave as expected if you set them to null.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute
     */
  }, {
    key: "removeAttribute",
    value: function removeAttribute(attributeName) {
      this.setAttribute(attributeName, null);
      delete this.attributes[attributeName];
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute
     */
  }, {
    key: "setAttribute",
    value: function setAttribute(attributeName, value2, force, memoize5) {
      this.attributes[attributeName] = value2;
    }
  }, {
    key: "getAttributeNS",
    value: function getAttributeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "getAttributeNode",
    value: function getAttributeNode(qualifiedName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "getAttributeNodeNS",
    value: function getAttributeNodeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "hasAttributeNS",
    value: function hasAttributeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "removeAttributeNS",
    value: function removeAttributeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "removeAttributeNode",
    value: function removeAttributeNode(attr2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "setAttributeNS",
    value: function setAttributeNS(namespace, qualifiedName, value2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "setAttributeNode",
    value: function setAttributeNode(attr2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "setAttributeNodeNS",
    value: function setAttributeNodeNS(attr2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "toggleAttribute",
    value: function toggleAttribute(qualifiedName, force) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }]);
}(Node);
function isDisplayObject(value2) {
  return !!(value2 !== null && value2 !== void 0 && value2.nodeName);
}
var Proxy = runtime.globalThis.Proxy ? runtime.globalThis.Proxy : function() {
};
var attrModifiedEvent = new MutationEvent(ElementEvent.ATTR_MODIFIED, null, null, null, null, MutationEvent.MODIFICATION, null, null);
var $vec3 = vec3_exports.create();
var $quat = quat_exports.create();
var DisplayObject = function(_Element) {
  function DisplayObject2(config) {
    var _this2;
    _classCallCheck(this, DisplayObject2);
    _this2 = _callSuper(this, DisplayObject2);
    _this2.isCustomElement = false;
    _this2.isMutationObserved = false;
    _this2.activeAnimations = [];
    _this2.config = config;
    _this2.id = config.id || "";
    _this2.name = config.name || "";
    if (config.className || config["class"]) {
      _this2.className = config.className || config["class"];
    }
    _this2.nodeName = config.type || Shape.GROUP;
    if (config.initialParsedStyle) {
      Object.assign(_this2.parsedStyle, config.initialParsedStyle);
    }
    _this2.initAttributes(config.style);
    if (runtime.enableStyleSyntax) {
      _this2.style = new Proxy(
        // @ts-ignore
        {
          // ...this.attributes,
          setProperty: function setProperty(propertyName, value2) {
            _this2.setAttribute(propertyName, value2);
          },
          getPropertyValue: function getPropertyValue(propertyName) {
            return _this2.getAttribute(propertyName);
          },
          removeProperty: function removeProperty(propertyName) {
            _this2.removeAttribute(propertyName);
          },
          item: function item() {
            return "";
          }
        },
        {
          get: function get4(target, name2) {
            if (target[name2] !== void 0) {
              return target[name2];
            }
            return _this2.getAttribute(name2);
          },
          set: function set9(_2, prop, value2) {
            _this2.setAttribute(prop, value2);
            return true;
          }
        }
      );
    }
    return _this2;
  }
  _inherits(DisplayObject2, _Element);
  return _createClass(DisplayObject2, [{
    key: "destroy",
    value: function destroy2() {
      _superPropGet(DisplayObject2, "destroy", this, 3)([]);
      this.getAnimations().forEach(function(animation) {
        animation.cancel();
      });
    }
  }, {
    key: "cloneNode",
    value: function cloneNode(deep2, customCloneFunc) {
      var clonedStyle = _objectSpread2({}, this.attributes);
      for (var attributeName in clonedStyle) {
        var attribute = clonedStyle[attributeName];
        if (isDisplayObject(attribute) && // share the same clipPath if possible
        attributeName !== "clipPath" && attributeName !== "offsetPath" && attributeName !== "textPath") {
          clonedStyle[attributeName] = attribute.cloneNode(deep2);
        }
        if (customCloneFunc) {
          clonedStyle[attributeName] = customCloneFunc(attributeName, attribute);
        }
      }
      var cloned = new this.constructor(_objectSpread2(_objectSpread2({}, this.config), {}, {
        style: clonedStyle
      }));
      cloned.setLocalTransform(this.getLocalTransform());
      if (deep2) {
        this.children.forEach(function(child) {
          if (!child.style.isMarker) {
            var clonedChild = child.cloneNode(deep2);
            cloned.appendChild(clonedChild);
          }
        });
      }
      return cloned;
    }
  }, {
    key: "initAttributes",
    value: function initAttributes() {
      var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var options = {
        forceUpdateGeometry: true
      };
      runtime.styleValueRegistry.processProperties(this, attributes, options);
      this.renderable.dirty = true;
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(name2, value2) {
      var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var memoize5 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      if (is_undefined_default(value2)) {
        return;
      }
      if (force || value2 !== this.attributes[name2]) {
        this.internalSetAttribute(name2, value2, {
          memoize: memoize5
        });
        _superPropGet(DisplayObject2, "setAttribute", this, 3)([name2, value2]);
      }
    }
    /**
     * called when attributes get changed or initialized
     */
  }, {
    key: "internalSetAttribute",
    value: function internalSetAttribute(name2, value2) {
      var parseOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var renderable = this.renderable;
      var oldValue = this.attributes[name2];
      var oldParsedValue = this.parsedStyle[name2];
      runtime.styleValueRegistry.processProperties(this, _defineProperty({}, name2, value2), parseOptions);
      renderable.dirty = true;
      var newParsedValue = this.parsedStyle[name2];
      if (this.isConnected) {
        attrModifiedEvent.relatedNode = this;
        attrModifiedEvent.prevValue = oldValue;
        attrModifiedEvent.newValue = value2;
        attrModifiedEvent.attrName = name2;
        attrModifiedEvent.prevParsedValue = oldParsedValue;
        attrModifiedEvent.newParsedValue = newParsedValue;
        if (this.isMutationObserved) {
          this.dispatchEvent(attrModifiedEvent);
        } else {
          attrModifiedEvent.target = this;
          this.ownerDocument.defaultView.dispatchEvent(attrModifiedEvent, true);
        }
      }
      if (this.isCustomElement && this.isConnected || !this.isCustomElement) {
        var _attributeChangedCall, _ref;
        (_attributeChangedCall = (_ref = this).attributeChangedCallback) === null || _attributeChangedCall === void 0 || _attributeChangedCall.call(_ref, name2, oldValue, value2, oldParsedValue, newParsedValue);
      }
    }
    // #region transformable
    /**
     * returns different values than getBoundingClientRect(), as the latter returns value relative to the viewport
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getBBox
     *
     * FIXME: It is worth noting that getBBox responds to original untransformed values of a drawn object.
     * @see https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html#getBBox
     */
  }, {
    key: "getBBox",
    value: function getBBox2() {
      var aabb = this.getBounds();
      var _aabb$getMin = aabb.getMin(), _aabb$getMin2 = _slicedToArray(_aabb$getMin, 2), left2 = _aabb$getMin2[0], top = _aabb$getMin2[1];
      var _aabb$getMax = aabb.getMax(), _aabb$getMax2 = _slicedToArray(_aabb$getMax, 2), right2 = _aabb$getMax2[0], bottom = _aabb$getMax2[1];
      return new Rectangle(left2, top, right2 - left2, bottom - top);
    }
  }, {
    key: "setOrigin",
    value: function setOrigin(position) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.setOrigin(this, createVec3(position, y3, z, false));
      return this;
    }
  }, {
    key: "getOrigin",
    value: function getOrigin2() {
      return runtime.sceneGraphService.getOrigin(this);
    }
    /**
     * set position in world space
     */
  }, {
    key: "setPosition",
    value: function setPosition(position) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.setPosition(this, createVec3(position, y3, z, false));
      return this;
    }
    /**
     * set position in local space
     */
  }, {
    key: "setLocalPosition",
    value: function setLocalPosition(position) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.setLocalPosition(this, createVec3(position, y3, z, false));
      return this;
    }
    /**
     * translate in world space
     */
  }, {
    key: "translate",
    value: function translate6(position) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.translate(this, createVec3(position, y3, z, false));
      return this;
    }
    /**
     * translate in local space
     */
  }, {
    key: "translateLocal",
    value: function translateLocal(position) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.translateLocal(this, createVec3(position, y3, z, false));
      return this;
    }
  }, {
    key: "getPosition",
    value: function getPosition() {
      return runtime.sceneGraphService.getPosition(this);
    }
  }, {
    key: "getLocalPosition",
    value: function getLocalPosition() {
      return runtime.sceneGraphService.getLocalPosition(this);
    }
    /**
     * compatible with G 3.0
     *
     * scaling in local space
     * scale(10) = scale(10, 10, 10)
     *
     * we can't set scale in world space
     */
  }, {
    key: "scale",
    value: function scale11(scaling, y3, z) {
      return this.scaleLocal(scaling, y3, z);
    }
  }, {
    key: "scaleLocal",
    value: function scaleLocal(scaling, y3, z) {
      if (typeof scaling === "number") {
        y3 = y3 || scaling;
        z = z || scaling;
        scaling = createVec3(scaling, y3, z, false);
      }
      runtime.sceneGraphService.scaleLocal(this, scaling);
      return this;
    }
    /**
     * set scaling in local space
     */
  }, {
    key: "setLocalScale",
    value: function setLocalScale(scaling, y3, z) {
      if (typeof scaling === "number") {
        y3 = y3 || scaling;
        z = z || scaling;
        scaling = createVec3(scaling, y3, z, false);
      }
      runtime.sceneGraphService.setLocalScale(this, scaling);
      return this;
    }
    /**
     * get scaling in local space
     */
  }, {
    key: "getLocalScale",
    value: function getLocalScale() {
      return runtime.sceneGraphService.getLocalScale(this);
    }
    /**
     * get scaling in world space
     */
  }, {
    key: "getScale",
    value: function getScale() {
      return runtime.sceneGraphService.getScale(this);
    }
    /**
     * only return degrees of Z axis in world space
     */
  }, {
    key: "getEulerAngles",
    value: function getEulerAngles() {
      var _getEuler = getEuler($vec3, runtime.sceneGraphService.getWorldTransform(this)), _getEuler2 = _slicedToArray(_getEuler, 3), ez = _getEuler2[2];
      return rad2deg(ez);
    }
    /**
     * only return degrees of Z axis in local space
     */
  }, {
    key: "getLocalEulerAngles",
    value: function getLocalEulerAngles() {
      var _getEuler3 = getEuler($vec3, runtime.sceneGraphService.getLocalRotation(this)), _getEuler4 = _slicedToArray(_getEuler3, 3), ez = _getEuler4[2];
      return rad2deg(ez);
    }
    /**
     * set euler angles(degrees) in world space
     */
  }, {
    key: "setEulerAngles",
    value: function setEulerAngles(z) {
      runtime.sceneGraphService.setEulerAngles(this, 0, 0, z);
      return this;
    }
    /**
     * set euler angles(degrees) in local space
     */
  }, {
    key: "setLocalEulerAngles",
    value: function setLocalEulerAngles(z) {
      runtime.sceneGraphService.setLocalEulerAngles(this, 0, 0, z);
      return this;
    }
  }, {
    key: "rotateLocal",
    value: function rotateLocal(x3, y3, z) {
      if (isNil(y3) && isNil(z)) {
        runtime.sceneGraphService.rotateLocal(this, 0, 0, x3);
      } else {
        runtime.sceneGraphService.rotateLocal(this, x3, y3, z);
      }
      return this;
    }
  }, {
    key: "rotate",
    value: function rotate7(x3, y3, z) {
      if (isNil(y3) && isNil(z)) {
        runtime.sceneGraphService.rotate(this, 0, 0, x3);
      } else {
        runtime.sceneGraphService.rotate(this, x3, y3, z);
      }
      return this;
    }
  }, {
    key: "setRotation",
    value: function setRotation(rotation, y3, z, w) {
      runtime.sceneGraphService.setRotation(this, rotation, y3, z, w);
      return this;
    }
  }, {
    key: "setLocalRotation",
    value: function setLocalRotation(rotation, y3, z, w) {
      runtime.sceneGraphService.setLocalRotation(this, rotation, y3, z, w);
      return this;
    }
  }, {
    key: "setLocalSkew",
    value: function setLocalSkew(skew2, y3) {
      runtime.sceneGraphService.setLocalSkew(this, skew2, y3);
      return this;
    }
  }, {
    key: "getRotation",
    value: function getRotation2() {
      return runtime.sceneGraphService.getRotation(this);
    }
  }, {
    key: "getLocalRotation",
    value: function getLocalRotation() {
      return runtime.sceneGraphService.getLocalRotation(this);
    }
  }, {
    key: "getLocalSkew",
    value: function getLocalSkew() {
      return runtime.sceneGraphService.getLocalSkew(this);
    }
  }, {
    key: "getLocalTransform",
    value: function getLocalTransform() {
      return runtime.sceneGraphService.getLocalTransform(this);
    }
  }, {
    key: "getWorldTransform",
    value: function getWorldTransform() {
      return runtime.sceneGraphService.getWorldTransform(this);
    }
  }, {
    key: "setLocalTransform",
    value: function setLocalTransform(transform2) {
      runtime.sceneGraphService.setLocalTransform(this, transform2);
      return this;
    }
  }, {
    key: "resetLocalTransform",
    value: function resetLocalTransform() {
      runtime.sceneGraphService.resetLocalTransform(this);
    }
    // #endregion transformable
    // #region animatable
    /**
     * returns an array of all Animation objects affecting this element
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAnimations
     */
  }, {
    key: "getAnimations",
    value: function getAnimations() {
      return this.activeAnimations;
    }
    /**
     * create an animation with WAAPI
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/animate
     */
  }, {
    key: "animate",
    value: function animate2(keyframes, options) {
      var _this$ownerDocument;
      var timeline = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.timeline;
      if (timeline) {
        return timeline.play(this, keyframes, options);
      }
      return null;
    }
    // #endregion animatable
    // #region visible
    /**
     * shortcut for Used value of `visibility`
     */
  }, {
    key: "isVisible",
    value: function isVisible() {
      var _this$parsedStyle;
      return ((_this$parsedStyle = this.parsedStyle) === null || _this$parsedStyle === void 0 ? void 0 : _this$parsedStyle.visibility) !== "hidden";
    }
  }, {
    key: "interactive",
    get: function get4() {
      return this.isInteractive();
    },
    set: function set9(b) {
      this.style.pointerEvents = b ? "auto" : "none";
    }
  }, {
    key: "isInteractive",
    value: function isInteractive() {
      var _this$parsedStyle2;
      return ((_this$parsedStyle2 = this.parsedStyle) === null || _this$parsedStyle2 === void 0 ? void 0 : _this$parsedStyle2.pointerEvents) !== "none";
    }
  }, {
    key: "isCulled",
    value: function isCulled() {
      return !!(this.cullable && this.cullable.enable && !this.cullable.visible);
    }
    /**
     * bring to front in current group
     */
  }, {
    key: "toFront",
    value: function toFront() {
      if (this.parentNode) {
        this.style.zIndex = Math.max.apply(Math, _toConsumableArray(this.parentNode.children.map(function(child) {
          return Number(child.style.zIndex);
        }))) + 1;
      }
      return this;
    }
    /**
     * send to back in current group
     */
  }, {
    key: "toBack",
    value: function toBack() {
      if (this.parentNode) {
        this.style.zIndex = Math.min.apply(Math, _toConsumableArray(this.parentNode.children.map(function(child) {
          return Number(child.style.zIndex);
        }))) - 1;
      }
      return this;
    }
    // #endregion visible
    // #region deprecated
    /**
     * compatible with G 3.0
     * @alias object.config
     * @deprecated
     */
  }, {
    key: "getConfig",
    value: function getConfig() {
      return this.config;
    }
    /**
     * @alias style
     * @example
     * circle.style.r = 10;
     * const r = circle.style;
     * @deprecated
     */
  }, {
    key: "attr",
    value: function attr2() {
      var _this2 = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var name2 = args[0], value2 = args[1];
      if (!name2) {
        return this.attributes;
      }
      if (is_object_default(name2)) {
        Object.keys(name2).forEach(function(key) {
          _this2.setAttribute(key, name2[key]);
        });
        return this;
      }
      if (args.length === 2) {
        this.setAttribute(name2, value2);
        return this;
      }
      return this.attributes[name2];
    }
    /**
     * return 3x3 matrix in world space
     * @deprecated
     */
  }, {
    key: "getMatrix",
    value: function getMatrix(transformMat44) {
      var transform2 = transformMat44 || this.getWorldTransform();
      var _mat4$getTranslation = mat4_exports.getTranslation($vec3, transform2), _mat4$getTranslation2 = _slicedToArray(_mat4$getTranslation, 2), tx = _mat4$getTranslation2[0], ty = _mat4$getTranslation2[1];
      var _mat4$getScaling = mat4_exports.getScaling($vec3, transform2), _mat4$getScaling2 = _slicedToArray(_mat4$getScaling, 2), sx = _mat4$getScaling2[0], sy = _mat4$getScaling2[1];
      var rotation = mat4_exports.getRotation($quat, transform2);
      var _getEuler5 = getEuler($vec3, rotation), _getEuler6 = _slicedToArray(_getEuler5, 3), eux = _getEuler6[0], euz = _getEuler6[2];
      return fromRotationTranslationScale2(eux || euz, tx, ty, sx, sy);
    }
    /**
     * return 3x3 matrix in local space
     * @deprecated
     */
  }, {
    key: "getLocalMatrix",
    value: function getLocalMatrix() {
      return this.getMatrix(this.getLocalTransform());
    }
    /**
     * set 3x3 matrix in world space
     * @deprecated
     */
  }, {
    key: "setMatrix",
    value: function setMatrix(mat) {
      var _decompose = decompose(mat), _decompose2 = _slicedToArray(_decompose, 5), tx = _decompose2[0], ty = _decompose2[1], scalingX = _decompose2[2], scalingY = _decompose2[3], angle4 = _decompose2[4];
      this.setEulerAngles(angle4).setPosition(tx, ty).setLocalScale(scalingX, scalingY);
    }
    /**
     * set 3x3 matrix in local space
     * @deprecated
     */
  }, {
    key: "setLocalMatrix",
    value: function setLocalMatrix(mat) {
      var _decompose3 = decompose(mat), _decompose4 = _slicedToArray(_decompose3, 5), tx = _decompose4[0], ty = _decompose4[1], scalingX = _decompose4[2], scalingY = _decompose4[3], angle4 = _decompose4[4];
      this.setLocalEulerAngles(angle4).setLocalPosition(tx, ty).setLocalScale(scalingX, scalingY);
    }
    /**
     * Use `visibility: visible` instead.
     * @deprecated
     */
  }, {
    key: "show",
    value: function show3() {
      this.forEach(function(object) {
        object.style.visibility = "visible";
      });
    }
    /**
     * Use `visibility: hidden` instead.
     * @deprecated
     */
  }, {
    key: "hide",
    value: function hide3() {
      this.forEach(function(object) {
        object.style.visibility = "hidden";
      });
    }
    /**
     * Use `childElementCount` instead.
     * @deprecated
     */
  }, {
    key: "getCount",
    value: function getCount() {
      return this.childElementCount;
    }
    /**
     * Use `parentElement` instead.
     * @deprecated
     */
  }, {
    key: "getParent",
    value: function getParent() {
      return this.parentElement;
    }
    /**
     * Use `children` instead.
     * @deprecated
     */
  }, {
    key: "getChildren",
    value: function getChildren() {
      return this.children;
    }
    /**
     * Use `firstElementChild` instead.
     * @deprecated
     */
  }, {
    key: "getFirst",
    value: function getFirst() {
      return this.firstElementChild;
    }
    /**
     * Use `lastElementChild` instead.
     * @deprecated
     */
  }, {
    key: "getLast",
    value: function getLast() {
      return this.lastElementChild;
    }
    /**
     * Use `this.children[index]` instead.
     * @deprecated
     */
  }, {
    key: "getChildByIndex",
    value: function getChildByIndex(index3) {
      return this.children[index3] || null;
    }
    /**
     * Use `appendChild` instead.
     * @deprecated
     */
  }, {
    key: "add",
    value: function add10(child, index3) {
      return this.appendChild(child, index3);
    }
    /**
     * @deprecated
     */
  }, {
    key: "set",
    value: function set9(name2, value2) {
      this.config[name2] = value2;
    }
    /**
     * @deprecated
     */
  }, {
    key: "get",
    value: function get4(name2) {
      return this.config[name2];
    }
    /**
     * Use `setPosition` instead.
     * @deprecated
     */
  }, {
    key: "moveTo",
    value: function moveTo(position) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      this.setPosition(position, y3, z);
      return this;
    }
    /**
     * Use `setPosition` instead.
     * @deprecated
     */
  }, {
    key: "move",
    value: function move(position) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      this.setPosition(position, y3, z);
      return this;
    }
    /**
     * Use `this.style.zIndex` instead.
     * @deprecated
     */
  }, {
    key: "setZIndex",
    value: function setZIndex(zIndex) {
      this.style.zIndex = zIndex;
      return this;
    }
    // #endregion deprecated
  }]);
}(Element2);
DisplayObject.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "display", "draggable", "droppable", "fill", "fillOpacity", "fillRule", "filter", "increasedLineWidthForHitTesting", "lineCap", "lineDash", "lineDashOffset", "lineJoin", "lineWidth", "miterLimit", "hitArea", "offsetDistance", "offsetPath", "offsetX", "offsetY", "opacity", "pointerEvents", "shadowColor", "shadowType", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "stroke", "strokeOpacity", "strokeWidth", "strokeLinecap", "strokeLineJoin", "strokeDasharray", "strokeDashoffset", "transform", "transformOrigin", "textTransform", "visibility", "zIndex"]);
var Circle = function(_DisplayObject) {
  function Circle3() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Circle3);
    return _callSuper(this, Circle3, [_objectSpread2({
      type: Shape.CIRCLE
    }, options)]);
  }
  _inherits(Circle3, _DisplayObject);
  return _createClass(Circle3);
}(DisplayObject);
Circle.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["cx", "cy", "cz", "r", "isBillboard", "isSizeAttenuation"]));
var _excluded$6 = ["style"];
var CustomElement = function(_DisplayObject) {
  function CustomElement2() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$6);
    _classCallCheck(this, CustomElement2);
    _this2 = _callSuper(this, CustomElement2, [_objectSpread2({
      style
    }, rest)]);
    _this2.isCustomElement = true;
    return _this2;
  }
  _inherits(CustomElement2, _DisplayObject);
  return _createClass(CustomElement2);
}(DisplayObject);
CustomElement.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "draggable", "droppable", "opacity", "pointerEvents", "transform", "transformOrigin", "zIndex", "visibility"]);
var Ellipse = function(_DisplayObject) {
  function Ellipse2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Ellipse2);
    return _callSuper(this, Ellipse2, [_objectSpread2({
      type: Shape.ELLIPSE
    }, options)]);
  }
  _inherits(Ellipse2, _DisplayObject);
  return _createClass(Ellipse2);
}(DisplayObject);
Ellipse.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["cx", "cy", "cz", "rx", "ry", "isBillboard", "isSizeAttenuation"]));
var Fragment = function(_DisplayObject) {
  function Fragment3() {
    _classCallCheck(this, Fragment3);
    return _callSuper(this, Fragment3, [{
      type: Shape.FRAGMENT
    }]);
  }
  _inherits(Fragment3, _DisplayObject);
  return _createClass(Fragment3);
}(DisplayObject);
Fragment.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className"]);
var Group2 = function(_DisplayObject) {
  function Group3() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Group3);
    return _callSuper(this, Group3, [_objectSpread2({
      type: Shape.GROUP
    }, options)]);
  }
  _inherits(Group3, _DisplayObject);
  return _createClass(Group3);
}(DisplayObject);
Group2.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "draggable", "droppable", "opacity", "pointerEvents", "transform", "transformOrigin", "zIndex", "visibility"]);
var _excluded$5 = ["style"];
var HTML = function(_DisplayObject) {
  function HTML2() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$5);
    _classCallCheck(this, HTML2);
    _this2 = _callSuper(this, HTML2, [_objectSpread2({
      type: Shape.HTML,
      style
    }, rest)]);
    _this2.cullable.enable = false;
    return _this2;
  }
  _inherits(HTML2, _DisplayObject);
  return _createClass(HTML2, [{
    key: "getDomElement",
    value: function getDomElement() {
      return this.parsedStyle.$el;
    }
    /**
     * override with $el.getBoundingClientRect
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect
     *
     * ! The calculation logic of the html element should be consistent with that of the canvas element
     */
    // getBoundingClientRect(): Rectangle {
    //   if (this.parsedStyle.$el) {
    //     return this.parsedStyle.$el.getBoundingClientRect();
    //   } else {
    //     const { x, y, width, height } = this.parsedStyle;
    //     return new Rectangle(x, y, width, height);
    //   }
    // }
  }, {
    key: "getClientRects",
    value: function getClientRects() {
      return [this.getBoundingClientRect()];
    }
    // getBounds() {
    //   const clientRect = this.getBoundingClientRect();
    //   // calc context's offset
    //   // @ts-ignore
    //   const canvasRect = this.ownerDocument?.defaultView
    //     ?.getContextService()
    //     .getBoundingClientRect();
    //   const aabb = new AABB();
    //   const minX = clientRect.left - (canvasRect?.left || 0);
    //   const minY = clientRect.top - (canvasRect?.top || 0);
    //   aabb.setMinMax(
    //     [minX, minY, 0],
    //     [minX + clientRect.width, minY + clientRect.height, 0],
    //   );
    //   return aabb;
    // }
  }, {
    key: "getLocalBounds",
    value: function getLocalBounds2() {
      if (this.parentNode) {
        var parentInvert = mat4_exports.invert(mat4_exports.create(), this.parentNode.getWorldTransform());
        var bounds = this.getBounds();
        if (!AABB.isEmpty(bounds)) {
          var localBounds = new AABB();
          localBounds.setFromTransformedAABB(bounds, parentInvert);
          return localBounds;
        }
      }
      return this.getBounds();
    }
  }]);
}(DisplayObject);
HTML.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "$el", "innerHTML", "width", "height"]));
var Image2 = function(_DisplayObject) {
  function Image5() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Image5);
    return _callSuper(this, Image5, [_objectSpread2({
      type: Shape.IMAGE
    }, options)]);
  }
  _inherits(Image5, _DisplayObject);
  return _createClass(Image5);
}(DisplayObject);
Image2.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "src", "width", "height", "isBillboard", "billboardRotation", "isSizeAttenuation", "keepAspectRatio"]));
var _excluded$4 = ["style"];
var Line = function(_DisplayObject) {
  function Line7() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$4);
    _classCallCheck(this, Line7);
    _this2 = _callSuper(this, Line7, [_objectSpread2({
      type: Shape.LINE,
      style: _objectSpread2({
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        z1: 0,
        z2: 0
      }, style)
    }, rest)]);
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  _inherits(Line7, _DisplayObject);
  return _createClass(Line7, [{
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === "x1" || attrName === "y1" || attrName === "x2" || attrName === "y2" || attrName === "markerStartOffset" || attrName === "markerEndOffset") {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === "markerStart") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === "markerEnd") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      }
    }
  }, {
    key: "transformMarker",
    value: function transformMarker(isStart) {
      var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, x12 = _this$parsedStyle2.x1, x22 = _this$parsedStyle2.x2, y12 = _this$parsedStyle2.y1, y22 = _this$parsedStyle2.y2;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker)) {
        return;
      }
      var rad2 = 0;
      var x3;
      var y3;
      var ox;
      var oy;
      var offset2;
      var originalAngle;
      if (isStart) {
        ox = x12;
        oy = y12;
        x3 = x22 - x12;
        y3 = y22 - y12;
        offset2 = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        ox = x22;
        oy = y22;
        x3 = x12 - x22;
        y3 = y12 - y22;
        offset2 = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad2 = Math.atan2(y3, x3);
      marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad2) * offset2, oy + Math.sin(rad2) * offset2);
    }
  }, {
    key: "getPoint",
    value: function getPoint(ratio) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _this$parsedStyle3 = this.parsedStyle, x12 = _this$parsedStyle3.x1, y12 = _this$parsedStyle3.y1, x22 = _this$parsedStyle3.x2, y22 = _this$parsedStyle3.y2;
      var _linePointAt = pointAt$3(x12, y12, x22, y22, ratio), x3 = _linePointAt.x, y3 = _linePointAt.y;
      var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      return new Point2(transformed[0], transformed[1]);
    }
  }, {
    key: "getPointAtLength",
    value: function getPointAtLength2(distance7) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this.getPoint(distance7 / this.getTotalLength(), inWorldSpace);
    }
  }, {
    key: "getTotalLength",
    value: function getTotalLength2() {
      var _this$parsedStyle4 = this.parsedStyle, x12 = _this$parsedStyle4.x1, y12 = _this$parsedStyle4.y1, x22 = _this$parsedStyle4.x2, y22 = _this$parsedStyle4.y2;
      return length$4(x12, y12, x22, y22);
    }
  }]);
}(DisplayObject);
Line.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x1", "y1", "x2", "y2", "z1", "z2", "isBillboard", "isSizeAttenuation", "markerStart", "markerEnd", "markerStartOffset", "markerEndOffset"]));
var _excluded$3 = ["style"];
var Path2 = function(_DisplayObject) {
  function Path5() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$3);
    _classCallCheck(this, Path5);
    _this2 = _callSuper(this, Path5, [_objectSpread2({
      type: Shape.PATH,
      style,
      initialParsedStyle: {
        miterLimit: 4,
        d: _objectSpread2({}, EMPTY_PARSED_PATH)
      }
    }, rest)]);
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    _this2.markerMidList = [];
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerMid && isDisplayObject(markerMid)) {
      _this2.placeMarkerMid(markerMid);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  _inherits(Path5, _DisplayObject);
  return _createClass(Path5, [{
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === "d") {
        this.transformMarker(true);
        this.transformMarker(false);
        this.placeMarkerMid(this.parsedStyle.markerMid);
      } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === "markerStart") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === "markerEnd") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      } else if (attrName === "markerMid") {
        this.placeMarkerMid(newParsedValue);
      }
    }
  }, {
    key: "transformMarker",
    value: function transformMarker(isStart) {
      var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker)) {
        return;
      }
      var rad2 = 0;
      var x3;
      var y3;
      var ox;
      var oy;
      var offset2;
      var originalAngle;
      if (isStart) {
        var _this$getStartTangent = this.getStartTangent(), _this$getStartTangent2 = _slicedToArray(_this$getStartTangent, 2), p1 = _this$getStartTangent2[0], p2 = _this$getStartTangent2[1];
        ox = p2[0];
        oy = p2[1];
        x3 = p1[0] - p2[0];
        y3 = p1[1] - p2[1];
        offset2 = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        var _this$getEndTangent = this.getEndTangent(), _this$getEndTangent2 = _slicedToArray(_this$getEndTangent, 2), _p = _this$getEndTangent2[0], _p2 = _this$getEndTangent2[1];
        ox = _p2[0];
        oy = _p2[1];
        x3 = _p[0] - _p2[0];
        y3 = _p[1] - _p2[1];
        offset2 = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad2 = Math.atan2(y3, x3);
      marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad2) * offset2, oy + Math.sin(rad2) * offset2);
    }
  }, {
    key: "placeMarkerMid",
    value: function placeMarkerMid(marker) {
      var segments = this.parsedStyle.d.segments;
      this.markerMidList.forEach(function(marker2) {
        marker2.remove();
      });
      if (marker && isDisplayObject(marker)) {
        for (var i = 1; i < segments.length - 1; i++) {
          var _segments$i$currentPo = _slicedToArray(segments[i].currentPoint, 2), ox = _segments$i$currentPo[0], oy = _segments$i$currentPo[1];
          var cloned = i === 1 ? marker : marker.cloneNode(true);
          this.markerMidList.push(cloned);
          this.appendChild(cloned);
          cloned.setLocalPosition(ox, oy);
        }
      }
    }
    /**
     * Returns the total length of the path.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
     */
  }, {
    key: "getTotalLength",
    value: function getTotalLength2() {
      return getOrCalculatePathTotalLength(this);
    }
    /**
     * Returns the point at a given distance along the path.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getPointAtLength
     */
  }, {
    key: "getPointAtLength",
    value: function getPointAtLength$1(distance7) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var absolutePath = this.parsedStyle.d.absolutePath;
      var _getPointAtLength2 = getPointAtLength(absolutePath, distance7), x3 = _getPointAtLength2.x, y3 = _getPointAtLength2.y;
      var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      return new Point2(transformed[0], transformed[1]);
    }
    /**
     * Returns the point at a given ratio of the total length in path.
     */
  }, {
    key: "getPoint",
    value: function getPoint(ratio) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this.getPointAtLength(ratio * getOrCalculatePathTotalLength(this), inWorldSpace);
    }
    /**
     * Get start tangent vector
     */
  }, {
    key: "getStartTangent",
    value: function getStartTangent() {
      var segments = this.parsedStyle.d.segments;
      var result = [];
      if (segments.length > 1) {
        var startPoint = segments[0].currentPoint;
        var endPoint = segments[1].currentPoint;
        var tangent = segments[1].startTangent;
        result = [];
        if (tangent) {
          result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
          result.push([startPoint[0], startPoint[1]]);
        } else {
          result.push([endPoint[0], endPoint[1]]);
          result.push([startPoint[0], startPoint[1]]);
        }
      }
      return result;
    }
    /**
     * Get end tangent vector
     */
  }, {
    key: "getEndTangent",
    value: function getEndTangent() {
      var segments = this.parsedStyle.d.segments;
      var length5 = segments.length;
      var result = [];
      if (length5 > 1) {
        var startPoint = segments[length5 - 2].currentPoint;
        var endPoint = segments[length5 - 1].currentPoint;
        var tangent = segments[length5 - 1].endTangent;
        result = [];
        if (tangent) {
          result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
          result.push([endPoint[0], endPoint[1]]);
        } else {
          result.push([startPoint[0], startPoint[1]]);
          result.push([endPoint[0], endPoint[1]]);
        }
      }
      return result;
    }
  }]);
}(DisplayObject);
Path2.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["d", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isBillboard", "isSizeAttenuation"]));
var _excluded$2 = ["style"];
var Polygon = function(_DisplayObject) {
  function Polygon5() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$2);
    _classCallCheck(this, Polygon5);
    _this2 = _callSuper(this, Polygon5, [_objectSpread2({
      type: Shape.POLYGON,
      style,
      initialParsedStyle: {
        points: {
          points: [],
          totalLength: 0,
          segments: []
        },
        miterLimit: 4,
        isClosed: true
      }
    }, rest)]);
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    _this2.markerMidList = [];
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerMid && isDisplayObject(markerMid)) {
      _this2.placeMarkerMid(markerMid);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  _inherits(Polygon5, _DisplayObject);
  return _createClass(Polygon5, [{
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === "points") {
        this.transformMarker(true);
        this.transformMarker(false);
        this.placeMarkerMid(this.parsedStyle.markerMid);
      } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === "markerStart") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === "markerEnd") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      } else if (attrName === "markerMid") {
        this.placeMarkerMid(newParsedValue);
      }
    }
  }, {
    key: "transformMarker",
    value: function transformMarker(isStart) {
      var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, P = _this$parsedStyle2.points;
      var _ref2 = P || {}, points = _ref2.points;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker) || !points) {
        return;
      }
      var rad2 = 0;
      var x3;
      var y3;
      var ox;
      var oy;
      var offset2;
      var originalAngle;
      ox = points[0][0];
      oy = points[0][1];
      if (isStart) {
        x3 = points[1][0] - points[0][0];
        y3 = points[1][1] - points[0][1];
        offset2 = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        var length5 = points.length;
        if (!this.parsedStyle.isClosed) {
          ox = points[length5 - 1][0];
          oy = points[length5 - 1][1];
          x3 = points[length5 - 2][0] - points[length5 - 1][0];
          y3 = points[length5 - 2][1] - points[length5 - 1][1];
        } else {
          x3 = points[length5 - 1][0] - points[0][0];
          y3 = points[length5 - 1][1] - points[0][1];
        }
        offset2 = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad2 = Math.atan2(y3, x3);
      marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad2) * offset2, oy + Math.sin(rad2) * offset2);
    }
  }, {
    key: "placeMarkerMid",
    value: function placeMarkerMid(marker) {
      var P = this.parsedStyle.points;
      var _ref3 = P || {}, points = _ref3.points;
      this.markerMidList.forEach(function(marker2) {
        marker2.remove();
      });
      this.markerMidList = [];
      if (marker && isDisplayObject(marker) && points) {
        for (var i = 1; i < (this.parsedStyle.isClosed ? points.length : points.length - 1); i++) {
          var ox = points[i][0];
          var oy = points[i][1];
          var cloned = i === 1 ? marker : marker.cloneNode(true);
          this.markerMidList.push(cloned);
          this.appendChild(cloned);
          cloned.setLocalPosition(ox, oy);
        }
      }
    }
  }]);
}(DisplayObject);
Polygon.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["points", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isClosed", "isBillboard", "isSizeAttenuation"]));
var _excluded$1 = ["style"];
var Polyline = function(_Polygon) {
  function Polyline2() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$1);
    _classCallCheck(this, Polyline2);
    return _callSuper(this, Polyline2, [_objectSpread2({
      type: Shape.POLYLINE,
      style,
      initialParsedStyle: {
        points: {
          points: [],
          totalLength: 0,
          segments: []
        },
        miterLimit: 4,
        isClosed: false
      }
    }, rest)]);
  }
  _inherits(Polyline2, _Polygon);
  return _createClass(Polyline2, [{
    key: "getTotalLength",
    value: function getTotalLength2() {
      return getOrCalculatePolylineTotalLength(this);
    }
  }, {
    key: "getPointAtLength",
    value: function getPointAtLength2(distance7) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this.getPoint(distance7 / this.getTotalLength(), inWorldSpace);
    }
  }, {
    key: "getPoint",
    value: function getPoint(ratio) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var points = this.parsedStyle.points.points;
      if (this.parsedStyle.points.segments.length === 0) {
        var segments = [];
        var tempLength = 0;
        var segmentT;
        var segmentL;
        var totalLength = this.getTotalLength();
        points.forEach(function(p2, i) {
          if (points[i + 1]) {
            segmentT = [0, 0];
            segmentT[0] = tempLength / totalLength;
            segmentL = length$4(p2[0], p2[1], points[i + 1][0], points[i + 1][1]);
            tempLength += segmentL;
            segmentT[1] = tempLength / totalLength;
            segments.push(segmentT);
          }
        });
        this.parsedStyle.points.segments = segments;
      }
      var subt = 0;
      var index3 = 0;
      this.parsedStyle.points.segments.forEach(function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index3 = i;
        }
      });
      var _linePointAt = pointAt$3(points[index3][0], points[index3][1], points[index3 + 1][0], points[index3 + 1][1], subt), x3 = _linePointAt.x, y3 = _linePointAt.y;
      var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      return new Point2(transformed[0], transformed[1]);
    }
  }, {
    key: "getStartTangent",
    value: function getStartTangent() {
      var points = this.parsedStyle.points.points;
      var result = [];
      result.push([points[1][0], points[1][1]]);
      result.push([points[0][0], points[0][1]]);
      return result;
    }
  }, {
    key: "getEndTangent",
    value: function getEndTangent() {
      var points = this.parsedStyle.points.points;
      var l = points.length - 1;
      var result = [];
      result.push([points[l - 1][0], points[l - 1][1]]);
      result.push([points[l][0], points[l][1]]);
      return result;
    }
  }]);
}(Polygon);
Polyline.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(Polygon.PARSED_STYLE_LIST), ["points", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isBillboard"]));
var Rect = function(_DisplayObject) {
  function Rect4() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Rect4);
    return _callSuper(this, Rect4, [_objectSpread2({
      type: Shape.RECT
    }, options)]);
  }
  _inherits(Rect4, _DisplayObject);
  return _createClass(Rect4);
}(DisplayObject);
Rect.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "width", "height", "isBillboard", "isSizeAttenuation", "radius"]));
var _excluded = ["style"];
var Text = function(_DisplayObject) {
  function Text6() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded);
    _classCallCheck(this, Text6);
    return _callSuper(this, Text6, [_objectSpread2({
      type: Shape.TEXT,
      style: _objectSpread2({
        fill: "black"
      }, style)
    }, rest)]);
  }
  _inherits(Text6, _DisplayObject);
  return _createClass(Text6, [{
    key: "getComputedTextLength",
    value: function getComputedTextLength() {
      var _this$parsedStyle$met;
      this.getGeometryBounds();
      return ((_this$parsedStyle$met = this.parsedStyle.metrics) === null || _this$parsedStyle$met === void 0 ? void 0 : _this$parsedStyle$met.maxLineWidth) || 0;
    }
  }, {
    key: "getLineBoundingRects",
    value: function getLineBoundingRects() {
      var _this$parsedStyle$met2;
      this.getGeometryBounds();
      return ((_this$parsedStyle$met2 = this.parsedStyle.metrics) === null || _this$parsedStyle$met2 === void 0 ? void 0 : _this$parsedStyle$met2.lineMetrics) || [];
    }
  }, {
    key: "isOverflowing",
    value: function isOverflowing() {
      this.getGeometryBounds();
      return !!this.parsedStyle.isOverflowing;
    }
  }]);
}(DisplayObject);
Text.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "isBillboard", "billboardRotation", "isSizeAttenuation", "text", "textAlign", "textBaseline", "fontStyle", "fontSize", "fontFamily", "fontWeight", "fontVariant", "lineHeight", "letterSpacing", "leading", "wordWrap", "wordWrapWidth", "maxLines", "textOverflow", "isOverflowing", "textPath", "textDecorationLine", "textDecorationColor", "textDecorationStyle", "textPathSide", "textPathStartOffset", "metrics", "dx", "dy"]));
var CustomElementRegistry = function() {
  function CustomElementRegistry2() {
    _classCallCheck(this, CustomElementRegistry2);
    this.registry = {};
    this.define(Shape.CIRCLE, Circle);
    this.define(Shape.ELLIPSE, Ellipse);
    this.define(Shape.RECT, Rect);
    this.define(Shape.IMAGE, Image2);
    this.define(Shape.LINE, Line);
    this.define(Shape.GROUP, Group2);
    this.define(Shape.PATH, Path2);
    this.define(Shape.POLYGON, Polygon);
    this.define(Shape.POLYLINE, Polyline);
    this.define(Shape.TEXT, Text);
    this.define(Shape.HTML, HTML);
  }
  return _createClass(CustomElementRegistry2, [{
    key: "define",
    value: function define3(name2, constructor) {
      this.registry[name2] = constructor;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/get
     */
  }, {
    key: "get",
    value: function get4(name2) {
      return this.registry[name2];
    }
  }]);
}();
var CSS = {
  /**
   * <number>
   * @see https://drafts.csswg.org/css-values-4/#number-value
   */
  number: function number2(n) {
    return new CSSUnitValue(n);
  },
  /**
   * <percentage>
   * @see https://drafts.csswg.org/css-values-4/#percentage-value
   */
  percent: function percent(n) {
    return new CSSUnitValue(n, "%");
  },
  /**
   * <length>
   */
  px: function px(n) {
    return new CSSUnitValue(n, "px");
  },
  /**
   * <length>
   */
  em: function em(n) {
    return new CSSUnitValue(n, "em");
  },
  rem: function rem(n) {
    return new CSSUnitValue(n, "rem");
  },
  /**
   * <angle>
   */
  deg: function deg(n) {
    return new CSSUnitValue(n, "deg");
  },
  /**
   * <angle>
   */
  grad: function grad(n) {
    return new CSSUnitValue(n, "grad");
  },
  /**
   * <angle>
   */
  rad: function rad(n) {
    return new CSSUnitValue(n, "rad");
  },
  /**
   * <angle>
   */
  turn: function turn(n) {
    return new CSSUnitValue(n, "turn");
  },
  /**
   * <time>
   */
  s: function s2(n) {
    return new CSSUnitValue(n, "s");
  },
  /**
   * <time>
   */
  ms: function ms(n) {
    return new CSSUnitValue(n, "ms");
  },
  /**
   * CSS Properties & Values API
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS_Properties_and_Values_API
   * @see https://drafts.css-houdini.org/css-properties-values-api/#registering-custom-properties
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty
   */
  registerProperty: function registerProperty(definition) {
    var name2 = definition.name, inherits = definition.inherits, interpolable = definition.interpolable, initialValue = definition.initialValue, syntax = definition.syntax;
    runtime.styleValueRegistry.registerMetadata({
      n: name2,
      inh: inherits,
      "int": interpolable,
      d: initialValue,
      syntax
    });
  },
  /**
   * CSS Layout API
   * register layout
   *
   * @see https://github.com/w3c/css-houdini-drafts/blob/main/css-layout-api/EXPLAINER.md
   * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Houdini#css_layout_api
   */
  registerLayout: function registerLayout(name2, clazz) {
    runtime.layoutRegistry.registerLayout(name2, clazz);
  }
};
var Document2 = function(_Node) {
  function Document3() {
    var _this2;
    _classCallCheck(this, Document3);
    _this2 = _callSuper(this, Document3);
    _this2.defaultView = null;
    _this2.ownerDocument = null;
    _this2.nodeName = "document";
    try {
      _this2.timeline = new runtime.AnimationTimeline(_this2);
    } catch (_unused) {
    }
    var initialStyle = {};
    BUILT_IN_PROPERTIES.forEach(function(_ref) {
      var n = _ref.n, inh = _ref.inh, d3 = _ref.d;
      if (inh && d3) {
        initialStyle[n] = isFunction(d3) ? d3(Shape.GROUP) : d3;
      }
    });
    _this2.documentElement = new Group2({
      id: "g-root",
      style: initialStyle
    });
    _this2.documentElement.ownerDocument = _this2;
    _this2.documentElement.parentNode = _this2;
    _this2.childNodes = [_this2.documentElement];
    return _this2;
  }
  _inherits(Document3, _Node);
  return _createClass(Document3, [{
    key: "children",
    get: function get4() {
      return this.childNodes;
    }
  }, {
    key: "childElementCount",
    get: function get4() {
      return this.childNodes.length;
    }
  }, {
    key: "firstElementChild",
    get: function get4() {
      return this.firstChild;
    }
  }, {
    key: "lastElementChild",
    get: function get4() {
      return this.lastChild;
    }
  }, {
    key: "createElement",
    value: (
      /**
       * @example const circle = document.createElement('circle', { style: { r: 10 } });
       */
      function createElement3(tagName, options) {
        if (tagName === "svg") {
          return this.documentElement;
        }
        var clazz = this.defaultView.customElements.get(tagName);
        if (!clazz) {
          console.warn("Unsupported tagName: ", tagName);
          clazz = tagName === "tspan" ? Text : Group2;
        }
        var shape23 = new clazz(options);
        shape23.ownerDocument = this;
        return shape23;
      }
    )
  }, {
    key: "createElementNS",
    value: function createElementNS(namespaceURI, tagName, options) {
      return this.createElement(tagName, options);
    }
  }, {
    key: "cloneNode",
    value: function cloneNode(deep2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      try {
        this.documentElement.destroyChildren();
        this.timeline.destroy();
      } catch (_unused2) {
      }
    }
    /**
     * Picking 2D graphics with RBush based on BBox, fast but inaccurate.
     */
  }, {
    key: "elementsFromBBox",
    value: function elementsFromBBox(minX, minY, maxX, maxY2) {
      var rBush = this.defaultView.context.rBushRoot;
      var rBushNodes = rBush.search({
        minX,
        minY,
        maxX,
        maxY: maxY2
      });
      var hitTestList = [];
      rBushNodes.forEach(function(_ref2) {
        var displayObject = _ref2.displayObject;
        var _displayObject$parsed = displayObject.parsedStyle.pointerEvents, pointerEvents = _displayObject$parsed === void 0 ? "auto" : _displayObject$parsed;
        var isVisibilityAffected = ["auto", "visiblepainted", "visiblefill", "visiblestroke", "visible"].includes(pointerEvents);
        if ((!isVisibilityAffected || isVisibilityAffected && displayObject.isVisible()) && !displayObject.isCulled() && displayObject.isInteractive()) {
          hitTestList.push(displayObject);
        }
      });
      hitTestList.sort(function(a4, b) {
        return b.sortable.renderOrder - a4.sortable.renderOrder;
      });
      return hitTestList;
    }
  }, {
    key: "elementFromPointSync",
    value: function elementFromPointSync(x3, y3) {
      var _this$defaultView$can = this.defaultView.canvas2Viewport({
        x: x3,
        y: y3
      }), viewportX = _this$defaultView$can.x, viewportY = _this$defaultView$can.y;
      var _this$defaultView$get = this.defaultView.getConfig(), width = _this$defaultView$get.width, height = _this$defaultView$get.height;
      if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
        return null;
      }
      var _this$defaultView$vie = this.defaultView.viewport2Client({
        x: viewportX,
        y: viewportY
      }), clientX = _this$defaultView$vie.x, clientY = _this$defaultView$vie.y;
      var _this$defaultView$get2 = this.defaultView.getRenderingService().hooks.pickSync.call({
        topmost: true,
        position: {
          x: x3,
          y: y3,
          viewportX,
          viewportY,
          clientX,
          clientY
        },
        picked: []
      }), picked = _this$defaultView$get2.picked;
      return picked && picked[0] || this.documentElement;
    }
    /**
     * Do picking with API instead of triggering interactive events.
     *
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementFromPoint
     */
  }, {
    key: "elementFromPoint",
    value: function() {
      var _elementFromPoint = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(x3, y3) {
        var _this$defaultView$can2, viewportX, viewportY, _this$defaultView$get3, width, height, _this$defaultView$vie2, clientX, clientY, _yield$this$defaultVi, picked;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                _this$defaultView$can2 = this.defaultView.canvas2Viewport({
                  x: x3,
                  y: y3
                }), viewportX = _this$defaultView$can2.x, viewportY = _this$defaultView$can2.y;
                _this$defaultView$get3 = this.defaultView.getConfig(), width = _this$defaultView$get3.width, height = _this$defaultView$get3.height;
                if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                  _context.next = 4;
                  break;
                }
                return _context.abrupt("return", null);
              case 4:
                _this$defaultView$vie2 = this.defaultView.viewport2Client({
                  x: viewportX,
                  y: viewportY
                }), clientX = _this$defaultView$vie2.x, clientY = _this$defaultView$vie2.y;
                _context.next = 7;
                return this.defaultView.getRenderingService().hooks.pick.promise({
                  topmost: true,
                  position: {
                    x: x3,
                    y: y3,
                    viewportX,
                    viewportY,
                    clientX,
                    clientY
                  },
                  picked: []
                });
              case 7:
                _yield$this$defaultVi = _context.sent;
                picked = _yield$this$defaultVi.picked;
                return _context.abrupt("return", picked && picked[0] || this.documentElement);
              case 10:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function elementFromPoint(_x, _x2) {
        return _elementFromPoint.apply(this, arguments);
      }
      return elementFromPoint;
    }()
  }, {
    key: "elementsFromPointSync",
    value: function elementsFromPointSync(x3, y3) {
      var _this$defaultView$can3 = this.defaultView.canvas2Viewport({
        x: x3,
        y: y3
      }), viewportX = _this$defaultView$can3.x, viewportY = _this$defaultView$can3.y;
      var _this$defaultView$get4 = this.defaultView.getConfig(), width = _this$defaultView$get4.width, height = _this$defaultView$get4.height;
      if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
        return [];
      }
      var _this$defaultView$vie3 = this.defaultView.viewport2Client({
        x: viewportX,
        y: viewportY
      }), clientX = _this$defaultView$vie3.x, clientY = _this$defaultView$vie3.y;
      var _this$defaultView$get5 = this.defaultView.getRenderingService().hooks.pickSync.call({
        topmost: false,
        position: {
          x: x3,
          y: y3,
          viewportX,
          viewportY,
          clientX,
          clientY
        },
        picked: []
      }), picked = _this$defaultView$get5.picked;
      if (picked[picked.length - 1] !== this.documentElement) {
        picked.push(this.documentElement);
      }
      return picked;
    }
    /**
     * Do picking with API instead of triggering interactive events.
     *
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementsFromPoint
     */
  }, {
    key: "elementsFromPoint",
    value: function() {
      var _elementsFromPoint = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(x3, y3) {
        var _this$defaultView$can4, viewportX, viewportY, _this$defaultView$get6, width, height, _this$defaultView$vie4, clientX, clientY, _yield$this$defaultVi2, picked;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                _this$defaultView$can4 = this.defaultView.canvas2Viewport({
                  x: x3,
                  y: y3
                }), viewportX = _this$defaultView$can4.x, viewportY = _this$defaultView$can4.y;
                _this$defaultView$get6 = this.defaultView.getConfig(), width = _this$defaultView$get6.width, height = _this$defaultView$get6.height;
                if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                  _context2.next = 4;
                  break;
                }
                return _context2.abrupt("return", []);
              case 4:
                _this$defaultView$vie4 = this.defaultView.viewport2Client({
                  x: viewportX,
                  y: viewportY
                }), clientX = _this$defaultView$vie4.x, clientY = _this$defaultView$vie4.y;
                _context2.next = 7;
                return this.defaultView.getRenderingService().hooks.pick.promise({
                  topmost: false,
                  position: {
                    x: x3,
                    y: y3,
                    viewportX,
                    viewportY,
                    clientX,
                    clientY
                  },
                  picked: []
                });
              case 7:
                _yield$this$defaultVi2 = _context2.sent;
                picked = _yield$this$defaultVi2.picked;
                if (picked[picked.length - 1] !== this.documentElement) {
                  picked.push(this.documentElement);
                }
                return _context2.abrupt("return", picked);
              case 11:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function elementsFromPoint(_x3, _x4) {
        return _elementsFromPoint.apply(this, arguments);
      }
      return elementsFromPoint;
    }()
  }, {
    key: "appendChild",
    value: function appendChild(newChild, index3) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(newChild, refChild) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "removeChild",
    value: function removeChild(oldChild, destroy2) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "replaceChild",
    value: function replaceChild2(newChild, oldChild, destroy2) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "append",
    value: function append3() {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "prepend",
    value: function prepend() {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
    /**
     * Execute query on documentElement.
     */
  }, {
    key: "getElementById",
    value: function getElementById(id4) {
      return this.documentElement.getElementById(id4);
    }
  }, {
    key: "getElementsByName",
    value: function getElementsByName(name2) {
      return this.documentElement.getElementsByName(name2);
    }
  }, {
    key: "getElementsByTagName",
    value: function getElementsByTagName(tagName) {
      return this.documentElement.getElementsByTagName(tagName);
    }
  }, {
    key: "getElementsByClassName",
    value: function getElementsByClassName(className2) {
      return this.documentElement.getElementsByClassName(className2);
    }
  }, {
    key: "querySelector",
    value: function querySelector(selectors) {
      return this.documentElement.querySelector(selectors);
    }
  }, {
    key: "querySelectorAll",
    value: function querySelectorAll(selectors) {
      return this.documentElement.querySelectorAll(selectors);
    }
  }, {
    key: "find",
    value: function find6(filter3) {
      return this.documentElement.find(filter3);
    }
  }, {
    key: "findAll",
    value: function findAll(filter3) {
      return this.documentElement.findAll(filter3);
    }
  }]);
}(Node);
var CullingPlugin = function() {
  function CullingPlugin2(strategies) {
    _classCallCheck(this, CullingPlugin2);
    this.strategies = strategies;
  }
  return _createClass(CullingPlugin2, [{
    key: "apply",
    value: function apply(context) {
      var camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext;
      var strategies = this.strategies;
      renderingService.hooks.cull.tap(CullingPlugin2.tag, function(object) {
        if (object) {
          var cullable = object.cullable;
          if (strategies.length === 0) {
            cullable.visible = renderingContext.unculledEntities.indexOf(object.entity) > -1;
          } else {
            cullable.visible = strategies.every(function(strategy) {
              return strategy.isVisible(camera, object);
            });
          }
          if (!object.isCulled() && object.isVisible()) {
            return object;
          }
          object.dispatchEvent(new CustomEvent(ElementEvent.CULLED));
          return null;
        }
        return object;
      });
      renderingService.hooks.afterRender.tap(CullingPlugin2.tag, function(object) {
        object.cullable.visibilityPlaneMask = -1;
      });
    }
  }]);
}();
CullingPlugin.tag = "Culling";
var EventPlugin = function() {
  function EventPlugin2() {
    var _this2 = this;
    _classCallCheck(this, EventPlugin2);
    this.autoPreventDefault = false;
    this.rootPointerEvent = new FederatedPointerEvent(null);
    this.rootWheelEvent = new FederatedWheelEvent(null);
    this.onPointerMove = function(nativeEvent) {
      var _this$context$renderi;
      var canvas = (_this$context$renderi = _this2.context.renderingContext.root) === null || _this$context$renderi === void 0 || (_this$context$renderi = _this$context$renderi.ownerDocument) === null || _this$context$renderi === void 0 ? void 0 : _this$context$renderi.defaultView;
      if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch")
        return;
      var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
      var _iterator = _createForOfIteratorHelper(normalizedEvents), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var normalizedEvent = _step.value;
          var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
          _this2.context.eventService.mapEvent(event);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      _this2.setCursor(_this2.context.eventService.cursor);
    };
    this.onClick = function(nativeEvent) {
      var _this$context$renderi2;
      var canvas = (_this$context$renderi2 = _this2.context.renderingContext.root) === null || _this$context$renderi2 === void 0 || (_this$context$renderi2 = _this$context$renderi2.ownerDocument) === null || _this$context$renderi2 === void 0 ? void 0 : _this$context$renderi2.defaultView;
      var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
      var _iterator2 = _createForOfIteratorHelper(normalizedEvents), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var normalizedEvent = _step2.value;
          var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
          _this2.context.eventService.mapEvent(event);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      _this2.setCursor(_this2.context.eventService.cursor);
    };
  }
  return _createClass(EventPlugin2, [{
    key: "apply",
    value: function apply(context) {
      var _this2 = this;
      this.context = context;
      var renderingService = context.renderingService;
      var canvas = this.context.renderingContext.root.ownerDocument.defaultView;
      this.context.eventService.setPickHandler(function(position) {
        var _this2$context$render = _this2.context.renderingService.hooks.pickSync.call({
          position,
          picked: [],
          topmost: true
          // we only concern the topmost element
        }), picked = _this2$context$render.picked;
        return picked[0] || null;
      });
      renderingService.hooks.pointerWheel.tap(EventPlugin2.tag, function(nativeEvent) {
        var wheelEvent = _this2.normalizeWheelEvent(nativeEvent);
        _this2.context.eventService.mapEvent(wheelEvent);
      });
      renderingService.hooks.pointerDown.tap(EventPlugin2.tag, function(nativeEvent) {
        if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch")
          return;
        var events = _this2.normalizeToPointerEvent(nativeEvent, canvas);
        if (_this2.autoPreventDefault && events[0].isNormalized) {
          var cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
          if (cancelable) {
            nativeEvent.preventDefault();
          }
        }
        var _iterator3 = _createForOfIteratorHelper(events), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var event = _step3.value;
            var federatedEvent = _this2.bootstrapEvent(_this2.rootPointerEvent, event, canvas, nativeEvent);
            _this2.context.eventService.mapEvent(federatedEvent);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
      renderingService.hooks.pointerUp.tap(EventPlugin2.tag, function(nativeEvent) {
        if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch")
          return;
        var $element = _this2.context.contextService.getDomElement();
        var isNativeEventFromCanvas = _this2.context.eventService.isNativeEventFromCanvas($element, nativeEvent);
        var outside2 = !isNativeEventFromCanvas ? "outside" : "";
        var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
        var _iterator4 = _createForOfIteratorHelper(normalizedEvents), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var normalizedEvent = _step4.value;
            var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
            event.type += outside2;
            _this2.context.eventService.mapEvent(event);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
      renderingService.hooks.pointerMove.tap(EventPlugin2.tag, this.onPointerMove);
      renderingService.hooks.pointerOver.tap(EventPlugin2.tag, this.onPointerMove);
      renderingService.hooks.pointerOut.tap(EventPlugin2.tag, this.onPointerMove);
      renderingService.hooks.click.tap(EventPlugin2.tag, this.onClick);
      renderingService.hooks.pointerCancel.tap(EventPlugin2.tag, function(nativeEvent) {
        var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
        var _iterator5 = _createForOfIteratorHelper(normalizedEvents), _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
            var normalizedEvent = _step5.value;
            var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
            _this2.context.eventService.mapEvent(event);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
    }
  }, {
    key: "bootstrapEvent",
    value: function bootstrapEvent(event, normalizedEvent, view, nativeEvent) {
      event.view = view;
      event.originalEvent = null;
      event.nativeEvent = nativeEvent;
      event.pointerId = normalizedEvent.pointerId;
      event.width = normalizedEvent.width;
      event.height = normalizedEvent.height;
      event.isPrimary = normalizedEvent.isPrimary;
      event.pointerType = normalizedEvent.pointerType;
      event.pressure = normalizedEvent.pressure;
      event.tangentialPressure = normalizedEvent.tangentialPressure;
      event.tiltX = normalizedEvent.tiltX;
      event.tiltY = normalizedEvent.tiltY;
      event.twist = normalizedEvent.twist;
      this.transferMouseData(event, normalizedEvent);
      var _this$context$eventSe = this.context.eventService.client2Viewport({
        x: normalizedEvent.clientX,
        y: normalizedEvent.clientY
      }), x3 = _this$context$eventSe.x, y3 = _this$context$eventSe.y;
      event.viewport.x = x3;
      event.viewport.y = y3;
      var _this$context$eventSe2 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe2.x, canvasY = _this$context$eventSe2.y;
      event.canvas.x = canvasX;
      event.canvas.y = canvasY;
      event.global.copyFrom(event.canvas);
      event.offset.copyFrom(event.canvas);
      event.isTrusted = nativeEvent.isTrusted;
      if (event.type === "pointerleave") {
        event.type = "pointerout";
      }
      if (event.type.startsWith("mouse")) {
        event.type = event.type.replace("mouse", "pointer");
      }
      if (event.type.startsWith("touch")) {
        event.type = TOUCH_TO_POINTER[event.type] || event.type;
      }
      return event;
    }
  }, {
    key: "normalizeWheelEvent",
    value: function normalizeWheelEvent(nativeEvent) {
      var event = this.rootWheelEvent;
      this.transferMouseData(event, nativeEvent);
      event.deltaMode = nativeEvent.deltaMode;
      event.deltaX = nativeEvent.deltaX;
      event.deltaY = nativeEvent.deltaY;
      event.deltaZ = nativeEvent.deltaZ;
      var _this$context$eventSe3 = this.context.eventService.client2Viewport({
        x: nativeEvent.clientX,
        y: nativeEvent.clientY
      }), x3 = _this$context$eventSe3.x, y3 = _this$context$eventSe3.y;
      event.viewport.x = x3;
      event.viewport.y = y3;
      var _this$context$eventSe4 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe4.x, canvasY = _this$context$eventSe4.y;
      event.canvas.x = canvasX;
      event.canvas.y = canvasY;
      event.global.copyFrom(event.canvas);
      event.offset.copyFrom(event.canvas);
      event.nativeEvent = nativeEvent;
      event.type = nativeEvent.type;
      return event;
    }
    /**
     * Transfers base & mouse event data from the nativeEvent to the federated event.
     */
  }, {
    key: "transferMouseData",
    value: function transferMouseData(event, nativeEvent) {
      event.isTrusted = nativeEvent.isTrusted;
      event.srcElement = nativeEvent.srcElement;
      event.timeStamp = clock.now();
      event.type = nativeEvent.type;
      event.altKey = nativeEvent.altKey;
      event.metaKey = nativeEvent.metaKey;
      event.shiftKey = nativeEvent.shiftKey;
      event.ctrlKey = nativeEvent.ctrlKey;
      event.button = nativeEvent.button;
      event.buttons = nativeEvent.buttons;
      event.client.x = nativeEvent.clientX;
      event.client.y = nativeEvent.clientY;
      event.movement.x = nativeEvent.movementX;
      event.movement.y = nativeEvent.movementY;
      event.page.x = nativeEvent.pageX;
      event.page.y = nativeEvent.pageY;
      event.screen.x = nativeEvent.screenX;
      event.screen.y = nativeEvent.screenY;
      event.relatedTarget = null;
    }
  }, {
    key: "setCursor",
    value: function setCursor2(cursor) {
      this.context.contextService.applyCursorStyle(cursor || this.context.config.cursor || "default");
    }
  }, {
    key: "normalizeToPointerEvent",
    value: function normalizeToPointerEvent(event, canvas) {
      var normalizedEvents = [];
      if (canvas.isTouchEvent(event)) {
        for (var i = 0; i < event.changedTouches.length; i++) {
          var touch = event.changedTouches[i];
          if (is_undefined_default(touch.button))
            touch.button = 0;
          if (is_undefined_default(touch.buttons))
            touch.buttons = 1;
          if (is_undefined_default(touch.isPrimary)) {
            touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
          }
          if (is_undefined_default(touch.width))
            touch.width = touch.radiusX || 1;
          if (is_undefined_default(touch.height))
            touch.height = touch.radiusY || 1;
          if (is_undefined_default(touch.tiltX))
            touch.tiltX = 0;
          if (is_undefined_default(touch.tiltY))
            touch.tiltY = 0;
          if (is_undefined_default(touch.pointerType))
            touch.pointerType = "touch";
          if (is_undefined_default(touch.pointerId))
            touch.pointerId = touch.identifier || 0;
          if (is_undefined_default(touch.pressure))
            touch.pressure = touch.force || 0.5;
          if (is_undefined_default(touch.twist))
            touch.twist = 0;
          if (is_undefined_default(touch.tangentialPressure))
            touch.tangentialPressure = 0;
          touch.isNormalized = true;
          touch.type = event.type;
          normalizedEvents.push(touch);
        }
      } else if (canvas.isMouseEvent(event)) {
        var tempEvent = event;
        if (is_undefined_default(tempEvent.isPrimary))
          tempEvent.isPrimary = true;
        if (is_undefined_default(tempEvent.width))
          tempEvent.width = 1;
        if (is_undefined_default(tempEvent.height))
          tempEvent.height = 1;
        if (is_undefined_default(tempEvent.tiltX))
          tempEvent.tiltX = 0;
        if (is_undefined_default(tempEvent.tiltY))
          tempEvent.tiltY = 0;
        if (is_undefined_default(tempEvent.pointerType))
          tempEvent.pointerType = "mouse";
        if (is_undefined_default(tempEvent.pointerId))
          tempEvent.pointerId = MOUSE_POINTER_ID;
        if (is_undefined_default(tempEvent.pressure))
          tempEvent.pressure = 0.5;
        if (is_undefined_default(tempEvent.twist))
          tempEvent.twist = 0;
        if (is_undefined_default(tempEvent.tangentialPressure))
          tempEvent.tangentialPressure = 0;
        tempEvent.isNormalized = true;
        normalizedEvents.push(tempEvent);
      } else {
        normalizedEvents.push(event);
      }
      return normalizedEvents;
    }
  }]);
}();
EventPlugin.tag = "Event";
var shape2D = [Shape.CIRCLE, Shape.ELLIPSE, Shape.IMAGE, Shape.RECT, Shape.LINE, Shape.POLYLINE, Shape.POLYGON, Shape.TEXT, Shape.PATH, Shape.HTML];
var FrustumCullingStrategy = function() {
  function FrustumCullingStrategy2() {
    _classCallCheck(this, FrustumCullingStrategy2);
  }
  return _createClass(FrustumCullingStrategy2, [{
    key: "isVisible",
    value: function isVisible(camera, object) {
      var _object$parentNode;
      var cullable = object.cullable;
      if (!cullable.enable) {
        return true;
      }
      var renderBounds = object.getRenderBounds();
      if (AABB.isEmpty(renderBounds)) {
        return false;
      }
      var frustum2 = camera.getFrustum();
      var parentVisibilityPlaneMask = (_object$parentNode = object.parentNode) === null || _object$parentNode === void 0 || (_object$parentNode = _object$parentNode.cullable) === null || _object$parentNode === void 0 ? void 0 : _object$parentNode.visibilityPlaneMask;
      cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || Mask.INDETERMINATE, frustum2.planes);
      cullable.visible = cullable.visibilityPlaneMask !== Mask.OUTSIDE;
      return cullable.visible;
    }
    /**
     *
     * @see「Optimized View Frustum Culling Algorithms for Bounding Boxes」
     * @see https://github.com/antvis/GWebGPUEngine/issues/3
     *
     * * 基础相交测试 the basic intersection test
     * * 标记 masking @see https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/
     * * TODO: 平面一致性测试 the plane-coherency test
     * * TODO: 支持 mesh 指定自身的剔除策略，参考 Babylon.js @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy
     *
     * @param aabb aabb
     * @param parentPlaneMask mask of parent
     * @param planes planes of frustum
     */
  }, {
    key: "computeVisibilityWithPlaneMask",
    value: function computeVisibilityWithPlaneMask(object, aabb, parentPlaneMask, planes) {
      if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {
        return parentPlaneMask;
      }
      var mask = Mask.INSIDE;
      var isShape2D = shape2D.indexOf(object.nodeName) > -1;
      for (var k2 = 0, len5 = planes.length; k2 < len5; ++k2) {
        var flag = 1 << k2;
        if ((parentPlaneMask & flag) === 0) {
          continue;
        }
        if (isShape2D && (k2 === 4 || k2 === 5)) {
          continue;
        }
        var _planes$k = planes[k2], normal = _planes$k.normal, distance7 = _planes$k.distance;
        if (vec3_exports.dot(normal, aabb.getPositiveFarPoint(planes[k2])) + distance7 < 0) {
          return Mask.OUTSIDE;
        }
        if (vec3_exports.dot(normal, aabb.getNegativeFarPoint(planes[k2])) + distance7 < 0) {
          mask |= flag;
        }
      }
      return mask;
    }
  }]);
}();
var PrepareRendererPlugin = function() {
  function PrepareRendererPlugin2() {
    _classCallCheck(this, PrepareRendererPlugin2);
    this.syncTasks = /* @__PURE__ */ new Map();
    this.isFirstTimeRendering = true;
    this.syncing = false;
    this.isFirstTimeRenderingFinished = false;
  }
  return _createClass(PrepareRendererPlugin2, [{
    key: "apply",
    value: function apply(context) {
      var _this2 = this, _runtime$globalThis$r;
      var renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      this.rBush = rBushRoot;
      var handleAttributeChanged = function handleAttributeChanged2(e) {
        var object = e.target;
        object.renderable.dirty = true;
        renderingService.dirtify();
      };
      var handleBoundsChanged = function handleBoundsChanged2(e) {
        _this2.syncTasks.set(e.target, e.detail.affectChildren);
        renderingService.dirtify();
      };
      var handleMounted = function handleMounted2(e) {
        var object = e.target;
        if (runtime.enableSizeAttenuation) {
          runtime.styleValueRegistry.updateSizeAttenuation(object, canvas.getCamera().getZoom());
        }
      };
      var handleUnmounted = function handleUnmounted2(e) {
        var object = e.target;
        var rBushNode = object.rBushNode;
        if (rBushNode.aabb) {
          _this2.rBush.remove(rBushNode.aabb);
        }
        _this2.syncTasks["delete"](object);
        runtime.sceneGraphService.dirtifyToRoot(object);
        renderingService.dirtify();
      };
      renderingService.hooks.init.tap(PrepareRendererPlugin2.tag, function() {
        canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      });
      renderingService.hooks.destroy.tap(PrepareRendererPlugin2.tag, function() {
        canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
        _this2.syncTasks.clear();
      });
      var ric = (_runtime$globalThis$r = runtime.globalThis.requestIdleCallback) !== null && _runtime$globalThis$r !== void 0 ? _runtime$globalThis$r : raf.bind(runtime.globalThis);
      renderingService.hooks.endFrame.tap(PrepareRendererPlugin2.tag, function() {
        if (_this2.isFirstTimeRendering) {
          _this2.isFirstTimeRendering = false;
          _this2.syncing = true;
          ric(function() {
            _this2.syncRTree(true);
            _this2.isFirstTimeRenderingFinished = true;
          });
        } else {
          _this2.syncRTree();
        }
      });
    }
  }, {
    key: "syncNode",
    value: function syncNode(node) {
      var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!node.isConnected)
        return;
      var rBushNode = node.rBushNode;
      if (rBushNode.aabb)
        this.rBush.remove(rBushNode.aabb);
      var renderBounds = node.getRenderBounds();
      if (renderBounds) {
        var renderable = node.renderable;
        if (force) {
          if (!renderable.dirtyRenderBounds) {
            renderable.dirtyRenderBounds = new AABB();
          }
          renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
        }
        var _renderBounds$getMin = renderBounds.getMin(), _renderBounds$getMin2 = _slicedToArray(_renderBounds$getMin, 2), minX = _renderBounds$getMin2[0], minY = _renderBounds$getMin2[1];
        var _renderBounds$getMax = renderBounds.getMax(), _renderBounds$getMax2 = _slicedToArray(_renderBounds$getMax, 2), maxX = _renderBounds$getMax2[0], maxY2 = _renderBounds$getMax2[1];
        if (!rBushNode.aabb) {
          rBushNode.aabb = {};
        }
        rBushNode.aabb.displayObject = node;
        rBushNode.aabb.minX = minX;
        rBushNode.aabb.minY = minY;
        rBushNode.aabb.maxX = maxX;
        rBushNode.aabb.maxY = maxY2;
      }
      if (rBushNode.aabb) {
        if (!isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.minX) && !isNaN(rBushNode.aabb.minY)) {
          return rBushNode.aabb;
        }
      }
    }
  }, {
    key: "syncRTree",
    value: function syncRTree() {
      var _this2 = this;
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (!force && (this.syncing || this.syncTasks.size === 0)) {
        return;
      }
      this.syncing = true;
      var bulk = [];
      var synced = /* @__PURE__ */ new Set();
      var sync = function sync2(node) {
        if (!synced.has(node) && node.renderable) {
          var aabb = _this2.syncNode(node, force);
          if (aabb) {
            bulk.push(aabb);
            synced.add(node);
          }
        }
      };
      this.syncTasks.forEach(function(affectChildren, node) {
        if (affectChildren) {
          node.forEach(sync);
        }
        var parent = node;
        while (parent) {
          sync(parent);
          parent = parent.parentElement;
        }
      });
      this.rBush.load(bulk);
      bulk.length = 0;
      this.syncing = false;
    }
  }]);
}();
PrepareRendererPlugin.tag = "Prepare";
var CanvasEvent = function(CanvasEvent2) {
  CanvasEvent2["READY"] = "ready";
  CanvasEvent2["BEFORE_RENDER"] = "beforerender";
  CanvasEvent2["RERENDER"] = "rerender";
  CanvasEvent2["AFTER_RENDER"] = "afterrender";
  CanvasEvent2["BEFORE_DESTROY"] = "beforedestroy";
  CanvasEvent2["AFTER_DESTROY"] = "afterdestroy";
  CanvasEvent2["RESIZE"] = "resize";
  CanvasEvent2["DIRTY_RECTANGLE"] = "dirtyrectangle";
  CanvasEvent2["RENDERER_CHANGED"] = "rendererchanged";
  return CanvasEvent2;
}({});
var DEFAULT_CAMERA_Z = 500;
var DEFAULT_CAMERA_NEAR = 0.1;
var DEFAULT_CAMERA_FAR = 1e3;
var mountedEvent = new CustomEvent(ElementEvent.MOUNTED);
var unmountedEvent = new CustomEvent(ElementEvent.UNMOUNTED);
var beforeRenderEvent = new CustomEvent(CanvasEvent.BEFORE_RENDER);
var rerenderEvent = new CustomEvent(CanvasEvent.RERENDER);
var afterRenderEvent = new CustomEvent(CanvasEvent.AFTER_RENDER);
var Canvas = function(_EventTarget) {
  function Canvas3(config) {
    var _this2;
    _classCallCheck(this, Canvas3);
    _this2 = _callSuper(this, Canvas3);
    _this2.Element = DisplayObject;
    _this2.inited = false;
    _this2.context = {};
    var container = config.container, canvas = config.canvas, renderer = config.renderer, width = config.width, height = config.height, background = config.background, cursor = config.cursor, supportsMutipleCanvasesInOneContainer = config.supportsMutipleCanvasesInOneContainer, _config$cleanUpOnDest = config.cleanUpOnDestroy, cleanUpOnDestroy = _config$cleanUpOnDest === void 0 ? true : _config$cleanUpOnDest, offscreenCanvas = config.offscreenCanvas, devicePixelRatio = config.devicePixelRatio, requestAnimationFrame3 = config.requestAnimationFrame, cancelAnimationFrame3 = config.cancelAnimationFrame, createImage = config.createImage, supportsTouchEvents = config.supportsTouchEvents, supportsPointerEvents = config.supportsPointerEvents, isTouchEvent = config.isTouchEvent, isMouseEvent = config.isMouseEvent, dblClickSpeed = config.dblClickSpeed;
    var canvasWidth = width;
    var canvasHeight = height;
    var dpr = devicePixelRatio || isBrowser && window.devicePixelRatio || 1;
    dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
    if (canvas) {
      canvasWidth = width || getWidth(canvas) || canvas.width / dpr;
      canvasHeight = height || getHeight(canvas) || canvas.height / dpr;
    }
    _this2.customElements = new CustomElementRegistry();
    _this2.devicePixelRatio = dpr;
    _this2.requestAnimationFrame = requestAnimationFrame3 !== null && requestAnimationFrame3 !== void 0 ? requestAnimationFrame3 : raf.bind(runtime.globalThis);
    _this2.cancelAnimationFrame = cancelAnimationFrame3 !== null && cancelAnimationFrame3 !== void 0 ? cancelAnimationFrame3 : caf.bind(runtime.globalThis);
    _this2.supportsTouchEvents = supportsTouchEvents !== null && supportsTouchEvents !== void 0 ? supportsTouchEvents : "ontouchstart" in runtime.globalThis;
    _this2.supportsPointerEvents = supportsPointerEvents !== null && supportsPointerEvents !== void 0 ? supportsPointerEvents : !!runtime.globalThis.PointerEvent;
    _this2.isTouchEvent = isTouchEvent !== null && isTouchEvent !== void 0 ? isTouchEvent : function(event) {
      return _this2.supportsTouchEvents && event instanceof runtime.globalThis.TouchEvent;
    };
    _this2.isMouseEvent = isMouseEvent !== null && isMouseEvent !== void 0 ? isMouseEvent : function(event) {
      return !runtime.globalThis.MouseEvent || event instanceof runtime.globalThis.MouseEvent && (!_this2.supportsPointerEvents || !(event instanceof runtime.globalThis.PointerEvent));
    };
    if (offscreenCanvas) {
      runtime.offscreenCanvas = offscreenCanvas;
    }
    _this2.document = new Document2();
    _this2.document.defaultView = _this2;
    if (!supportsMutipleCanvasesInOneContainer) {
      cleanExistedCanvas(container, _this2, cleanUpOnDestroy);
    }
    _this2.initRenderingContext(_objectSpread2(_objectSpread2({}, config), {}, {
      width: canvasWidth,
      height: canvasHeight,
      background: background !== null && background !== void 0 ? background : "transparent",
      cursor: cursor !== null && cursor !== void 0 ? cursor : "default",
      cleanUpOnDestroy,
      devicePixelRatio: dpr,
      requestAnimationFrame: _this2.requestAnimationFrame,
      cancelAnimationFrame: _this2.cancelAnimationFrame,
      supportsTouchEvents: _this2.supportsTouchEvents,
      supportsPointerEvents: _this2.supportsPointerEvents,
      isTouchEvent: _this2.isTouchEvent,
      isMouseEvent: _this2.isMouseEvent,
      dblClickSpeed: dblClickSpeed !== null && dblClickSpeed !== void 0 ? dblClickSpeed : 200,
      createImage: createImage !== null && createImage !== void 0 ? createImage : function() {
        return new window.Image();
      }
    }));
    _this2.initDefaultCamera(canvasWidth, canvasHeight, renderer.clipSpaceNearZ);
    _this2.initRenderer(renderer, true);
    return _this2;
  }
  _inherits(Canvas3, _EventTarget);
  return _createClass(Canvas3, [{
    key: "initRenderingContext",
    value: function initRenderingContext(mergedConfig) {
      this.context.config = mergedConfig;
      this.context.renderingContext = {
        /**
         * the root node in scene graph
         */
        root: this.document.documentElement,
        renderListCurrentFrame: [],
        unculledEntities: [],
        renderReasons: /* @__PURE__ */ new Set(),
        force: false,
        dirty: false
      };
    }
  }, {
    key: "initDefaultCamera",
    value: function initDefaultCamera(width, height, clipSpaceNearZ) {
      var _this2 = this;
      var camera = new runtime.CameraContribution();
      camera.clipSpaceNearZ = clipSpaceNearZ;
      camera.setType(CameraType.EXPLORING, CameraTrackingMode.DEFAULT).setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0).setOrthographic(width / -2, width / 2, height / 2, height / -2, DEFAULT_CAMERA_NEAR, DEFAULT_CAMERA_FAR);
      camera.canvas = this;
      camera.eventEmitter.on(CameraEvent.UPDATED, function() {
        _this2.context.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
        if (runtime.enableSizeAttenuation && _this2.getConfig().renderer.getConfig().enableSizeAttenuation) {
          _this2.updateSizeAttenuation();
        }
      });
      this.context.camera = camera;
    }
  }, {
    key: "updateSizeAttenuation",
    value: function updateSizeAttenuation() {
      var zoom = this.getCamera().getZoom();
      this.document.documentElement.forEach(function(node) {
        runtime.styleValueRegistry.updateSizeAttenuation(node, zoom);
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return this.context.config;
    }
    /**
     * get the root displayObject in scenegraph
     * @alias this.document.documentElement
     */
  }, {
    key: "getRoot",
    value: function getRoot() {
      return this.document.documentElement;
    }
    /**
     * get the camera of canvas
     */
  }, {
    key: "getCamera",
    value: function getCamera() {
      return this.context.camera;
    }
  }, {
    key: "getContextService",
    value: function getContextService() {
      return this.context.contextService;
    }
  }, {
    key: "getEventService",
    value: function getEventService() {
      return this.context.eventService;
    }
  }, {
    key: "getRenderingService",
    value: function getRenderingService() {
      return this.context.renderingService;
    }
  }, {
    key: "getRenderingContext",
    value: function getRenderingContext() {
      return this.context.renderingContext;
    }
  }, {
    key: "getStats",
    value: function getStats() {
      return this.getRenderingService().getStats();
    }
    // /**
    //  * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle
    //  */
    // getComputedStyle(node: DisplayObject) {
    //   return node.computedStyle;
    // }
  }, {
    key: "ready",
    get: function get4() {
      var _this3 = this;
      if (!this.readyPromise) {
        this.readyPromise = new Promise(function(resolve) {
          _this3.resolveReadyPromise = function() {
            resolve(_this3);
          };
        });
        if (this.inited) {
          this.resolveReadyPromise();
        }
      }
      return this.readyPromise;
    }
    /**
     * @param cleanUp - whether to clean up all the internal services of Canvas
     * @param skipTriggerEvent - whether to skip trigger destroy event
     */
  }, {
    key: "destroy",
    value: function destroy2() {
      var cleanUp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var skipTriggerEvent = arguments.length > 1 ? arguments[1] : void 0;
      memoize2.clearCache();
      if (!skipTriggerEvent) {
        this.dispatchEvent(new CustomEvent(CanvasEvent.BEFORE_DESTROY));
      }
      if (this.frameId) {
        this.cancelAnimationFrame(this.frameId);
      }
      var root2 = this.getRoot();
      if (cleanUp) {
        this.unmountChildren(root2);
        this.document.destroy();
        this.getEventService().destroy();
      }
      this.getRenderingService().destroy();
      this.getContextService().destroy();
      if (this.context.rBushRoot) {
        this.context.rBushRoot.clear();
      }
      if (!skipTriggerEvent) {
        this.dispatchEvent(new CustomEvent(CanvasEvent.AFTER_DESTROY));
      }
      var clearEventRetain = function clearEventRetain2(event) {
        event.currentTarget = null;
        event.manager = null;
        event.target = null;
        event.relatedNode = null;
      };
      clearEventRetain(mountedEvent);
      clearEventRetain(unmountedEvent);
      clearEventRetain(beforeRenderEvent);
      clearEventRetain(rerenderEvent);
      clearEventRetain(afterRenderEvent);
      clearEventRetain(attrModifiedEvent);
      clearEventRetain(insertedEvent);
      clearEventRetain(removedEvent);
      clearEventRetain(destroyEvent);
    }
    /**
     * compatible with G 3.0
     * @deprecated
     * @alias resize
     */
  }, {
    key: "changeSize",
    value: function changeSize(width, height) {
      this.resize(width, height);
    }
  }, {
    key: "resize",
    value: function resize(width, height) {
      var canvasConfig = this.context.config;
      canvasConfig.width = width;
      canvasConfig.height = height;
      this.getContextService().resize(width, height);
      var camera = this.context.camera;
      var projectionMode = camera.getProjectionMode();
      camera.setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0);
      if (projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
        camera.setOrthographic(width / -2, width / 2, height / 2, height / -2, camera.getNear(), camera.getFar());
      } else {
        camera.setAspect(width / height);
      }
      this.dispatchEvent(new CustomEvent(CanvasEvent.RESIZE, {
        width,
        height
      }));
    }
    // proxy to document.documentElement
  }, {
    key: "appendChild",
    value: function appendChild(child, index3) {
      return this.document.documentElement.appendChild(child, index3);
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(newChild, refChild) {
      return this.document.documentElement.insertBefore(newChild, refChild);
    }
  }, {
    key: "removeChild",
    value: function removeChild(child) {
      return this.document.documentElement.removeChild(child);
    }
    /**
     * Remove all children which can be appended to its original parent later again.
     */
  }, {
    key: "removeChildren",
    value: function removeChildren() {
      this.document.documentElement.removeChildren();
    }
    /**
     * Recursively destroy all children which can not be appended to its original parent later again.
     * But the canvas remains running which means display objects can be appended later.
     */
  }, {
    key: "destroyChildren",
    value: function destroyChildren() {
      this.document.documentElement.destroyChildren();
    }
  }, {
    key: "render",
    value: function render3(frame2) {
      var _this4 = this;
      if (frame2) {
        beforeRenderEvent.detail = frame2;
        afterRenderEvent.detail = frame2;
      }
      this.dispatchEvent(beforeRenderEvent);
      var renderingService = this.getRenderingService();
      renderingService.render(this.getConfig(), frame2, function() {
        _this4.dispatchEvent(rerenderEvent);
      });
      this.dispatchEvent(afterRenderEvent);
    }
  }, {
    key: "run",
    value: function run() {
      var _this5 = this;
      var _tick = function tick3(time, frame2) {
        _this5.render(frame2);
        _this5.frameId = _this5.requestAnimationFrame(_tick);
      };
      _tick();
    }
  }, {
    key: "initRenderer",
    value: function initRenderer(renderer) {
      var _this6 = this;
      var firstContentfullPaint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!renderer) {
        throw new Error("Renderer is required.");
      }
      this.inited = false;
      this.readyPromise = void 0;
      this.context.rBushRoot = new RBush();
      this.context.renderingPlugins = [];
      this.context.renderingPlugins.push(
        new EventPlugin(),
        new PrepareRendererPlugin(),
        // new DirtyCheckPlugin(),
        new CullingPlugin([new FrustumCullingStrategy()])
      );
      this.loadRendererContainerModule(renderer);
      this.context.contextService = new this.context.ContextService(_objectSpread2(_objectSpread2({}, runtime), this.context));
      this.context.renderingService = new RenderingService(runtime, this.context);
      this.context.eventService = new EventService(runtime, this.context);
      this.context.eventService.init();
      if (this.context.contextService.init) {
        this.context.contextService.init();
        this.initRenderingService(renderer, firstContentfullPaint, true);
      } else {
        this.context.contextService.initAsync().then(function() {
          _this6.initRenderingService(renderer, firstContentfullPaint);
        })["catch"](function(err) {
          console.error(err);
        });
      }
    }
  }, {
    key: "initRenderingService",
    value: function initRenderingService(renderer) {
      var _this7 = this;
      var firstContentfullPaint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var async = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      this.context.renderingService.init(function() {
        _this7.inited = true;
        if (firstContentfullPaint) {
          if (async) {
            _this7.requestAnimationFrame(function() {
              _this7.dispatchEvent(new CustomEvent(CanvasEvent.READY));
            });
          } else {
            _this7.dispatchEvent(new CustomEvent(CanvasEvent.READY));
          }
        } else {
          _this7.dispatchEvent(new CustomEvent(CanvasEvent.RENDERER_CHANGED));
        }
        if (_this7.readyPromise) {
          _this7.resolveReadyPromise();
        }
        if (!firstContentfullPaint) {
          _this7.getRoot().forEach(function(node) {
            var _ref = node, renderable = _ref.renderable;
            if (renderable) {
              renderable.renderBoundsDirty = true;
              renderable.boundsDirty = true;
              renderable.dirty = true;
            }
          });
        }
        _this7.mountChildren(_this7.getRoot());
        if (renderer.getConfig().enableAutoRendering) {
          _this7.run();
        }
      });
    }
  }, {
    key: "loadRendererContainerModule",
    value: function loadRendererContainerModule(renderer) {
      var _this8 = this;
      var plugins = renderer.getPlugins();
      plugins.forEach(function(plugin) {
        plugin.context = _this8.context;
        plugin.init(runtime);
      });
    }
  }, {
    key: "setRenderer",
    value: function setRenderer(renderer) {
      var canvasConfig = this.getConfig();
      if (canvasConfig.renderer === renderer) {
        return;
      }
      var oldRenderer = canvasConfig.renderer;
      canvasConfig.renderer = renderer;
      this.destroy(false, true);
      _toConsumableArray((oldRenderer === null || oldRenderer === void 0 ? void 0 : oldRenderer.getPlugins()) || []).reverse().forEach(function(plugin) {
        plugin.destroy(runtime);
      });
      this.initRenderer(renderer);
    }
  }, {
    key: "setCursor",
    value: function setCursor2(cursor) {
      var canvasConfig = this.getConfig();
      canvasConfig.cursor = cursor;
      this.getContextService().applyCursorStyle(cursor);
    }
  }, {
    key: "unmountChildren",
    value: function unmountChildren(parent) {
      var _this9 = this;
      parent.childNodes.forEach(function(child) {
        _this9.unmountChildren(child);
      });
      if (this.inited) {
        if (parent.isMutationObserved) {
          parent.dispatchEvent(unmountedEvent);
        } else {
          unmountedEvent.target = parent;
          this.dispatchEvent(unmountedEvent, true);
        }
        if (parent !== this.document.documentElement) {
          parent.ownerDocument = null;
        }
        parent.isConnected = false;
      }
      if (parent.isCustomElement) {
        if (parent.disconnectedCallback) {
          parent.disconnectedCallback();
        }
      }
    }
  }, {
    key: "mountChildren",
    value: function mountChildren(child) {
      var _this10 = this;
      var skipTriggerEvent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : isInFragment(child);
      if (this.inited) {
        if (!child.isConnected) {
          child.ownerDocument = this.document;
          child.isConnected = true;
          if (!skipTriggerEvent) {
            if (child.isMutationObserved) {
              child.dispatchEvent(mountedEvent);
            } else {
              mountedEvent.target = child;
              this.dispatchEvent(mountedEvent, true);
            }
          }
        }
      } else {
        console.warn("[g]: You are trying to call `canvas.appendChild` before canvas' initialization finished. You can either await `canvas.ready` or listen to `CanvasEvent.READY` manually.", "appended child: ", child.nodeName);
      }
      child.childNodes.forEach(function(c5) {
        _this10.mountChildren(c5, skipTriggerEvent);
      });
      if (child.isCustomElement) {
        if (child.connectedCallback) {
          child.connectedCallback();
        }
      }
    }
  }, {
    key: "mountFragment",
    value: function mountFragment(child) {
      this.mountChildren(child, false);
    }
  }, {
    key: "client2Viewport",
    value: function client2Viewport(client) {
      return this.getEventService().client2Viewport(client);
    }
  }, {
    key: "viewport2Client",
    value: function viewport2Client(canvas) {
      return this.getEventService().viewport2Client(canvas);
    }
  }, {
    key: "viewport2Canvas",
    value: function viewport2Canvas(viewport) {
      return this.getEventService().viewport2Canvas(viewport);
    }
  }, {
    key: "canvas2Viewport",
    value: function canvas2Viewport(canvas) {
      return this.getEventService().canvas2Viewport(canvas);
    }
    /**
     * @deprecated
     * @alias client2Viewport
     */
  }, {
    key: "getPointByClient",
    value: function getPointByClient(clientX, clientY) {
      return this.client2Viewport({
        x: clientX,
        y: clientY
      });
    }
    /**
     * @deprecated
     * @alias viewport2Client
     */
  }, {
    key: "getClientByPoint",
    value: function getClientByPoint(x3, y3) {
      return this.viewport2Client({
        x: x3,
        y: y3
      });
    }
  }]);
}(EventTarget);

// node_modules/@antv/g-camera-api/dist/index.esm.js
var AdvancedCamera = function(_Camera) {
  function AdvancedCamera2() {
    var _this2;
    _classCallCheck(this, AdvancedCamera2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, AdvancedCamera2, [].concat(args));
    _this2.landmarks = [];
    return _this2;
  }
  _inherits(AdvancedCamera2, _Camera);
  return _createClass(AdvancedCamera2, [{
    key: "rotate",
    value: (
      /**
       * Changes the azimuth and elevation with respect to the current camera axes
       * @param {Number} azimuth the relative azimuth
       * @param {Number} elevation the relative elevation
       * @param {Number} roll the relative roll
       */
      function rotate7(azimuth, elevation, roll) {
        this.relElevation = getAngle2(elevation);
        this.relAzimuth = getAngle2(azimuth);
        this.relRoll = getAngle2(roll);
        this.elevation += this.relElevation;
        this.azimuth += this.relAzimuth;
        this.roll += this.relRoll;
        if (this.type === CameraType.EXPLORING) {
          var rotX = quat_exports.setAxisAngle(quat_exports.create(), [1, 0, 0], deg2rad((this.rotateWorld ? 1 : -1) * this.relElevation));
          var rotY = quat_exports.setAxisAngle(quat_exports.create(), [0, 1, 0], deg2rad((this.rotateWorld ? 1 : -1) * this.relAzimuth));
          var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], deg2rad(this.relRoll));
          var rotQ = quat_exports.multiply(quat_exports.create(), rotY, rotX);
          rotQ = quat_exports.multiply(quat_exports.create(), rotQ, rotZ);
          var rotMatrix = mat4_exports.fromQuat(mat4_exports.create(), rotQ);
          mat4_exports.translate(this.matrix, this.matrix, [0, 0, -this.distance]);
          mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
          mat4_exports.translate(this.matrix, this.matrix, [0, 0, this.distance]);
        } else {
          if (Math.abs(this.elevation) > 90) {
            return this;
          }
          this.computeMatrix();
        }
        this._getAxes();
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          this._getPosition();
        } else if (this.type === CameraType.TRACKING) {
          this._getFocalPoint();
        }
        this._update();
        return this;
      }
    )
    /**
     * 沿水平(right) & 垂直(up)平移相机
     */
  }, {
    key: "pan",
    value: function pan(tx, ty) {
      var coords = createVec3(tx, ty, 0);
      var pos = vec3_exports.clone(this.position);
      vec3_exports.add(pos, pos, vec3_exports.scale(vec3_exports.create(), this.right, coords[0]));
      vec3_exports.add(pos, pos, vec3_exports.scale(vec3_exports.create(), this.up, coords[1]));
      this._setPosition(pos);
      this.triggerUpdate();
      return this;
    }
    /**
     * 沿 n 轴移动，当距离视点远时移动速度较快，离视点越近速度越慢
     */
  }, {
    key: "dolly",
    value: function dolly(value2) {
      var n = this.forward;
      var pos = vec3_exports.clone(this.position);
      var step2 = value2 * this.dollyingStep;
      var updatedDistance = this.distance + value2 * this.dollyingStep;
      step2 = Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) - this.distance;
      pos[0] += step2 * n[0];
      pos[1] += step2 * n[1];
      pos[2] += step2 * n[2];
      this._setPosition(pos);
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getDistance();
      } else if (this.type === CameraType.TRACKING) {
        vec3_exports.add(this.focalPoint, pos, this.distanceVector);
      }
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "cancelLandmarkAnimation",
    value: function cancelLandmarkAnimation() {
      if (this.landmarkAnimationID !== void 0) {
        this.canvas.cancelAnimationFrame(this.landmarkAnimationID);
      }
    }
  }, {
    key: "createLandmark",
    value: function createLandmark(name2) {
      var _position$, _position$2, _focalPoint$, _focalPoint$2;
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _params$position = params.position, position = _params$position === void 0 ? this.position : _params$position, _params$focalPoint = params.focalPoint, focalPoint = _params$focalPoint === void 0 ? this.focalPoint : _params$focalPoint, roll = params.roll, zoom = params.zoom;
      var camera = new runtime.CameraContribution();
      camera.setType(this.type, void 0);
      camera.setPosition(position[0], (_position$ = position[1]) !== null && _position$ !== void 0 ? _position$ : this.position[1], (_position$2 = position[2]) !== null && _position$2 !== void 0 ? _position$2 : this.position[2]);
      camera.setFocalPoint(focalPoint[0], (_focalPoint$ = focalPoint[1]) !== null && _focalPoint$ !== void 0 ? _focalPoint$ : this.focalPoint[1], (_focalPoint$2 = focalPoint[2]) !== null && _focalPoint$2 !== void 0 ? _focalPoint$2 : this.focalPoint[2]);
      camera.setRoll(roll !== null && roll !== void 0 ? roll : this.roll);
      camera.setZoom(zoom !== null && zoom !== void 0 ? zoom : this.zoom);
      var landmark = {
        name: name2,
        matrix: mat4_exports.clone(camera.getWorldTransform()),
        right: vec3_exports.clone(camera.right),
        up: vec3_exports.clone(camera.up),
        forward: vec3_exports.clone(camera.forward),
        position: vec3_exports.clone(camera.getPosition()),
        focalPoint: vec3_exports.clone(camera.getFocalPoint()),
        distanceVector: vec3_exports.clone(camera.getDistanceVector()),
        distance: camera.getDistance(),
        dollyingStep: camera.getDollyingStep(),
        azimuth: camera.getAzimuth(),
        elevation: camera.getElevation(),
        roll: camera.getRoll(),
        relAzimuth: camera.relAzimuth,
        relElevation: camera.relElevation,
        relRoll: camera.relRoll,
        zoom: camera.getZoom()
      };
      this.landmarks.push(landmark);
      return landmark;
    }
  }, {
    key: "gotoLandmark",
    value: function gotoLandmark(name2) {
      var _this2 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var landmark = isString(name2) ? this.landmarks.find(function(l) {
        return l.name === name2;
      }) : name2;
      if (landmark) {
        var _ref = isNumber(options) ? {
          duration: options
        } : options, _ref$easing = _ref.easing, easing = _ref$easing === void 0 ? "linear" : _ref$easing, _ref$duration = _ref.duration, duration = _ref$duration === void 0 ? 100 : _ref$duration, _ref$easingFunction = _ref.easingFunction, easingFunction = _ref$easingFunction === void 0 ? void 0 : _ref$easingFunction, _ref$onfinish = _ref.onfinish, onfinish = _ref$onfinish === void 0 ? void 0 : _ref$onfinish, _ref$onframe = _ref.onframe, onframe = _ref$onframe === void 0 ? void 0 : _ref$onframe;
        var epsilon4 = 0.01;
        this.cancelLandmarkAnimation();
        var destPosition = landmark.position;
        var destFocalPoint = landmark.focalPoint;
        var destZoom = landmark.zoom;
        var destRoll = landmark.roll;
        var easingFunc = easingFunction || runtime.EasingFunction(easing);
        var timeStart;
        var end = function end2() {
          _this2.setFocalPoint(destFocalPoint);
          _this2.setPosition(destPosition);
          _this2.setRoll(destRoll);
          _this2.setZoom(destZoom);
          _this2.computeMatrix();
          _this2.triggerUpdate();
          onfinish === null || onfinish === void 0 || onfinish();
        };
        if (duration === 0)
          return end();
        var _animate = function animate2(timestamp) {
          if (timeStart === void 0) {
            timeStart = timestamp;
          }
          var elapsed = timestamp - timeStart;
          if (elapsed >= duration) {
            end();
            return;
          }
          var t = easingFunc(elapsed / duration);
          var interFocalPoint = vec3_exports.create();
          var interPosition = vec3_exports.create();
          var interZoom = 1;
          var interRoll = 0;
          vec3_exports.lerp(interFocalPoint, _this2.focalPoint, destFocalPoint, t);
          vec3_exports.lerp(interPosition, _this2.position, destPosition, t);
          interRoll = _this2.roll * (1 - t) + destRoll * t;
          interZoom = _this2.zoom * (1 - t) + destZoom * t;
          _this2.setFocalPoint(interFocalPoint);
          _this2.setPosition(interPosition);
          _this2.setRoll(interRoll);
          _this2.setZoom(interZoom);
          var dist5 = vec3_exports.dist(interFocalPoint, destFocalPoint) + vec3_exports.dist(interPosition, destPosition);
          if (dist5 <= epsilon4 && destZoom === void 0 && destRoll === void 0) {
            return end();
          }
          _this2.computeMatrix();
          _this2.triggerUpdate();
          if (elapsed < duration) {
            onframe === null || onframe === void 0 || onframe(t);
            _this2.landmarkAnimationID = _this2.canvas.requestAnimationFrame(_animate);
          }
        };
        this.canvas.requestAnimationFrame(_animate);
      }
    }
    /**
     * Sets the camera to a distance such that the area covered by the bounding box is viewed.
     */
    // shot(displayObject: DisplayObject) {
    //   const aabb = displayObject.getBounds();
    //   if (!AABB.isEmpty(aabb)) {
    //     this.setElevation(0);
    //     this.setAzimuth(0);
    //     this.setRoll(0);
    //     const { halfExtents, center } = aabb;
    //     const maxDim = Math.max(halfExtents[0] * 2, halfExtents[1] * 2);
    //     const cc = center.map((c: number) => Math.round(c * 1000) / 1000) as [number, number, number];
    //     if (maxDim !== 0) {
    //       const d = (1.5 * maxDim) / Math.tan(this.fov * DEG_2_RAD);
    //       this.setPosition([cc[0], cc[1], cc[2] + d]);
    //     }
    //     this.setFocalPoint(cc);
    //   }
    // }
  }]);
}(Camera);
runtime.CameraContribution = AdvancedCamera;

// node_modules/@antv/g-dom-mutation-observer-api/dist/index.esm.js
var MutationRecord = function() {
  function MutationRecord2(type, target) {
    _classCallCheck(this, MutationRecord2);
    this.addedNodes = [];
    this.attributeName = null;
    this.attributeNamespace = null;
    this.nextSibling = null;
    this.oldValue = null;
    this.previousSibling = null;
    this.removedNodes = [];
    this.type = type;
    this.target = target;
  }
  return _createClass(MutationRecord2, null, [{
    key: "copy",
    value: function copy7(original) {
      var record = new MutationRecord2(original.type, original.target);
      record.addedNodes = original.addedNodes.slice();
      record.removedNodes = original.removedNodes.slice();
      record.previousSibling = original.previousSibling;
      record.nextSibling = original.nextSibling;
      record.attributeName = original.attributeName;
      record.attributeNamespace = original.attributeNamespace;
      record.oldValue = original.oldValue;
      return record;
    }
  }]);
}();
var uidCounter = 0;
var registrationsTable = /* @__PURE__ */ new WeakMap();
var Registration = function() {
  function Registration2(observer, target, options) {
    _classCallCheck(this, Registration2);
    this.transientObservedNodes = [];
    this.observer = observer;
    this.target = target;
    this.options = options;
  }
  return _createClass(Registration2, [{
    key: "enqueue",
    value: function enqueue(record) {
      var records = this.observer.records;
      var length5 = records.length;
      if (records.length > 0) {
        var lastRecord = records[length5 - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length5 - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length5] = record;
    }
  }, {
    key: "addListeners",
    value: function addListeners() {
      this.addListeners_(this.target);
    }
  }, {
    key: "addListeners_",
    value: function addListeners_(node) {
      var options = this.options;
      if (options.attributes)
        node.addEventListener(ElementEvent.ATTR_MODIFIED, this, true);
      if (options.childList)
        node.addEventListener(ElementEvent.INSERTED, this, true);
      if (options.childList || options.subtree)
        node.addEventListener(ElementEvent.REMOVED, this, true);
    }
  }, {
    key: "removeListeners",
    value: function removeListeners() {
      this.removeListeners_(this.target);
    }
  }, {
    key: "removeListeners_",
    value: function removeListeners_(node) {
      var options = this.options;
      if (options.attributes)
        node.removeEventListener(ElementEvent.ATTR_MODIFIED, this, true);
      if (options.childList)
        node.removeEventListener(ElementEvent.INSERTED, this, true);
      if (options.childList || options.subtree)
        node.removeEventListener(ElementEvent.REMOVED, this, true);
    }
    /**
     * Adds a transient observer on node. The transient observer gets removed
     * next time we deliver the change records.
     */
    // addTransientObserver(node: IElement) {
    //   // Don't add transient observers on the target itself. We already have all
    //   // the required listeners set up on the target.
    //   if (node === this.target) return;
    //   this.addListeners_(node);
    //   this.transientObservedNodes.push(node);
    //   let registrations = registrationsTable.get(node);
    //   if (!registrations) registrationsTable.set(node, (registrations = []));
    //   // We know that registrations does not contain this because we already
    //   // checked if node === this.target.
    //   registrations.push(this);
    // }
  }, {
    key: "removeTransientObservers",
    value: function removeTransientObservers() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(e) {
      e.stopImmediatePropagation();
      var record;
      var target;
      switch (e.type) {
        case ElementEvent.ATTR_MODIFIED:
          var name2 = e.attrName;
          var namespace = e.relatedNode.namespaceURI;
          target = e.target;
          record = getRecord("attributes", target);
          record.attributeName = name2;
          record.attributeNamespace = namespace;
          var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            if (!options.attributes)
              return;
            if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name2) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
              return;
            }
            if (options.attributeOldValue)
              return getRecordWithOldValue(oldValue);
            return record;
          });
          break;
        case ElementEvent.REMOVED:
        case ElementEvent.INSERTED:
          target = e.relatedNode;
          var changedNode = e.target;
          var addedNodes;
          var removedNodes;
          if (e.type === ElementEvent.INSERTED) {
            addedNodes = [changedNode];
            removedNodes = [];
          } else {
            addedNodes = [];
            removedNodes = [changedNode];
          }
          var previousSibling = changedNode.previousSibling;
          var nextSibling = changedNode.nextSibling;
          record = getRecord("childList", target);
          record.addedNodes = addedNodes;
          record.removedNodes = removedNodes;
          record.previousSibling = previousSibling;
          record.nextSibling = nextSibling;
          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            if (!options.childList)
              return;
            return record;
          });
      }
      clearRecords();
    }
  }]);
}();
var MutationObserver = function() {
  function MutationObserver2(callback) {
    _classCallCheck(this, MutationObserver2);
    this.nodes = [];
    this.records = [];
    this.uid = uidCounter++;
    this.callback = callback;
  }
  return _createClass(MutationObserver2, [{
    key: "observe",
    value: function observe(target, options) {
      if (!options.childList && !options.attributes && !options.characterData || // 1.2
      options.attributeOldValue && !options.attributes || // 1.3
      options.attributeFilter && options.attributeFilter.length && !options.attributes || // 1.4
      options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations)
        registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes.push(target);
      }
      registration.addListeners();
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      var _this2 = this;
      this.nodes.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === _this2) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records = [];
    }
  }, {
    key: "takeRecords",
    value: function takeRecords() {
      var copyOfRecords = this.records;
      this.records = [];
      return copyOfRecords;
    }
  }]);
}();
var currentRecord;
var recordWithOldValue;
function getRecord(type, target) {
  return currentRecord = new MutationRecord(type, target);
}
function getRecordWithOldValue(oldValue) {
  if (recordWithOldValue)
    return recordWithOldValue;
  recordWithOldValue = MutationRecord.copy(currentRecord);
  recordWithOldValue.oldValue = oldValue;
  return recordWithOldValue;
}
function clearRecords() {
  currentRecord = recordWithOldValue = void 0;
}
function recordRepresentsCurrentMutation(record) {
  return record === recordWithOldValue || record === currentRecord;
}
function selectRecord(lastRecord, newRecord) {
  if (lastRecord === newRecord)
    return lastRecord;
  if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))
    return recordWithOldValue;
  return null;
}
function removeTransientObserversFor(observer) {
  observer.nodes.forEach(function(node) {
    var registrations = registrationsTable.get(node);
    if (!registrations)
      return;
    registrations.forEach(function(registration) {
      if (registration.observer === observer)
        registration.removeTransientObservers();
    });
  });
}
function forEachAncestorAndObserverEnqueueRecord(target, callback) {
  for (var node = target; node; node = node.parentNode) {
    var registrations = registrationsTable.get(node);
    if (registrations) {
      for (var j = 0; j < registrations.length; j++) {
        var registration = registrations[j];
        var _options = registration.options;
        if (node !== target && !_options.subtree)
          continue;
        var record = callback(_options);
        if (record)
          registration.enqueue(record);
      }
    }
  }
}
var isScheduled = false;
var scheduledObservers = [];
function scheduleCallback(observer) {
  scheduledObservers.push(observer);
  if (!isScheduled) {
    isScheduled = true;
    if (typeof runtime.globalThis !== "undefined") {
      runtime.globalThis.setTimeout(dispatchCallbacks);
    } else {
      dispatchCallbacks();
    }
  }
}
function dispatchCallbacks() {
  isScheduled = false;
  var observers = scheduledObservers;
  scheduledObservers = [];
  observers.sort(function(o1, o2) {
    return o1.uid - o2.uid;
  });
  var anyNonEmpty = false;
  observers.forEach(function(observer) {
    var queue = observer.takeRecords();
    removeTransientObserversFor(observer);
    if (queue.length) {
      observer.callback(queue, observer);
      anyNonEmpty = true;
    }
  });
  if (anyNonEmpty)
    dispatchCallbacks();
}

// node_modules/@antv/g-web-animations-api/dist/index.esm.js
var AnimationEvent = function(_FederatedEvent) {
  function AnimationEvent2(manager, target, currentTime, timelineTime) {
    var _this2;
    _classCallCheck(this, AnimationEvent2);
    _this2 = _callSuper(this, AnimationEvent2, [manager]);
    _this2.currentTime = currentTime;
    _this2.timelineTime = timelineTime;
    _this2.target = target;
    _this2.type = "finish";
    _this2.bubbles = false;
    _this2.currentTarget = target;
    _this2.defaultPrevented = false;
    _this2.eventPhase = _this2.AT_TARGET;
    _this2.timeStamp = Date.now();
    _this2.currentTime = currentTime;
    _this2.timelineTime = timelineTime;
    return _this2;
  }
  _inherits(AnimationEvent2, _FederatedEvent);
  return _createClass(AnimationEvent2);
}(FederatedEvent);
var sequenceNumber = 0;
var Animation = function() {
  function Animation2(effect, timeline) {
    var _this$effect;
    _classCallCheck(this, Animation2);
    this.currentTimePending = false;
    this._idle = true;
    this._paused = false;
    this._finishedFlag = true;
    this._currentTime = 0;
    this._playbackRate = 1;
    this._inTimeline = true;
    this.effect = effect;
    effect.animation = this;
    this.timeline = timeline;
    this.id = "".concat(sequenceNumber++);
    this._inEffect = !!this.effect.update(0);
    this._totalDuration = Number((_this$effect = this.effect) === null || _this$effect === void 0 ? void 0 : _this$effect.getComputedTiming().endTime);
    this._holdTime = 0;
    this._paused = false;
    this.oldPlayState = "idle";
    this.updatePromises();
  }
  return _createClass(Animation2, [{
    key: "pending",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/effect
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/timeline
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/id
       */
      // animation: InternalAnimation | null;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/pending
       */
      function get4() {
        return this._startTime === null && !this._paused && this.playbackRate !== 0 || this.currentTimePending;
      }
    )
  }, {
    key: "playState",
    get: function get4() {
      if (this._idle)
        return "idle";
      if (this._isFinished)
        return "finished";
      if (this._paused)
        return "paused";
      return "running";
    }
    /**
     * record previos state
     */
  }, {
    key: "ready",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/ready
       * @example
        animation.pause();
        animation.ready.then(function() {
          // Displays 'running'
          alert(animation.playState);
        });
        animation.play();
       */
      function get4() {
        var _this2 = this;
        if (!this.readyPromise) {
          if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
            this.timeline.animationsWithPromises.push(this);
          }
          this.readyPromise = new Promise(function(resolve, reject) {
            _this2.resolveReadyPromise = function() {
              resolve(_this2);
            };
            _this2.rejectReadyPromise = function() {
              reject(new Error());
            };
          });
          if (!this.pending) {
            this.resolveReadyPromise();
          }
        }
        return this.readyPromise;
      }
    )
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/finished
     * @example
      Promise.all(
        elem.getAnimations().map(
          function(animation) {
            return animation.finished
          }
        )
      ).then(
        function() {
          return elem.remove();
        }
      );
     */
  }, {
    key: "finished",
    get: function get4() {
      var _this2 = this;
      if (!this.finishedPromise) {
        if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
          this.timeline.animationsWithPromises.push(this);
        }
        this.finishedPromise = new Promise(function(resolve, reject) {
          _this2.resolveFinishedPromise = function() {
            resolve(_this2);
          };
          _this2.rejectFinishedPromise = function() {
            reject(new Error());
          };
        });
        if (this.playState === "finished") {
          this.resolveFinishedPromise();
        }
      }
      return this.finishedPromise;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/onfinish
     */
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/oncancel
     */
    /**
     * get called after each frame when running
     */
  }, {
    key: "currentTime",
    get: function get4() {
      this.updatePromises();
      return this._idle || this.currentTimePending ? null : this._currentTime;
    },
    set: function set9(newTime) {
      newTime = Number(newTime);
      if (isNaN(newTime))
        return;
      this.timeline.restart();
      if (!this._paused && this._startTime !== null) {
        var _this$timeline;
        this._startTime = Number((_this$timeline = this.timeline) === null || _this$timeline === void 0 ? void 0 : _this$timeline.currentTime) - newTime / this.playbackRate;
      }
      this.currentTimePending = false;
      if (this._currentTime === newTime) {
        return;
      }
      if (this._idle) {
        this._idle = false;
        this._paused = true;
      }
      this.tickCurrentTime(newTime, true);
      this.timeline.applyDirtiedAnimation(this);
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/startTime
     */
  }, {
    key: "startTime",
    get: function get4() {
      return this._startTime;
    },
    set: function set9(newTime) {
      if (newTime !== null) {
        this.updatePromises();
        newTime = Number(newTime);
        if (isNaN(newTime))
          return;
        if (this._paused || this._idle)
          return;
        this._startTime = newTime;
        this.tickCurrentTime((Number(this.timeline.currentTime) - this._startTime) * this.playbackRate);
        this.timeline.applyDirtiedAnimation(this);
        this.updatePromises();
      }
    }
  }, {
    key: "playbackRate",
    get: function get4() {
      return this._playbackRate;
    },
    set: function set9(value2) {
      if (value2 === this._playbackRate) {
        return;
      }
      this.updatePromises();
      var oldCurrentTime = this.currentTime;
      this._playbackRate = value2;
      this.startTime = null;
      if (this.playState !== "paused" && this.playState !== "idle") {
        this._finishedFlag = false;
        this._idle = false;
        this.ensureAlive();
        this.timeline.applyDirtiedAnimation(this);
      }
      if (oldCurrentTime !== null) {
        this.currentTime = oldCurrentTime;
      }
      this.updatePromises();
    }
  }, {
    key: "_isFinished",
    get: function get4() {
      return !this._idle && (this._playbackRate > 0 && Number(this._currentTime) >= this._totalDuration || this._playbackRate < 0 && Number(this._currentTime) <= 0);
    }
  }, {
    key: "totalDuration",
    get: function get4() {
      return this._totalDuration;
    }
  }, {
    key: "_needsTick",
    get: function get4() {
      return this.pending || this.playState === "running" || !this._finishedFlag;
    }
  }, {
    key: "updatePromises",
    value: function updatePromises() {
      var oldPlayState = this.oldPlayState;
      var newPlayState = this.pending ? "pending" : this.playState;
      if (this.readyPromise && newPlayState !== oldPlayState) {
        if (newPlayState === "idle") {
          this.rejectReadyPromise();
          this.readyPromise = void 0;
        } else if (oldPlayState === "pending") {
          this.resolveReadyPromise();
        } else if (newPlayState === "pending") {
          this.readyPromise = void 0;
        }
      }
      if (this.finishedPromise && newPlayState !== oldPlayState) {
        if (newPlayState === "idle") {
          this.rejectFinishedPromise();
          this.finishedPromise = void 0;
        } else if (newPlayState === "finished") {
          this.resolveFinishedPromise();
        } else if (oldPlayState === "finished") {
          this.finishedPromise = void 0;
        }
      }
      this.oldPlayState = newPlayState;
      return this.readyPromise || this.finishedPromise;
    }
  }, {
    key: "play",
    value: function play() {
      this.updatePromises();
      this._paused = false;
      if (this._isFinished || this._idle) {
        this.rewind();
        this._startTime = null;
      }
      this._finishedFlag = false;
      this._idle = false;
      this.ensureAlive();
      this.timeline.applyDirtiedAnimation(this);
      if (this.timeline.animations.indexOf(this) === -1) {
        this.timeline.animations.push(this);
      }
      this.updatePromises();
    }
  }, {
    key: "pause",
    value: function pause() {
      this.updatePromises();
      if (this.currentTime) {
        this._holdTime = this.currentTime;
      }
      if (!this._isFinished && !this._paused && !this._idle) {
        this.currentTimePending = true;
      } else if (this._idle) {
        this.rewind();
        this._idle = false;
      }
      this._startTime = null;
      this._paused = true;
      this.updatePromises();
    }
  }, {
    key: "finish",
    value: function finish() {
      this.updatePromises();
      if (this._idle)
        return;
      this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
      this._startTime = this._totalDuration - this.currentTime;
      this.currentTimePending = false;
      this.timeline.applyDirtiedAnimation(this);
      this.updatePromises();
    }
  }, {
    key: "cancel",
    value: function cancel2() {
      var _this3 = this;
      this.updatePromises();
      if (!this._inEffect)
        return;
      this._inEffect = false;
      this._idle = true;
      this._paused = false;
      this._finishedFlag = true;
      this._currentTime = 0;
      this._startTime = null;
      this.effect.update(null);
      this.timeline.applyDirtiedAnimation(this);
      this.updatePromises();
      if (this.oncancel) {
        var event = new AnimationEvent(null, this, this.currentTime, null);
        setTimeout(function() {
          _this3.oncancel(event);
        });
      }
    }
  }, {
    key: "reverse",
    value: function reverse2() {
      this.updatePromises();
      var oldCurrentTime = this.currentTime;
      this.playbackRate *= -1;
      this.play();
      if (oldCurrentTime !== null) {
        this.currentTime = oldCurrentTime;
      }
      this.updatePromises();
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/updatePlaybackRate
     */
  }, {
    key: "updatePlaybackRate",
    value: function updatePlaybackRate(playbackRate) {
      this.playbackRate = playbackRate;
    }
  }, {
    key: "targetAnimations",
    value: function targetAnimations() {
      var _this$effect2;
      var target = (_this$effect2 = this.effect) === null || _this$effect2 === void 0 ? void 0 : _this$effect2.target;
      return target.getAnimations();
    }
  }, {
    key: "markTarget",
    value: function markTarget() {
      var animations = this.targetAnimations();
      if (animations.indexOf(this) === -1) {
        animations.push(this);
      }
    }
  }, {
    key: "unmarkTarget",
    value: function unmarkTarget() {
      var animations = this.targetAnimations();
      var index3 = animations.indexOf(this);
      if (index3 !== -1) {
        animations.splice(index3, 1);
      }
    }
  }, {
    key: "tick",
    value: function tick3(timelineTime, isAnimationFrame) {
      if (!this._idle && !this._paused) {
        if (this._startTime === null) {
          if (isAnimationFrame) {
            this.startTime = timelineTime - this._currentTime / this.playbackRate;
          }
        } else if (!this._isFinished) {
          this.tickCurrentTime((timelineTime - this._startTime) * this.playbackRate);
        }
      }
      if (isAnimationFrame) {
        this.currentTimePending = false;
        this.fireEvents(timelineTime);
      }
    }
  }, {
    key: "rewind",
    value: function rewind() {
      if (this.playbackRate >= 0) {
        this.currentTime = 0;
      } else if (this._totalDuration < Infinity) {
        this.currentTime = this._totalDuration;
      } else {
        throw new Error("Unable to rewind negative playback rate animation with infinite duration");
      }
    }
  }, {
    key: "persist",
    value: function persist() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "commitStyles",
    value: (
      // replaceState: AnimationReplaceState;
      function commitStyles() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    )
  }, {
    key: "ensureAlive",
    value: function ensureAlive() {
      if (this.playbackRate < 0 && this.currentTime === 0) {
        var _this$effect3;
        this._inEffect = !!((_this$effect3 = this.effect) !== null && _this$effect3 !== void 0 && _this$effect3.update(-1));
      } else {
        var _this$effect4;
        this._inEffect = !!((_this$effect4 = this.effect) !== null && _this$effect4 !== void 0 && _this$effect4.update(this.currentTime));
      }
      if (!this._inTimeline && (this._inEffect || !this._finishedFlag)) {
        this._inTimeline = true;
        this.timeline.animations.push(this);
      }
    }
  }, {
    key: "tickCurrentTime",
    value: function tickCurrentTime(newTime, ignoreLimit) {
      if (newTime !== this._currentTime) {
        this._currentTime = newTime;
        if (this._isFinished && !ignoreLimit) {
          this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
        }
        this.ensureAlive();
      }
    }
  }, {
    key: "fireEvents",
    value: function fireEvents(baseTime) {
      var _this4 = this;
      if (this._isFinished) {
        if (!this._finishedFlag) {
          if (this.onfinish) {
            var event = new AnimationEvent(null, this, this.currentTime, baseTime);
            setTimeout(function() {
              if (_this4.onfinish) {
                _this4.onfinish(event);
              }
            });
          }
          this._finishedFlag = true;
        }
      } else {
        if (this.onframe && this.playState === "running") {
          var _event = new AnimationEvent(null, this, this.currentTime, baseTime);
          this.onframe(_event);
        }
        this._finishedFlag = false;
      }
    }
  }]);
}();
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 1e-3;
var SUBDIVISION_PRECISION = 1e-7;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
var float32ArraySupported = typeof Float32Array === "function";
var A = function A2(aA1, aA2) {
  return 1 - 3 * aA2 + 3 * aA1;
};
var B = function B2(aA1, aA2) {
  return 3 * aA2 - 6 * aA1;
};
var C = function C2(aA1) {
  return 3 * aA1;
};
var calcBezier = function calcBezier2(aT, aA1, aA2) {
  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
};
var getSlope = function getSlope2(aT, aA1, aA2) {
  return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
};
var binarySubdivide = function binarySubdivide2(aX, aA, aB, mX1, mX2) {
  var currentX;
  var currentT;
  var i = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0)
      aB = currentT;
    else
      aA = currentT;
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
};
var newtonRaphsonIterate = function newtonRaphsonIterate2(aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0)
      return aGuessT;
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
};
var bezier2 = function bezier3(mX1, mY1, mX2, mY2) {
  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1))
    throw new Error("bezier x values must be in [0, 1] range");
  if (mX1 === mY1 && mX2 === mY2)
    return function(t) {
      return t;
    };
  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  for (var i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }
  var getTForX = function getTForX2(aX) {
    var intervalStart = 0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample)
      intervalStart += kSampleStepSize;
    --currentSample;
    var dist5 = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist5 * kSampleStepSize;
    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE)
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    if (initialSlope === 0)
      return guessForT;
    return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
  };
  return function(t) {
    if (t === 0 || t === 1)
      return t;
    return calcBezier(getTForX(t), mY1, mY2);
  };
};
var convertToDash = function convertToDash2(str7) {
  str7 = str7.replace(/([A-Z])/g, function(letter) {
    return "-".concat(letter.toLowerCase());
  });
  return str7.charAt(0) === "-" ? str7.substring(1) : str7;
};
var Quad = function Quad2(t) {
  return Math.pow(t, 2);
};
var Cubic = function Cubic2(t) {
  return Math.pow(t, 3);
};
var Quart = function Quart2(t) {
  return Math.pow(t, 4);
};
var Quint = function Quint2(t) {
  return Math.pow(t, 5);
};
var Expo = function Expo2(t) {
  return Math.pow(t, 6);
};
var Sine = function Sine2(t) {
  return 1 - Math.cos(t * Math.PI / 2);
};
var Circ = function Circ2(t) {
  return 1 - Math.sqrt(1 - t * t);
};
var Back = function Back2(t) {
  return t * t * (3 * t - 2);
};
var Bounce = function Bounce2(t) {
  var pow22;
  var b = 4;
  while (t < ((pow22 = Math.pow(2, --b)) - 1) / 11) {
  }
  return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow22 * 3 - 2) / 22 - t, 2);
};
var Elastic = function Elastic2(t) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var _params = _slicedToArray(params, 2), _params$ = _params[0], amplitude = _params$ === void 0 ? 1 : _params$, _params$2 = _params[1], period = _params$2 === void 0 ? 0.5 : _params$2;
  var a4 = clamp_default(Number(amplitude), 1, 10);
  var p2 = clamp_default(Number(period), 0.1, 2);
  if (t === 0 || t === 1)
    return t;
  return -a4 * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p2 / (Math.PI * 2) * Math.asin(1 / a4)) * (Math.PI * 2) / p2);
};
var Spring = function Spring2(t) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var duration = arguments.length > 2 ? arguments[2] : void 0;
  var _params2 = _slicedToArray(params, 4), _params2$ = _params2[0], mass = _params2$ === void 0 ? 1 : _params2$, _params2$2 = _params2[1], stiffness = _params2$2 === void 0 ? 100 : _params2$2, _params2$3 = _params2[2], damping = _params2$3 === void 0 ? 10 : _params2$3, _params2$4 = _params2[3], velocity = _params2$4 === void 0 ? 0 : _params2$4;
  mass = clamp_default(mass, 0.1, 1e3);
  stiffness = clamp_default(stiffness, 0.1, 1e3);
  damping = clamp_default(damping, 0.1, 1e3);
  velocity = clamp_default(velocity, 0.1, 1e3);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a4 = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;
  var progress = duration ? duration * t / 1e3 : t;
  if (zeta < 1) {
    progress = Math.exp(-progress * zeta * w0) * (a4 * Math.cos(wd * progress) + b * Math.sin(wd * progress));
  } else {
    progress = (a4 + b * progress) * Math.exp(-progress * w0);
  }
  if (t === 0 || t === 1)
    return t;
  return 1 - progress;
};
var Steps = function Steps2(t) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var _ref = params, _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], steps = _ref2$ === void 0 ? 10 : _ref2$, type = _ref2[1];
  var trunc = type === "start" ? Math.ceil : Math.floor;
  return trunc(clamp_default(t, 0, 1) * steps) / steps;
};
var Bezier = function Bezier2(t) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var _params3 = _slicedToArray(params, 4), mX1 = _params3[0], mY1 = _params3[1], mX2 = _params3[2], mY2 = _params3[3];
  return bezier2(mX1, mY1, mX2, mY2)(t);
};
var easein = bezier2(0.42, 0, 1, 1);
var EaseOut = function EaseOut2(ease2) {
  return function(t) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var duration = arguments.length > 2 ? arguments[2] : void 0;
    return 1 - ease2(1 - t, params, duration);
  };
};
var EaseInOut = function EaseInOut2(ease2) {
  return function(t) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var duration = arguments.length > 2 ? arguments[2] : void 0;
    return t < 0.5 ? ease2(t * 2, params, duration) / 2 : 1 - ease2(t * -2 + 2, params, duration) / 2;
  };
};
var EaseOutIn = function EaseOutIn2(ease2) {
  return function(t) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var duration = arguments.length > 2 ? arguments[2] : void 0;
    return t < 0.5 ? (1 - ease2(1 - t * 2, params, duration)) / 2 : (ease2(t * 2 - 1, params, duration) + 1) / 2;
  };
};
var EasingFunctions = {
  steps: Steps,
  "step-start": function stepStart(t) {
    return Steps(t, [1, "start"]);
  },
  "step-end": function stepEnd(t) {
    return Steps(t, [1, "end"]);
  },
  linear: function linear(t) {
    return t;
  },
  "cubic-bezier": Bezier,
  ease: function ease(t) {
    return Bezier(t, [0.25, 0.1, 0.25, 1]);
  },
  "in": easein,
  out: EaseOut(easein),
  "in-out": EaseInOut(easein),
  "out-in": EaseOutIn(easein),
  "in-quad": Quad,
  "out-quad": EaseOut(Quad),
  "in-out-quad": EaseInOut(Quad),
  "out-in-quad": EaseOutIn(Quad),
  "in-cubic": Cubic,
  "out-cubic": EaseOut(Cubic),
  "in-out-cubic": EaseInOut(Cubic),
  "out-in-cubic": EaseOutIn(Cubic),
  "in-quart": Quart,
  "out-quart": EaseOut(Quart),
  "in-out-quart": EaseInOut(Quart),
  "out-in-quart": EaseOutIn(Quart),
  "in-quint": Quint,
  "out-quint": EaseOut(Quint),
  "in-out-quint": EaseInOut(Quint),
  "out-in-quint": EaseOutIn(Quint),
  "in-expo": Expo,
  "out-expo": EaseOut(Expo),
  "in-out-expo": EaseInOut(Expo),
  "out-in-expo": EaseOutIn(Expo),
  "in-sine": Sine,
  "out-sine": EaseOut(Sine),
  "in-out-sine": EaseInOut(Sine),
  "out-in-sine": EaseOutIn(Sine),
  "in-circ": Circ,
  "out-circ": EaseOut(Circ),
  "in-out-circ": EaseInOut(Circ),
  "out-in-circ": EaseOutIn(Circ),
  "in-back": Back,
  "out-back": EaseOut(Back),
  "in-out-back": EaseInOut(Back),
  "out-in-back": EaseOutIn(Back),
  "in-bounce": Bounce,
  "out-bounce": EaseOut(Bounce),
  "in-out-bounce": EaseInOut(Bounce),
  "out-in-bounce": EaseOutIn(Bounce),
  "in-elastic": Elastic,
  "out-elastic": EaseOut(Elastic),
  "in-out-elastic": EaseInOut(Elastic),
  "out-in-elastic": EaseOutIn(Elastic),
  spring: Spring,
  "spring-in": Spring,
  "spring-out": EaseOut(Spring),
  "spring-in-out": EaseInOut(Spring),
  "spring-out-in": EaseOutIn(Spring)
};
var complexEasingSyntax = function complexEasingSyntax2(ease2) {
  return convertToDash(ease2).replace(/^ease-/, "").replace(/(\(|\s).+/, "").toLowerCase().trim();
};
var getEasingFunction = function getEasingFunction2(ease2) {
  return EasingFunctions[complexEasingSyntax(ease2)] || EasingFunctions.linear;
};
var linear2 = function linear3(x3) {
  return x3;
};
var Start = 1;
var Middle = 0.5;
var End = 0;
function step(count4, pos) {
  return function(x3) {
    if (x3 >= 1) {
      return 1;
    }
    var stepSize = 1 / count4;
    x3 += pos * stepSize;
    return x3 - x3 % stepSize;
  };
}
var numberString = "\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*";
var cubicBezierRe = new RegExp("cubic-bezier\\(".concat(numberString, ",").concat(numberString, ",").concat(numberString, ",").concat(numberString, "\\)"));
var step1Re = /steps\(\s*(\d+)\s*\)/;
var step2Re = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/;
function parseEasingFunction(normalizedEasing) {
  var cubicData = cubicBezierRe.exec(normalizedEasing);
  if (cubicData) {
    return bezier2.apply(void 0, _toConsumableArray(cubicData.slice(1).map(Number)));
  }
  var step1Data = step1Re.exec(normalizedEasing);
  if (step1Data) {
    return step(Number(step1Data[1]), End);
  }
  var step2Data = step2Re.exec(normalizedEasing);
  if (step2Data) {
    return step(Number(step2Data[1]), {
      start: Start,
      middle: Middle,
      end: End
    }[step2Data[2]]);
  }
  return getEasingFunction(normalizedEasing);
}
function calculateActiveDuration(timing) {
  return Math.abs(repeatedDuration(timing) / (timing.playbackRate || 1));
}
function repeatedDuration(timing) {
  var _timing$iterations;
  if (timing.duration === 0 || timing.iterations === 0) {
    return 0;
  }
  return (timing.duration === "auto" ? 0 : Number(timing.duration)) * ((_timing$iterations = timing.iterations) !== null && _timing$iterations !== void 0 ? _timing$iterations : 1);
}
var PhaseNone = 0;
var PhaseBefore = 1;
var PhaseAfter = 2;
var PhaseActive = 3;
function calculatePhase(activeDuration, localTime, timing) {
  if (localTime === null) {
    return PhaseNone;
  }
  var endTime = timing.endTime;
  if (localTime < Math.min(timing.delay, endTime)) {
    return PhaseBefore;
  }
  if (localTime >= Math.min(timing.delay + activeDuration + timing.endDelay, endTime)) {
    return PhaseAfter;
  }
  return PhaseActive;
}
function calculateActiveTime(activeDuration, fillMode, localTime, phase, delay) {
  switch (phase) {
    case PhaseBefore:
      if (fillMode === "backwards" || fillMode === "both")
        return 0;
      return null;
    case PhaseActive:
      return localTime - delay;
    case PhaseAfter:
      if (fillMode === "forwards" || fillMode === "both")
        return activeDuration;
      return null;
    case PhaseNone:
      return null;
  }
}
function calculateOverallProgress(iterationDuration, phase, iterations2, activeTime, iterationStart) {
  var overallProgress = iterationStart;
  if (iterationDuration === 0) {
    if (phase !== PhaseBefore) {
      overallProgress += iterations2;
    }
  } else {
    overallProgress += activeTime / iterationDuration;
  }
  return overallProgress;
}
function calculateSimpleIterationProgress(overallProgress, iterationStart, phase, iterations2, activeTime, iterationDuration) {
  var simpleIterationProgress = overallProgress === Infinity ? iterationStart % 1 : overallProgress % 1;
  if (simpleIterationProgress === 0 && phase === PhaseAfter && iterations2 !== 0 && (activeTime !== 0 || iterationDuration === 0)) {
    simpleIterationProgress = 1;
  }
  return simpleIterationProgress;
}
function calculateCurrentIteration(phase, iterations2, simpleIterationProgress, overallProgress) {
  if (phase === PhaseAfter && iterations2 === Infinity) {
    return Infinity;
  }
  if (simpleIterationProgress === 1) {
    return Math.floor(overallProgress) - 1;
  }
  return Math.floor(overallProgress);
}
function calculateDirectedProgress(playbackDirection, currentIteration, simpleIterationProgress) {
  var currentDirection = playbackDirection;
  if (playbackDirection !== "normal" && playbackDirection !== "reverse") {
    var d3 = currentIteration;
    if (playbackDirection === "alternate-reverse") {
      d3 += 1;
    }
    currentDirection = "normal";
    if (d3 !== Infinity && d3 % 2 !== 0) {
      currentDirection = "reverse";
    }
  }
  if (currentDirection === "normal") {
    return simpleIterationProgress;
  }
  return 1 - simpleIterationProgress;
}
function calculateIterationProgress(activeDuration, localTime, timing) {
  var phase = calculatePhase(activeDuration, localTime, timing);
  var activeTime = calculateActiveTime(activeDuration, timing.fill, localTime, phase, timing.delay);
  if (activeTime === null)
    return null;
  var duration = timing.duration === "auto" ? 0 : timing.duration;
  var overallProgress = calculateOverallProgress(duration, phase, timing.iterations, activeTime, timing.iterationStart);
  var simpleIterationProgress = calculateSimpleIterationProgress(overallProgress, timing.iterationStart, phase, timing.iterations, activeTime, duration);
  var currentIteration = calculateCurrentIteration(phase, timing.iterations, simpleIterationProgress, overallProgress);
  var directedProgress = calculateDirectedProgress(timing.direction, currentIteration, simpleIterationProgress);
  timing.currentIteration = currentIteration;
  timing.progress = directedProgress;
  return timing.easingFunction(directedProgress);
}
function convertEffectInput(keyframes, timing, target) {
  var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups(keyframes, timing);
  var interpolations = makeInterpolations(propertySpecificKeyframeGroups, target);
  return function(target2, fraction) {
    if (fraction !== null) {
      interpolations.filter(function(interpolation) {
        return fraction >= interpolation.applyFrom && fraction < interpolation.applyTo;
      }).forEach(function(interpolation) {
        var offsetFraction = fraction - interpolation.startOffset;
        var localDuration = interpolation.endOffset - interpolation.startOffset;
        var scaledLocalTime = localDuration === 0 ? 0 : offsetFraction / localDuration;
        target2.setAttribute(
          interpolation.property,
          interpolation.interpolation(scaledLocalTime),
          false,
          false
          // disable memoize
        );
      });
    } else {
      for (var property in propertySpecificKeyframeGroups)
        if (isNotReservedWord(property)) {
          target2.setAttribute(property, null);
        }
    }
  };
}
function isNotReservedWord(member) {
  return member !== "offset" && member !== "easing" && member !== "composite" && member !== "computedOffset";
}
function makePropertySpecificKeyframeGroups(keyframes, timing) {
  var propertySpecificKeyframeGroups = {};
  for (var i = 0; i < keyframes.length; i++) {
    for (var member in keyframes[i]) {
      if (isNotReservedWord(member)) {
        var propertySpecificKeyframe = {
          offset: keyframes[i].offset,
          computedOffset: keyframes[i].computedOffset,
          easing: keyframes[i].easing,
          easingFunction: parseEasingFunction(keyframes[i].easing) || timing.easingFunction,
          value: keyframes[i][member]
        };
        propertySpecificKeyframeGroups[member] = propertySpecificKeyframeGroups[member] || [];
        propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);
      }
    }
  }
  return propertySpecificKeyframeGroups;
}
function makeInterpolations(propertySpecificKeyframeGroups, target) {
  var interpolations = [];
  for (var groupName in propertySpecificKeyframeGroups) {
    var keyframes = propertySpecificKeyframeGroups[groupName];
    for (var i = 0; i < keyframes.length - 1; i++) {
      var startIndex = i;
      var endIndex = i + 1;
      var startOffset = keyframes[startIndex].computedOffset;
      var endOffset = keyframes[endIndex].computedOffset;
      var applyFrom = startOffset;
      var applyTo = endOffset;
      if (i === 0) {
        applyFrom = -Infinity;
        if (endOffset === 0) {
          endIndex = startIndex;
        }
      }
      if (i === keyframes.length - 2) {
        applyTo = Infinity;
        if (startOffset === 1) {
          startIndex = endIndex;
        }
      }
      interpolations.push({
        applyFrom,
        applyTo,
        startOffset: keyframes[startIndex].computedOffset,
        endOffset: keyframes[endIndex].computedOffset,
        easingFunction: keyframes[startIndex].easingFunction,
        property: groupName,
        interpolation: propertyInterpolation(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target)
      });
    }
  }
  interpolations.sort(function(leftInterpolation, rightInterpolation) {
    return leftInterpolation.startOffset - rightInterpolation.startOffset;
  });
  return interpolations;
}
var InterpolationFactory = function InterpolationFactory2(from, to, convertToString) {
  return function(f) {
    var interpolated = interpolate2(from, to, f);
    return isNumber(interpolated) ? interpolated : convertToString(interpolated);
  };
};
function propertyInterpolation(property, left2, right2, target) {
  var metadata = propertyMetadataCache[property];
  if (metadata && metadata.syntax && metadata["int"]) {
    var propertyHandler = runtime.styleValueRegistry.getPropertySyntax(metadata.syntax);
    if (propertyHandler) {
      var parser2 = propertyHandler.parser;
      var usedLeft = parser2 ? parser2(left2, target) : left2;
      var usedRight = parser2 ? parser2(right2, target) : right2;
      var interpolationArgs = propertyHandler.mixer(usedLeft, usedRight, target);
      if (interpolationArgs) {
        var interp = InterpolationFactory.apply(void 0, _toConsumableArray(interpolationArgs));
        return function(t) {
          if (t === 0)
            return left2;
          if (t === 1)
            return right2;
          return interp(t);
        };
      }
    }
  }
  return InterpolationFactory(false, true, function(bool) {
    return bool ? right2 : left2;
  });
}
function interpolate2(from, to, f) {
  if (typeof from === "number" && typeof to === "number") {
    return from * (1 - f) + to * f;
  }
  if (typeof from === "boolean" && typeof to === "boolean" || typeof from === "string" && typeof to === "string") {
    return f < 0.5 ? from : to;
  }
  if (Array.isArray(from) && Array.isArray(to)) {
    var fromLength = from.length;
    var toLength = to.length;
    var length5 = Math.max(fromLength, toLength);
    var r = [];
    for (var i = 0; i < length5; i++) {
      r.push(interpolate2(from[i < fromLength ? i : fromLength - 1], to[i < toLength ? i : toLength - 1], f));
    }
    return r;
  }
  throw new Error("Mismatched interpolation arguments ".concat(from, ":").concat(to));
}
var AnimationEffectTiming = function() {
  function AnimationEffectTiming2() {
    _classCallCheck(this, AnimationEffectTiming2);
    this.delay = 0;
    this.direction = "normal";
    this.duration = "auto";
    this._easing = "linear";
    this.easingFunction = linear2;
    this.endDelay = 0;
    this.fill = "auto";
    this.iterationStart = 0;
    this.iterations = 1;
    this.currentIteration = null;
    this.progress = null;
  }
  return _createClass(AnimationEffectTiming2, [{
    key: "easing",
    get: function get4() {
      return this._easing;
    },
    set: function set9(value2) {
      this.easingFunction = parseEasingFunction(value2);
      this._easing = value2;
    }
  }]);
}();
function convertToArrayForm(effectInput) {
  var normalizedEffectInput = [];
  for (var property in effectInput) {
    if (property in ["easing", "offset", "composite"]) {
      continue;
    }
    var values4 = effectInput[property];
    if (!Array.isArray(values4)) {
      values4 = [values4];
    }
    var numKeyframes = values4.length;
    for (var i = 0; i < numKeyframes; i++) {
      if (!normalizedEffectInput[i]) {
        var keyframe = {};
        if ("offset" in effectInput) {
          keyframe.offset = Number(effectInput.offset);
        }
        if ("easing" in effectInput) {
          keyframe.easing = effectInput.easing;
        }
        if ("composite" in effectInput) {
          keyframe.composite = effectInput.composite;
        }
        normalizedEffectInput[i] = keyframe;
      }
      if (values4[i] !== void 0 && values4[i] !== null) {
        normalizedEffectInput[i][property] = values4[i];
      }
    }
  }
  normalizedEffectInput.sort(function(a4, b) {
    return (a4.computedOffset || 0) - (b.computedOffset || 0);
  });
  return normalizedEffectInput;
}
function normalizeKeyframes(effectInput, timing) {
  if (effectInput === null) {
    return [];
  }
  if (!Array.isArray(effectInput)) {
    effectInput = convertToArrayForm(effectInput);
  }
  var keyframes = effectInput.map(function(originalKeyframe) {
    var keyframe = {};
    if (timing !== null && timing !== void 0 && timing.composite) {
      keyframe.composite = "auto";
    }
    for (var member in originalKeyframe) {
      var memberValue = originalKeyframe[member];
      if (member === "offset") {
        if (memberValue !== null) {
          memberValue = Number(memberValue);
          if (!isFinite(memberValue))
            throw new Error("Keyframe offsets must be numbers.");
          if (memberValue < 0 || memberValue > 1)
            throw new Error("Keyframe offsets must be between 0 and 1.");
          keyframe.computedOffset = memberValue;
        }
      } else if (member === "composite") {
        if (["replace", "add", "accumulate", "auto"].indexOf(memberValue) === -1) {
          throw new Error("".concat(memberValue, " compositing is not supported"));
        }
      } else
        ;
      keyframe[member] = memberValue;
    }
    if (keyframe.offset === void 0) {
      keyframe.offset = null;
    }
    if (keyframe.easing === void 0) {
      keyframe.easing = (timing === null || timing === void 0 ? void 0 : timing.easing) || "linear";
    }
    if (keyframe.composite === void 0) {
      keyframe.composite = "auto";
    }
    return keyframe;
  });
  var everyFrameHasOffset = true;
  var previousOffset = -Infinity;
  for (var i = 0; i < keyframes.length; i++) {
    var offset2 = keyframes[i].offset;
    if (!isNil(offset2)) {
      if (offset2 < previousOffset) {
        throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");
      }
      previousOffset = offset2;
    } else {
      everyFrameHasOffset = false;
    }
  }
  keyframes = keyframes.filter(function(keyframe) {
    return Number(keyframe.offset) >= 0 && Number(keyframe.offset) <= 1;
  });
  function spaceKeyframes() {
    var _keyframes$offset;
    var _keyframes = keyframes, length5 = _keyframes.length;
    keyframes[length5 - 1].computedOffset = Number((_keyframes$offset = keyframes[length5 - 1].offset) !== null && _keyframes$offset !== void 0 ? _keyframes$offset : 1);
    if (length5 > 1) {
      var _keyframes$0$offset;
      keyframes[0].computedOffset = Number((_keyframes$0$offset = keyframes[0].offset) !== null && _keyframes$0$offset !== void 0 ? _keyframes$0$offset : 0);
    }
    var previousIndex = 0;
    var previousOffset2 = Number(keyframes[0].computedOffset);
    for (var _i = 1; _i < length5; _i++) {
      var _offset = keyframes[_i].computedOffset;
      if (!isNil(_offset) && !isNil(previousOffset2)) {
        for (var j = 1; j < _i - previousIndex; j++)
          keyframes[previousIndex + j].computedOffset = previousOffset2 + (Number(_offset) - previousOffset2) * j / (_i - previousIndex);
        previousIndex = _i;
        previousOffset2 = Number(_offset);
      }
    }
  }
  if (!everyFrameHasOffset)
    spaceKeyframes();
  return keyframes;
}
var fills = "backwards|forwards|both|none".split("|");
var directions = "reverse|alternate|alternate-reverse".split("|");
function makeTiming(timingInput, forGroup) {
  var timing = new AnimationEffectTiming();
  if (forGroup) {
    timing.fill = "both";
    timing.duration = "auto";
  }
  if (typeof timingInput === "number" && !isNaN(timingInput)) {
    timing.duration = timingInput;
  } else if (timingInput !== void 0) {
    Object.keys(timingInput).forEach(function(property) {
      if (timingInput[property] !== void 0 && timingInput[property] !== null && timingInput[property] !== "auto") {
        if (typeof timing[property] === "number" || property === "duration") {
          if (typeof timingInput[property] !== "number" || isNaN(timingInput[property])) {
            return;
          }
        }
        if (property === "fill" && fills.indexOf(timingInput[property]) === -1) {
          return;
        }
        if (property === "direction" && directions.indexOf(timingInput[property]) === -1) {
          return;
        }
        timing[property] = timingInput[property];
      }
    });
  }
  return timing;
}
function normalizeTimingInput(timingInput, forGroup) {
  timingInput = numericTimingToObject(timingInput !== null && timingInput !== void 0 ? timingInput : {
    duration: "auto"
  });
  return makeTiming(timingInput, forGroup);
}
function numericTimingToObject(timingInput) {
  if (typeof timingInput === "number") {
    if (isNaN(timingInput)) {
      timingInput = {
        duration: "auto"
      };
    } else {
      timingInput = {
        duration: timingInput
      };
    }
  }
  return timingInput;
}
var KeyframeEffect = function() {
  function KeyframeEffect2(target, effectInput, timingInput) {
    var _this2 = this;
    _classCallCheck(this, KeyframeEffect2);
    this.composite = "replace";
    this.iterationComposite = "replace";
    this.target = target;
    this.timing = normalizeTimingInput(timingInput, false);
    this.timing.effect = this;
    this.timing.activeDuration = calculateActiveDuration(this.timing);
    this.timing.endTime = Math.max(0, this.timing.delay + this.timing.activeDuration + this.timing.endDelay);
    this.normalizedKeyframes = normalizeKeyframes(effectInput, this.timing);
    this.interpolations = convertEffectInput(this.normalizedKeyframes, this.timing, this.target);
    var Proxy2 = runtime.globalThis.Proxy;
    this.computedTiming = Proxy2 ? new Proxy2(this.timing, {
      get: function get4(target2, prop) {
        if (prop === "duration") {
          return target2.duration === "auto" ? 0 : target2.duration;
        }
        if (prop === "fill") {
          return target2.fill === "auto" ? "none" : target2.fill;
        }
        if (prop === "localTime") {
          return _this2.animation && _this2.animation.currentTime || null;
        }
        if (prop === "currentIteration") {
          if (!_this2.animation || _this2.animation.playState !== "running") {
            return null;
          }
          return target2.currentIteration || 0;
        }
        if (prop === "progress") {
          if (!_this2.animation || _this2.animation.playState !== "running") {
            return null;
          }
          return target2.progress || 0;
        }
        return target2[prop];
      },
      set: function set9() {
        return true;
      }
    }) : this.timing;
  }
  return _createClass(KeyframeEffect2, [{
    key: "applyInterpolations",
    value: function applyInterpolations() {
      this.interpolations(this.target, Number(this.timeFraction));
    }
  }, {
    key: "update",
    value: function update2(localTime) {
      if (localTime === null) {
        return false;
      }
      this.timeFraction = calculateIterationProgress(this.timing.activeDuration, localTime, this.timing);
      return this.timeFraction !== null;
    }
  }, {
    key: "getKeyframes",
    value: function getKeyframes() {
      return this.normalizedKeyframes;
    }
  }, {
    key: "setKeyframes",
    value: function setKeyframes(keyframes) {
      this.normalizedKeyframes = normalizeKeyframes(keyframes);
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getComputedTiming
     */
  }, {
    key: "getComputedTiming",
    value: function getComputedTiming() {
      return this.computedTiming;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getTiming
     */
  }, {
    key: "getTiming",
    value: function getTiming() {
      return this.timing;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/updateTiming
     */
  }, {
    key: "updateTiming",
    value: function updateTiming(timing) {
      var _this2 = this;
      Object.keys(timing || {}).forEach(function(name2) {
        _this2.timing[name2] = timing[name2];
      });
    }
  }]);
}();
function compareAnimations(leftAnimation, rightAnimation) {
  return Number(leftAnimation.id) - Number(rightAnimation.id);
}
var AnimationTimeline = function() {
  function AnimationTimeline2(document2) {
    var _this2 = this;
    _classCallCheck(this, AnimationTimeline2);
    this.animations = [];
    this.ticking = false;
    this.timelineTicking = false;
    this.hasRestartedThisFrame = false;
    this.animationsWithPromises = [];
    this.inTick = false;
    this.pendingEffects = [];
    this.currentTime = null;
    this.rafId = 0;
    this.rafCallbacks = [];
    this.webAnimationsNextTick = function(t) {
      _this2.currentTime = t;
      _this2.discardAnimations();
      if (_this2.animations.length === 0) {
        _this2.timelineTicking = false;
      } else {
        _this2.requestAnimationFrame(_this2.webAnimationsNextTick);
      }
    };
    this.processRafCallbacks = function(t) {
      var processing = _this2.rafCallbacks;
      _this2.rafCallbacks = [];
      if (t < Number(_this2.currentTime))
        t = Number(_this2.currentTime);
      _this2.animations.sort(compareAnimations);
      _this2.animations = _this2.tick(t, true, _this2.animations)[0];
      processing.forEach(function(entry) {
        entry[1](t);
      });
      _this2.applyPendingEffects();
    };
    this.document = document2;
  }
  return _createClass(AnimationTimeline2, [{
    key: "getAnimations",
    value: function getAnimations() {
      this.discardAnimations();
      return this.animations.slice();
    }
  }, {
    key: "isTicking",
    value: function isTicking() {
      return this.inTick;
    }
  }, {
    key: "play",
    value: function play(target, keyframes, options) {
      var effect = new KeyframeEffect(target, keyframes, options);
      var animation = new Animation(effect, this);
      this.animations.push(animation);
      this.restartWebAnimationsNextTick();
      animation.updatePromises();
      animation.play();
      animation.updatePromises();
      return animation;
    }
    // RAF is supposed to be the last script to occur before frame rendering but not
    // all browsers behave like this. This function is for synchonously updating an
    // animation's effects whenever its state is mutated by script to work around
    // incorrect script execution ordering by the browser.
  }, {
    key: "applyDirtiedAnimation",
    value: function applyDirtiedAnimation(animation) {
      var _this2 = this;
      if (this.inTick) {
        return;
      }
      animation.markTarget();
      var animations = animation.targetAnimations();
      animations.sort(compareAnimations);
      var inactiveAnimations = this.tick(Number(this.currentTime), false, animations.slice())[1];
      inactiveAnimations.forEach(function(animation2) {
        var index3 = _this2.animations.indexOf(animation2);
        if (index3 !== -1) {
          _this2.animations.splice(index3, 1);
        }
      });
      this.applyPendingEffects();
    }
  }, {
    key: "restart",
    value: function restart() {
      if (!this.ticking) {
        this.ticking = true;
        this.requestAnimationFrame(function() {
        });
        this.hasRestartedThisFrame = true;
      }
      return this.hasRestartedThisFrame;
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      this.document.defaultView.cancelAnimationFrame(this.frameId);
    }
  }, {
    key: "applyPendingEffects",
    value: function applyPendingEffects() {
      this.pendingEffects.forEach(function(effect) {
        effect === null || effect === void 0 || effect.applyInterpolations();
      });
      this.pendingEffects = [];
    }
  }, {
    key: "updateAnimationsPromises",
    value: function updateAnimationsPromises() {
      this.animationsWithPromises = this.animationsWithPromises.filter(function(animation) {
        return animation.updatePromises();
      });
    }
  }, {
    key: "discardAnimations",
    value: function discardAnimations() {
      this.updateAnimationsPromises();
      this.animations = this.animations.filter(function(animation) {
        return animation.playState !== "finished" && animation.playState !== "idle";
      });
    }
  }, {
    key: "restartWebAnimationsNextTick",
    value: function restartWebAnimationsNextTick() {
      if (!this.timelineTicking) {
        this.timelineTicking = true;
        this.requestAnimationFrame(this.webAnimationsNextTick);
      }
    }
  }, {
    key: "rAF",
    value: function rAF(f) {
      var id4 = this.rafId++;
      if (this.rafCallbacks.length === 0) {
        this.frameId = this.document.defaultView.requestAnimationFrame(this.processRafCallbacks);
      }
      this.rafCallbacks.push([id4, f]);
      return id4;
    }
  }, {
    key: "requestAnimationFrame",
    value: function requestAnimationFrame3(f) {
      var _this3 = this;
      return this.rAF(function(x3) {
        _this3.updateAnimationsPromises();
        f(x3);
        _this3.updateAnimationsPromises();
      });
    }
  }, {
    key: "tick",
    value: function tick3(t, isAnimationFrame, updatingAnimations) {
      var _this4 = this, _this$pendingEffects, _this$pendingEffects2;
      this.inTick = true;
      this.hasRestartedThisFrame = false;
      this.currentTime = t;
      this.ticking = false;
      var newPendingClears = [];
      var newPendingEffects = [];
      var activeAnimations = [];
      var inactiveAnimations = [];
      updatingAnimations.forEach(function(animation) {
        animation.tick(t, isAnimationFrame);
        if (!animation._inEffect) {
          newPendingClears.push(animation.effect);
          animation.unmarkTarget();
        } else {
          newPendingEffects.push(animation.effect);
          animation.markTarget();
        }
        if (animation._needsTick)
          _this4.ticking = true;
        var alive = animation._inEffect || animation._needsTick;
        animation._inTimeline = alive;
        if (alive) {
          activeAnimations.push(animation);
        } else {
          inactiveAnimations.push(animation);
        }
      });
      (_this$pendingEffects = this.pendingEffects).push.apply(_this$pendingEffects, newPendingClears);
      (_this$pendingEffects2 = this.pendingEffects).push.apply(_this$pendingEffects2, newPendingEffects);
      if (this.ticking)
        this.requestAnimationFrame(function() {
        });
      this.inTick = false;
      return [activeAnimations, inactiveAnimations];
    }
  }]);
}();
runtime.EasingFunction = parseEasingFunction;
runtime.AnimationTimeline = AnimationTimeline;

// node_modules/@antv/g2/esm/utils/selection.js
function select(node) {
  return new Selection([node], null, node, node.ownerDocument);
}
var Selection = class _Selection {
  constructor(elements = null, data2 = null, parent = null, document2 = null, selections = [
    null,
    null,
    null,
    null,
    null
  ], transitions = [], updateElements = []) {
    this._elements = Array.from(elements);
    this._data = data2;
    this._parent = parent;
    this._document = document2;
    this._enter = selections[0];
    this._update = selections[1];
    this._exit = selections[2];
    this._merge = selections[3];
    this._split = selections[4];
    this._transitions = transitions;
    this._facetElements = updateElements;
  }
  selectAll(selector) {
    const elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
    return new _Selection(elements, null, this._elements[0], this._document);
  }
  selectFacetAll(selector) {
    const elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
    return new _Selection(this._elements, null, this._parent, this._document, void 0, void 0, elements);
  }
  /**
   * @todo Replace with querySelector which has bug now.
   */
  select(selector) {
    const element = typeof selector === "string" ? this._parent.querySelectorAll(selector)[0] || null : selector;
    return new _Selection([element], null, element, this._document);
  }
  append(node) {
    const callback = typeof node === "function" ? node : () => this.createElement(node);
    const elements = [];
    if (this._data !== null) {
      for (let i = 0; i < this._data.length; i++) {
        const d3 = this._data[i];
        const [datum, from] = Array.isArray(d3) ? d3 : [d3, null];
        const newElement = callback(datum, i);
        newElement.__data__ = datum;
        if (from !== null)
          newElement.__fromElements__ = from;
        this._parent.appendChild(newElement);
        elements.push(newElement);
      }
      return new _Selection(elements, null, this._parent, this._document);
    } else {
      for (let i = 0; i < this._elements.length; i++) {
        const element = this._elements[i];
        const datum = element.__data__;
        const newElement = callback(datum, i);
        element.appendChild(newElement);
        elements.push(newElement);
      }
      return new _Selection(elements, null, elements[0], this._document);
    }
  }
  maybeAppend(id4, node, className2) {
    const element = this._elements[0];
    const child = element.getElementById(id4);
    if (child) {
      return new _Selection([child], null, this._parent, this._document);
    }
    const newChild = typeof node === "string" ? this.createElement(node) : node();
    newChild.id = id4;
    if (className2)
      newChild.className = className2;
    element.appendChild(newChild);
    return new _Selection([newChild], null, this._parent, this._document);
  }
  /**
   * Bind data to elements, and produce three selection:
   * Enter: Selection with empty elements and data to be bind to elements.
   * Update: Selection with elements to be updated.
   * Exit: Selection with elements to be removed.
   */
  data(data2, id4 = (d3) => d3, groupId = () => null) {
    const enter = [];
    const update2 = [];
    const exit = new Set(this._elements);
    const merge2 = [];
    const split = /* @__PURE__ */ new Set();
    const keyElement = new Map(this._elements.map((d3, i) => [id4(d3.__data__, i), d3]));
    const keyUpdateElement = new Map(this._facetElements.map((d3, i) => [id4(d3.__data__, i), d3]));
    const groupKeyElements = group(this._elements, (d3) => groupId(d3.__data__));
    for (let i = 0; i < data2.length; i++) {
      const datum = data2[i];
      const key = id4(datum, i);
      const groupKey = groupId(datum, i);
      if (keyElement.has(key)) {
        const element = keyElement.get(key);
        element.__data__ = datum;
        element.__facet__ = false;
        update2.push(element);
        exit.delete(element);
        keyElement.delete(key);
      } else if (keyUpdateElement.has(key)) {
        const element = keyUpdateElement.get(key);
        element.__data__ = datum;
        element.__facet__ = true;
        update2.push(element);
        keyUpdateElement.delete(key);
      } else if (groupKeyElements.has(key)) {
        const group3 = groupKeyElements.get(key);
        merge2.push([datum, group3]);
        for (const element of group3)
          exit.delete(element);
        groupKeyElements.delete(key);
      } else if (keyElement.has(groupKey)) {
        const element = keyElement.get(groupKey);
        if (element.__toData__)
          element.__toData__.push(datum);
        else
          element.__toData__ = [datum];
        split.add(element);
        exit.delete(element);
      } else {
        enter.push(datum);
      }
    }
    const S = [
      new _Selection([], enter, this._parent, this._document),
      new _Selection(update2, null, this._parent, this._document),
      new _Selection(exit, null, this._parent, this._document),
      new _Selection([], merge2, this._parent, this._document),
      new _Selection(split, null, this._parent, this._document)
    ];
    return new _Selection(this._elements, null, this._parent, this._document, S);
  }
  merge(other) {
    const elements = [...this._elements, ...other._elements];
    const transitions = [...this._transitions, ...other._transitions];
    return new _Selection(elements, null, this._parent, this._document, void 0, transitions);
  }
  createElement(type) {
    if (this._document) {
      return this._document.createElement(type, {});
    }
    const Ctor = _Selection.registry[type];
    if (Ctor)
      return new Ctor();
    return error(`Unknown node type: ${type}`);
  }
  /**
   * Apply callback for each selection(enter, update, exit)
   * and merge them into one selection.
   */
  join(enter = (d3) => d3, update2 = (d3) => d3, exit = (d3) => d3.remove(), merge2 = (d3) => d3, split = (d3) => d3.remove()) {
    const newEnter = enter(this._enter);
    const newUpdate = update2(this._update);
    const newExit = exit(this._exit);
    const newMerge = merge2(this._merge);
    const newSplit = split(this._split);
    return newUpdate.merge(newEnter).merge(newExit).merge(newMerge).merge(newSplit);
  }
  remove() {
    for (let i = 0; i < this._elements.length; i++) {
      const transition2 = this._transitions[i];
      if (transition2) {
        const T = Array.isArray(transition2) ? transition2 : [transition2];
        Promise.all(T.map((d3) => d3.finished)).then(() => {
          const element = this._elements[i];
          element.remove();
        });
      } else {
        const element = this._elements[i];
        element.remove();
      }
    }
    return new _Selection([], null, this._parent, this._document, void 0, this._transitions);
  }
  each(callback) {
    for (let i = 0; i < this._elements.length; i++) {
      const element = this._elements[i];
      const datum = element.__data__;
      callback(datum, i, element);
    }
    return this;
  }
  attr(key, value2) {
    const callback = typeof value2 !== "function" ? () => value2 : value2;
    return this.each(function(d3, i, element) {
      if (value2 !== void 0)
        element[key] = callback(d3, i, element);
    });
  }
  style(key, value2) {
    const callback = typeof value2 !== "function" ? () => value2 : value2;
    return this.each(function(d3, i, element) {
      if (value2 !== void 0)
        element.style[key] = callback(d3, i, element);
    });
  }
  transition(value2) {
    const callback = typeof value2 !== "function" ? () => value2 : value2;
    const { _transitions: T } = this;
    return this.each(function(d3, i, element) {
      T[i] = callback(d3, i, element);
    });
  }
  on(event, handler) {
    this.each(function(d3, i, element) {
      element.addEventListener(event, handler);
    });
    return this;
  }
  call(callback, ...args) {
    callback(this, ...args);
    return this;
  }
  node() {
    return this._elements[0];
  }
  nodes() {
    return this._elements;
  }
  transitions() {
    return this._transitions;
  }
  parent() {
    return this._parent;
  }
};
Selection.registry = {
  g: Group2,
  rect: Rect,
  circle: Circle,
  path: Path2,
  text: Text,
  ellipse: Ellipse,
  image: Image2,
  line: Line,
  polygon: Polygon,
  polyline: Polyline,
  html: HTML
};

// node_modules/@antv/g2/esm/utils/number.js
function clamp2(v, lower2, upper2) {
  return Math.max(lower2, Math.min(v, upper2));
}
function prettyNumber2(n, precision = 10) {
  if (typeof n !== "number")
    return n;
  return Math.abs(n) < 1e-15 ? n : parseFloat(n.toFixed(precision));
}

// node_modules/@antv/g2/esm/shape/utils.js
function applyStyle(selection, style) {
  for (const [key, value2] of Object.entries(style)) {
    selection.style(key, value2);
  }
}
function appendPolygon(path2, points) {
  points.forEach((p2, idx) => idx === 0 ? path2.moveTo(p2[0], p2[1]) : path2.lineTo(p2[0], p2[1]));
  path2.closePath();
  return path2;
}
function arrowPoints(from, to, options) {
  const { arrowSize } = options;
  const size3 = typeof arrowSize === "string" ? +parseFloat(arrowSize) / 100 * dist4(from, to) : arrowSize;
  const arrowAngle = Math.PI / 6;
  const angle4 = Math.atan2(to[1] - from[1], to[0] - from[0]);
  const arrowAngle1 = Math.PI / 2 - angle4 - arrowAngle;
  const arrow1 = [
    to[0] - size3 * Math.sin(arrowAngle1),
    to[1] - size3 * Math.cos(arrowAngle1)
  ];
  const arrowAngle2 = angle4 - arrowAngle;
  const arrow2 = [
    to[0] - size3 * Math.cos(arrowAngle2),
    to[1] - size3 * Math.sin(arrowAngle2)
  ];
  return [arrow1, arrow2];
}
function appendArc(path2, from, to, center2, radius) {
  const startAngle = angle3(sub6(center2, from)) + Math.PI;
  const endAngle = angle3(sub6(center2, to)) + Math.PI;
  path2.arc(center2[0], center2[1], radius, startAngle, endAngle, endAngle - startAngle < 0);
  return path2;
}
function computeGradient(C4, X, Y, from = "y", mode2 = "between", tpShape = false) {
  const getTheta = (from2, tpShape2) => {
    if (from2 === "y" || from2 === true) {
      if (tpShape2) {
        return 180;
      } else {
        return 90;
      }
    } else {
      if (tpShape2) {
        return 90;
      } else {
        return 0;
      }
    }
  };
  const P = from === "y" || from === true ? Y : X;
  const theta = getTheta(from, tpShape);
  const I = indexOf3(P);
  const [min10, max11] = extent(I, (i) => P[i]);
  const p2 = new Linear({
    domain: [min10, max11],
    range: [0, 100]
  });
  const percentage = (i) => isNumber(P[i]) && !Number.isNaN(P[i]) ? p2.map(P[i]) : 0;
  const gradientMode = {
    // Interpolate the colors for this segment.
    between: (i) => `${C4[i]} ${percentage(i)}%`,
    // Use the color of the start point as the color for this segment.
    start: (i) => i === 0 ? `${C4[i]} ${percentage(i)}%` : `${C4[i - 1]} ${percentage(i)}%, ${C4[i]} ${percentage(i)}%`,
    // Use the color of the end point as the color for this segment.
    end: (i) => i === C4.length - 1 ? `${C4[i]} ${percentage(i)}%` : `${C4[i]} ${percentage(i)}%, ${C4[i + 1]} ${percentage(i)}%`
  };
  const gradient2 = I.sort((a4, b) => percentage(a4) - percentage(b)).map(gradientMode[mode2] || gradientMode["between"]).join(",");
  return `linear-gradient(${theta}deg, ${gradient2})`;
}
function reorder(points) {
  const [p0, p1, p2, p3] = points;
  return [p3, p0, p1, p2];
}
function getArcObject(coordinate, points, Y) {
  const [p0, p1, , p3] = isTranspose(coordinate) ? reorder(points) : points;
  const [y3, y12] = Y;
  const center2 = coordinate.getCenter();
  const a1 = angleWithQuadrant(sub6(p0, center2));
  const a22 = angleWithQuadrant(sub6(p1, center2));
  const a32 = a22 === a1 && y3 !== y12 ? a22 + Math.PI * 2 : a22;
  return {
    startAngle: a1,
    endAngle: a32 - a1 >= 0 ? a32 : Math.PI * 2 + a32,
    innerRadius: dist4(p3, center2),
    outerRadius: dist4(p0, center2)
  };
}
function toOpacityKey(options) {
  const { colorAttribute, opacityAttribute = colorAttribute } = options;
  return `${opacityAttribute}Opacity`;
}
function getTransform(coordinate, value2) {
  if (!isPolar(coordinate))
    return "";
  const center2 = coordinate.getCenter();
  const { transform: suffix } = value2;
  return `translate(${center2[0]}, ${center2[1]}) ${suffix || ""}`;
}
function getOrigin(points) {
  if (points.length === 1)
    return points[0];
  const [[x05, y05, z0 = 0], [x22, y22, z2 = 0]] = points;
  return [(x05 + x22) / 2, (y05 + y22) / 2, (z0 + z2) / 2];
}

// node_modules/@antv/g2/esm/shape/interval/color.js
var __rest13 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function rect(document2, points, value2, coordinate, style = {}) {
  const { inset = 0, radius = 0, insetLeft = inset, insetTop = inset, insetRight = inset, insetBottom = inset, radiusBottomLeft = radius, radiusBottomRight = radius, radiusTopLeft = radius, radiusTopRight = radius, minWidth = -Infinity, maxWidth = Infinity, minHeight = -Infinity } = style, rest = __rest13(style, ["inset", "radius", "insetLeft", "insetTop", "insetRight", "insetBottom", "radiusBottomLeft", "radiusBottomRight", "radiusTopLeft", "radiusTopRight", "minWidth", "maxWidth", "minHeight"]);
  if (!isPolar(coordinate) && !isHelix(coordinate)) {
    const tpShape = !!isTranspose(coordinate);
    const [p0, , p2] = tpShape ? reorder(points) : points;
    const [x3, y4] = p0;
    const [width, height] = sub6(p2, p0);
    const absX = width > 0 ? x3 : x3 + width;
    const absY = height > 0 ? y4 : y4 + height;
    const absWidth = Math.abs(width);
    const absHeight = Math.abs(height);
    const finalX = absX + insetLeft;
    const finalY = absY + insetTop;
    const finalWidth = absWidth - (insetLeft + insetRight);
    const finalHeight = absHeight - (insetTop + insetBottom);
    const clampWidth = tpShape ? clamp2(finalWidth, minHeight, Infinity) : clamp2(finalWidth, minWidth, maxWidth);
    const clampHeight = tpShape ? clamp2(finalHeight, minWidth, maxWidth) : clamp2(finalHeight, minHeight, Infinity);
    const clampX = tpShape ? finalX : finalX - (clampWidth - finalWidth) / 2;
    const clampY = tpShape ? finalY - (clampHeight - finalHeight) / 2 : finalY - (clampHeight - finalHeight);
    return select(document2.createElement("rect", {})).style("x", clampX).style("y", clampY).style("width", clampWidth).style("height", clampHeight).style("radius", [
      radiusTopLeft,
      radiusTopRight,
      radiusBottomRight,
      radiusBottomLeft
    ]).call(applyStyle, rest).node();
  }
  const { y: y3, y1: y12 } = value2;
  const center2 = coordinate.getCenter();
  const arcObject = getArcObject(coordinate, points, [y3, y12]);
  const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
  return select(document2.createElement("path", {})).style("d", path2(arcObject)).style("transform", `translate(${center2[0]}, ${center2[1]})`).style("radius", radius).style("inset", inset).call(applyStyle, rest).node();
}
var Color2 = (options, context) => {
  const { colorAttribute, opacityAttribute = "fill", first: first3 = true, last: last5 = true } = options, style = __rest13(options, ["colorAttribute", "opacityAttribute", "first", "last"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor, radius: defaultRadius2 = 0 } = defaults4, restDefaults = __rest13(defaults4, ["color", "radius"]);
    const defaultLineWidth = restDefaults.lineWidth || 1;
    const { stroke: stroke2, radius = defaultRadius2, radiusTopLeft = radius, radiusTopRight = radius, radiusBottomRight = radius, radiusBottomLeft = radius, innerRadius = 0, innerRadiusTopLeft = innerRadius, innerRadiusTopRight = innerRadius, innerRadiusBottomRight = innerRadius, innerRadiusBottomLeft = innerRadius, lineWidth = colorAttribute === "stroke" || stroke2 ? defaultLineWidth : 0, inset = 0, insetLeft = inset, insetRight = inset, insetBottom = inset, insetTop = inset, minWidth, maxWidth, minHeight } = style, rest = __rest13(style, ["stroke", "radius", "radiusTopLeft", "radiusTopRight", "radiusBottomRight", "radiusBottomLeft", "innerRadius", "innerRadiusTopLeft", "innerRadiusTopRight", "innerRadiusBottomRight", "innerRadiusBottomLeft", "lineWidth", "inset", "insetLeft", "insetRight", "insetBottom", "insetTop", "minWidth", "maxWidth", "minHeight"]);
    const { color: color3 = defaultColor, opacity } = value2;
    const standardDirRadius = [
      first3 ? radiusTopLeft : innerRadiusTopLeft,
      first3 ? radiusTopRight : innerRadiusTopRight,
      last5 ? radiusBottomRight : innerRadiusBottomRight,
      last5 ? radiusBottomLeft : innerRadiusBottomLeft
    ];
    const standardDir = [
      "radiusTopLeft",
      "radiusTopRight",
      "radiusBottomRight",
      "radiusBottomLeft"
    ];
    if (isTranspose(coordinate)) {
      standardDir.push(standardDir.shift());
    }
    const extendedStyle = Object.assign(Object.assign({ radius }, Object.fromEntries(standardDir.map((d3, i) => [d3, standardDirRadius[i]]))), {
      inset,
      insetLeft,
      insetRight,
      insetBottom,
      insetTop,
      minWidth,
      maxWidth,
      minHeight
    });
    return select(rect(document2, points, value2, coordinate, extendedStyle)).call(applyStyle, restDefaults).style("fill", "transparent").style(colorAttribute, color3).style(toOpacityKey(options), opacity).style("lineWidth", lineWidth).style("stroke", stroke2 === void 0 ? color3 : stroke2).call(applyStyle, rest).node();
  };
};
Color2.props = {
  defaultEnterAnimation: "scaleInY",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/interval/rect.js
var Rect2 = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "fill" }, options), context);
};
Rect2.props = Object.assign(Object.assign({}, Color2.props), { defaultMarker: "square" });

// node_modules/@antv/g2/esm/shape/interval/hollow.js
var Hollow = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke" }, options), context);
};
Hollow.props = Object.assign(Object.assign({}, Color2.props), { defaultMarker: "hollowSquare" });

// node_modules/@antv/g2/esm/shape/interval/funnel.js
var __rest14 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function getFunnelPoints(points, nextPoints, coordinate) {
  const [p0, p1, p2, p3] = points;
  if (isTranspose(coordinate)) {
    const newP12 = [nextPoints ? nextPoints[0][0] : p1[0], p1[1]];
    const newP22 = [nextPoints ? nextPoints[3][0] : p2[0], p2[1]];
    return [p0, newP12, newP22, p3];
  }
  const newP1 = [p1[0], nextPoints ? nextPoints[0][1] : p1[1]];
  const newP2 = [p2[0], nextPoints ? nextPoints[3][1] : p2[1]];
  return [p0, newP1, newP2, p3];
}
var Funnel = (options, context) => {
  const { adjustPoints = getFunnelPoints } = options, style = __rest14(options, ["adjustPoints"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4, point2d) => {
    const { index: index3 } = value2;
    const { color: defaultColor } = defaults4, rest = __rest14(defaults4, ["color"]);
    const nextPoints = point2d[index3 + 1];
    const funnelPoints = adjustPoints(points, nextPoints, coordinate);
    const tpShape = !!isTranspose(coordinate);
    const [p0, p1, p2, p3] = tpShape ? reorder(funnelPoints) : funnelPoints;
    const { color: color3 = defaultColor, opacity } = value2;
    const b = line_default().curve(linearClosed_default)([p0, p1, p2, p3]);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", b).style("fill", color3).style("fillOpacity", opacity).call(applyStyle, style).node();
  };
};
Funnel.props = {
  defaultMarker: "square"
};

// node_modules/@antv/g2/esm/shape/interval/pyramid.js
function getPyramidPoints(points, nextPoints, coordinate) {
  const [p0, p1, p2, p3] = points;
  if (isTranspose(coordinate)) {
    const newP12 = [
      nextPoints ? nextPoints[0][0] : (p1[0] + p2[0]) / 2,
      p1[1]
    ];
    const newP22 = [
      nextPoints ? nextPoints[3][0] : (p1[0] + p2[0]) / 2,
      p2[1]
    ];
    return [p0, newP12, newP22, p3];
  }
  const newP1 = [
    p1[0],
    nextPoints ? nextPoints[0][1] : (p1[1] + p2[1]) / 2
  ];
  const newP2 = [
    p2[0],
    nextPoints ? nextPoints[3][1] : (p1[1] + p2[1]) / 2
  ];
  return [p0, newP1, newP2, p3];
}
var Pyramid = (options, context) => {
  return Funnel(Object.assign({ adjustPoints: getPyramidPoints }, options), context);
};
Pyramid.props = {
  defaultMarker: "square"
};

// node_modules/@antv/g2/esm/utils/createElement.js
function createElement(descriptor) {
  const render3 = typeof descriptor === "function" ? descriptor : descriptor.render;
  return class extends CustomElement {
    connectedCallback() {
      this.draw();
    }
    attributeChangedCallback() {
      this.draw();
    }
    draw() {
      render3(this);
    }
  };
}

// node_modules/@antv/g2/esm/shape/line/curve.js
var __rest15 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var DoublePath = createElement((g) => {
  const { d1, d2: d22, style1, style2 } = g.attributes;
  const document2 = g.ownerDocument;
  select(g).maybeAppend("line", () => document2.createElement("path", {})).style("d", d1).call(applyStyle, style1);
  select(g).maybeAppend("line1", () => document2.createElement("path", {})).style("d", d22).call(applyStyle, style2);
});
function segmentation(points, defined4) {
  const definedPoints = [];
  const segments = [];
  let m3 = false;
  let dp = null;
  for (const p2 of points) {
    if (!defined4(p2[0]) || !defined4(p2[1]))
      m3 = true;
    else {
      definedPoints.push(p2);
      if (m3) {
        m3 = false;
        segments.push([dp, p2]);
      }
      dp = p2;
    }
  }
  return [definedPoints, segments];
}
var Curve = (options, context) => {
  const {
    curve,
    gradient: gradient2 = false,
    // The color for each segment.
    gradientColor = "between",
    defined: defined4 = (d3) => !Number.isNaN(d3) && d3 !== void 0 && d3 !== null,
    connect: connectNulls = false
  } = options, style = __rest15(options, ["curve", "gradient", "gradientColor", "defined", "connect"]);
  const { coordinate, document: document2 } = context;
  return (P, value2, defaults4) => {
    const { color: defaultColor, lineWidth: defaultSize } = defaults4, rest = __rest15(defaults4, ["color", "lineWidth"]);
    const { color: color3 = defaultColor, size: size3 = defaultSize, seriesColor: sc, seriesX: sx, seriesY: sy } = value2;
    const transform2 = getTransform(coordinate, value2);
    const tpShape = isTranspose(coordinate);
    const stroke2 = gradient2 && sc ? computeGradient(sc, sx, sy, gradient2, gradientColor, tpShape) : color3;
    const finalStyle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, rest), stroke2 && { stroke: stroke2 }), size3 && { lineWidth: size3 }), transform2 && { transform: transform2 }), style);
    let linePath;
    if (isPolar(coordinate)) {
      const center2 = coordinate.getCenter();
      linePath = (points) => lineRadial_default().angle((_2, idx) => angleWithQuadrant(sub6(points[idx], center2))).radius((_2, idx) => dist4(points[idx], center2)).defined(([x3, y3]) => defined4(x3) && defined4(y3)).curve(curve)(points);
    } else {
      linePath = line_default().x((d3) => d3[0]).y((d3) => d3[1]).defined(([x3, y3]) => defined4(x3) && defined4(y3)).curve(curve);
    }
    const [DP, MS] = segmentation(P, defined4);
    const connectStyle = subObject(finalStyle, "connect");
    const missing = !!MS.length;
    if (!missing || connectNulls && !Object.keys(connectStyle).length) {
      return select(document2.createElement("path", {})).style("d", linePath(DP) || []).call(applyStyle, finalStyle).node();
    }
    if (missing && !connectNulls) {
      return select(document2.createElement("path", {})).style("d", linePath(P)).call(applyStyle, finalStyle).node();
    }
    const connectPath = (segments) => segments.map(linePath).join(",");
    return select(new DoublePath()).style("style1", Object.assign(Object.assign({}, finalStyle), connectStyle)).style("style2", finalStyle).style("d1", connectPath(MS)).style("d2", linePath(P)).node();
  };
};
Curve.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/line/line.js
var Line2 = (options, context) => {
  const { coordinate } = context;
  return (...params) => {
    const curve = isPolar(coordinate) ? linearClosed_default : linear_default;
    return Curve(Object.assign({ curve }, options), context)(...params);
  };
};
Line2.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "line" });

// node_modules/@antv/g2/esm/shape/line/smooth.js
var __rest16 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var Smooth = (options, context) => {
  const rest = __rest16(options, []);
  const { coordinate } = context;
  return (...params) => {
    const curve = isPolar(coordinate) ? catmullRomClosed_default : isTranspose(coordinate) ? monotoneY : monotoneX;
    return Curve(Object.assign({ curve }, rest), context)(...params);
  };
};
Smooth.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "smooth" });

// node_modules/@antv/g2/esm/shape/line/hv.js
var HV = (options, context) => {
  return Curve(Object.assign({ curve: stepAfter }, options), context);
};
HV.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "hv" });

// node_modules/@antv/g2/esm/shape/line/vh.js
var VH = (options, context) => {
  return Curve(Object.assign({ curve: stepBefore }, options), context);
};
VH.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "vh" });

// node_modules/@antv/g2/esm/shape/line/hvh.js
var HVH = (options, context) => {
  return Curve(Object.assign({ curve: step_default }, options), context);
};
HVH.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "hvh" });

// node_modules/@antv/g2/esm/shape/line/trail.js
var __rest17 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function stroke(path2, p0, p1, s0, s1) {
  const v = sub6(p1, p0);
  const a4 = angle3(v);
  const a1 = a4 + Math.PI / 2;
  const r1 = [s0 / 2 * Math.cos(a1), s0 / 2 * Math.sin(a1)];
  const r2 = [s1 / 2 * Math.cos(a1), s1 / 2 * Math.sin(a1)];
  const r3 = [s1 / 2 * Math.cos(a4), s1 / 2 * Math.sin(a4)];
  const r4 = [s0 / 2 * Math.cos(a4), s0 / 2 * Math.sin(a4)];
  const x05 = add7(p0, r1);
  const x12 = add7(p1, r2);
  const x22 = add7(x12, r3);
  const x3 = add7(p1, r3);
  const x4 = sub6(x3, r2);
  const x5 = sub6(p1, r2);
  const x6 = sub6(p0, r1);
  const x7 = sub6(x6, r4);
  const x8 = sub6(p0, r4);
  const x9 = sub6(x05, r4);
  path2.moveTo(...x05);
  path2.lineTo(...x12);
  path2.arcTo(...x22, ...x3, s1 / 2);
  path2.arcTo(...x4, ...x5, s1 / 2);
  path2.lineTo(...x6);
  path2.arcTo(...x7, ...x8, s0 / 2);
  path2.arcTo(...x9, ...x05, s0 / 2);
  path2.closePath();
}
var Trail = (options, context) => {
  const { document: document2 } = context;
  return (P, value2, defaults4) => {
    const { seriesSize, color: color3 } = value2;
    const { color: defaultColor } = defaults4, rest = __rest17(defaults4, ["color"]);
    const path2 = path();
    for (let i = 0; i < P.length - 1; i++) {
      const p0 = P[i];
      const p1 = P[i + 1];
      const s0 = seriesSize[i];
      const s1 = seriesSize[i + 1];
      if ([...p0, ...p1].every(defined))
        stroke(path2, p0, p1, s0, s1);
    }
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("fill", color3 || defaultColor).style("d", path2.toString()).call(applyStyle, options).node();
  };
};
Trail.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "line" });

// node_modules/@antv/g2/esm/utils/marker.js
var __rest18 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var point5 = (x3, y3, r) => {
  return [
    ["M", x3 - r, y3],
    ["A", r, r, 0, 1, 0, x3 + r, y3],
    ["A", r, r, 0, 1, 0, x3 - r, y3],
    ["Z"]
  ];
};
point5.style = ["fill"];
var hollowPoint = point5.bind(void 0);
hollowPoint.style = ["stroke", "lineWidth"];
var square = (x3, y3, r) => {
  return [
    ["M", x3 - r, y3 - r],
    ["L", x3 + r, y3 - r],
    ["L", x3 + r, y3 + r],
    ["L", x3 - r, y3 + r],
    ["Z"]
  ];
};
square.style = ["fill"];
var rect2 = square.bind(void 0);
rect2.style = ["fill"];
var hollowSquare = square.bind(void 0);
hollowSquare.style = ["stroke", "lineWidth"];
var diamond = (x3, y3, r) => {
  const hr = r * 0.618;
  return [
    ["M", x3 - hr, y3],
    ["L", x3, y3 - r],
    ["L", x3 + hr, y3],
    ["L", x3, y3 + r],
    ["Z"]
  ];
};
diamond.style = ["fill"];
var hollowDiamond = diamond.bind(void 0);
hollowDiamond.style = ["stroke", "lineWidth"];
var triangle = (x3, y3, r) => {
  const diffY = r * Math.sin(1 / 3 * Math.PI);
  return [
    ["M", x3 - r, y3 + diffY],
    ["L", x3, y3 - diffY],
    ["L", x3 + r, y3 + diffY],
    ["Z"]
  ];
};
triangle.style = ["fill"];
var hollowTriangle = triangle.bind(void 0);
hollowTriangle.style = ["stroke", "lineWidth"];
var triangleDown = (x3, y3, r) => {
  const diffY = r * Math.sin(1 / 3 * Math.PI);
  return [
    ["M", x3 - r, y3 - diffY],
    ["L", x3 + r, y3 - diffY],
    ["L", x3, y3 + diffY],
    ["Z"]
  ];
};
triangleDown.style = ["fill"];
var hollowTriangleDown = triangleDown.bind(void 0);
hollowTriangleDown.style = ["stroke", "lineWidth"];
var hexagon = (x3, y3, r) => {
  const diffX = r / 2 * Math.sqrt(3);
  return [
    ["M", x3, y3 - r],
    ["L", x3 + diffX, y3 - r / 2],
    ["L", x3 + diffX, y3 + r / 2],
    ["L", x3, y3 + r],
    ["L", x3 - diffX, y3 + r / 2],
    ["L", x3 - diffX, y3 - r / 2],
    ["Z"]
  ];
};
hexagon.style = ["fill"];
var hollowHexagon = hexagon.bind(void 0);
hollowHexagon.style = ["stroke", "lineWidth"];
var bowtie = (x3, y3, r) => {
  const diffY = r - 1.5;
  return [
    ["M", x3 - r, y3 - diffY],
    ["L", x3 + r, y3 + diffY],
    ["L", x3 + r, y3 - diffY],
    ["L", x3 - r, y3 + diffY],
    ["Z"]
  ];
};
bowtie.style = ["fill"];
var hollowBowtie = bowtie.bind(void 0);
hollowBowtie.style = ["stroke", "lineWidth"];
var line = (x3, y3, r) => {
  return [
    ["M", x3, y3 + r],
    ["L", x3, y3 - r]
  ];
};
line.style = ["stroke", "lineWidth"];
var cross5 = (x3, y3, r) => {
  return [
    ["M", x3 - r, y3 - r],
    ["L", x3 + r, y3 + r],
    ["M", x3 + r, y3 - r],
    ["L", x3 - r, y3 + r]
  ];
};
cross5.style = ["stroke", "lineWidth"];
var tick = (x3, y3, r) => {
  return [
    ["M", x3 - r / 2, y3 - r],
    ["L", x3 + r / 2, y3 - r],
    ["M", x3, y3 - r],
    ["L", x3, y3 + r],
    ["M", x3 - r / 2, y3 + r],
    ["L", x3 + r / 2, y3 + r]
  ];
};
tick.style = ["stroke", "lineWidth"];
var plus = (x3, y3, r) => {
  return [
    ["M", x3 - r, y3],
    ["L", x3 + r, y3],
    ["M", x3, y3 - r],
    ["L", x3, y3 + r]
  ];
};
plus.style = ["stroke", "lineWidth"];
var hyphen = (x3, y3, r) => {
  return [
    ["M", x3 - r, y3],
    ["L", x3 + r, y3]
  ];
};
hyphen.style = ["stroke", "lineWidth"];
var dot6 = (x3, y3, r) => {
  return [
    ["M", x3 - r, y3],
    ["L", x3 + r, y3]
  ];
};
dot6.style = ["stroke", "lineWidth"];
var dash = dot6.bind(void 0);
dash.style = ["stroke", "lineWidth"];
var smooth = (x3, y3, r) => {
  return [
    ["M", x3 - r, y3],
    ["A", r / 2, r / 2, 0, 1, 1, x3, y3],
    ["A", r / 2, r / 2, 0, 1, 0, x3 + r, y3]
  ];
};
smooth.style = ["stroke", "lineWidth"];
var hv = (x3, y3, r) => {
  return [
    ["M", x3 - r - 1, y3 - 2.5],
    ["L", x3, y3 - 2.5],
    ["L", x3, y3 + 2.5],
    ["L", x3 + r + 1, y3 + 2.5]
  ];
};
hv.style = ["stroke", "lineWidth"];
var vh = (x3, y3, r) => {
  return [
    ["M", x3 - r - 1, y3 + 2.5],
    ["L", x3, y3 + 2.5],
    ["L", x3, y3 - 2.5],
    ["L", x3 + r + 1, y3 - 2.5]
  ];
};
vh.style = ["stroke", "lineWidth"];
var hvh = (x3, y3, r) => {
  return [
    ["M", x3 - (r + 1), y3 + 2.5],
    ["L", x3 - r / 2, y3 + 2.5],
    ["L", x3 - r / 2, y3 - 2.5],
    ["L", x3 + r / 2, y3 - 2.5],
    ["L", x3 + r / 2, y3 + 2.5],
    ["L", x3 + r + 1, y3 + 2.5]
  ];
};
hvh.style = ["stroke", "lineWidth"];
var vhv = (x3, y3, r) => {
  return [
    ["M", x3 - 5, y3 + 2.5],
    ["L", x3 - 5, y3],
    ["L", x3, y3],
    ["L", x3, y3 - 3],
    ["L", x3, y3 + 3],
    ["L", x3 + 6.5, y3 + 3]
  ];
};
vhv.style = ["stroke", "lineWidth"];
var Symbols = /* @__PURE__ */ new Map([
  ["bowtie", bowtie],
  ["cross", cross5],
  ["dash", dash],
  ["diamond", diamond],
  ["dot", dot6],
  ["hexagon", hexagon],
  ["hollowBowtie", hollowBowtie],
  ["hollowDiamond", hollowDiamond],
  ["hollowHexagon", hollowHexagon],
  ["hollowPoint", hollowPoint],
  ["hollowSquare", hollowSquare],
  ["hollowTriangle", hollowTriangle],
  ["hollowTriangleDown", hollowTriangleDown],
  ["hv", hv],
  ["hvh", hvh],
  ["hyphen", hyphen],
  ["line", line],
  ["plus", plus],
  ["point", point5],
  ["rect", rect2],
  ["smooth", smooth],
  ["square", square],
  ["tick", tick],
  ["triangleDown", triangleDown],
  ["triangle", triangle],
  ["vh", vh],
  ["vhv", vhv]
]);
function useMarker(type, _a2) {
  var { d: d3, fill, lineWidth, path: path2, stroke: stroke2, color: color3 } = _a2, style = __rest18(_a2, ["d", "fill", "lineWidth", "path", "stroke", "color"]);
  const symbol = Symbols.get(type) || Symbols.get("point");
  return (...args) => {
    const path3 = new Path2({
      style: Object.assign(Object.assign({}, style), { d: symbol(...args), stroke: symbol.style.includes("stroke") ? color3 || stroke2 : "", fill: symbol.style.includes("fill") ? color3 || fill : "", lineWidth: symbol.style.includes("lineWidth") ? lineWidth || lineWidth || 2 : 0 })
    });
    return path3;
  };
}
function registerSymbol(type, marker) {
  Symbols.set(type, marker);
}

// node_modules/@antv/g2/esm/shape/point/color.js
var __rest19 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function getRadius2(mode2, points, value2, coordinate) {
  if (points.length === 1)
    return void 0;
  const { size: size3 } = value2;
  if (mode2 === "fixed")
    return size3;
  if (mode2 === "normal" || isFisheye(coordinate)) {
    const [[x05, y05], [x22, y22]] = points;
    const a4 = Math.abs((x22 - x05) / 2);
    const b = Math.abs((y22 - y05) / 2);
    return Math.max(0, (a4 + b) / 2);
  }
  return size3;
}
var Color3 = (options, context) => {
  const { colorAttribute, symbol, mode: mode2 = "auto" } = options, style = __rest19(options, ["colorAttribute", "symbol", "mode"]);
  const path2 = Symbols.get(symbol) || Symbols.get("point");
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { lineWidth, color: defaultColor } = defaults4;
    const finalLineWidth = style.stroke ? lineWidth || 1 : lineWidth;
    const { color: color3 = defaultColor, transform: transform2, opacity } = value2;
    const [cx, cy] = getOrigin(points);
    const r = getRadius2(mode2, points, value2, coordinate);
    const finalRadius = r || style.r || defaults4.r;
    return select(document2.createElement("path", {})).call(applyStyle, defaults4).style("fill", "transparent").style("d", path2(cx, cy, finalRadius)).style("lineWidth", finalLineWidth).style("transform", transform2).style("transformOrigin", `${cx - finalRadius} ${cy - finalRadius}`).style("stroke", color3).style(toOpacityKey(options), opacity).style(colorAttribute, color3).call(applyStyle, style).node();
  };
};
Color3.props = {
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/point/hollowBowtie.js
var HollowBowtie = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "bowtie" }, options), context);
};
HollowBowtie.props = Object.assign({ defaultMarker: "hollowBowtie" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollowDiamond.js
var HollowDiamond = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "diamond" }, options), context);
};
HollowDiamond.props = Object.assign({ defaultMarker: "hollowDiamond" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollowHexagon.js
var HollowHexagon = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "hexagon" }, options), context);
};
HollowHexagon.props = Object.assign({ defaultMarker: "hollowHexagon" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollow.js
var HollowPoint = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "point" }, options), context);
};
HollowPoint.props = Object.assign({ defaultMarker: "hollowPoint" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollowSquare.js
var HollowSquare = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "square" }, options), context);
};
HollowSquare.props = Object.assign({ defaultMarker: "hollowSquare" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollowTriangle.js
var HollowTriangle = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "triangle" }, options), context);
};
HollowTriangle.props = Object.assign({ defaultMarker: "hollowTriangle" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollowTriangleDown.js
var HollowTriangleDown = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "triangle-down" }, options), context);
};
HollowTriangleDown.props = Object.assign({ defaultMarker: "hollowTriangleDown" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/circle.js
var __rest20 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var BaseCircle = (options, context) => {
  const { colorAttribute, mode: mode2 = "auto" } = options, style = __rest20(options, ["colorAttribute", "mode"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { lineWidth, color: defaultColor } = defaults4;
    const finalLineWidth = style.stroke ? lineWidth || 1 : lineWidth;
    const { color: color3 = defaultColor, transform: transform2, opacity } = value2;
    const [cx, cy] = getOrigin(points);
    const r = getRadius2(mode2, points, value2, coordinate);
    const finalRadius = r || style.r || defaults4.r;
    return select(document2.createElement("circle", {})).call(applyStyle, defaults4).style("fill", "transparent").style("cx", cx).style("cy", cy).style("r", finalRadius).style("lineWidth", finalLineWidth).style("transform", transform2).style("transformOrigin", `${cx} ${cy}`).style("stroke", color3).style(toOpacityKey(options), opacity).style(colorAttribute, color3).call(applyStyle, style).node();
  };
};
var Circle2 = (options, context) => {
  return BaseCircle(Object.assign({ colorAttribute: "fill" }, options), context);
};
Circle2.props = {
  defaultMarker: "circle",
  defaultEnterAnimation: "fadeIn",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/point/hollowCircle.js
var HollowCircle = (options, context) => {
  return BaseCircle(Object.assign({ colorAttribute: "stroke" }, options), context);
};
HollowCircle.props = Object.assign({ defaultMarker: "hollowPoint" }, Circle2.props);

// node_modules/@antv/g2/esm/shape/point/bowtie.js
var Bowtie = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "bowtie" }, options), context);
};
Bowtie.props = Object.assign({ defaultMarker: "bowtie" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/cross.js
var Cross = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "cross" }, options), context);
};
Cross.props = Object.assign({ defaultMarker: "cross" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/diamond.js
var Diamond = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "diamond" }, options), context);
};
Diamond.props = Object.assign({ defaultMarker: "diamond" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hexagon.js
var Hexagon = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "hexagon" }, options), context);
};
Hexagon.props = Object.assign({ defaultMarker: "hexagon" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hyphen.js
var Hyphen = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "hyphen" }, options), context);
};
Hyphen.props = Object.assign({ defaultMarker: "hyphen" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/line.js
var Line3 = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "line" }, options), context);
};
Line3.props = Object.assign({ defaultMarker: "line" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/plus.js
var Plus = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "plus" }, options), context);
};
Plus.props = Object.assign({ defaultMarker: "plus" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/point.js
var Point3 = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "point" }, options), context);
};
Point3.props = Object.assign({ defaultMarker: "point" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/square.js
var Square = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "square" }, options), context);
};
Square.props = Object.assign({ defaultMarker: "square" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/tick.js
var Tick = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "tick" }, options), context);
};
Tick.props = Object.assign({ defaultMarker: "tick" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/triangle.js
var Triangle = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "triangle" }, options), context);
};
Triangle.props = Object.assign({ defaultMarker: "triangle" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/triangleDown.js
var TriangleDown = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "triangle-down" }, options), context);
};
TriangleDown.props = Object.assign({ defaultMarker: "triangleDown" }, Color3.props);

// node_modules/@antv/g2/esm/shape/vector/vector.js
var __rest21 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var Vector = (options, context) => {
  const { arrow: arrow2 = true, arrowSize = "40%" } = options, style = __rest21(options, ["arrow", "arrowSize"]);
  const { document: document2 } = context;
  return (points, value2, defaults4) => {
    const { defaultColor } = defaults4, rest = __rest21(defaults4, ["defaultColor"]);
    const { color: color3 = defaultColor, transform: transform2 } = value2;
    const [from, to] = points;
    const path2 = path();
    path2.moveTo(...from);
    path2.lineTo(...to);
    if (arrow2) {
      const [arrow1, arrow22] = arrowPoints(from, to, { arrowSize });
      path2.moveTo(...arrow1);
      path2.lineTo(...to);
      path2.lineTo(...arrow22);
    }
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color3).style("transform", transform2).call(applyStyle, style).node();
  };
};
Vector.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/component/esm/util/traverse.js
function traverse(element, callback) {
  callback(element);
  if (element.children) {
    element.children.forEach(function(child) {
      if (child)
        traverse(child, callback);
    });
  }
}

// node_modules/@antv/component/esm/util/visibility.js
function show(element) {
  visibility(element, true);
}
function hide(element) {
  visibility(element, false);
}
function visibility(element, visible) {
  var value2 = visible ? "visible" : "hidden";
  traverse(element, function(node) {
    node.attr("visibility", value2);
  });
}

// node_modules/@antv/component/esm/util/offscreen.js
var OffscreenGroup = (
  /** @class */
  function(_super) {
    __extends(OffscreenGroup2, _super);
    function OffscreenGroup2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _this2 = _super.apply(this, __spreadArray([], __read(args), false)) || this;
      _this2.isMutationObserved = true;
      _this2.addEventListener(ElementEvent.INSERTED, function() {
        hide(_this2);
      });
      return _this2;
    }
    return OffscreenGroup2;
  }(Group2)
);
function createOffscreenGroup(container) {
  var group3 = container.appendChild(new OffscreenGroup({
    class: "offscreen"
  }));
  hide(group3);
  return group3;
}
function isInOffscreenGroup(group3) {
  var ancestor = group3;
  while (ancestor) {
    if (ancestor.className === "offscreen") {
      return true;
    }
    ancestor = ancestor.parent;
  }
  return false;
}

// node_modules/@antv/component/esm/shapes/Text.js
var Text2 = (
  /** @class */
  function(_super) {
    __extends(Text6, _super);
    function Text6(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var style = _a2.style, restOptions = __rest(_a2, ["style"]);
      return _super.call(this, __assign({ style: __assign({ text: "", fill: "black", fontFamily: "sans-serif", fontSize: 16, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", lineWidth: 1, textAlign: "start", textBaseline: "middle" }, style) }, restOptions)) || this;
    }
    Object.defineProperty(Text6.prototype, "offscreenGroup", {
      get: function() {
        if (!this._offscreen)
          this._offscreen = createOffscreenGroup(this);
        return this._offscreen;
      },
      enumerable: false,
      configurable: true
    });
    Text6.prototype.disconnectedCallback = function() {
      var _a2;
      (_a2 = this._offscreen) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    };
    return Text6;
  }(Text)
);

// node_modules/@antv/component/esm/util/angle-converter.js
function degToRad(deg2) {
  return deg2 * Math.PI / 180;
}
function radToDeg(rad2) {
  return Number((rad2 * 180 / Math.PI).toPrecision(5));
}

// node_modules/@antv/component/esm/util/bbox.js
var BBox = (
  /** @class */
  function() {
    function BBox2(x3, y3, width, height) {
      if (x3 === void 0) {
        x3 = 0;
      }
      if (y3 === void 0) {
        y3 = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
      this.x = x3;
      this.y = y3;
      this.width = width;
      this.height = height;
    }
    Object.defineProperty(BBox2.prototype, "bottom", {
      get: function() {
        return this.y + this.height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "left", {
      get: function() {
        return this.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "right", {
      get: function() {
        return this.x + this.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "top", {
      get: function() {
        return this.y;
      },
      enumerable: false,
      configurable: true
    });
    BBox2.fromRect = function(other) {
      return new BBox2(other.x, other.y, other.width, other.height);
    };
    BBox2.prototype.toJSON = function() {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height,
        top: this.top,
        right: this.right,
        bottom: this.bottom,
        left: this.left
      };
    };
    BBox2.prototype.isPointIn = function(x3, y3) {
      return x3 >= this.left && x3 <= this.right && y3 >= this.top && y3 <= this.bottom;
    };
    return BBox2;
  }()
);

// node_modules/@antv/component/esm/util/callback.js
function getCallbackValue(value2, params) {
  return isFunction(value2) ? value2.apply(void 0, __spreadArray([], __read(params), false)) : value2;
}

// node_modules/@antv/component/esm/util/classnames.js
var classNames = function(cls, prefix) {
  var PREFIX = function(str7) {
    return "".concat(prefix, "-").concat(str7);
  };
  var obj = Object.fromEntries(Object.entries(cls).map(function(_a2) {
    var _b = __read(_a2, 2), k2 = _b[0], v = _b[1];
    var name2 = PREFIX(v);
    return [
      k2,
      {
        name: name2,
        class: ".".concat(name2),
        id: "#".concat(name2),
        toString: function() {
          return name2;
        }
      }
    ];
  }));
  Object.assign(obj, { prefix: PREFIX });
  return obj;
};

// node_modules/@antv/component/esm/util/deep-assign.js
var MAX_MIX_LEVEL2 = 5;
var deep = function(dist5, src, level, maxLevel) {
  if (level === void 0) {
    level = 0;
  }
  if (maxLevel === void 0) {
    maxLevel = MAX_MIX_LEVEL2;
  }
  Object.entries(src).forEach(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], value2 = _b[1];
    var res = dist5;
    if (Object.prototype.hasOwnProperty.call(src, key)) {
      if (!value2) {
        res[key] = value2;
      } else if (is_plain_object_default(value2)) {
        if (!is_plain_object_default(dist5[key])) {
          res[key] = {};
        }
        if (level < maxLevel) {
          deep(dist5[key], value2, level + 1, maxLevel);
        } else {
          res[key] = src[key];
        }
      } else if (isArray(value2)) {
        res[key] = [];
        res[key] = res[key].concat(value2);
      } else {
        res[key] = value2;
      }
    }
  });
};
var deepAssign2 = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    deep(rst, args[i]);
  }
  return rst;
};

// node_modules/@antv/component/esm/util/defined.js
var defined2 = function(x3) {
  return x3 !== void 0 && x3 != null && !Number.isNaN(x3);
};

// node_modules/@antv/component/esm/util/text.js
var ctx;
var mockMeasureTextWidth;
var measureTextWidth = memoize(function(text, font) {
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  if (mockMeasureTextWidth) {
    return mockMeasureTextWidth(text, fontSize);
  }
  if (!ctx) {
    ctx = runtime.offscreenCanvasCreator.getOrCreateContext(void 0);
  }
  ctx.font = [fontStyle, fontVariant, fontWeight, "".concat(fontSize, "px"), fontFamily].join(" ");
  return ctx.measureText(text).width;
}, function(text, font) {
  return [text, Object.values(font || getFont(text)).join()].join("");
}, 4096);
var getFont = function(textShape) {
  var fontFamily = textShape.style.fontFamily || "sans-serif";
  var fontWeight = textShape.style.fontWeight || "normal";
  var fontStyle = textShape.style.fontStyle || "normal";
  var fontVariant = textShape.style.fontVariant;
  var fontSize = textShape.style.fontSize;
  fontSize = typeof fontSize === "object" ? fontSize.value : fontSize;
  return { fontSize, fontFamily, fontWeight, fontStyle, fontVariant };
};
function textOf(node) {
  if (node.nodeName === "text") {
    return node;
  }
  if (node.nodeName === "g" && node.children.length === 1 && node.children[0].nodeName === "text") {
    return node.children[0];
  }
  return null;
}
function applyToText(node, style) {
  var text = textOf(node);
  if (text)
    text.attr(style);
}

// node_modules/@antv/component/esm/util/ellipsis.js
function ellipsisIt(node, w, suffix) {
  if (suffix === void 0) {
    suffix = "...";
  }
  applyToText(node, { wordWrap: true, wordWrapWidth: w, maxLines: 1, textOverflow: suffix });
}

// node_modules/@antv/component/esm/util/wrap.js
function wrapIt(node, wordWrapWidth, maxLines, textBaseline) {
  if (maxLines === void 0) {
    maxLines = 2;
  }
  if (textBaseline === void 0) {
    textBaseline = "top";
  }
  applyToText(node, { wordWrap: true, wordWrapWidth, maxLines, textBaseline });
}

// node_modules/@antv/component/esm/util/event.js
function getEventPos(e) {
  var canvas = e.canvas, touches = e.touches, offsetX = e.offsetX, offsetY = e.offsetY;
  if (canvas) {
    var x3 = canvas.x, y3 = canvas.y;
    return [x3, y3];
  }
  if (touches) {
    var _a2 = touches[0], clientX = _a2.clientX, clientY = _a2.clientY;
    return [clientX, clientY];
  }
  if (offsetX && offsetY)
    return [offsetX, offsetY];
  return [0, 0];
}

// node_modules/@antv/component/esm/util/extend-display-object.js
function renderExtDo(el) {
  if (typeof el === "function")
    return el();
  return isString(el) || isNumber(el) ? new Text2({ style: { text: String(el) } }) : el;
}

// node_modules/@antv/component/esm/util/geometry/lines-intersection.js
function inside(x12, x22, y12, y22, xk, yk) {
  return (x12 === x22 || Math.min(x12, x22) <= xk && xk <= Math.max(x12, x22)) && (y12 === y22 || Math.min(y12, y22) <= yk && yk <= Math.max(y12, y22));
}
function update(ans, x3, y3) {
  var out = ans;
  if (!ans.length || x3 < ans[0] || x3 === ans[0] && y3 < ans[1]) {
    out[0] = x3;
    out[1] = y3;
  }
}
function intersection2(_a2, _b, _c, _d) {
  var _e = __read(_a2, 2), x12 = _e[0], y12 = _e[1];
  var _f = __read(_b, 2), x22 = _f[0], y22 = _f[1];
  var _g = __read(_c, 2), x3 = _g[0], y3 = _g[1];
  var _h = __read(_d, 2), x4 = _h[0], y4 = _h[1];
  var ans = [];
  if ((y4 - y3) * (x22 - x12) === (y22 - y12) * (x4 - x3)) {
    if ((y22 - y12) * (x3 - x12) === (y3 - y12) * (x22 - x12)) {
      if (inside(x12, x22, y12, y22, x3, y3)) {
        update(ans, x3, y3);
      }
      if (inside(x12, x22, y12, y22, x4, y4)) {
        update(ans, x4, y4);
      }
      if (inside(x3, x4, y3, y4, x12, y12)) {
        update(ans, x12, y12);
      }
      if (inside(x3, x4, y3, y4, x22, y22)) {
        update(ans, x22, y22);
      }
    }
  } else {
    var t12 = (x3 * (y4 - y3) + y12 * (x4 - x3) - y3 * (x4 - x3) - x12 * (y4 - y3)) / ((x22 - x12) * (y4 - y3) - (x4 - x3) * (y22 - y12));
    var t22 = (x12 * (y22 - y12) + y3 * (x22 - x12) - y12 * (x22 - x12) - x3 * (y22 - y12)) / ((x4 - x3) * (y22 - y12) - (x22 - x12) * (y4 - y3));
    if (t12 >= 0 && t12 <= 1 && t22 >= 0 && t22 <= 1) {
      ans[0] = x12 + t12 * (x22 - x12);
      ans[1] = y12 + t12 * (y22 - y12);
    }
  }
  return ans;
}

// node_modules/@antv/component/esm/util/geometry/line-length.js
function lineLen(_a2, _b) {
  var _c = __read(_a2, 2), x12 = _c[0], y12 = _c[1];
  var _d = __read(_b, 2), x22 = _d[0], y22 = _d[1];
  return Math.pow(Math.pow(x12 - x22, 2) + Math.pow(y12 - y22, 2), 0.5);
}

// node_modules/@antv/component/esm/util/group-by.js
function groupBy(source, by) {
  return source.reduce(function(acc, curr) {
    (acc[curr[by]] = acc[curr[by]] || []).push(curr);
    return acc;
  }, {});
}

// node_modules/@antv/component/esm/util/if-show.js
function ifShow(show3, container, creator, removeChildren, removeHandler) {
  if (removeChildren === void 0) {
    removeChildren = true;
  }
  if (removeHandler === void 0) {
    removeHandler = function(g) {
      g.node().removeChildren();
    };
  }
  if (show3) {
    return creator(container);
  }
  if (removeChildren)
    removeHandler(container);
  return null;
}

// node_modules/@antv/component/esm/util/in-range.js
function inRange(n, start, end, includeLeft, includeRight) {
  if (includeLeft === void 0) {
    includeLeft = true;
  }
  if (includeRight === void 0) {
    includeRight = false;
  }
  if (includeLeft && n === start || includeRight && n === end)
    return true;
  return n > start && n < end;
}

// node_modules/@antv/component/esm/util/interpolate.js
var numberInterpolate = function(from, to) {
  return function(t) {
    return from * (1 - t) + to * t;
  };
};
function arrayInterpolate(from, to) {
  var nb = to ? to.length : 0;
  var na = from ? Math.min(nb, from.length) : 0;
  return function(t) {
    var x3 = new Array(na);
    var c5 = new Array(nb);
    var i = 0;
    for (i = 0; i < na; ++i)
      x3[i] = interpolate3(from[i], to[i]);
    for (; i < nb; ++i)
      c5[i] = to[i];
    for (i = 0; i < na; ++i)
      c5[i] = x3[i](t);
    return c5;
  };
}
function objectInterpolate(from, to) {
  if (from === void 0) {
    from = {};
  }
  if (to === void 0) {
    to = {};
  }
  var i = {};
  var c5 = {};
  Object.entries(to).forEach(function(_a2) {
    var _b = __read(_a2, 2), k2 = _b[0], v = _b[1];
    if (k2 in from)
      i[k2] = interpolate3(from[k2], v);
    else
      c5[k2] = v;
  });
  return function(t) {
    Object.entries(i).forEach(function(_a2) {
      var _b = __read(_a2, 2), k2 = _b[0], v = _b[1];
      return c5[k2] = v(t);
    });
    return c5;
  };
}
function interpolate3(from, to) {
  if (typeof from === "number" && typeof to === "number") {
    return numberInterpolate(from, to);
  }
  if (Array.isArray(from) && Array.isArray(to)) {
    return arrayInterpolate(from, to);
  }
  if (typeof from === "object" && typeof to === "object") {
    return objectInterpolate(from, to);
  }
  return function(t) {
    return from;
  };
}

// node_modules/@antv/component/esm/util/keyframe-interpolate.js
function keyframeInterpolate(element, from, to, options) {
  if (!options) {
    element.attr("__keyframe_data__", to);
    return null;
  }
  var _a2 = options.duration, duration = _a2 === void 0 ? 0 : _a2;
  var int = interpolate3(from, to);
  var count4 = Math.ceil(+duration / 16);
  var keyframes = new Array(count4).fill(0).map(function(datum, index3, array2) {
    return { __keyframe_data__: int(index3 / (array2.length - 1)) };
  });
  return element.animate(keyframes, __assign({ fill: "both" }, options));
}

// node_modules/@antv/component/esm/util/layout/utils/helper.js
function getItemsBBox(items) {
  var minX = Infinity;
  var minY = Infinity;
  var maxX = -Infinity;
  var maxY2 = -Infinity;
  for (var i = 0; i < items.length; i++) {
    var _a2 = items[i], x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
    var _b = __read([x3 + width, y3 + height], 2), X = _b[0], Y = _b[1];
    if (x3 < minX)
      minX = x3;
    if (y3 < minY)
      minY = y3;
    if (X > maxX)
      maxX = X;
    if (Y > maxY2)
      maxY2 = Y;
  }
  return new BBox(minX, minY, maxX - minX, maxY2 - minY);
}

// node_modules/@antv/component/esm/util/layout/flex/index.js
var flex = function(container, children, config) {
  var width = container.width, height = container.height;
  var _a2 = config.flexDirection, flexDirection = _a2 === void 0 ? "row" : _a2, _b = config.flexWrap, flexWrap = _b === void 0 ? "nowrap" : _b, _c = config.justifyContent, justifyContent = _c === void 0 ? "flex-start" : _c, _d = config.alignContent, alignContent = _d === void 0 ? "flex-start" : _d, _e = config.alignItems, alignItems = _e === void 0 ? "flex-start" : _e;
  var isHorizontalFlow = flexDirection === "row";
  var isLeftToRightFlow = flexDirection === "row" || flexDirection === "column";
  var direction3 = isHorizontalFlow ? isLeftToRightFlow ? [1, 0] : [-1, 0] : isLeftToRightFlow ? [0, 1] : [0, -1];
  var _f = __read([0, 0], 2), offsetX = _f[0], offsetY = _f[1];
  var itemsFromDirection = children.map(function(child) {
    var _a3;
    var width2 = child.width, height2 = child.height;
    var _b2 = __read([offsetX, offsetY], 2), x3 = _b2[0], y3 = _b2[1];
    _a3 = __read([offsetX + width2 * direction3[0], offsetY + height2 * direction3[1]], 2), offsetX = _a3[0], offsetY = _a3[1];
    return new BBox(x3, y3, width2, height2);
  });
  var itemsForJustifyContentBBox = getItemsBBox(itemsFromDirection);
  var justifyContentOffset = {
    "flex-start": 0,
    "flex-end": isHorizontalFlow ? width - itemsForJustifyContentBBox.width : height - itemsForJustifyContentBBox.height,
    center: isHorizontalFlow ? (width - itemsForJustifyContentBBox.width) / 2 : (height - itemsForJustifyContentBBox.height) / 2
  };
  var itemsFromJustifyContent = itemsFromDirection.map(function(item) {
    var x3 = item.x, y3 = item.y;
    var itemBox = BBox.fromRect(item);
    itemBox.x = isHorizontalFlow ? x3 + justifyContentOffset[justifyContent] : x3;
    itemBox.y = isHorizontalFlow ? y3 : y3 + justifyContentOffset[justifyContent];
    return itemBox;
  });
  var itemsForAlignItemsBBox = getItemsBBox(itemsFromJustifyContent);
  var calcAlignItemsOffset = function(box2) {
    var _a3 = __read(isHorizontalFlow ? ["height", height] : ["width", width], 2), key = _a3[0], size3 = _a3[1];
    switch (alignItems) {
      case "flex-start":
        return 0;
      case "flex-end":
        return size3 - box2[key];
      case "center":
        return size3 / 2 - box2[key] / 2;
      default:
        return 0;
    }
  };
  var itemsFromAlignItems = itemsFromJustifyContent.map(function(item) {
    var x3 = item.x, y3 = item.y;
    var itemBox = BBox.fromRect(item);
    itemBox.x = isHorizontalFlow ? x3 : x3 + calcAlignItemsOffset(itemBox);
    itemBox.y = isHorizontalFlow ? y3 + calcAlignItemsOffset(itemBox) : y3;
    return itemBox;
  });
  var finalItems = itemsFromAlignItems.map(function(item) {
    var _a3, _b2;
    var itemBox = BBox.fromRect(item);
    itemBox.x += (_a3 = container.x) !== null && _a3 !== void 0 ? _a3 : 0;
    itemBox.y += (_b2 = container.y) !== null && _b2 !== void 0 ? _b2 : 0;
    return itemBox;
  });
  return finalItems;
};

// node_modules/@antv/component/esm/util/layout/grid/index.js
var grid = function(container, children, config) {
  return [];
};

// node_modules/@antv/component/esm/util/layout/executer.js
var executer_default = function(container, children, config) {
  if (children.length === 0)
    return [];
  var callers = { flex, grid };
  var caller = config.display in callers ? callers[config.display] : null;
  return (caller === null || caller === void 0 ? void 0 : caller.call(null, container, children, config)) || [];
};

// node_modules/@antv/component/esm/util/matrix.js
function scale8(vec, s3) {
  return [vec[0] * s3, vec[1] * s3];
}
function add8(vec1, vec2) {
  return [vec1[0] + vec2[0], vec1[1] + vec2[1]];
}
function sub7(vec1, vec2) {
  return [vec1[0] - vec2[0], vec1[1] - vec2[1]];
}
function min8(vec1, vec2) {
  return [Math.min(vec1[0], vec2[0]), Math.min(vec1[1], vec2[1])];
}
function max9(vec1, vec2) {
  return [Math.max(vec1[0], vec2[0]), Math.max(vec1[1], vec2[1])];
}
function distance5(vec1, vec2) {
  return Math.sqrt(Math.pow(vec1[0] - vec2[0], 2) + Math.pow(vec1[1] - vec2[1], 2));
}
function normalize7(vec) {
  if (vec[0] === 0 && vec[1] === 0)
    return [0, 0];
  var len5 = Math.sqrt(Math.pow(vec[0], 2) + Math.pow(vec[1], 2));
  return [vec[0] / len5, vec[1] / len5];
}
function rotate5(vec, origin, angle4) {
  var _a2 = __read(vec, 2), x3 = _a2[0], y3 = _a2[1];
  var _b = __read(origin, 2), ox = _b[0], oy = _b[1];
  var dx = x3 - ox;
  var dy = y3 - oy;
  var sin3 = Math.sin(angle4);
  var cos3 = Math.cos(angle4);
  return [dx * cos3 - dy * sin3 + ox, dx * sin3 + dy * cos3 + oy];
}
function vertical2(vec, flag) {
  return flag ? [vec[1], -vec[0]] : [-vec[1], vec[0]];
}

// node_modules/@antv/component/esm/util/number.js
function toPrecision(num, precision) {
  return +num.toPrecision(precision);
}

// node_modules/@antv/component/esm/util/omit.js
function omit(obj, keys2) {
  var res = {};
  var innerKeys = Array.isArray(keys2) ? keys2 : [keys2];
  for (var key in obj) {
    if (!innerKeys.includes(key)) {
      res[key] = obj[key];
    }
  }
  return res;
}

// node_modules/@antv/component/esm/util/path.js
function smoothBezier(points, smooth3, isLoop, constraint) {
  var _a2;
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min10 = [Infinity, Infinity];
  var max11 = [-Infinity, -Infinity];
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    _a2 = __read(constraint, 2), min10 = _a2[0], max11 = _a2[1];
    for (var i = 0, l = points.length; i < l; i += 1) {
      var point7 = points[i];
      min10 = min8(min10, point7);
      max11 = max9(max11, point7);
    }
  }
  for (var i = 0, len5 = points.length; i < len5; i += 1) {
    var point7 = points[i];
    if (i === 0 && !isLoop) {
      cp0 = point7;
    } else if (i === len5 - 1 && !isLoop) {
      cp1 = point7;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      var prevIdx = [i ? i - 1 : len5 - 1, i - 1][isLoop ? 0 : 1];
      prevPoint = points[prevIdx];
      nextPoint = points[isLoop ? (i + 1) % len5 : i + 1];
      var v = [0, 0];
      v = sub7(nextPoint, prevPoint);
      v = scale8(v, smooth3);
      var d0 = distance5(point7, prevPoint);
      var d1 = distance5(point7, nextPoint);
      var sum4 = d0 + d1;
      if (sum4 !== 0) {
        d0 /= sum4;
        d1 /= sum4;
      }
      var v1 = scale8(v, -d0);
      var v2 = scale8(v, d1);
      cp1 = add8(point7, v1);
      nextCp0 = add8(point7, v2);
      nextCp0 = min8(nextCp0, max9(nextPoint, point7));
      nextCp0 = max9(nextCp0, min8(nextPoint, point7));
      v1 = sub7(nextCp0, point7);
      v1 = scale8(v1, -d0 / d1);
      cp1 = add8(point7, v1);
      cp1 = min8(cp1, max9(prevPoint, point7));
      cp1 = max9(cp1, min8(prevPoint, point7));
      v2 = sub7(point7, cp1);
      v2 = scale8(v2, d1 / d0);
      nextCp0 = add8(point7, v2);
      if (hasConstraint) {
        cp1 = max9(cp1, min10);
        cp1 = min8(cp1, max11);
        nextCp0 = max9(nextCp0, min10);
        nextCp0 = min8(nextCp0, max11);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function catmullRom2Bezier(crp, z, constraint) {
  var _a2;
  if (z === void 0) {
    z = false;
  }
  if (constraint === void 0) {
    constraint = [
      [0, 0],
      [1, 1]
    ];
  }
  var isLoop = !!z;
  var pointList = [];
  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }
  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
  var len5 = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p2;
  for (var i = 0; i < len5 - 1; i += 1) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p2 = pointList[i + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len5];
    cp2 = controlPointList[len5 + 1];
    _a2 = __read(pointList, 1), p2 = _a2[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
  }
  return d1;
}

// node_modules/@antv/component/esm/util/primitive.js
var PRIMILTIVE_ATTRIBUTES = [
  "$el",
  "cx",
  "cy",
  "d",
  "dx",
  "dy",
  "fill",
  "fillOpacity",
  "filter",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "height",
  "img",
  "increasedLineWidthForHitTesting",
  "innerHTML",
  "isBillboard",
  "billboardRotation",
  "isSizeAttenuation",
  "isClosed",
  "isOverflowing",
  "leading",
  "letterSpacing",
  "lineDash",
  "lineHeight",
  "lineWidth",
  "markerEnd",
  "markerEndOffset",
  "markerMid",
  "markerStart",
  "markerStartOffset",
  "maxLines",
  "metrics",
  "miterLimit",
  "offsetX",
  "offsetY",
  "opacity",
  "path",
  "points",
  "r",
  "radius",
  "rx",
  "ry",
  "shadowColor",
  "src",
  "stroke",
  "strokeOpacity",
  "text",
  "textAlign",
  "textBaseline",
  "textDecorationColor",
  "textDecorationLine",
  "textDecorationStyle",
  "textOverflow",
  "textPath",
  "textPathSide",
  "textPathStartOffset",
  "transform",
  "transformOrigin",
  "visibility",
  "width",
  "wordWrap",
  "wordWrapWidth",
  "x",
  "x1",
  "x2",
  "y",
  "y1",
  "y2",
  "z1",
  "z2",
  "zIndex"
];
function isPrimitiveAttribute(key) {
  return PRIMILTIVE_ATTRIBUTES.includes(key);
}
function getPrimitiveAttributes(attributes) {
  var object = {};
  for (var key in attributes) {
    if (isPrimitiveAttribute(key))
      object[key] = attributes[key];
  }
  return object;
}

// node_modules/@antv/component/esm/util/sampling.js
function sampling(data2, size3) {
  if (data2.length <= size3)
    return data2;
  var step2 = Math.floor(data2.length / size3);
  var result = [];
  for (var i = 0; i < data2.length; i += step2) {
    result.push(data2[i]);
  }
  return result;
}

// node_modules/@antv/component/esm/util/scale-to-pixel.js
function scaleToPixel(el, size3, applyScale2) {
  if (applyScale2 === void 0) {
    applyScale2 = false;
  }
  var _a2 = el.getBBox(), width = _a2.width, height = _a2.height;
  var scale11 = size3 / Math.max(width, height);
  if (applyScale2) {
    el.style.transform = "scale(".concat(scale11, ")");
  }
  return scale11;
}

// node_modules/@antv/component/esm/util/group.js
function group2(array2, keyFunc) {
  var grouped = /* @__PURE__ */ new Map();
  array2.forEach(function(item) {
    var key = keyFunc(item);
    if (!grouped.has(key)) {
      grouped.set(key, []);
    }
    grouped.get(key).push(item);
  });
  return grouped;
}

// node_modules/@antv/component/esm/util/selection.js
function error2(msg) {
  throw new Error(msg);
}
var Selection2 = (
  /** @class */
  function() {
    function Selection3(elements, data2, parent, document2, selections, transitions, updateElements) {
      if (elements === void 0) {
        elements = null;
      }
      if (data2 === void 0) {
        data2 = null;
      }
      if (parent === void 0) {
        parent = null;
      }
      if (document2 === void 0) {
        document2 = null;
      }
      if (selections === void 0) {
        selections = [null, null, null, null, null];
      }
      if (transitions === void 0) {
        transitions = [];
      }
      if (updateElements === void 0) {
        updateElements = [];
      }
      _Selection_instances.add(this);
      this._elements = Array.from(elements);
      this._data = data2;
      this._parent = parent;
      this._document = document2;
      this._enter = selections[0];
      this._update = selections[1];
      this._exit = selections[2];
      this._merge = selections[3];
      this._split = selections[4];
      this._transitions = transitions;
      this._facetElements = updateElements;
    }
    Selection3.prototype.selectAll = function(selector) {
      var elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
      return new _a2(elements, null, this._elements[0], this._document);
    };
    Selection3.prototype.selectFacetAll = function(selector) {
      var elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
      return new _a2(this._elements, null, this._parent, this._document, void 0, void 0, elements);
    };
    Selection3.prototype.select = function(selector) {
      var element = typeof selector === "string" ? this._parent.querySelectorAll(selector)[0] || null : selector;
      return new _a2([element], null, element, this._document);
    };
    Selection3.prototype.append = function(node) {
      var _this2 = this;
      var callback = typeof node === "function" ? node : function() {
        return _this2.createElement(node);
      };
      var elements = [];
      if (this._data !== null) {
        for (var i = 0; i < this._data.length; i++) {
          var d3 = this._data[i];
          var _b = __read(Array.isArray(d3) ? d3 : [d3, null], 2), datum = _b[0], from = _b[1];
          var newElement = callback(datum, i);
          newElement.__data__ = datum;
          if (from !== null)
            newElement.__fromElements__ = from;
          this._parent.appendChild(newElement);
          elements.push(newElement);
        }
        return new _a2(elements, null, this._parent, this._document);
      }
      for (var i = 0; i < this._elements.length; i++) {
        var element = this._elements[i];
        var datum = element.__data__;
        var newElement = callback(datum, i);
        element.appendChild(newElement);
        elements.push(newElement);
      }
      return new _a2(elements, null, elements[0], this._document);
    };
    Selection3.prototype.maybeAppend = function(id4, node) {
      var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, id4[0] === "#" ? id4 : "#".concat(id4), node);
      element.attr("id", id4);
      return element;
    };
    Selection3.prototype.maybeAppendByClassName = function(className2, node) {
      var cls = className2.toString();
      var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, cls[0] === "." ? cls : ".".concat(cls), node);
      element.attr("className", cls);
      return element;
    };
    Selection3.prototype.maybeAppendByName = function(name2, node) {
      var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, '[name="'.concat(name2, '"]'), node);
      element.attr("name", name2);
      return element;
    };
    Selection3.prototype.data = function(data2, id4, groupId) {
      var e_1, _b;
      if (id4 === void 0) {
        id4 = function(d3) {
          return d3;
        };
      }
      if (groupId === void 0) {
        groupId = function() {
          return null;
        };
      }
      var enter = [];
      var update2 = [];
      var exit = new Set(this._elements);
      var merge2 = [];
      var split = /* @__PURE__ */ new Set();
      var keyElement = new Map(this._elements.map(function(d3, i2) {
        return [id4(d3.__data__, i2), d3];
      }));
      var keyUpdateElement = new Map(this._facetElements.map(function(d3, i2) {
        return [id4(d3.__data__, i2), d3];
      }));
      var groupKeyElements = group2(this._elements, function(d3) {
        return groupId(d3.__data__);
      });
      for (var i = 0; i < data2.length; i++) {
        var datum = data2[i];
        var key = id4(datum, i);
        var groupKey = groupId(datum, i);
        if (keyElement.has(key)) {
          var element = keyElement.get(key);
          element.__data__ = datum;
          element.__facet__ = false;
          update2.push(element);
          exit.delete(element);
          keyElement.delete(key);
        } else if (keyUpdateElement.has(key)) {
          var element = keyUpdateElement.get(key);
          element.__data__ = datum;
          element.__facet__ = true;
          update2.push(element);
          keyUpdateElement.delete(key);
        } else if (groupKeyElements.has(key)) {
          var group_2 = groupKeyElements.get(key);
          merge2.push([datum, group_2]);
          try {
            for (var group_1 = (e_1 = void 0, __values(group_2)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {
              var element = group_1_1.value;
              exit.delete(element);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (group_1_1 && !group_1_1.done && (_b = group_1.return))
                _b.call(group_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          groupKeyElements.delete(key);
        } else if (keyElement.has(groupKey)) {
          var element = keyElement.get(groupKey);
          if (element.__toData__)
            element.__toData__.push(datum);
          else
            element.__toData__ = [datum];
          split.add(element);
          exit.delete(element);
        } else {
          enter.push(datum);
        }
      }
      var S = [
        new _a2([], enter, this._parent, this._document),
        new _a2(update2, null, this._parent, this._document),
        new _a2(exit, null, this._parent, this._document),
        new _a2([], merge2, this._parent, this._document),
        new _a2(split, null, this._parent, this._document)
      ];
      return new _a2(this._elements, null, this._parent, this._document, S);
    };
    Selection3.prototype.merge = function(other) {
      var elements = __spreadArray(__spreadArray([], __read(this._elements), false), __read(other._elements), false);
      var transitions = __spreadArray(__spreadArray([], __read(this._transitions), false), __read(other._transitions), false);
      return new _a2(elements, null, this._parent, this._document, void 0, transitions);
    };
    Selection3.prototype.createElement = function(type) {
      if (this._document) {
        return this._document.createElement(type, {});
      }
      var Ctor = _a2.registry[type];
      if (Ctor)
        return new Ctor();
      return error2("Unknown node type: ".concat(type));
    };
    Selection3.prototype.join = function(enter, update2, exit, merge2, split) {
      if (enter === void 0) {
        enter = function(d3) {
          return d3;
        };
      }
      if (update2 === void 0) {
        update2 = function(d3) {
          return d3;
        };
      }
      if (exit === void 0) {
        exit = function(d3) {
          return d3.remove();
        };
      }
      if (merge2 === void 0) {
        merge2 = function(d3) {
          return d3;
        };
      }
      if (split === void 0) {
        split = function(d3) {
          return d3.remove();
        };
      }
      var newEnter = enter(this._enter);
      var newUpdate = update2(this._update);
      var newExit = exit(this._exit);
      var newMerge = merge2(this._merge);
      var newSplit = split(this._split);
      return newUpdate.merge(newEnter).merge(newExit).merge(newMerge).merge(newSplit);
    };
    Selection3.prototype.remove = function() {
      var _loop_1 = function(i2) {
        var element = this_1._elements[i2];
        var transition2 = this_1._transitions[i2];
        if (transition2) {
          transition2.then(function() {
            return element.remove();
          });
        } else {
          element.remove();
        }
      };
      var this_1 = this;
      for (var i = 0; i < this._elements.length; i++) {
        _loop_1(i);
      }
      return new _a2([], null, this._parent, this._document, void 0, this._transitions);
    };
    Selection3.prototype.each = function(callback) {
      for (var i = 0; i < this._elements.length; i++) {
        var element = this._elements[i];
        var datum = element.__data__;
        callback.call(element, datum, i);
      }
      return this;
    };
    Selection3.prototype.attr = function(key, value2) {
      var callback = typeof value2 !== "function" ? function() {
        return value2;
      } : value2;
      return this.each(function(d3, i) {
        if (value2 !== void 0)
          this[key] = callback.call(this, d3, i);
      });
    };
    Selection3.prototype.style = function(key, value2, callable) {
      if (callable === void 0) {
        callable = true;
      }
      var callback = typeof value2 !== "function" || !callable ? function() {
        return value2;
      } : value2;
      return this.each(function(d3, i) {
        if (value2 !== void 0)
          this.style[key] = callback.call(this, d3, i);
      });
    };
    Selection3.prototype.styles = function(style, callable) {
      if (style === void 0) {
        style = {};
      }
      if (callable === void 0) {
        callable = true;
      }
      return this.each(function(d3, i) {
        var _this2 = this;
        Object.entries(style).forEach(function(_b) {
          var _c = __read(_b, 2), key = _c[0], value2 = _c[1];
          var callback = typeof value2 !== "function" || !callable ? function() {
            return value2;
          } : value2;
          if (value2 !== void 0)
            _this2.attr(key, callback.call(_this2, d3, i));
        });
      });
    };
    Selection3.prototype.update = function(option, callable) {
      if (callable === void 0) {
        callable = true;
      }
      var callback = typeof option !== "function" || !callable ? function() {
        return option;
      } : option;
      return this.each(function(d3, i) {
        if (option && this.update)
          this.update(callback.call(this, d3, i));
      });
    };
    Selection3.prototype.maybeUpdate = function(option, callable) {
      if (callable === void 0) {
        callable = true;
      }
      var callback = typeof option !== "function" || !callable ? function() {
        return option;
      } : option;
      return this.each(function(d3, i) {
        if (option && this.update)
          this.update(callback.call(this, d3, i));
      });
    };
    Selection3.prototype.transition = function(callback) {
      var T = this._transitions;
      return this.each(function(d3, i) {
        T[i] = callback.call(this, d3, i);
      });
    };
    Selection3.prototype.on = function(event, handler) {
      this.each(function() {
        this.addEventListener(event, handler);
      });
      return this;
    };
    Selection3.prototype.call = function(callback) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      callback.call.apply(callback, __spreadArray([this._parent, this], __read(args), false));
      return this;
    };
    Selection3.prototype.node = function() {
      return this._elements[0];
    };
    Selection3.prototype.nodes = function() {
      return this._elements;
    };
    Selection3.prototype.transitions = function() {
      return this._transitions.filter(function(t) {
        return !!t;
      });
    };
    Selection3.prototype.parent = function() {
      return this._parent;
    };
    var _Selection_instances, _a2, _Selection_maybeAppend;
    _a2 = Selection3, _Selection_instances = /* @__PURE__ */ new WeakSet(), _Selection_maybeAppend = function _Selection_maybeAppend2(selector, node) {
      var element = this._elements[0];
      var child = element.querySelector(selector);
      if (child)
        return new _a2([child], null, this._parent, this._document);
      var newChild = typeof node === "string" ? this.createElement(node) : node();
      element.appendChild(newChild);
      return new _a2([newChild], null, this._parent, this._document);
    };
    Selection3.registry = {
      g: Group2,
      rect: Rect,
      circle: Circle,
      path: Path2,
      text: Text2,
      ellipse: Ellipse,
      image: Image2,
      line: Line,
      polygon: Polygon,
      polyline: Polyline,
      html: HTML
    };
    return Selection3;
  }()
);
function select2(node) {
  return new Selection2([node], null, node, node.ownerDocument);
}
function maybeAppend(parent, selector, node) {
  if (!parent.querySelector(selector)) {
    return select2(parent).append(node);
  }
  return select2(parent).select(selector);
}

// node_modules/@antv/component/esm/util/series.js
function parseSeriesAttr(series) {
  if (isNumber(series)) {
    return [series, series, series, series];
  }
  if (isArray(series)) {
    var len5 = series.length;
    if (len5 === 1) {
      return [series[0], series[0], series[0], series[0]];
    }
    if (len5 === 2) {
      return [series[0], series[1], series[0], series[1]];
    }
    if (len5 === 3) {
      return [series[0], series[1], series[2], series[1]];
    }
    if (len5 === 4) {
      return series;
    }
  }
  return [0, 0, 0, 0];
}

// node_modules/@antv/component/esm/util/shape.js
function getShapeSpace(shape23) {
  var bounds = shape23 && shape23.getRenderBounds();
  if (!bounds)
    return {
      width: 0,
      height: 0
    };
  var max11 = bounds.getMax();
  var min10 = bounds.getMin();
  return {
    width: max11[0] - min10[0],
    height: max11[1] - min10[1]
  };
}
function getLocalBBox(shape23) {
  var _a2 = shape23.getLocalBounds(), min10 = _a2.min, max11 = _a2.max;
  var _b = __read([min10, max11], 2), _c = __read(_b[0], 2), x12 = _c[0], y12 = _c[1], _d = __read(_b[1], 2), x22 = _d[0], y22 = _d[1];
  return { x: x12, y: y12, width: x22 - x12, height: y22 - y12, left: x12, bottom: y22, top: y12, right: x22 };
}
function isHorizontal(p1, p2) {
  var _a2 = __read(p1, 2), x12 = _a2[0], y12 = _a2[1];
  var _b = __read(p2, 2), x22 = _b[0], y22 = _b[1];
  return x12 !== x22 && y12 === y22;
}
function copyAttributes2(target, source) {
  var e_1, _a2;
  var attributes = source.attributes;
  try {
    for (var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var _d = __read(_c.value, 2), key = _d[0], value2 = _d[1];
      if (key !== "id" && key !== "className")
        target.attr(key, value2);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
}

// node_modules/@antv/component/esm/util/string.js
function toUppercaseFirstLetter(string) {
  return string.toString().charAt(0).toUpperCase() + string.toString().slice(1);
}
function toLowercaseFirstLetter(string) {
  return string.toString().charAt(0).toLowerCase() + string.toString().slice(1);
}
function addPrefix(string, prefix) {
  return "".concat(prefix).concat(toUppercaseFirstLetter(string));
}
function removePrefix(string, prefix, lowercaseFirstLetter) {
  var _a2;
  if (lowercaseFirstLetter === void 0) {
    lowercaseFirstLetter = true;
  }
  var inferPrefix = prefix || ((_a2 = string.match(/^([a-z][a-z0-9]+)/)) === null || _a2 === void 0 ? void 0 : _a2[0]) || "";
  var withoutPrefix = string.replace(new RegExp("^(".concat(inferPrefix, ")")), "");
  return lowercaseFirstLetter ? toLowercaseFirstLetter(withoutPrefix) : withoutPrefix;
}

// node_modules/@antv/component/esm/util/style.js
function applyStyleSheet(element, style) {
  Object.entries(style).forEach(function(_a2) {
    var _b = __read(_a2, 2), selector = _b[0], styleString = _b[1];
    __spreadArray([element], __read(element.querySelectorAll(selector)), false).filter(function(el) {
      return el.matches(selector);
    }).forEach(function(target) {
      if (!target)
        return;
      var temp = target;
      temp.style.cssText += Object.entries(styleString).reduce(function(total, currVal) {
        return "".concat(total).concat(currVal.join(":"), ";");
      }, "");
    });
  });
}
var startsWith = function(text, prefix) {
  if (!(text === null || text === void 0 ? void 0 : text.startsWith(prefix)))
    return false;
  var nextChart = text[prefix.length];
  return nextChart >= "A" && nextChart <= "Z";
};
function subStyleProps(style, prefix, invert5) {
  if (invert5 === void 0) {
    invert5 = false;
  }
  var result = {};
  Object.entries(style).forEach(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], value2 = _b[1];
    if (key === "className" || key === "class") {
    } else if (startsWith(key, "show") && startsWith(removePrefix(key, "show"), prefix) !== invert5) {
      if (key === addPrefix(prefix, "show"))
        result[key] = value2;
      else
        result[key.replace(new RegExp(toUppercaseFirstLetter(prefix)), "")] = value2;
    } else if (!startsWith(key, "show") && startsWith(key, prefix) !== invert5) {
      var name_1 = removePrefix(key, prefix);
      if (name_1 === "filter" && typeof value2 === "function") {
      } else
        result[name_1] = value2;
    }
  });
  return result;
}
function superStyleProps(style, prefix) {
  return Object.entries(style).reduce(function(acc, _a2) {
    var _b = __read(_a2, 2), key = _b[0], value2 = _b[1];
    if (key.startsWith("show"))
      acc["show".concat(prefix).concat(key.slice(4))] = value2;
    else
      acc["".concat(prefix).concat(toUppercaseFirstLetter(key))] = value2;
    return acc;
  }, {});
}
function splitStyle(style, ignoreStyleDict) {
  if (ignoreStyleDict === void 0) {
    ignoreStyleDict = ["x", "y", "class", "className"];
  }
  var groupStyleDict = [
    "transform",
    "transformOrigin",
    "anchor",
    "visibility",
    "pointerEvents",
    "zIndex",
    "cursor",
    "clipPath",
    "clipPathTargets",
    "offsetPath",
    "offsetPathTargets",
    "offsetDistance",
    "draggable",
    "droppable"
  ];
  var output = {};
  var groupStyle = {};
  Object.entries(style).forEach(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], val = _b[1];
    if (ignoreStyleDict.includes(key)) {
    } else if (groupStyleDict.indexOf(key) !== -1)
      groupStyle[key] = val;
    else
      output[key] = val;
  });
  return [output, groupStyle];
}

// node_modules/@antv/component/esm/util/svg2marker.js
var import_svg_path_parser = __toESM(require_svg_path_parser());

// node_modules/@antv/component/esm/util/time.js
function formatTime(date, mask) {
  var timeMap = {
    YYYY: date.getFullYear(),
    MM: date.getMonth() + 1,
    DD: date.getDate(),
    HH: date.getHours(),
    mm: date.getMinutes(),
    ss: date.getSeconds()
  };
  var strftime = mask;
  Object.keys(timeMap).forEach(function(key) {
    var val = timeMap[key];
    strftime = strftime.replace(key, key === "YYYY" ? "".concat(val) : "".concat(val).padStart(2, "0"));
  });
  return strftime;
}

// node_modules/@antv/component/esm/util/transform.js
function getTranslate(node, x3, y3) {
  var _a2 = node.getBBox(), width = _a2.width, height = _a2.height;
  var _b = __read([x3, y3].map(function(v, i) {
    var _a3;
    return v.includes("%") ? parseFloat(((_a3 = v.match(/[+-]?([0-9]*[.])?[0-9]+/)) === null || _a3 === void 0 ? void 0 : _a3[0]) || "0") / 100 * (i === 0 ? width : height) : v;
  }), 2), tx = _b[0], ty = _b[1];
  return [tx, ty];
}
function percentTransform(node, val) {
  if (!val)
    return;
  try {
    var reg = /translate\(([+-]*[\d]+[%]*),[ ]*([+-]*[\d]+[%]*)\)/g;
    var computedVal = val.replace(reg, function(match, x3, y3) {
      return "translate(".concat(getTranslate(node, x3, y3), ")");
    });
    node.attr("transform", computedVal);
  } catch (e) {
  }
}

// node_modules/@antv/component/esm/util/transpose.js
function transpose4(m3) {
  var _a2;
  return ((_a2 = m3[0]) === null || _a2 === void 0 ? void 0 : _a2.map(function(x3, i) {
    return m3.map(function(x4) {
      return x4[i];
    });
  })) || [];
}

// node_modules/@antv/component/esm/util/replace-children.js
var replaceChildren = function(el, content) {
  if (content == null) {
    el.innerHTML = "";
    return;
  }
  if (el.replaceChildren) {
    if (Array.isArray(content)) {
      el.replaceChildren.apply(el, __spreadArray([], __read(content), false));
    } else {
      el.replaceChildren(content);
    }
  } else {
    el.innerHTML = "";
    if (Array.isArray(content)) {
      content.forEach(function(child) {
        return el.appendChild(child);
      });
    } else {
      el.appendChild(content);
    }
  }
};

// node_modules/@antv/component/esm/core/component.js
function applyVisibility() {
  visibility(this, this.attributes.visibility !== "hidden");
}
var Component = (
  /** @class */
  function(_super) {
    __extends(Component2, _super);
    function Component2(options, defaultStyleProps) {
      if (defaultStyleProps === void 0) {
        defaultStyleProps = {};
      }
      var _this2 = _super.call(this, deepAssign2({}, { style: defaultStyleProps }, options)) || this;
      _this2.initialized = false;
      _this2._defaultOptions = defaultStyleProps;
      return _this2;
    }
    Object.defineProperty(Component2.prototype, "offscreenGroup", {
      get: function() {
        if (!this._offscreen)
          this._offscreen = createOffscreenGroup(this);
        return this._offscreen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Component2.prototype, "defaultOptions", {
      get: function() {
        return this._defaultOptions;
      },
      enumerable: false,
      configurable: true
    });
    Component2.prototype.connectedCallback = function() {
      this.render(this.attributes, this);
      this.bindEvents(this.attributes, this);
      this.initialized = true;
    };
    Component2.prototype.disconnectedCallback = function() {
      var _a2;
      (_a2 = this._offscreen) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    };
    Component2.prototype.attributeChangedCallback = function(name2) {
      if (name2 === "visibility") {
        applyVisibility.call(this);
      }
    };
    Component2.prototype.update = function(attr2, animate2) {
      var _a2;
      this.attr(deepAssign2({}, this.attributes, attr2 || {}));
      return (_a2 = this.render) === null || _a2 === void 0 ? void 0 : _a2.call(this, this.attributes, this, animate2);
    };
    Component2.prototype.clear = function() {
      this.removeChildren();
    };
    Component2.prototype.bindEvents = function(attributes, container) {
    };
    Component2.prototype.getSubShapeStyle = function(attributes) {
      var x3 = attributes.x, y3 = attributes.y, transform2 = attributes.transform, transformOrigin = attributes.transformOrigin, _class = attributes.class, className2 = attributes.className, zIndex = attributes.zIndex, style = __rest(attributes, ["x", "y", "transform", "transformOrigin", "class", "className", "zIndex"]);
      return style;
    };
    return Component2;
  }(CustomElement)
);

// node_modules/@antv/component/esm/ui/marker/symbol.js
var circle = function(x3, y3, r) {
  return [["M", x3 - r, y3], ["A", r, r, 0, 1, 0, x3 + r, y3], ["A", r, r, 0, 1, 0, x3 - r, y3], ["Z"]];
};
var point6 = circle;
var square2 = function(x3, y3, r) {
  return [["M", x3 - r, y3 - r], ["L", x3 + r, y3 - r], ["L", x3 + r, y3 + r], ["L", x3 - r, y3 + r], ["Z"]];
};
var diamond2 = function(x3, y3, r) {
  return [["M", x3 - r, y3], ["L", x3, y3 - r], ["L", x3 + r, y3], ["L", x3, y3 + r], ["Z"]];
};
var triangle2 = function(x3, y3, r) {
  var diffY = r * Math.sin(1 / 3 * Math.PI);
  return [["M", x3 - r, y3 + diffY], ["L", x3, y3 - diffY], ["L", x3 + r, y3 + diffY], ["Z"]];
};
var triangleDown2 = function(x3, y3, r) {
  var diffY = r * Math.sin(1 / 3 * Math.PI);
  return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 - diffY], ["L", x3, y3 + diffY], ["Z"]];
};
var hexagon2 = function(x3, y3, r) {
  var diffX = r / 2 * Math.sqrt(3);
  return [
    ["M", x3, y3 - r],
    ["L", x3 + diffX, y3 - r / 2],
    ["L", x3 + diffX, y3 + r / 2],
    ["L", x3, y3 + r],
    ["L", x3 - diffX, y3 + r / 2],
    ["L", x3 - diffX, y3 - r / 2],
    ["Z"]
  ];
};
var bowtie2 = function(x3, y3, r) {
  var diffY = r - 1.5;
  return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 + diffY], ["L", x3 + r, y3 - diffY], ["L", x3 - r, y3 + diffY], ["Z"]];
};
var line2 = function(x3, y3, r) {
  return [
    ["M", x3, y3 + r],
    ["L", x3, y3 - r]
  ];
};
var cross6 = function(x3, y3, r) {
  return [
    ["M", x3 - r, y3 - r],
    ["L", x3 + r, y3 + r],
    ["M", x3 + r, y3 - r],
    ["L", x3 - r, y3 + r]
  ];
};
var tick2 = function(x3, y3, r) {
  return [
    ["M", x3 - r / 2, y3 - r],
    ["L", x3 + r / 2, y3 - r],
    ["M", x3, y3 - r],
    ["L", x3, y3 + r],
    ["M", x3 - r / 2, y3 + r],
    ["L", x3 + r / 2, y3 + r]
  ];
};
var plus2 = function(x3, y3, r) {
  return [
    ["M", x3 - r, y3],
    ["L", x3 + r, y3],
    ["M", x3, y3 - r],
    ["L", x3, y3 + r]
  ];
};
var hyphen2 = function(x3, y3, r) {
  return [
    ["M", x3 - r, y3],
    ["L", x3 + r, y3]
  ];
};
var dot7 = function(x3, y3, r) {
  return [
    ["M", x3 - r, y3],
    ["L", x3 + r, y3]
  ];
};
var dash2 = dot7;
var smooth2 = function(x3, y3, r) {
  return [
    ["M", x3 - r, y3],
    ["A", r / 2, r / 2, 0, 1, 1, x3, y3],
    ["A", r / 2, r / 2, 0, 1, 0, x3 + r, y3]
  ];
};
var hv2 = function(x3, y3, r) {
  return [
    ["M", x3 - r - 1, y3 - 2.5],
    ["L", x3, y3 - 2.5],
    ["L", x3, y3 + 2.5],
    ["L", x3 + r + 1, y3 + 2.5]
  ];
};
var vh2 = function(x3, y3, r) {
  return [
    ["M", x3 - r - 1, y3 + 2.5],
    ["L", x3, y3 + 2.5],
    ["L", x3, y3 - 2.5],
    ["L", x3 + r + 1, y3 - 2.5]
  ];
};
var hvh2 = function(x3, y3, r) {
  return [
    ["M", x3 - (r + 1), y3 + 2.5],
    ["L", x3 - r / 2, y3 + 2.5],
    ["L", x3 - r / 2, y3 - 2.5],
    ["L", x3 + r / 2, y3 - 2.5],
    ["L", x3 + r / 2, y3 + 2.5],
    ["L", x3 + r + 1, y3 + 2.5]
  ];
};
function vhv2(x3, y3) {
  return [
    ["M", x3 - 5, y3 + 2.5],
    ["L", x3 - 5, y3],
    ["L", x3, y3],
    ["L", x3, y3 - 3],
    ["L", x3, y3 + 3],
    ["L", x3 + 6.5, y3 + 3]
  ];
}
var button = function(x3, y3, r) {
  return [["M", x3 - r, y3 - r], ["L", x3 + r, y3], ["L", x3 - r, y3 + r], ["Z"]];
};

// node_modules/@antv/component/esm/ui/marker/utils.js
function parseMarker(icon) {
  var type = "default";
  if (is_object_default(icon) && icon instanceof Image)
    type = "image";
  else if (isFunction(icon))
    type = "symbol";
  else if (isString(icon)) {
    var dataURLsPattern = new RegExp("data:(image|text)");
    if (icon.match(dataURLsPattern)) {
      type = "base64";
    } else if (/^(https?:\/\/(([a-zA-Z0-9]+-?)+[a-zA-Z0-9]+\.)+[a-zA-Z]+)(:\d+)?(\/.*)?(\?.*)?(#.*)?$/.test(icon)) {
      type = "url";
    } else {
      type = "symbol";
    }
  }
  return type;
}

// node_modules/@antv/component/esm/ui/marker/index.js
function getType(symbol) {
  var markerType = parseMarker(symbol);
  if (["base64", "url", "image"].includes(markerType)) {
    return "image";
  }
  if (symbol && markerType === "symbol") {
    return "path";
  }
  return null;
}
var Marker = (
  /** @class */
  function(_super) {
    __extends(Marker2, _super);
    function Marker2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Marker2.prototype.render = function(attributes, container) {
      var _a2 = attributes.x, x3 = _a2 === void 0 ? 0 : _a2, _b = attributes.y, y3 = _b === void 0 ? 0 : _b;
      var _c = this.getSubShapeStyle(attributes), symbol = _c.symbol, _d = _c.size, size3 = _d === void 0 ? 16 : _d, style = __rest(_c, ["symbol", "size"]);
      var type = getType(symbol);
      ifShow(!!type, select2(container), function(group3) {
        group3.maybeAppendByClassName("marker", type).attr("className", "marker ".concat(type, "-marker")).call(function(selection) {
          if (type === "image") {
            var r = size3 * 2;
            selection.styles({
              img: symbol,
              width: r,
              height: r,
              x: x3 - size3,
              y: y3 - size3
            });
          } else {
            var r = size3 / 2;
            var symbolFn = isFunction(symbol) ? symbol : Marker2.getSymbol(symbol);
            selection.styles(__assign({ d: symbolFn === null || symbolFn === void 0 ? void 0 : symbolFn(x3, y3, r) }, style));
          }
        });
      });
    };
    Marker2.MARKER_SYMBOL_MAP = /* @__PURE__ */ new Map();
    Marker2.registerSymbol = function(type, symbol) {
      Marker2.MARKER_SYMBOL_MAP.set(type, symbol);
    };
    Marker2.getSymbol = function(type) {
      return Marker2.MARKER_SYMBOL_MAP.get(type);
    };
    Marker2.getSymbols = function() {
      return Array.from(Marker2.MARKER_SYMBOL_MAP.keys());
    };
    return Marker2;
  }(Component)
);
Marker.registerSymbol("cross", cross6);
Marker.registerSymbol("hyphen", hyphen2);
Marker.registerSymbol("line", line2);
Marker.registerSymbol("plus", plus2);
Marker.registerSymbol("tick", tick2);
Marker.registerSymbol("circle", circle);
Marker.registerSymbol("point", point6);
Marker.registerSymbol("bowtie", bowtie2);
Marker.registerSymbol("hexagon", hexagon2);
Marker.registerSymbol("square", square2);
Marker.registerSymbol("diamond", diamond2);
Marker.registerSymbol("triangle", triangle2);
Marker.registerSymbol("triangle-down", triangleDown2);
Marker.registerSymbol("line", line2);
Marker.registerSymbol("dot", dot7);
Marker.registerSymbol("dash", dash2);
Marker.registerSymbol("smooth", smooth2);
Marker.registerSymbol("hv", hv2);
Marker.registerSymbol("vh", vh2);
Marker.registerSymbol("hvh", hvh2);
Marker.registerSymbol("vhv", vhv2);

// node_modules/@antv/component/esm/ui/tag/index.js
function adjust(container, paddingLeft, paddingTop, align, baseline) {
  var bounds = container.getLocalBounds();
  var x3 = 0;
  var y3 = 0;
  if (align === "start")
    x3 = paddingLeft;
  if (align === "center")
    x3 = -bounds.halfExtents[0];
  if (align === "end")
    x3 = -paddingLeft - bounds.halfExtents[0] * 2;
  if (baseline === "top")
    y3 = paddingTop + bounds.halfExtents[1];
  if (baseline === "middle")
    y3 = 0;
  if (baseline === "bottom")
    y3 = paddingTop - bounds.halfExtents[1] * 2;
  container.setLocalPosition([x3, y3]);
}
function getTextPosition(markerShape, spacing) {
  var bounds = markerShape.getLocalBounds();
  return {
    x: bounds.halfExtents[0] ? bounds.max[0] + (spacing || 0) : markerShape.style.x,
    y: bounds.halfExtents[1] ? (bounds.min[1] + bounds.max[1]) / 2 : markerShape.style.y
  };
}
var Tag = (
  /** @class */
  function(_super) {
    __extends(Tag3, _super);
    function Tag3(options) {
      return _super.call(this, options, {
        padding: 4,
        spacing: 4
      }) || this;
    }
    Tag3.prototype.render = function(attributes, container) {
      var _a2 = attributes.padding, padding = _a2 === void 0 ? 0 : _a2, marker = attributes.marker, text = attributes.text, radius = attributes.radius, spacing = attributes.spacing, align = attributes.align, verticalAlign = attributes.verticalAlign;
      var labelStyle = subStyleProps(attributes, "label");
      var backgroundStyle = subStyleProps(attributes, "background");
      var _b = __read(parseSeriesAttr(padding), 4), pt = _b[0], pr = _b[1], pb = _b[2], pl = _b[3];
      var group3 = maybeAppend(container, ".tag-content", "g").attr("className", "tag-content").style("zIndex", 0).node();
      var markerStyle = marker || { symbol: "triangle", size: 0 };
      var markerShape = maybeAppend(group3, ".tag-marker", function() {
        return new Marker({ style: markerStyle });
      }).attr("className", "tag-marker").update(markerStyle).node();
      var _c = getTextPosition(markerShape, spacing), x3 = _c.x, y3 = _c.y;
      select2(group3).maybeAppendByClassName("tag-text", function() {
        return new Text2();
      }).styles(__assign(__assign({ fontSize: 12, text: isNil(text) ? "" : "".concat(text), x: x3, y: y3 }, labelStyle), { textBaseline: "middle" })).call(function(selection) {
        if (!text)
          selection.remove();
      });
      adjust(group3, pl, pt, align || "start", verticalAlign || "top");
      var bounds = group3.getLocalBounds();
      select2(container).maybeAppendByClassName("tag-background", "rect").styles(__assign({ zIndex: -1, y: bounds.min[1] - pt, x: bounds.min[0] - pl, width: backgroundStyle !== null ? pl + pr + bounds.halfExtents[0] * 2 : 0, height: backgroundStyle !== null ? pt + pb + bounds.halfExtents[1] * 2 : 0, radius: radius !== null && radius !== void 0 ? radius : 2, fill: "#fafafa", stroke: "#d9d9d9", lineWidth: 1 }, backgroundStyle));
    };
    Tag3.tag = "tag";
    return Tag3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/button/constant.js
var SIZE_STYLE = {
  small: {
    textFontSize: 10,
    buttonWidth: 40,
    buttonHeight: 20,
    markerSize: 8
  },
  middle: {
    textFontSize: 12,
    buttonWidth: 60,
    buttonHeight: 30,
    markerSize: 12
  },
  large: {
    textFontSize: 16,
    buttonWidth: 80,
    buttonHeight: 40,
    markerSize: 16
  }
};
var TYPE_STYLE = {
  primary: {
    default: { textFill: "#fff", buttonFill: "#1890ff", buttonLineWidth: 0, markerFill: "#1890ff" },
    active: {
      buttonFill: "#40a9ff",
      markerFill: "#40a9ff"
    },
    disabled: {}
  },
  dashed: {
    default: {
      buttonFill: "transparent",
      buttonStroke: "#bbb",
      buttonLineDash: [5, 5]
    },
    active: {},
    disabled: {}
  },
  link: {
    default: { textFill: "#1890ff", buttonFill: "transparent", buttonLineWidth: 0, markerFill: "#1890ff" },
    active: {},
    disabled: {}
  },
  text: {
    default: { textFill: "#000", buttonFill: "transparent", buttonLineWidth: 0, markerFill: "#000" },
    active: {},
    disabled: {}
  },
  default: {
    default: { textFill: "#000", buttonFill: "transparent", buttonStroke: "#bbb", markerFill: "#bbb" },
    active: { textFill: "#1890ff", buttonStroke: "#1890ff", markerStroke: "#1890ff" },
    disabled: {}
  }
};
var DISABLED_STYLE = {
  // 严格需要替换的样式
  strict: {
    textFill: "#b8b8b8"
  },
  buttonStroke: "#d9d9d9",
  buttonFill: "#f5f5f5",
  markerStroke: "#d9d9d9"
};

// node_modules/@antv/component/esm/ui/button/index.js
var Button = (
  /** @class */
  function(_super) {
    __extends(Button2, _super);
    function Button2(options) {
      var _this2 = _super.call(this, options, {
        cursor: "pointer",
        padding: 10,
        size: "middle",
        type: "default",
        text: "",
        state: "default",
        markerAlign: "left",
        markerSpacing: 5,
        default: {
          buttonLineWidth: 1,
          buttonRadius: 5
        },
        active: {}
      }) || this;
      _this2.state = "default";
      _this2.clickEvents = function() {
        var _a2 = _this2.attributes, onClick = _a2.onClick, state = _a2.state;
        if (state !== "disabled")
          onClick === null || onClick === void 0 ? void 0 : onClick.call(_this2, _this2);
      };
      _this2.mouseenterEvent = function() {
        var state = _this2.attributes.state;
        if (state !== "disabled") {
          _this2.state = "active";
          _this2.render(_this2.attributes, _this2);
        }
      };
      _this2.mouseleaveEvent = function() {
        var state = _this2.attributes.state;
        _this2.state = state;
        _this2.render(_this2.attributes, _this2);
      };
      return _this2;
    }
    Object.defineProperty(Button2.prototype, "markerSize", {
      get: function() {
        var markerSymbol = this.attributes.markerSymbol;
        var markerStyle = this.getStyle("marker");
        var markerSize = !markerSymbol ? 0 : (markerStyle === null || markerStyle === void 0 ? void 0 : markerStyle.size) || 2;
        return markerSize;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Button2.prototype, "textAvailableWidth", {
      /* 获得文本可用宽度 */
      get: function() {
        var _a2 = this.attributes, markerSymbol = _a2.markerSymbol, padding = _a2.padding, ellipsis = _a2.ellipsis, bWidth = _a2.width, spacing = _a2.markerSpacing;
        if (!ellipsis)
          return Infinity;
        var width = is_undefined_default(bWidth) ? this.getStyle("button").width : bWidth;
        if (markerSymbol)
          return width - padding * 2 - spacing - this.markerSize;
        return width - padding * 2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Button2.prototype, "buttonHeight", {
      get: function() {
        var height = this.attributes.height;
        if (height)
          return +height;
        return +this.getStyle("button").height;
      },
      enumerable: false,
      configurable: true
    });
    Button2.prototype.getStyle = function(name2) {
      var _a2 = this.attributes, size3 = _a2.size, type = _a2.type;
      var state = this.state;
      var mixedStyle = deep_mix_default({}, SIZE_STYLE[size3], TYPE_STYLE[type][state], this.attributes.default, this.attributes[state]);
      if (state === "disabled") {
        Object.keys(mixedStyle).forEach(function(key) {
          if (key in DISABLED_STYLE) {
            mixedStyle[key] = DISABLED_STYLE[key];
          }
        });
        Object.keys(DISABLED_STYLE.strict).forEach(function(key) {
          mixedStyle[key] = DISABLED_STYLE.strict[key];
        });
        deep_mix_default(mixedStyle, this.attributes.disabled || {});
      }
      return subStyleProps(mixedStyle, name2);
    };
    Button2.prototype.render = function(attributes, container) {
      var _a2 = attributes.text, text = _a2 === void 0 ? "" : _a2, _b = attributes.padding, padding = _b === void 0 ? 0 : _b, markerSymbol = attributes.markerSymbol, _c = attributes.markerSpacing, markerSpacing = _c === void 0 ? 0 : _c, _d = attributes.x, x3 = _d === void 0 ? 0 : _d, _e = attributes.y, y3 = _e === void 0 ? 0 : _e;
      container.attr({
        cursor: this.state === "disabled" ? "not-allowed" : "pointer"
      });
      var _f = __read(parseSeriesAttr(padding), 4), pt = _f[0], pr = _f[1], pb = _f[2], pl = _f[3];
      var height = this.buttonHeight;
      var markerStyle = this.getStyle("marker");
      var markerSize = this.markerSize;
      var style = __assign(__assign({}, markerStyle), { symbol: markerSymbol, x: x3 + pl + markerSize / 2, y: y3 + height / 2, size: markerSize });
      var markerShape = maybeAppend(container, ".marker", function() {
        return new Marker({ className: "marker", style });
      }).update({ style }).node();
      var bounds = markerShape.getLocalBounds();
      var textStyle = this.getStyle("text");
      this.textShape = maybeAppend(container, ".text", "text").attr("className", "text").styles(__assign(__assign({ x: x3 + (markerSize ? bounds.max[0] + markerSpacing : pl), y: y3 + height / 2 }, textStyle), { text, textAlign: "left", textBaseline: "middle", wordWrap: true, wordWrapWidth: this.textAvailableWidth, maxLines: 1, textOverflow: "..." })).node();
      var textBounds = this.textShape.getLocalBounds();
      var buttonStyle = this.getStyle("button");
      select2(container).maybeAppendByClassName(".background", "rect").styles(__assign(__assign({ zIndex: -1 }, buttonStyle), { x: x3, y: y3, height, width: pl + (markerSize ? markerSize + markerSpacing : 0) + textBounds.halfExtents[0] * 2 + pr }));
    };
    Button2.prototype.update = function(attr2) {
      if (attr2 === void 0) {
        attr2 = {};
      }
      this.attr(deep_mix_default({}, this.attributes, attr2));
      var state = this.attributes.state;
      this.state = state;
      this.render(this.attributes, this);
    };
    Button2.prototype.setState = function(state) {
      this.update({ state });
    };
    Button2.prototype.hide = function() {
      this.style.visibility = "hidden";
    };
    Button2.prototype.show = function() {
      this.style.visibility = "visible";
    };
    Button2.prototype.bindEvents = function() {
      this.addEventListener("click", this.clickEvents);
      this.addEventListener("mouseenter", this.mouseenterEvent);
      this.addEventListener("mouseleave", this.mouseleaveEvent);
    };
    Button2.tag = "button";
    return Button2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/breadcrumb/index.js
var Breadcrumb = (
  /** @class */
  function(_super) {
    __extends(Breadcrumb2, _super);
    function Breadcrumb2(options) {
      return _super.call(this, deep_mix_default({}, Breadcrumb2.defaultOptions, options)) || this;
    }
    Breadcrumb2.prototype.render = function(attributes, container) {
      var x3 = attributes.x, y3 = attributes.y, items = attributes.items, textStyle = attributes.textStyle, _a2 = attributes.padding, padding = _a2 === void 0 ? 0 : _a2, width = attributes.width, separator = attributes.separator;
      var _b = __read(parseSeriesAttr(padding), 3), top = _b[0], right2 = _b[1], left2 = _b[2];
      var tagStyle = subStyleProps(attributes, "tag");
      var selection = maybeAppend(container, ".container", "g").styles({
        className: "container",
        x: x3 + left2,
        y: y3 + top
      });
      var cursorX = 0;
      var cursorY = 0;
      selection.node().removeChildren();
      var _loop_1 = function(i2) {
        var datum = items[i2];
        var shape23 = new Tag({
          className: "breadcrumb-item",
          style: __assign(__assign(__assign(__assign({ transform: "translate(".concat(cursorX, ", ").concat(cursorY, ")") }, tagStyle), { text: isNil(datum.text) ? datum.id : datum.text }), pick_default(datum, ["marker"])), {
            // 强制不需要背景
            padding: 0
          })
        });
        selection.append(function() {
          return shape23;
        });
        var bounds = shape23.getLocalBounds();
        var shapeW = bounds.halfExtents[0] * 2;
        var shapeH = bounds.halfExtents[1] * 2;
        cursorX += shapeW;
        if (!isNil(width)) {
          var avaliableWidth = width - right2;
          if (cursorX > avaliableWidth) {
            shape23.attr({ transform: "translateY(".concat(cursorY + shapeH, ")") });
            cursorX = shapeW;
            cursorY += shapeH;
          }
        }
        this_1.bindInnerEvents(shape23, datum);
        var _c = separator || {}, _d = _c.spacing, spacing = _d === void 0 ? 0 : _d, _e = _c.text, text = _e === void 0 ? "/" : _e, style = _c.style;
        if (i2 !== items.length - 1) {
          var shape_1 = new Text2({
            className: "".concat(Breadcrumb2.tag, "-separator"),
            id: "".concat(Breadcrumb2.tag, "-separator-").concat(i2),
            style: __assign(__assign({ x: cursorX + spacing, y: cursorY + shapeH / 2 }, style), { text, textAlign: "end", textBaseline: "middle" })
          });
          selection.append(function() {
            return shape_1;
          });
          var bounds_1 = shape_1.getLocalBounds();
          cursorX += bounds_1.halfExtents[0] * 2 + spacing;
        }
      };
      var this_1 = this;
      for (var i = 0; i < items.length; i++) {
        _loop_1(i);
      }
    };
    Breadcrumb2.prototype.update = function(cfg) {
      this.attr(deep_mix_default({}, this.attributes, cfg));
      this.render(this.attributes, this);
    };
    Breadcrumb2.prototype.bindInnerEvents = function(shape23, item) {
      var _a2 = this.attributes, items = _a2.items, onClick = _a2.onClick;
      if (onClick) {
        shape23.addEventListener("click", function() {
          onClick.call(shape23, item.id, item, items);
        });
      }
    };
    Breadcrumb2.tag = "breadcrumb";
    Breadcrumb2.defaultOptions = {
      style: {
        separator: {
          text: "/",
          style: {
            fontSize: 14,
            fill: "rgba(0, 0, 0, 0.45)"
          },
          spacing: 8
        },
        textStyle: {
          default: {
            fontSize: 14,
            fill: "rgba(0, 0, 0, 0.45)"
          },
          active: {
            fill: "#5468ff",
            cursor: "pointer"
          }
        },
        padding: [8, 8, 8, 8]
      }
    };
    return Breadcrumb2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/sparkline/columns.js
var Columns = (
  /** @class */
  function(_super) {
    __extends(Columns2, _super);
    function Columns2(_a2) {
      var _this2 = this;
      var style = _a2.style, rest = __rest(_a2, ["style"]);
      _this2 = _super.call(this, deep_mix_default({}, { type: "column" }, __assign({ style }, rest))) || this;
      _this2.columnsGroup = new Group2({ name: "columns" });
      _this2.appendChild(_this2.columnsGroup);
      _this2.render();
      return _this2;
    }
    Columns2.prototype.render = function() {
      var _a2 = this.attributes, columns = _a2.columns, x3 = _a2.x, y3 = _a2.y;
      this.columnsGroup.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
      select2(this.columnsGroup).selectAll(".column").data(columns.flat()).join(function(enter) {
        return enter.append("rect").attr("className", "column").each(function(style) {
          this.attr(style);
        });
      }, function(update2) {
        return update2.each(function(style) {
          this.attr(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    Columns2.prototype.update = function(attr2) {
      this.attr(deepAssign2({}, this.attributes, attr2));
      this.render();
    };
    Columns2.prototype.clear = function() {
      this.removeChildren();
    };
    return Columns2;
  }(DisplayObject)
);

// node_modules/@antv/component/esm/ui/sparkline/lines.js
var Lines = (
  /** @class */
  function(_super) {
    __extends(Lines2, _super);
    function Lines2(_a2) {
      var _this2 = this;
      var style = _a2.style, rest = __rest(_a2, ["style"]);
      _this2 = _super.call(this, deep_mix_default({}, { type: "lines" }, __assign({ style }, rest))) || this;
      _this2.linesGroup = _this2.appendChild(new Group2());
      _this2.areasGroup = _this2.appendChild(new Group2());
      _this2.render();
      return _this2;
    }
    Lines2.prototype.render = function() {
      var _a2 = this.attributes, lines = _a2.lines, areas = _a2.areas, x3 = _a2.x, y3 = _a2.y;
      this.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
      if (lines)
        this.renderLines(lines);
      if (areas)
        this.renderAreas(areas);
    };
    Lines2.prototype.clear = function() {
      this.linesGroup.removeChildren();
      this.areasGroup.removeChildren();
    };
    Lines2.prototype.update = function(attr2) {
      this.attr(deepAssign2({}, this.attributes, attr2));
      this.render();
    };
    Lines2.prototype.renderLines = function(lines) {
      select2(this.linesGroup).selectAll(".line").data(lines).join(function(enter) {
        return enter.append("path").attr("className", "line").each(function(style) {
          this.attr(style);
        });
      }, function(update2) {
        return update2.each(function(style) {
          this.attr(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    Lines2.prototype.renderAreas = function(areas) {
      select2(this.linesGroup).selectAll(".area").data(areas).join(function(enter) {
        return enter.append("path").attr("className", "area").each(function(style) {
          this.attr(style);
        });
      }, function(update2) {
        return update2.each(function(style) {
          this.style(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    return Lines2;
  }(DisplayObject)
);

// node_modules/@antv/component/esm/ui/sparkline/path.js
function dataToLines(data2, scales) {
  var _a2;
  var x3 = scales.x, y3 = scales.y;
  var _b = __read(y3.getOptions().range || [0, 0], 2), max11 = _b[0], min10 = _b[1];
  if (min10 > max11)
    _a2 = __read([max11, min10], 2), min10 = _a2[0], max11 = _a2[1];
  return data2.map(function(points) {
    var lines = points.map(function(val, idx) {
      return [x3.map(idx), clamp_default(y3.map(val), min10, max11)];
    });
    return lines;
  });
}
function lineToLinePath(line4, reverse2) {
  if (reverse2 === void 0) {
    reverse2 = false;
  }
  var M2 = reverse2 ? line4.length - 1 : 0;
  var linePath = line4.map(function(point7, idx) {
    return __spreadArray([idx === M2 ? "M" : "L"], __read(point7), false);
  });
  return reverse2 ? linePath.reverse() : linePath;
}
function lineToCurvePath(line4, reverse2) {
  if (reverse2 === void 0) {
    reverse2 = false;
  }
  if (line4.length <= 2) {
    return lineToLinePath(line4);
  }
  var data2 = [];
  var len5 = line4.length;
  for (var idx = 0; idx < len5; idx += 1) {
    var point7 = reverse2 ? line4[len5 - idx - 1] : line4[idx];
    if (!is_equal_default(point7, data2.slice(-2))) {
      data2.push.apply(data2, __spreadArray([], __read(point7), false));
    }
  }
  var path2 = catmullRom2Bezier(data2, false);
  if (reverse2) {
    path2.unshift(__spreadArray(["M"], __read(line4[len5 - 1]), false));
  } else {
    path2.unshift(__spreadArray(["M"], __read(line4[0]), false));
  }
  return path2;
}
function closePathByBaseLine(path2, width, baseline) {
  var closedPath = clone_default(path2);
  closedPath.push(["L", width, baseline], ["L", 0, baseline], ["Z"]);
  return closedPath;
}
function linesToAreaPaths(lines, smooth3, width, baseline) {
  return lines.map(function(line4) {
    return closePathByBaseLine(smooth3 ? lineToCurvePath(line4) : lineToLinePath(line4), width, baseline);
  });
}
function linesToStackAreaPaths(lines, width, baseline) {
  var paths = [];
  for (var idx = lines.length - 1; idx >= 0; idx -= 1) {
    var currLine = lines[idx];
    var currCurvePath = lineToLinePath(currLine);
    var path2 = void 0;
    if (idx === 0) {
      path2 = closePathByBaseLine(currCurvePath, width, baseline);
    } else {
      var belowLine = lines[idx - 1];
      var belowCurvePath = lineToLinePath(belowLine, true);
      belowCurvePath[0][0] = "L";
      path2 = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [["Z"]], false);
    }
    paths.push(path2);
  }
  return paths;
}
function linesToStackCurveAreaPaths(lines, width, baseline) {
  var paths = [];
  for (var idx = lines.length - 1; idx >= 0; idx -= 1) {
    var currLine = lines[idx];
    var currCurvePath = lineToCurvePath(currLine);
    var path2 = void 0;
    if (idx === 0) {
      path2 = closePathByBaseLine(currCurvePath, width, baseline);
    } else {
      var belowLine = lines[idx - 1];
      var belowCurvePath = lineToCurvePath(belowLine, true);
      var A6 = currLine[0];
      belowCurvePath[0][0] = "L";
      path2 = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [__spreadArray(["M"], __read(A6), false), ["Z"]], false);
    }
    paths.push(path2);
  }
  return paths;
}

// node_modules/@antv/component/esm/ui/sparkline/utils.js
function getRange(data2) {
  if (data2.length === 0)
    return [0, 0];
  return [
    min_default(min_by_default(data2, function(arr) {
      return min_default(arr) || 0;
    })),
    max(max_by_default(data2, function(arr) {
      return max(arr) || 0;
    }))
  ];
}
function getStackedData(_2) {
  var data2 = clone_default(_2);
  var datumLen = data2[0].length;
  var _a2 = __read([Array(datumLen).fill(0), Array(datumLen).fill(0)], 2), positivePrev = _a2[0], negativePrev = _a2[1];
  for (var i = 0; i < data2.length; i += 1) {
    var datum = data2[i];
    for (var j = 0; j < datumLen; j += 1) {
      if (datum[j] >= 0) {
        datum[j] += positivePrev[j];
        positivePrev[j] = datum[j];
      } else {
        datum[j] += negativePrev[j];
        negativePrev[j] = datum[j];
      }
    }
  }
  return data2;
}

// node_modules/@antv/component/esm/ui/sparkline/index.js
var Sparkline = (
  /** @class */
  function(_super) {
    __extends(Sparkline2, _super);
    function Sparkline2(options) {
      return _super.call(this, options, {
        type: "line",
        x: 0,
        y: 0,
        width: 200,
        height: 20,
        isStack: false,
        color: ["#83daad", "#edbf45", "#d2cef9", "#e290b3", "#6f63f4"],
        smooth: true,
        lineLineWidth: 1,
        areaOpacity: 0,
        isGroup: false,
        columnLineWidth: 1,
        columnStroke: "#fff",
        scale: 1,
        spacing: 0
      }) || this;
    }
    Object.defineProperty(Sparkline2.prototype, "rawData", {
      /**
       * 将data统一格式化为数组形式
       * 如果堆叠，则生成堆叠数据
       */
      get: function() {
        var rawData = this.attributes.data;
        if (!rawData || (rawData === null || rawData === void 0 ? void 0 : rawData.length) === 0)
          return [[]];
        var data2 = clone_default(rawData);
        return isNumber(data2[0]) ? [data2] : data2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "data", {
      get: function() {
        if (this.attributes.isStack)
          return getStackedData(this.rawData);
        return this.rawData;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "scales", {
      get: function() {
        return this.createScales(this.data);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "baseline", {
      /**
       * 基准线，默认为 0
       */
      get: function() {
        var y3 = this.scales.y;
        var _a2 = __read(y3.getOptions().domain || [0, 0], 2), y12 = _a2[0], y22 = _a2[1];
        if (y22 < 0) {
          return y3.map(y22);
        }
        return y3.map(y12 < 0 ? 0 : y12);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "containerShape", {
      get: function() {
        var _a2 = this.attributes, width = _a2.width, height = _a2.height;
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "linesStyle", {
      get: function() {
        var _this2 = this;
        var _a2 = this.attributes, type = _a2.type, isStack = _a2.isStack, smooth3 = _a2.smooth;
        if (type !== "line")
          throw new Error("linesStyle can only be used in line type");
        var areaStyle = subStyleProps(this.attributes, "area");
        var lineStyle = subStyleProps(this.attributes, "line");
        var width = this.containerShape.width;
        var data2 = this.data;
        if (data2[0].length === 0)
          return { lines: [], areas: [] };
        var _b = this.scales, x3 = _b.x, y3 = _b.y;
        var lines = dataToLines(data2, { type: "line", x: x3, y: y3 });
        var areas = [];
        if (areaStyle) {
          var baseline = this.baseline;
          if (isStack) {
            areas = smooth3 ? linesToStackCurveAreaPaths(lines, width, baseline) : linesToStackAreaPaths(lines, width, baseline);
          } else {
            areas = linesToAreaPaths(lines, smooth3, width, baseline);
          }
        }
        return {
          lines: lines.map(function(line4, idx) {
            return __assign({ stroke: _this2.getColor(idx), d: smooth3 ? lineToCurvePath(line4) : lineToLinePath(line4) }, lineStyle);
          }),
          areas: areas.map(function(path2, idx) {
            return __assign({ d: path2, fill: _this2.getColor(idx) }, areaStyle);
          })
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "columnsStyle", {
      get: function() {
        var _this2 = this;
        var columnStyle = subStyleProps(this.attributes, "column");
        var _a2 = this.attributes, isStack = _a2.isStack, type = _a2.type, scale11 = _a2.scale;
        if (type !== "column")
          throw new Error("columnsStyle can only be used in column type");
        var height = this.containerShape.height;
        var data2 = this.rawData;
        if (!data2)
          return { columns: [] };
        if (isStack)
          data2 = getStackedData(data2);
        var _b = this.createScales(data2), x3 = _b.x, y3 = _b.y;
        var _c = __read(getRange(data2), 2), minVal = _c[0], maxVal = _c[1];
        var heightScale = new Linear({
          domain: [0, maxVal - (minVal > 0 ? 0 : minVal)],
          range: [0, height * scale11]
        });
        var bandWidth3 = x3.getBandWidth();
        var rawData = this.rawData;
        return {
          columns: data2.map(function(column2, i) {
            return column2.map(function(val, j) {
              var barWidth = bandWidth3 / data2.length;
              var getShape2 = function() {
                return {
                  x: x3.map(j) + barWidth * i,
                  y: val >= 0 ? y3.map(val) : y3.map(0),
                  width: barWidth,
                  height: heightScale.map(Math.abs(val))
                };
              };
              var getStackShape = function() {
                return {
                  x: x3.map(j),
                  y: y3.map(val),
                  width: bandWidth3,
                  height: heightScale.map(rawData[i][j])
                };
              };
              return __assign(__assign({ fill: _this2.getColor(i) }, columnStyle), isStack ? getStackShape() : getShape2());
            });
          })
        };
      },
      enumerable: false,
      configurable: true
    });
    Sparkline2.prototype.render = function(attributes, container) {
      maybeAppend(container, ".container", "rect").attr("className", "container").node();
      var type = attributes.type, x3 = attributes.x, y3 = attributes.y;
      var className2 = "spark".concat(type);
      var style = __assign({ x: x3, y: y3 }, type === "line" ? this.linesStyle : this.columnsStyle);
      select2(container).selectAll(".spark").data([type]).join(function(enter) {
        return enter.append(function(type2) {
          if (type2 === "line")
            return new Lines({ className: className2, style });
          return new Columns({ className: className2, style });
        }).attr("className", "spark ".concat(className2));
      }, function(update2) {
        return update2.update(style);
      }, function(exit) {
        return exit.remove();
      });
    };
    Sparkline2.prototype.getColor = function(index3) {
      var color3 = this.attributes.color;
      if (isArray(color3)) {
        return color3[index3 % color3.length];
      }
      if (isFunction(color3)) {
        return color3.call(null, index3);
      }
      return color3;
    };
    Sparkline2.prototype.createScales = function(data2) {
      var _a2, _b;
      var _c = this.attributes, type = _c.type, scale11 = _c.scale, _d = _c.range, range3 = _d === void 0 ? [] : _d, spacing = _c.spacing;
      var _e = this.containerShape, width = _e.width, height = _e.height;
      var _f = __read(getRange(data2), 2), minVal = _f[0], maxVal = _f[1];
      var yScale = new Linear({
        domain: [(_a2 = range3[0]) !== null && _a2 !== void 0 ? _a2 : minVal, (_b = range3[1]) !== null && _b !== void 0 ? _b : maxVal],
        range: [height, height * (1 - scale11)]
      });
      if (type === "line") {
        return {
          type,
          x: new Linear({
            domain: [0, data2[0].length - 1],
            range: [0, width]
          }),
          y: yScale
        };
      }
      return {
        type,
        x: new Band({
          domain: data2[0].map(function(val, idx) {
            return idx;
          }),
          range: [0, width],
          paddingInner: spacing,
          paddingOuter: spacing / 2,
          align: 0.5
        }),
        y: yScale
      };
    };
    Sparkline2.tag = "sparkline";
    return Sparkline2;
  }(Component)
);

// node_modules/@antv/component/esm/animation/utils.js
function isStandardAnimationOption(option) {
  if (typeof option === "boolean")
    return false;
  return "enter" in option && "update" in option && "exit" in option;
}
function parseAnimationOption(option) {
  if (!option)
    return { enter: false, update: false, exit: false };
  var keys2 = ["enter", "update", "exit"];
  var baseOption = Object.fromEntries(Object.entries(option).filter(function(_a2) {
    var _b = __read(_a2, 1), k2 = _b[0];
    return !keys2.includes(k2);
  }));
  return Object.fromEntries(keys2.map(function(k2) {
    if (isStandardAnimationOption(option)) {
      if (option[k2] === false)
        return [k2, false];
      return [k2, __assign(__assign({}, option[k2]), baseOption)];
    }
    return [k2, baseOption];
  }));
}
function onAnimateFinished(animation, callback) {
  if (!animation)
    callback();
  else
    animation.finished.then(callback);
}
function onAnimatesFinished(animations, callback) {
  if (animations.length === 0)
    callback();
  else
    Promise.all(animations.map(function(a4) {
      return a4 === null || a4 === void 0 ? void 0 : a4.finished;
    })).then(callback);
}
function attr(target, value2) {
  if ("update" in target)
    target.update(value2);
  else
    target.attr(value2);
}
function animate(target, keyframes, options) {
  if (keyframes.length === 0)
    return null;
  if (!options) {
    var state = keyframes.slice(-1)[0];
    attr(target, { style: state });
    return null;
  }
  return target.animate(keyframes, options);
}
function identicalTextNode(source, target) {
  if (source.nodeName !== "text" || target.nodeName !== "text")
    return false;
  if (source.attributes.text !== target.attributes.text)
    return false;
  return true;
}
function transitionShape(source, target, options, after) {
  if (after === void 0) {
    after = "destroy";
  }
  if (identicalTextNode(source, target)) {
    source.remove();
    return [null];
  }
  var afterTransition = function() {
    if (after === "destroy")
      source.destroy();
    else if (after === "hide")
      hide(source);
    if (target.isVisible())
      show(target);
  };
  if (!options) {
    afterTransition();
    return [null];
  }
  var _a2 = options.duration, duration = _a2 === void 0 ? 0 : _a2, _b = options.delay, delay = _b === void 0 ? 0 : _b;
  var middle = Math.ceil(+duration / 2);
  var offset2 = +duration / 4;
  var _c = __read(source.getGeometryBounds().center, 2), sx = _c[0], sy = _c[1];
  var _d = __read(target.getGeometryBounds().center, 2), ex = _d[0], ey = _d[1];
  var _e = __read([(sx + ex) / 2 - sx, (sy + ey) / 2 - sy], 2), mx = _e[0], my = _e[1];
  var _f = source.style.opacity, so = _f === void 0 ? 1 : _f;
  var _g = target.style.opacity, to = _g === void 0 ? 1 : _g;
  var st = source.style.transform || "";
  var tt = target.style.transform || "";
  var sourceAnimation = source.animate([
    { opacity: so, transform: "translate(0, 0) ".concat(st) },
    { opacity: 0, transform: "translate(".concat(mx, ", ").concat(my, ") ").concat(st) }
  ], __assign(__assign({ fill: "both" }, options), { duration: delay + middle + offset2 }));
  var targetAnimation = target.animate([
    { opacity: 0, transform: "translate(".concat(-mx, ", ").concat(-my, ") ").concat(tt), offset: 0.01 },
    { opacity: to, transform: "translate(0, 0) ".concat(tt) }
  ], __assign(__assign({ fill: "both" }, options), { duration: middle + offset2, delay: delay + middle - offset2 }));
  onAnimateFinished(targetAnimation, afterTransition);
  return [sourceAnimation, targetAnimation];
}
function transition(target, state, options) {
  var from = {};
  var to = {};
  Object.entries(state).forEach(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], tarStyle = _b[1];
    if (!isNil(tarStyle)) {
      var currStyle = target.style[key] || target.parsedStyle[key] || 0;
      if (currStyle !== tarStyle) {
        from[key] = currStyle;
        to[key] = tarStyle;
      }
    }
  });
  if (!options) {
    attr(target, to);
    return null;
  }
  return animate(target, [from, to], __assign({ fill: "both" }, options));
}

// node_modules/@antv/component/esm/animation/fadeOut.js
function fadeOut_default(element, options) {
  if (!element.style.opacity)
    element.style.opacity = 1;
  return transition(element, { opacity: 0 }, options);
}

// node_modules/@antv/component/esm/ui/slider/constant.js
var HANDLE_ICON_DEFAULT_CFG = {
  fill: "#fff",
  lineWidth: 1,
  radius: 2,
  size: 10,
  stroke: "#bfbfbf",
  strokeOpacity: 1,
  zIndex: 0
};
var HANDLE_LABEL_DEFAULT_CFG = {
  fill: "#000",
  fillOpacity: 0.45,
  fontSize: 12,
  textAlign: "center",
  textBaseline: "middle",
  zIndex: 1
};
var HANDLE_DEFAULT_CFG = {
  x: 0,
  y: 0,
  orientation: "horizontal",
  showLabel: true,
  type: "start"
};
var CLASS_NAMES = classNames({
  foreground: "foreground",
  handle: "handle",
  selection: "selection",
  sparkline: "sparkline",
  sparklineGroup: "sparkline-group",
  track: "track",
  brushArea: "brush-area"
}, "slider");

// node_modules/@antv/component/esm/ui/slider/handle.js
var CLASS_NAMES2 = classNames({
  labelGroup: "label-group",
  label: "label",
  iconGroup: "icon-group",
  icon: "icon",
  iconRect: "icon-rect",
  iconLine: "icon-line"
}, "handle");
var HandleIcon = (
  /** @class */
  function(_super) {
    __extends(HandleIcon2, _super);
    function HandleIcon2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HandleIcon2.prototype.render = function(attributes, container) {
      var x3 = attributes.x, y3 = attributes.y, _a2 = attributes.size, size3 = _a2 === void 0 ? 10 : _a2, _b = attributes.radius, radius = _b === void 0 ? size3 / 4 : _b, orientation = attributes.orientation, iconStyle = __rest(attributes, ["x", "y", "size", "radius", "orientation"]);
      var width = size3;
      var height = width * 2.4;
      var rect4 = select2(container).maybeAppendByClassName(CLASS_NAMES2.iconRect, "rect").styles(__assign(__assign({}, iconStyle), { width, height, radius, x: x3 - width / 2, y: y3 - height / 2, transformOrigin: "center" }));
      var x12 = x3 + 1 / 3 * width - width / 2;
      var x22 = x3 + 2 / 3 * width - width / 2;
      var y12 = y3 + 1 / 4 * height - height / 2;
      var y22 = y3 + 3 / 4 * height - height / 2;
      rect4.maybeAppendByClassName("".concat(CLASS_NAMES2.iconLine, "-1"), "line").styles(__assign({ x1: x12, x2: x12, y1: y12, y2: y22 }, iconStyle));
      rect4.maybeAppendByClassName("".concat(CLASS_NAMES2.iconLine, "-2"), "line").styles(__assign({ x1: x22, x2: x22, y1: y12, y2: y22 }, iconStyle));
      if (orientation === "vertical")
        rect4.node().style.transform = "rotate(90)";
    };
    return HandleIcon2;
  }(Component)
);
var Handle = (
  /** @class */
  function(_super) {
    __extends(Handle3, _super);
    function Handle3(options) {
      return _super.call(this, options, HANDLE_DEFAULT_CFG) || this;
    }
    Handle3.prototype.renderLabel = function(container) {
      var _this2 = this;
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, showLabel = _a2.showLabel;
      var _b = subStyleProps(this.attributes, "label"), _c = _b.x, labelX = _c === void 0 ? 0 : _c, _d = _b.y, labelY = _d === void 0 ? 0 : _d, transform2 = _b.transform, transformOrigin = _b.transformOrigin, style = __rest(_b, ["x", "y", "transform", "transformOrigin"]);
      var _e = __read(splitStyle(style, []), 2), labelStyle = _e[0], groupStyle = _e[1];
      var labelGroup = select2(container).maybeAppendByClassName(CLASS_NAMES2.labelGroup, "g").styles(groupStyle);
      var _f = __assign(__assign({}, HANDLE_LABEL_DEFAULT_CFG), labelStyle), text = _f.text, rest = __rest(_f, ["text"]);
      ifShow(!!showLabel, labelGroup, function(group3) {
        _this2.label = group3.maybeAppendByClassName(CLASS_NAMES2.label, "text").styles(__assign(__assign({}, rest), { x: x3 + labelX, y: y3 + labelY, transform: transform2, transformOrigin, text: "".concat(text) }));
        _this2.label.on("mousedown", function(e) {
          e.stopPropagation();
        });
        _this2.label.on("touchstart", function(e) {
          e.stopPropagation();
        });
      });
    };
    Handle3.prototype.renderIcon = function(container) {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, orientation = _a2.orientation, type = _a2.type;
      var iconStyle = __assign(__assign({ x: x3, y: y3, orientation }, HANDLE_ICON_DEFAULT_CFG), subStyleProps(this.attributes, "icon"));
      var _b = this.attributes.iconShape, iconShape = _b === void 0 ? function() {
        return new HandleIcon({ style: iconStyle });
      } : _b;
      var iconGroup = select2(container).maybeAppendByClassName(CLASS_NAMES2.iconGroup, "g");
      iconGroup.selectAll(CLASS_NAMES2.icon.class).data([iconShape]).join(function(enter) {
        return enter.append(typeof iconShape === "string" ? iconShape : function() {
          return iconShape(type);
        }).attr("className", CLASS_NAMES2.icon.name);
      }, function(update2) {
        return update2.update(iconStyle);
      }, function(exit) {
        return exit.remove();
      });
    };
    Handle3.prototype.render = function(attributes, container) {
      this.renderIcon(container);
      this.renderLabel(container);
    };
    return Handle3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/slider/index.js
var Slider = (
  /** @class */
  function(_super) {
    __extends(Slider3, _super);
    function Slider3(options) {
      var _this2 = _super.call(this, options, __assign(__assign(__assign({ x: 0, y: 0, animate: { duration: 100, fill: "both" }, brushable: true, formatter: function(val) {
        return val.toString();
      }, handleSpacing: 2, orientation: "horizontal", padding: 0, autoFitLabel: true, scrollable: true, selectionFill: "#5B8FF9", selectionFillOpacity: 0.45, selectionZIndex: 2, showHandle: true, showLabel: true, slidable: true, trackFill: "#416180", trackLength: 200, trackOpacity: 0.05, trackSize: 20, trackZIndex: -1, values: [0, 1], type: "range", selectionType: "select", handleIconOffset: 0 }, superStyleProps(HANDLE_DEFAULT_CFG, "handle")), superStyleProps(HANDLE_ICON_DEFAULT_CFG, "handleIcon")), superStyleProps(HANDLE_LABEL_DEFAULT_CFG, "handleLabel"))) || this;
      _this2.range = [0, 1];
      _this2.onDragStart = function(target) {
        return function(e) {
          e.stopPropagation();
          _this2.target = target;
          _this2.prevPos = _this2.getOrientVal(getEventPos(e));
          var _a2 = _this2.availableSpace, x3 = _a2.x, y3 = _a2.y;
          var _b = _this2.getBBox(), X = _b.x, Y = _b.y;
          _this2.selectionStartPos = _this2.getRatio(_this2.prevPos - _this2.getOrientVal([x3, y3]) - _this2.getOrientVal([+X, +Y]));
          _this2.selectionWidth = 0;
          document.addEventListener("pointermove", _this2.onDragging);
          document.addEventListener("pointerup", _this2.onDragEnd);
        };
      };
      _this2.onDragging = function(e) {
        var _a2 = _this2.attributes, slidable = _a2.slidable, brushable = _a2.brushable, type = _a2.type;
        e.stopPropagation();
        var currPos = _this2.getOrientVal(getEventPos(e));
        var diffPos = currPos - _this2.prevPos;
        if (!diffPos)
          return;
        var deltaVal = _this2.getRatio(diffPos);
        switch (_this2.target) {
          case "start":
            if (slidable)
              _this2.setValuesOffset(deltaVal);
            break;
          case "end":
            if (slidable)
              _this2.setValuesOffset(0, deltaVal);
            break;
          case "selection":
            if (slidable)
              _this2.setValuesOffset(deltaVal, deltaVal);
            break;
          case "track":
            if (!brushable)
              return;
            _this2.selectionWidth += deltaVal;
            if (type === "range") {
              _this2.innerSetValues([_this2.selectionStartPos, _this2.selectionStartPos + _this2.selectionWidth].sort(), true);
            } else
              _this2.innerSetValues([0, _this2.selectionStartPos + _this2.selectionWidth], true);
            break;
          default:
            break;
        }
        _this2.prevPos = currPos;
      };
      _this2.onDragEnd = function() {
        document.removeEventListener("pointermove", _this2.onDragging);
        document.removeEventListener("pointermove", _this2.onDragging);
        document.removeEventListener("pointerup", _this2.onDragEnd);
        _this2.target = "";
        _this2.updateHandlesPosition(false);
      };
      _this2.onValueChange = function(oldValue) {
        var _a2 = _this2.attributes, onChange = _a2.onChange, type = _a2.type;
        var internalOldValue = type === "range" ? oldValue : oldValue[1];
        var value2 = type === "range" ? _this2.getValues() : _this2.getValues()[1];
        var evt = new CustomEvent("valuechange", {
          detail: { oldValue: internalOldValue, value: value2 }
        });
        _this2.dispatchEvent(evt);
        onChange === null || onChange === void 0 ? void 0 : onChange(value2);
      };
      _this2.selectionStartPos = 0;
      _this2.selectionWidth = 0;
      _this2.prevPos = 0;
      _this2.target = "";
      return _this2;
    }
    Object.defineProperty(Slider3.prototype, "values", {
      get: function() {
        return this.attributes.values;
      },
      set: function(values4) {
        this.attributes.values = this.clampValues(values4);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slider3.prototype, "sparklineStyle", {
      get: function() {
        var orientation = this.attributes.orientation;
        if (orientation !== "horizontal")
          return null;
        var attr2 = subStyleProps(this.attributes, "sparkline");
        return __assign(__assign({ zIndex: 0 }, this.availableSpace), attr2);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slider3.prototype, "shape", {
      get: function() {
        var _a2 = this.attributes, trackLength = _a2.trackLength, trackSize = _a2.trackSize;
        var _b = __read(this.getOrientVal([
          [trackLength, trackSize],
          [trackSize, trackLength]
        ]), 2), width = _b[0], height = _b[1];
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slider3.prototype, "availableSpace", {
      get: function() {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, padding = _a2.padding;
        var _b = __read(parseSeriesAttr(padding), 4), top = _b[0], right2 = _b[1], bottom = _b[2], left2 = _b[3];
        var _c = this.shape, width = _c.width, height = _c.height;
        return {
          x: left2,
          y: top,
          width: width - (left2 + right2),
          height: height - (top + bottom)
        };
      },
      enumerable: false,
      configurable: true
    });
    Slider3.prototype.getValues = function() {
      return this.values;
    };
    Slider3.prototype.setValues = function(values4, animate2) {
      if (values4 === void 0) {
        values4 = [0, 0];
      }
      if (animate2 === void 0) {
        animate2 = false;
      }
      this.attributes.values = values4;
      var animation = animate2 === false ? false : this.attributes.animate;
      this.updateSelectionArea(animation);
      this.updateHandlesPosition(animation);
    };
    Slider3.prototype.updateSelectionArea = function(animation) {
      var newSelectionArea = this.calcSelectionArea();
      this.foregroundGroup.selectAll(CLASS_NAMES.selection.class).each(function(datum, index3) {
        transition(this, newSelectionArea[index3], animation);
      });
    };
    Slider3.prototype.updateHandlesPosition = function(animation) {
      if (!this.attributes.showHandle)
        return;
      this.startHandle && transition(this.startHandle, this.getHandleStyle("start"), animation);
      this.endHandle && transition(this.endHandle, this.getHandleStyle("end"), animation);
    };
    Slider3.prototype.innerSetValues = function(values4, trigger) {
      if (values4 === void 0) {
        values4 = [0, 0];
      }
      if (trigger === void 0) {
        trigger = false;
      }
      var oldValues = this.values;
      var newValues = this.clampValues(values4);
      this.attributes.values = newValues;
      this.setValues(newValues);
      if (trigger) {
        this.onValueChange(oldValues);
      }
    };
    Slider3.prototype.renderTrack = function(container) {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y;
      var style = subStyleProps(this.attributes, "track");
      this.trackShape = select2(container).maybeAppendByClassName(CLASS_NAMES.track, "rect").styles(__assign(__assign({ x: x3, y: y3 }, this.shape), style));
    };
    Slider3.prototype.renderBrushArea = function(container) {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, brushable = _a2.brushable;
      this.brushArea = select2(container).maybeAppendByClassName(CLASS_NAMES.brushArea, "rect").styles(__assign({ x: x3, y: y3, fill: "transparent", cursor: brushable ? "crosshair" : "default" }, this.shape));
    };
    Slider3.prototype.renderSparkline = function(container) {
      var _this2 = this;
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, orientation = _a2.orientation;
      var sparklineGroup = select2(container).maybeAppendByClassName(CLASS_NAMES.sparklineGroup, "g");
      ifShow(orientation === "horizontal", sparklineGroup, function(group3) {
        var style = __assign(__assign({}, _this2.sparklineStyle), { x: x3, y: y3 });
        group3.maybeAppendByClassName(CLASS_NAMES.sparkline, function() {
          return new Sparkline({ style });
        }).update(style);
      });
    };
    Slider3.prototype.renderHandles = function() {
      var _this2 = this;
      var _a2;
      var _b = this.attributes, showHandle = _b.showHandle, type = _b.type;
      var availableHandle = type === "range" ? ["start", "end"] : ["end"];
      var data2 = showHandle ? availableHandle : [];
      var that = this;
      (_a2 = this.foregroundGroup) === null || _a2 === void 0 ? void 0 : _a2.selectAll(CLASS_NAMES.handle.class).data(data2.map(function(type2) {
        return { type: type2 };
      }), function(d3) {
        return d3.type;
      }).join(function(enter) {
        return enter.append(function(_a3) {
          var type2 = _a3.type;
          return new Handle({ style: _this2.getHandleStyle(type2) });
        }).each(function(_a3) {
          var type2 = _a3.type;
          this.attr("class", "".concat(CLASS_NAMES.handle.name, " ").concat(type2, "-handle"));
          var name2 = "".concat(type2, "Handle");
          that[name2] = this;
          this.addEventListener("pointerdown", that.onDragStart(type2));
        });
      }, function(update2) {
        return update2.each(function(_a3) {
          var type2 = _a3.type;
          this.update(that.getHandleStyle(type2));
        });
      }, function(exit) {
        return exit.each(function(_a3) {
          var type2 = _a3.type;
          var name2 = "".concat(type2, "Handle");
          that[name2] = void 0;
        }).remove();
      });
    };
    Slider3.prototype.renderSelection = function(container) {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, type = _a2.type, selectionType = _a2.selectionType;
      this.foregroundGroup = select2(container).maybeAppendByClassName(CLASS_NAMES.foreground, "g");
      var selectionStyle = subStyleProps(this.attributes, "selection");
      var applyStyle4 = function(selection) {
        return selection.style("visibility", function(d3) {
          return d3.show ? "visible" : "hidden";
        }).style("cursor", function(d3) {
          if (selectionType === "select")
            return "grab";
          if (selectionType === "invert")
            return "crosshair";
          return "default";
        }).styles(__assign(__assign({}, selectionStyle), { transform: "translate(".concat(x3, ", ").concat(y3, ")") }));
      };
      var that = this;
      this.foregroundGroup.selectAll(CLASS_NAMES.selection.class).data(type === "value" ? [] : this.calcSelectionArea().map(function(area2, index3) {
        return {
          style: __assign({}, area2),
          index: index3,
          // 是否可见
          show: selectionType === "select" ? index3 === 1 : index3 !== 1
        };
      }), function(d3) {
        return d3.index;
      }).join(function(enter) {
        return enter.append("rect").attr("className", CLASS_NAMES.selection.name).call(applyStyle4).each(function(datum, index3) {
          var _this2 = this;
          if (index3 === 1) {
            that.selectionShape = select2(this);
            this.on("pointerdown", function(e) {
              _this2.attr("cursor", "grabbing");
              that.onDragStart("selection")(e);
            });
            that.dispatchCustomEvent(this, "pointerenter", "selectionMouseenter");
            that.dispatchCustomEvent(this, "pointerleave", "selectionMouseleave");
            that.dispatchCustomEvent(this, "click", "selectionClick");
            this.addEventListener("pointerdown", function() {
              _this2.attr("cursor", "grabbing");
            });
            this.addEventListener("pointerup", function() {
              _this2.attr("cursor", "pointer");
            });
            this.addEventListener("pointerover", function() {
              _this2.attr("cursor", "pointer");
            });
          } else {
            this.on("pointerdown", that.onDragStart("track"));
          }
        });
      }, function(update2) {
        return update2.call(applyStyle4);
      }, function(exit) {
        return exit.remove();
      });
      this.updateSelectionArea(false);
      this.renderHandles();
    };
    Slider3.prototype.render = function(attributes, container) {
      this.renderTrack(container);
      this.renderSparkline(container);
      this.renderBrushArea(container);
      this.renderSelection(container);
    };
    Slider3.prototype.clampValues = function(values4, precision) {
      var _a2;
      if (precision === void 0) {
        precision = 4;
      }
      var _b = __read(this.range, 2), min10 = _b[0], max11 = _b[1];
      var _c = __read(this.getValues().map(function(num) {
        return toPrecision(num, precision);
      }), 2), prevStart = _c[0], prevEnd = _c[1];
      var internalValues = Array.isArray(values4) ? values4 : [prevStart, values4 !== null && values4 !== void 0 ? values4 : prevEnd];
      var _d = __read((internalValues || [prevStart, prevEnd]).map(function(num) {
        return toPrecision(num, precision);
      }), 2), startVal = _d[0], endVal = _d[1];
      if (this.attributes.type === "value")
        return [0, clamp_default(endVal, min10, max11)];
      if (startVal > endVal) {
        _a2 = __read([endVal, startVal], 2), startVal = _a2[0], endVal = _a2[1];
      }
      var range3 = endVal - startVal;
      if (range3 > max11 - min10)
        return [min10, max11];
      if (startVal < min10) {
        if (prevStart === min10 && prevEnd === endVal)
          return [min10, endVal];
        return [min10, range3 + min10];
      }
      if (endVal > max11) {
        if (prevEnd === max11 && prevStart === startVal)
          return [startVal, max11];
        return [max11 - range3, max11];
      }
      return [startVal, endVal];
    };
    Slider3.prototype.calcSelectionArea = function(values4) {
      var _a2 = __read(this.clampValues(values4), 2), start = _a2[0], end = _a2[1];
      var _b = this.availableSpace, x3 = _b.x, y3 = _b.y, width = _b.width, height = _b.height;
      return this.getOrientVal([
        [
          { y: y3, height, x: x3, width: start * width },
          { y: y3, height, x: start * width + x3, width: (end - start) * width },
          { y: y3, height, x: end * width, width: (1 - end) * width }
        ],
        [
          { x: x3, width, y: y3, height: start * height },
          { x: x3, width, y: start * height + y3, height: (end - start) * height },
          { x: x3, width, y: end * height, height: (1 - end) * height }
        ]
      ]);
    };
    Slider3.prototype.calcHandlePosition = function(handleType) {
      var handleIconOffset = this.attributes.handleIconOffset;
      var _a2 = this.availableSpace, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
      var _b = __read(this.clampValues(), 2), stVal = _b[0], endVal = _b[1];
      var offset2 = handleType === "start" ? -handleIconOffset : handleIconOffset;
      var L = (handleType === "start" ? stVal : endVal) * this.getOrientVal([width, height]) + offset2;
      return {
        x: x3 + this.getOrientVal([L, width / 2]),
        y: y3 + this.getOrientVal([height / 2, L])
      };
    };
    Slider3.prototype.inferTextStyle = function(handleType) {
      var orientation = this.attributes.orientation;
      if (orientation === "horizontal")
        return {};
      if (handleType === "start")
        return { transformOrigin: "left center", transform: "rotate(90)", textAlign: "start" };
      if (handleType === "end")
        return { transformOrigin: "right center", transform: "rotate(90)", textAlign: "end" };
      return {};
    };
    Slider3.prototype.calcHandleText = function(handleType) {
      var _a2;
      var _b = this.attributes, type = _b.type, orientation = _b.orientation, formatter2 = _b.formatter, autoFitLabel = _b.autoFitLabel;
      var handleStyle = subStyleProps(this.attributes, "handle");
      var labelStyle = subStyleProps(handleStyle, "label");
      var spacing = handleStyle.spacing;
      var size3 = this.getHandleSize();
      var values4 = this.clampValues();
      var value2 = handleType === "start" ? values4[0] : values4[1];
      var text = formatter2(value2);
      var temp = new Text2({
        style: __assign(__assign(__assign({}, labelStyle), this.inferTextStyle(handleType)), { text })
      });
      var _c = temp.getBBox(), textWidth = _c.width, textHeight = _c.height;
      temp.destroy();
      if (!autoFitLabel) {
        if (type === "value")
          return { text, x: 0, y: -textHeight - spacing };
        var finaleWidth = spacing + size3 + (orientation === "horizontal" ? textWidth / 2 : 0);
        return _a2 = { text }, _a2[orientation === "horizontal" ? "x" : "y"] = handleType === "start" ? -finaleWidth : finaleWidth, _a2;
      }
      var x3 = 0;
      var y3 = 0;
      var _d = this.availableSpace, iW = _d.width, iH = _d.height;
      var _e = this.calcSelectionArea()[1], fX = _e.x, fY = _e.y, fW = _e.width, fH = _e.height;
      var totalSpacing = spacing + size3;
      if (orientation === "horizontal") {
        var finalWidth = totalSpacing + textWidth / 2;
        if (handleType === "start") {
          var left2 = fX - totalSpacing - textWidth;
          x3 = left2 > 0 ? -finalWidth : finalWidth;
        } else {
          var sign3 = iW - fX - fW - totalSpacing > textWidth;
          x3 = sign3 ? finalWidth : -finalWidth;
        }
      } else {
        var positiveSize = totalSpacing;
        var negativeSize = textHeight + totalSpacing;
        if (handleType === "start") {
          y3 = fY - size3 > textHeight ? -negativeSize : positiveSize;
        } else {
          y3 = iH - (fY + fH) - size3 > textHeight ? negativeSize : -positiveSize;
        }
      }
      return { x: x3, y: y3, text };
    };
    Slider3.prototype.getHandleLabelStyle = function(handleType) {
      var style = subStyleProps(this.attributes, "handleLabel");
      return __assign(__assign(__assign({}, style), this.calcHandleText(handleType)), this.inferTextStyle(handleType));
    };
    Slider3.prototype.getHandleIconStyle = function() {
      var shape23 = this.attributes.handleIconShape;
      var style = subStyleProps(this.attributes, "handleIcon");
      var cursor = this.getOrientVal(["ew-resize", "ns-resize"]);
      var size3 = this.getHandleSize();
      return __assign({ cursor, shape: shape23, size: size3 }, style);
    };
    Slider3.prototype.getHandleStyle = function(handleType) {
      var _a2 = this.attributes, ox = _a2.x, oy = _a2.y, showLabel = _a2.showLabel, showLabelOnInteraction = _a2.showLabelOnInteraction, orientation = _a2.orientation;
      var _b = this.calcHandlePosition(handleType), x3 = _b.x, y3 = _b.y;
      var textStyle = this.calcHandleText(handleType);
      var internalShowLabel = showLabel;
      if (!showLabel && showLabelOnInteraction) {
        if (this.target)
          internalShowLabel = true;
        else
          internalShowLabel = false;
      }
      return __assign(__assign(__assign({}, superStyleProps(this.getHandleIconStyle(), "icon")), superStyleProps(__assign(__assign({}, this.getHandleLabelStyle(handleType)), textStyle), "label")), { transform: "translate(".concat(x3 + ox, ", ").concat(y3 + oy, ")"), orientation, showLabel: internalShowLabel, type: handleType, zIndex: 3 });
    };
    Slider3.prototype.getHandleSize = function() {
      var _a2 = this.attributes, size3 = _a2.handleIconSize, width = _a2.width, height = _a2.height;
      if (size3)
        return size3;
      return Math.floor((this.getOrientVal([+height, +width]) + 4) / 2.4);
    };
    Slider3.prototype.getOrientVal = function(_a2) {
      var _b = __read(_a2, 2), x3 = _b[0], y3 = _b[1];
      var orientation = this.attributes.orientation;
      return orientation === "horizontal" ? x3 : y3;
    };
    Slider3.prototype.setValuesOffset = function(stOffset, endOffset, animate2) {
      if (endOffset === void 0) {
        endOffset = 0;
      }
      if (animate2 === void 0) {
        animate2 = false;
      }
      var type = this.attributes.type;
      var _a2 = __read(this.getValues(), 2), oldStartVal = _a2[0], oldEndVal = _a2[1];
      var internalStartOffset = type === "range" ? stOffset : 0;
      var values4 = [oldStartVal + internalStartOffset, oldEndVal + endOffset].sort();
      if (animate2)
        this.setValues(values4);
      else
        this.innerSetValues(values4, true);
    };
    Slider3.prototype.getRatio = function(val) {
      var _a2 = this.availableSpace, width = _a2.width, height = _a2.height;
      return val / this.getOrientVal([width, height]);
    };
    Slider3.prototype.dispatchCustomEvent = function(target, event, name2) {
      var _this2 = this;
      target.on(event, function(e) {
        e.stopPropagation();
        _this2.dispatchEvent(new CustomEvent(name2, { detail: e }));
      });
    };
    Slider3.prototype.bindEvents = function() {
      this.addEventListener("wheel", this.onScroll);
      var brushArea = this.brushArea;
      this.dispatchCustomEvent(brushArea, "click", "trackClick");
      this.dispatchCustomEvent(brushArea, "pointerenter", "trackMouseenter");
      this.dispatchCustomEvent(brushArea, "pointerleave", "trackMouseleave");
      brushArea.on("pointerdown", this.onDragStart("track"));
    };
    Slider3.prototype.onScroll = function(event) {
      var scrollable = this.attributes.scrollable;
      if (scrollable) {
        var deltaX = event.deltaX, deltaY = event.deltaY;
        var offset2 = deltaY || deltaX;
        var deltaVal = this.getRatio(offset2);
        this.setValuesOffset(deltaVal, deltaVal, true);
      }
    };
    Slider3.tag = "slider";
    return Slider3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/scrollbar/index.js
var Scrollbar = (
  /** @class */
  function(_super) {
    __extends(Scrollbar3, _super);
    function Scrollbar3(options) {
      var _this2 = _super.call(this, options, {
        x: 0,
        y: 0,
        isRound: true,
        orientation: "vertical",
        padding: [2, 2, 2, 2],
        scrollable: true,
        slidable: true,
        thumbCursor: "default",
        trackSize: 10,
        value: 0
      }) || this;
      _this2.range = [0, 1];
      _this2.onValueChange = function(oldValue) {
        var newValue = _this2.attributes.value;
        if (oldValue === newValue)
          return;
        var evtVal = {
          detail: {
            oldValue,
            value: newValue
          }
        };
        _this2.dispatchEvent(new CustomEvent("scroll", evtVal));
        _this2.dispatchEvent(new CustomEvent("valuechange", evtVal));
      };
      _this2.onTrackClick = function(e) {
        var slidable = _this2.attributes.slidable;
        if (!slidable)
          return;
        var _a2 = __read(_this2.getLocalPosition(), 2), x3 = _a2[0], y3 = _a2[1];
        var _b = __read(_this2.padding, 4), top = _b[0], left2 = _b[3];
        var basePos = _this2.getOrientVal([x3 + left2, y3 + top]);
        var clickPos = _this2.getOrientVal(getEventPos(e));
        var value2 = (clickPos - basePos) / _this2.trackLength;
        _this2.setValue(value2, true);
      };
      _this2.onThumbMouseenter = function(e) {
        _this2.dispatchEvent(new CustomEvent("thumbMouseenter", { detail: e.detail }));
      };
      _this2.onTrackMouseenter = function(e) {
        _this2.dispatchEvent(new CustomEvent("trackMouseenter", { detail: e.detail }));
      };
      _this2.onThumbMouseleave = function(e) {
        _this2.dispatchEvent(new CustomEvent("thumbMouseleave", { detail: e.detail }));
      };
      _this2.onTrackMouseleave = function(e) {
        _this2.dispatchEvent(new CustomEvent("trackMouseleave", { detail: e.detail }));
      };
      return _this2;
    }
    Object.defineProperty(Scrollbar3.prototype, "padding", {
      get: function() {
        var padding = this.attributes.padding;
        return parseSeriesAttr(padding);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar3.prototype, "value", {
      get: function() {
        var value2 = this.attributes.value;
        var _a2 = __read(this.range, 2), min10 = _a2[0], max11 = _a2[1];
        return clamp_default(value2, min10, max11);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar3.prototype, "trackLength", {
      get: function() {
        var _a2 = this.attributes, viewportLength = _a2.viewportLength, _b = _a2.trackLength, trackLength = _b === void 0 ? viewportLength : _b;
        return trackLength;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar3.prototype, "availableSpace", {
      get: function() {
        var trackSize = this.attributes.trackSize;
        var trackLength = this.trackLength;
        var _a2 = __read(this.padding, 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
        var _b = __read(this.getOrientVal([
          [trackLength, trackSize],
          [trackSize, trackLength]
        ]), 2), width = _b[0], height = _b[1];
        return {
          x: left2,
          y: top,
          width: +width - (left2 + right2),
          height: +height - (top + bottom)
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar3.prototype, "trackRadius", {
      get: function() {
        var _a2 = this.attributes, isRound = _a2.isRound, trackSize = _a2.trackSize;
        if (!isRound)
          return 0;
        return trackSize / 2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar3.prototype, "thumbRadius", {
      get: function() {
        var _a2 = this.attributes, isRound = _a2.isRound, thumbRadius = _a2.thumbRadius;
        if (!isRound)
          return 0;
        var _b = this.availableSpace, width = _b.width, height = _b.height;
        return thumbRadius || this.getOrientVal([height, width]) / 2;
      },
      enumerable: false,
      configurable: true
    });
    Scrollbar3.prototype.getValues = function(value2) {
      if (value2 === void 0) {
        value2 = this.value;
      }
      var _a2 = this.attributes, viewportLength = _a2.viewportLength, contentLength = _a2.contentLength;
      var unit = viewportLength / contentLength;
      var _b = __read(this.range, 2), min10 = _b[0], max11 = _b[1];
      var start = value2 * (max11 - min10 - unit);
      return [start, start + unit];
    };
    Scrollbar3.prototype.getValue = function() {
      return this.value;
    };
    Scrollbar3.prototype.renderSlider = function(container) {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, orientation = _a2.orientation, trackSize = _a2.trackSize, padding = _a2.padding, slidable = _a2.slidable;
      var trackStyle = subStyleProps(this.attributes, "track");
      var selectionStyle = subStyleProps(this.attributes, "thumb");
      var style = __assign(__assign({ x: x3, y: y3, brushable: false, orientation, padding, selectionRadius: this.thumbRadius, showHandle: false, slidable, trackLength: this.trackLength, trackRadius: this.trackRadius, trackSize, values: this.getValues() }, superStyleProps(trackStyle, "track")), superStyleProps(selectionStyle, "selection"));
      this.slider = select2(container).maybeAppendByClassName("scrollbar", function() {
        return new Slider({ style });
      }).update(style).node();
    };
    Scrollbar3.prototype.render = function(attributes, container) {
      this.renderSlider(container);
    };
    Scrollbar3.prototype.setValue = function(value2, animate2) {
      if (animate2 === void 0) {
        animate2 = false;
      }
      var oldValue = this.attributes.value;
      var _a2 = __read(this.range, 2), min10 = _a2[0], max11 = _a2[1];
      this.slider.setValues(this.getValues(clamp_default(value2, min10, max11)), animate2);
      this.onValueChange(oldValue);
    };
    Scrollbar3.prototype.bindEvents = function() {
      var _this2 = this;
      this.slider.addEventListener("trackClick", function(e) {
        e.stopPropagation();
        _this2.onTrackClick(e.detail);
      });
      this.onHover();
    };
    Scrollbar3.prototype.getOrientVal = function(values4) {
      var orientation = this.attributes.orientation;
      return orientation === "horizontal" ? values4[0] : values4[1];
    };
    Scrollbar3.prototype.onHover = function() {
      this.slider.addEventListener("selectionMouseenter", this.onThumbMouseenter);
      this.slider.addEventListener("trackMouseenter", this.onTrackMouseenter);
      this.slider.addEventListener("selectionMouseleave", this.onThumbMouseleave);
      this.slider.addEventListener("trackMouseleave", this.onTrackMouseleave);
    };
    Scrollbar3.tag = "scrollbar";
    return Scrollbar3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/axis/constant.js
var AXIS_BASE_DEFAULT_ATTR = {
  data: [],
  animate: {
    enter: false,
    update: {
      duration: 100,
      easing: "ease-in-out-sine",
      fill: "both"
    },
    exit: {
      duration: 100,
      fill: "both"
    }
  },
  showArrow: true,
  showGrid: true,
  showLabel: true,
  showLine: true,
  showTick: true,
  showTitle: true,
  showTrunc: false,
  dataThreshold: 100,
  lineLineWidth: 1,
  lineStroke: "black",
  crossPadding: 10,
  titleFill: "black",
  titleFontSize: 12,
  titlePosition: "lb",
  titleSpacing: 0,
  titleTextAlign: "center",
  titleTextBaseline: "middle",
  lineArrow: function() {
    return new Path2({
      style: {
        d: [["M", 10, 10], ["L", -10, 0], ["L", 10, -10], ["L", 0, 0], ["L", 10, 10], ["Z"]],
        fill: "black",
        transformOrigin: "center"
      }
    });
  },
  labelAlign: "parallel",
  labelDirection: "positive",
  labelFontSize: 12,
  labelSpacing: 0,
  gridConnect: "line",
  gridControlAngles: [],
  gridDirection: "positive",
  gridLength: 0,
  gridType: "segment",
  lineArrowOffset: 15,
  lineArrowSize: 10,
  tickDirection: "positive",
  tickLength: 5,
  tickLineWidth: 1,
  tickStroke: "black",
  labelOverlap: [
    // { type: 'rotate', optionalAngles: [0, 45, 90] },
    // { type: 'ellipsis', suffix: '...', minLength: 14, maxLength: 160 },
    // { type: 'hide' },
  ]
};
var ARC_DEFAULT_OPTIONS = deep_mix_default({}, AXIS_BASE_DEFAULT_ATTR, {
  style: {
    type: "arc"
  }
});
var HELIX_DEFAULT_OPTIONS = deep_mix_default({}, AXIS_BASE_DEFAULT_ATTR, {
  style: {}
});
var CLASS_NAMES3 = classNames({
  mainGroup: "main-group",
  gridGroup: "grid-group",
  grid: "grid",
  lineGroup: "line-group",
  line: "line",
  tickGroup: "tick-group",
  tick: "tick",
  tickItem: "tick-item",
  labelGroup: "label-group",
  label: "label",
  labelItem: "label-item",
  titleGroup: "title-group",
  title: "title",
  lineFirst: "line-first",
  lineSecond: "line-second"
}, "axis");

// node_modules/@antv/component/esm/ui/grid/index.js
var CLASS_NAMES4 = classNames({
  lineGroup: "line-group",
  line: "line",
  regionGroup: "region-group",
  region: "region"
}, "grid");
function getStraightPath(points) {
  return points.reduce(function(acc, curr, idx) {
    acc.push(__spreadArray([idx === 0 ? "M" : "L"], __read(curr), false));
    return acc;
  }, []);
}
function getSurroundPath(points, attr2, reversed) {
  var _a2 = attr2.connect, connect = _a2 === void 0 ? "line" : _a2, center2 = attr2.center;
  if (connect === "line")
    return getStraightPath(points);
  if (!center2)
    return [];
  var radius = distance5(points[0], center2);
  var sweepFlag = reversed ? 0 : 1;
  return points.reduce(function(r, p2, idx) {
    if (idx === 0)
      r.push(__spreadArray(["M"], __read(p2), false));
    else
      r.push(__spreadArray(["A", radius, radius, 0, 0, sweepFlag], __read(p2), false));
    return r;
  }, []);
}
function getLinePath(points, cfg, reversed) {
  if (cfg.type === "surround")
    return getSurroundPath(points, cfg, reversed);
  return getStraightPath(points);
}
function connectPaths(from, to, cfg) {
  var type = cfg.type, connect = cfg.connect, center2 = cfg.center, closed = cfg.closed;
  var closeFlag = closed ? [["Z"]] : [];
  var _a2 = __read([getLinePath(from, cfg), getLinePath(to.slice().reverse(), cfg, true)], 2), path1 = _a2[0], path2 = _a2[1];
  var _b = __read([from[0], to.slice(-1)[0]], 2), startOfFrom = _b[0], endOfTo = _b[1];
  var createPath = function(insertA, insertB) {
    return [path1, insertA, path2, insertB, closeFlag].flat();
  };
  if (connect === "line" || type === "surround") {
    return createPath([__spreadArray(["L"], __read(endOfTo), false)], [__spreadArray(["L"], __read(startOfFrom), false)]);
  }
  if (!center2)
    throw new Error("Arc grid need to specified center");
  var _c = __read([distance5(endOfTo, center2), distance5(startOfFrom, center2)], 2), raduis1 = _c[0], radius2 = _c[1];
  return createPath([
    __spreadArray(["A", raduis1, raduis1, 0, 0, 1], __read(endOfTo), false),
    __spreadArray(["L"], __read(endOfTo), false)
  ], [
    __spreadArray(["A", radius2, radius2, 0, 0, 0], __read(startOfFrom), false),
    __spreadArray(["L"], __read(startOfFrom), false)
  ]);
}
function renderGridLine(container, data2, attr2, style) {
  var animate2 = attr2.animate, isBillboard = attr2.isBillboard;
  var lines = data2.map(function(item, idx) {
    return {
      id: item.id || "grid-line-".concat(idx),
      d: getLinePath(item.points, attr2)
    };
  });
  return container.selectAll(CLASS_NAMES4.line.class).data(lines, function(d3) {
    return d3.id;
  }).join(function(enter) {
    return enter.append("path").each(function(datum, index3) {
      var lineStyle = getCallbackValue(getPrimitiveAttributes(__assign({ d: datum.d }, style)), [datum, index3, lines]);
      this.attr(__assign({ class: CLASS_NAMES4.line.name, stroke: "#D9D9D9", lineWidth: 1, lineDash: [4, 4], isBillboard }, lineStyle));
    });
  }, function(update2) {
    return update2.transition(function(datum, index3) {
      var lineStyle = getCallbackValue(getPrimitiveAttributes(__assign({ d: datum.d }, style)), [datum, index3, lines]);
      return transition(this, lineStyle, animate2.update);
    });
  }, function(exit) {
    return exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut_default(this, animate2.exit);
      onAnimateFinished(animation, function() {
        return _this2.remove();
      });
      return animation;
    });
  }).transitions();
}
function renderAlternateRegion(container, data2, style) {
  var animate2 = style.animate, connect = style.connect, areaFill = style.areaFill;
  if (data2.length < 2 || !areaFill || !connect)
    return [];
  var colors = Array.isArray(areaFill) ? areaFill : [areaFill, "transparent"];
  var getColor3 = function(idx2) {
    return colors[idx2 % colors.length];
  };
  var regions = [];
  for (var idx = 0; idx < data2.length - 1; idx++) {
    var _a2 = __read([data2[idx].points, data2[idx + 1].points], 2), prev = _a2[0], curr = _a2[1];
    var path2 = connectPaths(prev, curr, style);
    regions.push({ d: path2, fill: getColor3(idx) });
  }
  return container.selectAll(CLASS_NAMES4.region.class).data(regions, function(_2, i) {
    return i;
  }).join(function(enter) {
    return enter.append("path").each(function(datum, index3) {
      var regionStyle = getCallbackValue(datum, [datum, index3, regions]);
      this.attr(regionStyle);
    }).attr("className", CLASS_NAMES4.region.name);
  }, function(update2) {
    return update2.transition(function(datum, index3) {
      var regionStyle = getCallbackValue(datum, [datum, index3, regions]);
      return transition(this, regionStyle, animate2.update);
    });
  }, function(exit) {
    return exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut_default(this, animate2.exit);
      onAnimateFinished(animation, function() {
        return _this2.remove();
      });
      return animation;
    });
  }).transitions();
}
function getData(attr2) {
  var _a2 = attr2.data, data2 = _a2 === void 0 ? [] : _a2, closed = attr2.closed;
  if (!closed)
    return data2;
  return data2.map(function(datum) {
    var points = datum.points;
    var _a3 = __read(points, 1), start = _a3[0];
    return __assign(__assign({}, datum), { points: __spreadArray(__spreadArray([], __read(points), false), [start], false) });
  });
}
var Grid = (
  /** @class */
  function(_super) {
    __extends(Grid2, _super);
    function Grid2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Grid2.prototype.render = function(attributes, container) {
      var type = attributes.type, center2 = attributes.center, areaFill = attributes.areaFill, closed = attributes.closed, style = __rest(attributes, ["type", "center", "areaFill", "closed"]);
      var data2 = getData(attributes);
      var lineGroup = select2(container).maybeAppendByClassName(CLASS_NAMES4.lineGroup, "g");
      var regionGroup = select2(container).maybeAppendByClassName(CLASS_NAMES4.regionGroup, "g");
      var lineTransitions = renderGridLine(lineGroup, data2, attributes, style);
      var reigionTransitions = renderAlternateRegion(regionGroup, data2, attributes);
      return __spreadArray(__spreadArray([], __read(lineTransitions), false), __read(reigionTransitions), false);
    };
    return Grid2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/axis/guides/utils.js
function getCallbackStyle(style, params) {
  return Object.fromEntries(Object.entries(style).map(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], val = _b[1];
    return [key, getCallbackValue(val, params)];
  }));
}
function filterExec(data2, filter3) {
  return !!filter3 && isFunction(filter3) ? data2.filter(filter3) : data2;
}
function getLineAngle(value2, attr2) {
  var startAngle = attr2.startAngle, endAngle = attr2.endAngle;
  return (endAngle - startAngle) * value2 + startAngle;
}
function getLineTangentVector(value2, attr2) {
  if (attr2.type === "linear") {
    var _a2 = __read(attr2.startPos, 2), startX = _a2[0], startY = _a2[1], _b = __read(attr2.endPos, 2), endX = _b[0], endY = _b[1];
    var _c = __read([endX - startX, endY - startY], 2), dx = _c[0], dy = _c[1];
    return normalize7([dx, dy]);
  }
  var angle4 = degToRad(getLineAngle(value2, attr2));
  return [-Math.sin(angle4), Math.cos(angle4)];
}
function getDirectionVector(value2, direction3, attr2) {
  var tangentVector = getLineTangentVector(value2, attr2);
  return vertical2(tangentVector, direction3 !== "positive");
}
function getLabelVector(value2, attr2) {
  return getDirectionVector(value2, attr2.labelDirection, attr2);
}

// node_modules/@antv/component/esm/ui/axis/guides/line.js
function getLinearValuePos(value2, attr2) {
  var _a2 = __read(attr2.startPos, 2), sx = _a2[0], sy = _a2[1], _b = __read(attr2.endPos, 2), ex = _b[0], ey = _b[1];
  var _c = __read([ex - sx, ey - sy], 2), dx = _c[0], dy = _c[1];
  return [sx + dx * value2, sy + dy * value2];
}
function getArcValuePos(value2, attr2) {
  var radius = attr2.radius, _a2 = __read(attr2.center, 2), cx = _a2[0], cy = _a2[1];
  var angle4 = degToRad(getLineAngle(value2, attr2));
  return [cx + radius * Math.cos(angle4), cy + radius * Math.sin(angle4)];
}
function getValuePos(value2, attr2) {
  if (attr2.type === "linear")
    return getLinearValuePos(value2, attr2);
  return getArcValuePos(value2, attr2);
}
function isAxisHorizontal(attr2) {
  return getLineTangentVector(0, attr2)[1] === 0;
}
function isAxisVertical(attr2) {
  return getLineTangentVector(0, attr2)[0] === 0;
}
function isCircle(startAngle, endAngle) {
  return endAngle - startAngle === 360;
}
function getArcPath(startAngle, endAngle, cx, cy, radius) {
  var diffAngle = endAngle - startAngle;
  var _a2 = __read([radius, radius], 2), rx = _a2[0], ry = _a2[1];
  var _b = __read([degToRad(startAngle), degToRad(endAngle)], 2), startAngleRadians = _b[0], endAngleRadians = _b[1];
  var getPosByAngle = function(angle4) {
    return [cx + radius * Math.cos(angle4), cy + radius * Math.sin(angle4)];
  };
  var _c = __read(getPosByAngle(startAngleRadians), 2), x12 = _c[0], y12 = _c[1];
  var _d = __read(getPosByAngle(endAngleRadians), 2), x22 = _d[0], y22 = _d[1];
  if (isCircle(startAngle, endAngle)) {
    var middleAngleRadians = (endAngleRadians + startAngleRadians) / 2;
    var _e = __read(getPosByAngle(middleAngleRadians), 2), xm = _e[0], ym = _e[1];
    return [
      ["M", x12, y12],
      ["A", rx, ry, 0, 1, 0, xm, ym],
      ["A", rx, ry, 0, 1, 0, x22, y22]
    ];
  }
  var large = diffAngle > 180 ? 1 : 0;
  var sweep = startAngle > endAngle ? 0 : 1;
  var isClosePath = false;
  return isClosePath ? "M".concat(cx, ",").concat(cy, ",L").concat(x12, ",").concat(y12, ",A").concat(rx, ",").concat(ry, ",0,").concat(large, ",").concat(sweep, ",").concat(x22, ",").concat(y22, ",L").concat(cx, ",").concat(cy) : "M".concat(x12, ",").concat(y12, ",A").concat(rx, ",").concat(ry, ",0,").concat(large, ",").concat(sweep, ",").concat(x22, ",").concat(y22);
}
function getArcAttr(arc) {
  var _a2 = arc.attributes, startAngle = _a2.startAngle, endAngle = _a2.endAngle, center2 = _a2.center, radius = _a2.radius;
  return __spreadArray(__spreadArray([startAngle, endAngle], __read(center2), false), [radius], false);
}
function renderArc(container, attr2, style, animate2) {
  var startAngle = attr2.startAngle, endAngle = attr2.endAngle, center2 = attr2.center, radius = attr2.radius;
  return container.selectAll(CLASS_NAMES3.line.class).data([{ d: getArcPath.apply(void 0, __spreadArray(__spreadArray([startAngle, endAngle], __read(center2), false), [radius], false)) }], function(d3, i) {
    return i;
  }).join(function(enter) {
    return enter.append("path").attr("className", CLASS_NAMES3.line.name).styles(attr2).styles({ d: function(d3) {
      return d3.d;
    } });
  }, function(update2) {
    return update2.transition(function() {
      var _this2 = this;
      var animation = keyframeInterpolate(this, getArcAttr(this), __spreadArray(__spreadArray([startAngle, endAngle], __read(center2), false), [radius], false), animate2.update);
      if (animation) {
        var layout = function() {
          var data2 = get_default(_this2.attributes, "__keyframe_data__");
          _this2.style.d = getArcPath.apply(void 0, __spreadArray([], __read(data2), false));
        };
        animation.onframe = layout;
        animation.onfinish = layout;
      }
      return animation;
    }).styles(attr2);
  }, function(exit) {
    return exit.remove();
  }).styles(style).transitions();
}
function renderTruncation(container, _a2) {
  var truncRange = _a2.truncRange, truncShape = _a2.truncShape, lineExtension = _a2.lineExtension;
}
function extendLine(startPos, endPos, range3) {
  if (range3 === void 0) {
    range3 = [0, 0];
  }
  var _a2 = __read([startPos, endPos, range3], 3), _b = __read(_a2[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1], _d = __read(_a2[2], 2), l1 = _d[0], l2 = _d[1];
  var _e = __read([x22 - x12, y22 - y12], 2), x3 = _e[0], y3 = _e[1];
  var L = Math.sqrt(Math.pow(x3, 2) + Math.pow(y3, 2));
  var _f = __read([-l1 / L, l2 / L], 2), s1 = _f[0], s22 = _f[1];
  return [s1 * x3, s1 * y3, s22 * x3, s22 * y3];
}
function getLinePath2(points) {
  var _a2 = __read(points, 2), _b = __read(_a2[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1];
  return { x1: x12, y1: y12, x2: x22, y2: y22 };
}
function renderLinear(container, attr2, style, animate2) {
  var showTrunc = attr2.showTrunc, startPos = attr2.startPos, endPos = attr2.endPos, truncRange = attr2.truncRange, lineExtension = attr2.lineExtension;
  var _a2 = __read([startPos, endPos], 2), _b = __read(_a2[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1];
  var _d = __read(lineExtension ? extendLine(startPos, endPos, lineExtension) : new Array(4).fill(0), 4), ox1 = _d[0], oy1 = _d[1], ox2 = _d[2], oy2 = _d[3];
  var renderLine = function(data2) {
    return container.selectAll(CLASS_NAMES3.line.class).data(data2, function(d3, i) {
      return i;
    }).join(function(enter) {
      return enter.append("line").attr("className", function(d3) {
        return "".concat(CLASS_NAMES3.line.name, " ").concat(d3.className);
      }).styles(style).transition(function(d3) {
        return transition(this, getLinePath2(d3.line), false);
      });
    }, function(update2) {
      return update2.styles(style).transition(function(_a3) {
        var line4 = _a3.line;
        return transition(this, getLinePath2(line4), animate2.update);
      });
    }, function(exit) {
      return exit.remove();
    }).transitions();
  };
  if (!showTrunc || !truncRange) {
    return renderLine([
      {
        line: [
          [x12 + ox1, y12 + oy1],
          [x22 + ox2, y22 + oy2]
        ],
        className: CLASS_NAMES3.line.name
      }
    ]);
  }
  var _e = __read(truncRange, 2), r1 = _e[0], r2 = _e[1];
  var dx = x22 - x12;
  var dy = y22 - y12;
  var _f = __read([x12 + dx * r1, y12 + dy * r1], 2), x3 = _f[0], y3 = _f[1];
  var _g = __read([x12 + dx * r2, y12 + dy * r2], 2), x4 = _g[0], y4 = _g[1];
  var animation = renderLine([
    {
      line: [
        [x12 + ox1, y12 + oy1],
        [x3, y3]
      ],
      className: CLASS_NAMES3.lineFirst.name
    },
    {
      line: [
        [x4, y4],
        [x22 + ox2, y22 + oy2]
      ],
      className: CLASS_NAMES3.lineSecond.name
    }
  ]);
  renderTruncation(container, attr2);
  return animation;
}
function renderAxisArrow(container, type, attr2, style) {
  var showArrow = attr2.showArrow, showTrunc = attr2.showTrunc, lineArrow = attr2.lineArrow, lineArrowOffset = attr2.lineArrowOffset, lineArrowSize = attr2.lineArrowSize;
  var shapeToAddArrow;
  if (type === "arc")
    shapeToAddArrow = container.select(CLASS_NAMES3.line.class);
  else if (showTrunc)
    shapeToAddArrow = container.select(CLASS_NAMES3.lineSecond.class);
  else
    shapeToAddArrow = container.select(CLASS_NAMES3.line.class);
  if (!showArrow || !lineArrow || attr2.type === "arc" && isCircle(attr2.startAngle, attr2.endAngle)) {
    var node = shapeToAddArrow.node();
    if (node)
      node.style.markerEnd = void 0;
    return;
  }
  var arrow2 = renderExtDo(lineArrow);
  arrow2.attr(style);
  scaleToPixel(arrow2, lineArrowSize, true);
  shapeToAddArrow.style("markerEnd", arrow2).style("markerEndOffset", -lineArrowOffset);
}
function renderAxisLine(container, attr2, animate2) {
  var type = attr2.type;
  var animation;
  var style = subStyleProps(attr2, "line");
  if (type === "linear")
    animation = renderLinear(container, attr2, omit(style, "arrow"), animate2);
  else
    animation = renderArc(container, attr2, omit(style, "arrow"), animate2);
  renderAxisArrow(container, type, attr2, style);
  return animation;
}

// node_modules/@antv/component/esm/ui/axis/guides/grid.js
function getGridVector(value2, attr2) {
  return getDirectionVector(value2, attr2.gridDirection, attr2);
}
function getGridCenter(attr2) {
  var type = attr2.type, gridCenter = attr2.gridCenter;
  if (type === "linear")
    return gridCenter;
  return gridCenter || attr2.center;
}
function renderStraight(data2, attr2) {
  var gridLength = attr2.gridLength;
  return data2.map(function(_a2, index3) {
    var value2 = _a2.value;
    var _b = __read(getValuePos(value2, attr2), 2), x3 = _b[0], y3 = _b[1];
    var _c = __read(scale8(getGridVector(value2, attr2), gridLength), 2), dx = _c[0], dy = _c[1];
    return {
      id: index3,
      points: [
        [x3, y3],
        [x3 + dx, y3 + dy]
      ]
    };
  });
}
function renderSurround(data2, attr2) {
  var controlAngles = attr2.gridControlAngles;
  var center2 = getGridCenter(attr2);
  if (!center2)
    throw new Error("grid center is not provide");
  if (data2.length < 2)
    throw new Error("Invalid grid data");
  if (!controlAngles || controlAngles.length === 0)
    throw new Error("Invalid gridControlAngles");
  var _a2 = __read(center2, 2), cx = _a2[0], cy = _a2[1];
  return data2.map(function(_a3, index3) {
    var value2 = _a3.value;
    var _b = __read(getValuePos(value2, attr2), 2), sx = _b[0], sy = _b[1];
    var _c = __read([sx - cx, sy - cy], 2), dx = _c[0], dy = _c[1];
    var points = [];
    controlAngles.forEach(function(angle4) {
      var angleInRad = degToRad(angle4);
      var _a4 = __read([Math.cos(angleInRad), Math.sin(angleInRad)], 2), cosa = _a4[0], sina = _a4[1];
      var x3 = dx * cosa - dy * sina + cx;
      var y3 = dx * sina + dy * cosa + cy;
      points.push([x3, y3]);
    });
    return { points, id: index3 };
  });
}
function renderGrid(container, data2, attr2, animate2) {
  var gridAttr = subStyleProps(attr2, "grid");
  var type = gridAttr.type, areaFill = gridAttr.areaFill;
  var center2 = getGridCenter(attr2);
  var finalData = filterExec(data2, attr2.gridFilter);
  var gridItems = type === "segment" ? renderStraight(finalData, attr2) : renderSurround(finalData, attr2);
  var style = __assign(__assign({}, gridAttr), { center: center2, areaFill: isFunction(areaFill) ? finalData.map(function(datum, index3) {
    return getCallbackValue(areaFill, [datum, index3, finalData]);
  }) : areaFill, animate: animate2, data: gridItems });
  return container.selectAll(CLASS_NAMES3.grid.class).data([1]).join(function(enter) {
    return enter.append(function() {
      return new Grid({ style });
    }).attr("className", CLASS_NAMES3.grid.name);
  }, function(update2) {
    return update2.transition(function() {
      return this.update(style);
    });
  }, function(exit) {
    return exit.remove();
  }).transitions();
}

// node_modules/@antv/component/esm/ui/axis/utils/bounds.js
var Bounds = (
  /** @class */
  function() {
    function Bounds2(x12, y12, x22, y22) {
      this.set(x12, y12, x22, y22);
    }
    Object.defineProperty(Bounds2.prototype, "left", {
      get: function() {
        return this.x1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "top", {
      get: function() {
        return this.y1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "right", {
      get: function() {
        return this.x2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "bottom", {
      get: function() {
        return this.y2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "width", {
      get: function() {
        return this.defined("x2") && this.defined("x1") ? this.x2 - this.x1 : void 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "height", {
      get: function() {
        return this.defined("y2") && this.defined("y1") ? this.y2 - this.y1 : void 0;
      },
      enumerable: false,
      configurable: true
    });
    Bounds2.prototype.rotatedPoints = function(radian, x3, y3) {
      var _a2 = this, x12 = _a2.x1, y12 = _a2.y1, x22 = _a2.x2, y22 = _a2.y2;
      var cos3 = Math.cos(radian);
      var sin3 = Math.sin(radian);
      var cx = x3 - x3 * cos3 + y3 * sin3;
      var cy = y3 - x3 * sin3 - y3 * cos3;
      var points = [
        [cos3 * x12 - sin3 * y22 + cx, sin3 * x12 + cos3 * y22 + cy],
        [cos3 * x22 - sin3 * y22 + cx, sin3 * x22 + cos3 * y22 + cy],
        [cos3 * x12 - sin3 * y12 + cx, sin3 * x12 + cos3 * y12 + cy],
        [cos3 * x22 - sin3 * y12 + cx, sin3 * x22 + cos3 * y12 + cy]
      ];
      return points;
    };
    Bounds2.prototype.set = function(x12, y12, x22, y22) {
      if (x22 < x12) {
        this.x2 = x12;
        this.x1 = x22;
      } else {
        this.x1 = x12;
        this.x2 = x22;
      }
      if (y22 < y12) {
        this.y2 = y12;
        this.y1 = y22;
      } else {
        this.y1 = y12;
        this.y2 = y22;
      }
      return this;
    };
    Bounds2.prototype.defined = function(key) {
      return this[key] !== Number.MAX_VALUE && this[key] !== -Number.MAX_VALUE;
    };
    return Bounds2;
  }()
);
function getBounds(item, margin) {
  var angle4 = item.getEulerAngles() || 0;
  item.setEulerAngles(0);
  var _a2 = item.getBounds(), _b = __read(_a2.min, 2), x3 = _b[0], y3 = _b[1], _c = __read(_a2.max, 2), right2 = _c[0], bottom = _c[1];
  var _d = item.getBBox(), w = _d.width, h = _d.height;
  var height = h;
  var dx = 0;
  var dy = 0;
  var anchorX = x3;
  var anchorY = y3;
  var text = textOf(item);
  if (text) {
    height -= 1.5;
    var a4 = text.style.textAlign;
    var b_1 = text.style.textBaseline;
    if (a4 === "center") {
      anchorX = (x3 + right2) / 2;
    } else if (a4 === "right" || a4 === "end") {
      anchorX = right2;
    } else {
    }
    if (b_1 === "middle") {
      anchorY = (y3 + bottom) / 2;
    } else if (b_1 === "bottom") {
      anchorY = bottom;
    }
  }
  var _e = __read(parseSeriesAttr(margin), 4), _f = _e[0], t = _f === void 0 ? 0 : _f, _g = _e[1], r = _g === void 0 ? 0 : _g, _h = _e[2], b = _h === void 0 ? t : _h, _j = _e[3], l = _j === void 0 ? r : _j;
  var bounds = new Bounds((dx += x3) - l, (dy += y3) - t, dx + w + r, dy + height + b);
  item.setEulerAngles(angle4);
  return bounds.rotatedPoints(degToRad(angle4), anchorX, anchorY);
}

// node_modules/@antv/component/esm/ui/axis/utils/contain.js
function onLine(line4, point7) {
  return point7[0] <= Math.max(line4[0][0], line4[1][0]) && point7[0] <= Math.min(line4[0][0], line4[1][0]) && point7[1] <= Math.max(line4[0][1], line4[1][1]) && point7[1] <= Math.min(line4[0][1], line4[1][1]);
}
function direction2(a4, b, c5) {
  var val = (b[1] - a4[1]) * (c5[0] - b[0]) - (b[0] - a4[0]) * (c5[1] - b[1]);
  if (val === 0)
    return 0;
  return val < 0 ? 2 : 1;
}
function isIntersect(line1, line22) {
  var dir1 = direction2(line1[0], line1[1], line22[0]);
  var dir2 = direction2(line1[0], line1[1], line22[1]);
  var dir3 = direction2(line22[0], line22[1], line1[0]);
  var dir4 = direction2(line22[0], line22[1], line1[1]);
  if (dir1 !== dir2 && dir3 !== dir4)
    return true;
  if (dir1 === 0 && onLine(line1, line22[0]))
    return true;
  if (dir2 === 0 && onLine(line1, line22[1]))
    return true;
  if (dir3 === 0 && onLine(line22, line1[0]))
    return true;
  if (dir4 === 0 && onLine(line22, line1[1]))
    return true;
  return false;
}
function isPointInsideRectangle(polygon, point7) {
  var n = polygon.length;
  if (n < 3)
    return false;
  var lineToInfinity = [point7, [9999, point7[1]]];
  var count4 = 0;
  var i = 0;
  do {
    var side = [polygon[i], polygon[(i + 1) % n]];
    if (isIntersect(side, lineToInfinity)) {
      if (direction2(side[0], point7, side[1]) === 0)
        return onLine(side, point7);
      count4++;
    }
    i = (i + 1) % n;
  } while (i !== 0);
  return !!(count4 & 1);
}
function isRectangleBInsideA(rectA, rectB) {
  return rectB.every(function(point7) {
    return isPointInsideRectangle(rectA, point7);
  });
}
function contain(container, child, margin) {
  var x12 = container.x1, x22 = container.x2, y12 = container.y1, y22 = container.y2;
  var parent = [
    [x12, y12],
    [x22, y12],
    [x22, y22],
    [x12, y22]
  ];
  var element = getBounds(child, margin);
  return isRectangleBInsideA(parent, element);
}

// node_modules/@antv/component/esm/ui/axis/utils/intersect.js
function lineToLine(line1, line22) {
  var _a2 = __read(line1, 4), x05 = _a2[0], y05 = _a2[1], x12 = _a2[2], y12 = _a2[3];
  var _b = __read(line22, 4), x22 = _b[0], y22 = _b[1], x3 = _b[2], y3 = _b[3];
  var s10x = x12 - x05;
  var s10y = y12 - y05;
  var s32x = x3 - x22;
  var s32y = y3 - y22;
  var denom = s10x * s32y - s32x * s10y;
  if (denom === 0)
    return false;
  var denomPositive = denom > 0;
  var s02x = x05 - x22;
  var s02y = y05 - y22;
  var sNum = s10x * s02y - s10y * s02x;
  if (sNum < 0 === denomPositive)
    return false;
  var tNum = s32x * s02y - s32y * s02x;
  if (tNum < 0 === denomPositive)
    return false;
  if (sNum > denom === denomPositive || tNum > denom === denomPositive)
    return false;
  return true;
}
function intersectBoxLine(box2, line4) {
  var lines = [
    [box2[0], box2[1], box2[2], box2[3]],
    [box2[2], box2[3], box2[4], box2[5]],
    [box2[4], box2[5], box2[6], box2[7]],
    [box2[6], box2[7], box2[0], box2[1]]
  ];
  return lines.some(function(boxLine) {
    return lineToLine(line4, boxLine);
  });
}
function intersect2(a4, b, margin) {
  var e_1, _a2;
  var p2 = getBounds(a4, margin).flat(1);
  var q = getBounds(b, margin).flat(1);
  var linesP = [
    [p2[0], p2[1], p2[2], p2[3]],
    [p2[0], p2[1], p2[4], p2[5]],
    [p2[4], p2[5], p2[6], p2[7]],
    [p2[2], p2[3], p2[6], p2[7]]
  ];
  try {
    for (var linesP_1 = __values(linesP), linesP_1_1 = linesP_1.next(); !linesP_1_1.done; linesP_1_1 = linesP_1.next()) {
      var line4 = linesP_1_1.value;
      if (intersectBoxLine(q, line4))
        return true;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (linesP_1_1 && !linesP_1_1.done && (_a2 = linesP_1.return))
        _a2.call(linesP_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return false;
}

// node_modules/@antv/component/esm/ui/axis/utils/test.js
function createCrossBBox(attr2, padding) {
  var type = attr2.type, labelDirection = attr2.labelDirection, crossSize = attr2.crossSize;
  if (!crossSize)
    return false;
  if (type === "arc") {
    var center2 = attr2.center, radius = attr2.radius;
    var _a2 = __read(center2, 2), cx = _a2[0], cy = _a2[1];
    var size3 = labelDirection === "negative" ? 0 : crossSize;
    var dMin = -radius - size3;
    var dMax = radius + size3;
    var _b = __read(parseSeriesAttr(padding), 4), top_1 = _b[0], right_1 = _b[1], bottom_1 = _b[2], left_1 = _b[3];
    return new Bounds(cx + dMin - left_1, cy + dMin - top_1, cx + dMax + right_1, cy + dMax + bottom_1);
  }
  var _c = __read(attr2.startPos, 2), sx = _c[0], sy = _c[1], _d = __read(attr2.endPos, 2), ex = _d[0], ey = _d[1];
  var _e = __read(isAxisVertical(attr2) ? [-padding, 0, padding, 0] : [0, padding, 0, -padding], 4), top = _e[0], right2 = _e[1], bottom = _e[2], left2 = _e[3];
  var labelVector = getLabelVector(0, attr2);
  var diff = scale8(labelVector, crossSize);
  var bbox = new Bounds(sx, sy, ex, ey);
  bbox.x1 += left2;
  bbox.y1 += top;
  bbox.x2 += right2 + diff[0];
  bbox.y2 += bottom + diff[1];
  return bbox;
}
function boundTest(items, attr2, margin) {
  var e_1, _a2;
  var crossPadding = attr2.crossPadding;
  var resultSet = /* @__PURE__ */ new Set();
  var prev = null;
  var crossBBox = createCrossBBox(attr2, crossPadding);
  var testContain = function(item) {
    if (crossBBox)
      return contain(crossBBox, item);
    return true;
  };
  var testIntersect = function(prevItem, currItem) {
    if (!prevItem || !prevItem.firstChild)
      return true;
    return !intersect2(prevItem.firstChild, currItem.firstChild, parseSeriesAttr(margin));
  };
  try {
    for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
      var curr = items_1_1.value;
      if (!testContain(curr)) {
        resultSet.add(curr);
      } else if (!prev || testIntersect(prev, curr)) {
        prev = curr;
      } else {
        resultSet.add(prev);
        resultSet.add(curr);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (items_1_1 && !items_1_1.done && (_a2 = items_1.return))
        _a2.call(items_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return Array.from(resultSet);
}

// node_modules/@antv/component/esm/ui/axis/overlap/autoEllipsis.js
function parseLengthString(str7, font) {
  if (font === void 0) {
    font = {};
  }
  if (isNil(str7))
    return 0;
  if (typeof str7 === "number")
    return str7;
  return Math.floor(measureTextWidth(str7, font));
}
function ellipseLabels(labels, overlapCfg, attr2, utils) {
  if (labels.length <= 1)
    return;
  var _a2 = overlapCfg.suffix, suffix = _a2 === void 0 ? "..." : _a2, minLength = overlapCfg.minLength, _b = overlapCfg.maxLength, maxLength = _b === void 0 ? Infinity : _b, _c = overlapCfg.step, ellipsisStep = _c === void 0 ? " " : _c, _d = overlapCfg.margin, margin = _d === void 0 ? [0, 0, 0, 0] : _d;
  var font = getFont(utils.getTextShape(labels[0]));
  var step2 = parseLengthString(ellipsisStep, font);
  var min10 = minLength ? parseLengthString(minLength, font) : step2;
  var max11 = parseLengthString(maxLength, font);
  if (isNil(max11) || max11 === Infinity) {
    max11 = Math.max.apply(null, labels.map(function(d3) {
      return d3.getBBox().width;
    }));
  }
  var source = labels.slice();
  var _e = __read(margin, 4), _f = _e[0], top = _f === void 0 ? 0 : _f, _g = _e[1], right2 = _g === void 0 ? 0 : _g, _h = _e[2], bottom = _h === void 0 ? top : _h, _j = _e[3], left2 = _j === void 0 ? right2 : _j;
  var _loop_1 = function(allowedLength2) {
    source.forEach(function(label) {
      utils.ellipsis(utils.getTextShape(label), allowedLength2, suffix);
    });
    source = boundTest(labels, attr2, margin);
    if (source.length < 1)
      return { value: void 0 };
  };
  for (var allowedLength = max11; allowedLength > min10 + step2; allowedLength -= step2) {
    var state_1 = _loop_1(allowedLength);
    if (typeof state_1 === "object")
      return state_1.value;
  }
}

// node_modules/@antv/component/esm/ui/axis/overlap/autoHide.js
var methods = {
  parity: function(items, _a2) {
    var _b = _a2.seq, seq = _b === void 0 ? 2 : _b;
    return items.filter(function(item, i) {
      return i % seq ? (hide(item), false) : true;
    });
  }
};
var filterDefined = function(arr) {
  return arr.filter(defined2);
};
function hideLabels(labels, overlapCfg, attr2, utils) {
  var count4 = labels.length;
  var keepHeader = overlapCfg.keepHeader, keepTail = overlapCfg.keepTail;
  if (count4 <= 1 || count4 === 2 && keepHeader && keepTail)
    return;
  var parityHide = methods.parity;
  var reset = function(els) {
    return els.forEach(utils.show), els;
  };
  var seq = 2;
  var source = labels.slice();
  var target = labels.slice();
  var minLabelWidth = Math.min.apply(Math, __spreadArray([1], __read(labels.map(function(d3) {
    return d3.getBBox().width;
  })), false));
  if (attr2.type === "linear" && (isAxisHorizontal(attr2) || isAxisVertical(attr2))) {
    var minX = getLocalBBox(labels[0]).left;
    var maxX = getLocalBBox(labels[count4 - 1]).right;
    var distance7 = Math.abs(maxX - minX) || 1;
    seq = Math.max(Math.floor(count4 * minLabelWidth / distance7), seq);
  }
  var first3;
  var last5;
  if (keepHeader)
    first3 = source.splice(0, 1)[0];
  if (keepTail) {
    last5 = source.splice(-1, 1)[0];
    source.reverse();
  }
  reset(source);
  while (seq < labels.length && boundTest(filterDefined(last5 ? __spreadArray(__spreadArray([last5], __read(target), false), [first3], false) : __spreadArray([first3], __read(target), false)), attr2, overlapCfg === null || overlapCfg === void 0 ? void 0 : overlapCfg.margin).length) {
    if (last5 && !first3 && seq % 2 === 0) {
      var rest = source.splice(0, 1);
      rest.forEach(utils.hide);
    } else if (last5 && first3) {
      var rest = source.splice(0, 1);
      rest.forEach(utils.hide);
    }
    target = parityHide(reset(source), { seq });
    seq++;
  }
}

// node_modules/@antv/component/esm/ui/axis/overlap/autoRotate.js
function rotateLabels(labels, overlapCfg, attr2, utils) {
  var e_1, _a2;
  var _b = overlapCfg.optionalAngles, optionalAngles = _b === void 0 ? [0, 45, 90] : _b, margin = overlapCfg.margin, _c = overlapCfg.recoverWhenFailed, recoverWhenFailed = _c === void 0 ? true : _c;
  var defaultAngles = labels.map(function(label) {
    return label.getLocalEulerAngles();
  });
  var runAndPassed = function() {
    return boundTest(labels, attr2, margin).length < 1;
  };
  var setLabelsRotate = function(angle5) {
    return labels.forEach(function(label, index3) {
      var rotate7 = Array.isArray(angle5) ? angle5[index3] : angle5;
      utils.rotate(label, +rotate7);
    });
  };
  try {
    for (var optionalAngles_1 = __values(optionalAngles), optionalAngles_1_1 = optionalAngles_1.next(); !optionalAngles_1_1.done; optionalAngles_1_1 = optionalAngles_1.next()) {
      var angle4 = optionalAngles_1_1.value;
      setLabelsRotate(angle4);
      if (runAndPassed())
        return;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (optionalAngles_1_1 && !optionalAngles_1_1.done && (_a2 = optionalAngles_1.return))
        _a2.call(optionalAngles_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  if (recoverWhenFailed) {
    setLabelsRotate(defaultAngles);
  }
}

// node_modules/@antv/component/esm/ui/axis/overlap/autoWrap.js
function inferTextBaseline(attr2) {
  var type = attr2.type, labelDirection = attr2.labelDirection;
  if (type === "linear" && isAxisHorizontal(attr2)) {
    return labelDirection === "negative" ? "bottom" : "top";
  }
  return "middle";
}
function wrapLabels(labels, overlapCfg, attr2, utils) {
  var _a2 = overlapCfg.wordWrapWidth, wordWrapWidth = _a2 === void 0 ? 50 : _a2, _b = overlapCfg.maxLines, maxLines = _b === void 0 ? 3 : _b, _c = overlapCfg.recoverWhenFailed, recoverWhenFailed = _c === void 0 ? true : _c, _d = overlapCfg.margin, margin = _d === void 0 ? [0, 0, 0, 0] : _d;
  var defaultLines = labels.map(function(label) {
    return label.attr("maxLines") || 1;
  });
  var minLines = Math.min.apply(Math, __spreadArray([], __read(defaultLines), false));
  var runAndPassed = function() {
    return boundTest(labels, attr2, margin).length < 1;
  };
  var textBaseline = inferTextBaseline(attr2);
  var setLabelsWrap = function(lines2) {
    return labels.forEach(function(label, index3) {
      var maxLines2 = Array.isArray(lines2) ? lines2[index3] : lines2;
      utils.wrap(label, wordWrapWidth, maxLines2, textBaseline);
    });
  };
  if (minLines > maxLines)
    return;
  for (var lines = minLines; lines <= maxLines; lines++) {
    setLabelsWrap(lines);
    if (runAndPassed())
      return;
  }
  if (recoverWhenFailed) {
    setLabelsWrap(defaultLines);
  }
}

// node_modules/@antv/component/esm/ui/axis/overlap/index.js
var OverlapUtils = /* @__PURE__ */ new Map([
  ["hide", hideLabels],
  ["rotate", rotateLabels],
  ["ellipsis", ellipseLabels],
  ["wrap", wrapLabels]
]);
function canProcessOverlap(labels, attr2, type) {
  if (attr2.labelOverlap.length < 1)
    return false;
  if (type === "hide")
    return !isInOffscreenGroup(labels[0]);
  if (type === "rotate")
    return !labels.some(function(label) {
      var _a2;
      return !!((_a2 = label.attr("transform")) === null || _a2 === void 0 ? void 0 : _a2.includes("rotate"));
    });
  if (type === "ellipsis" || type === "wrap")
    return labels.filter(function(item) {
      return item.querySelector("text");
    }).length > 1;
  return true;
}
function processOverlap(labels, attr2, utils) {
  var _a2 = attr2.labelOverlap, labelOverlap = _a2 === void 0 ? [] : _a2;
  if (!labelOverlap.length)
    return;
  labelOverlap.forEach(function(overlapCfg) {
    var type = overlapCfg.type;
    var util = OverlapUtils.get(type);
    if (canProcessOverlap(labels, attr2, type))
      util === null || util === void 0 ? void 0 : util(labels, overlapCfg, attr2, utils);
  });
}

// node_modules/@antv/component/esm/ui/axis/utils/index.js
function getFactor() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var fn = function(str7) {
    return str7 === "positive" ? -1 : 1;
  };
  return args.reduce(function(acc, cur) {
    return acc * fn(cur);
  }, 1);
}

// node_modules/@antv/component/esm/ui/axis/guides/labels.js
function angleNormalizer(angle4) {
  var normalizedAngle = angle4;
  while (normalizedAngle < 0)
    normalizedAngle += 360;
  return Math.round(normalizedAngle % 360);
}
function getAngle3(v1, v2) {
  var _a2 = __read(v1, 2), x12 = _a2[0], y12 = _a2[1];
  var _b = __read(v2, 2), x22 = _b[0], y22 = _b[1];
  var _c = __read([x12 * x22 + y12 * y22, x12 * y22 - y12 * x22], 2), dot9 = _c[0], det = _c[1];
  return Math.atan2(det, dot9);
}
function correctLabelRotation(_rotate) {
  var rotate7 = (_rotate + 360) % 180;
  if (!inRange(rotate7, -90, 90))
    rotate7 += 180;
  return rotate7;
}
function getLabelRotation(datum, label, attr2) {
  var _a2;
  var labelAlign = attr2.labelAlign;
  var customRotate = (_a2 = label.style.transform) === null || _a2 === void 0 ? void 0 : _a2.includes("rotate");
  if (customRotate)
    return label.getLocalEulerAngles();
  var rotate7 = 0;
  var labelVector = getLabelVector(datum.value, attr2);
  var tangentVector = getLineTangentVector(datum.value, attr2);
  if (labelAlign === "horizontal")
    return 0;
  if (labelAlign === "perpendicular")
    rotate7 = getAngle3([1, 0], labelVector);
  else
    rotate7 = getAngle3([tangentVector[0] < 0 ? -1 : 1, 0], tangentVector);
  return correctLabelRotation(radToDeg(rotate7));
}
function getLabelStyle(value2, rotate7, attr2) {
  var type = attr2.type, labelAlign = attr2.labelAlign;
  var labelVector = getLabelVector(value2, attr2);
  var labelAngle = angleNormalizer(rotate7);
  var tickAngle = angleNormalizer(radToDeg(getAngle3([1, 0], labelVector)));
  var textAlign = "center";
  var textBaseline = "middle";
  if (type === "linear") {
    if ([90, 270].includes(tickAngle) && labelAngle === 0) {
      textAlign = "center";
      textBaseline = labelVector[1] === 1 ? "top" : "bottom";
    } else if (!(tickAngle % 180) && [90, 270].includes(labelAngle)) {
      textAlign = "center";
    } else if (tickAngle === 0) {
      if (inRange(labelAngle, 0, 90, false, true)) {
        textAlign = "start";
      } else if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360)) {
        textAlign = "start";
      }
    } else if (tickAngle === 90) {
      if (inRange(labelAngle, 0, 90, false, true)) {
        textAlign = "start";
      } else if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360)) {
        textAlign = "end";
      }
    } else if (tickAngle === 270) {
      if (inRange(labelAngle, 0, 90, false, true)) {
        textAlign = "end";
      } else if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360)) {
        textAlign = "start";
      }
    } else if (tickAngle === 180) {
      if (labelAngle === 90) {
        textAlign = "start";
      } else if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360)) {
        textAlign = "end";
      }
    }
  } else {
    if (labelAlign === "parallel") {
      if (inRange(tickAngle, 0, 180, true)) {
        textBaseline = "top";
      } else {
        textBaseline = "bottom";
      }
    } else if (labelAlign === "horizontal") {
      if (inRange(tickAngle, 90, 270, false)) {
        textAlign = "end";
      } else if (inRange(tickAngle, 270, 360, false) || inRange(tickAngle, 0, 90)) {
        textAlign = "start";
      }
    } else if (labelAlign === "perpendicular") {
      if (inRange(tickAngle, 90, 270)) {
        textAlign = "end";
      } else {
        textAlign = "start";
      }
    }
  }
  return { textAlign, textBaseline };
}
function setRotateAndAdjustLabelAlign(rotate7, group3, attr2) {
  group3.setLocalEulerAngles(rotate7);
  var value2 = group3.__data__.value;
  var textStyle = getLabelStyle(value2, rotate7, attr2);
  var label = group3.querySelector(CLASS_NAMES3.labelItem.class);
  if (label)
    applyTextStyle(label, textStyle);
}
function getLabelPos(datum, data2, attr2) {
  var showTick = attr2.showTick, tickLength = attr2.tickLength, tickDirection = attr2.tickDirection, labelDirection = attr2.labelDirection, labelSpacing = attr2.labelSpacing;
  var index3 = data2.indexOf(datum);
  var finalLabelSpacing = getCallbackValue(labelSpacing, [datum, index3, data2]);
  var _a2 = __read([getLabelVector(datum.value, attr2), getFactor(labelDirection, tickDirection)], 2), labelVector = _a2[0], unionFactor = _a2[1];
  var extraLength = unionFactor === 1 ? getCallbackValue(showTick ? tickLength : 0, [datum, index3, data2]) : 0;
  var _b = __read(add8(scale8(labelVector, finalLabelSpacing + extraLength), getValuePos(datum.value, attr2)), 2), x3 = _b[0], y3 = _b[1];
  return { x: x3, y: y3 };
}
function formatter(datum, index3, data2, attr2) {
  var labelFormatter2 = attr2.labelFormatter;
  var element = isFunction(labelFormatter2) ? function() {
    return renderExtDo(getCallbackValue(labelFormatter2, [datum, index3, data2, getLabelVector(datum.value, attr2)]));
  } : function() {
    return renderExtDo(datum.label || "");
  };
  return element;
}
function applyTextStyle(node, style) {
  if (node.nodeName === "text")
    node.attr(style);
}
function overlapHandler(attr2) {
  processOverlap(this.node().childNodes, attr2, {
    hide,
    show,
    rotate: function(label, angle4) {
      setRotateAndAdjustLabelAlign(+angle4, label, attr2);
    },
    ellipsis: function(label, len5, suffix) {
      label && ellipsisIt(label, len5 || Infinity, suffix);
    },
    wrap: function(label, width, lines) {
      label && wrapIt(label, width, lines);
    },
    getTextShape: function(label) {
      return label.querySelector("text");
    }
  });
}
function renderLabel(container, datum, data2, style, attr2) {
  var index3 = data2.indexOf(datum);
  var label = select2(container).append(formatter(datum, index3, data2, attr2)).attr("className", CLASS_NAMES3.labelItem.name).node();
  var _a2 = __read(splitStyle(getCallbackStyle(style, [datum, index3, data2])), 2), labelStyle = _a2[0], _b = _a2[1], transform2 = _b.transform, groupStyle = __rest(_b, ["transform"]);
  percentTransform(label, transform2);
  var rotate7 = getLabelRotation(datum, label, attr2);
  if (!label.getLocalEulerAngles()) {
    label.setLocalEulerAngles(rotate7);
  }
  applyTextStyle(label, __assign(__assign({}, getLabelStyle(datum.value, rotate7, attr2)), labelStyle));
  container.attr(groupStyle);
  return label;
}
function renderLabels(container, data2, attr2, animate2) {
  var finalData = filterExec(data2, attr2.labelFilter);
  var style = subStyleProps(attr2, "label");
  return container.selectAll(CLASS_NAMES3.label.class).data(finalData, function(d3, i) {
    return i;
  }).join(function(enter) {
    return enter.append("g").attr("className", CLASS_NAMES3.label.name).transition(function(datum) {
      renderLabel(this, datum, data2, style, attr2);
      var _a2 = getLabelPos(datum, data2, attr2), x3 = _a2.x, y3 = _a2.y;
      this.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
      return null;
    }).call(function() {
      overlapHandler.call(container, attr2);
    });
  }, function(update2) {
    return update2.transition(function(datum) {
      var prevLabel = this.querySelector(CLASS_NAMES3.labelItem.class);
      var label = renderLabel(this, datum, data2, style, attr2);
      var shapeAnimation = transitionShape(prevLabel, label, animate2.update);
      var _a2 = getLabelPos(datum, data2, attr2), x3 = _a2.x, y3 = _a2.y;
      var animation = transition(this, { transform: "translate(".concat(x3, ", ").concat(y3, ")") }, animate2.update);
      return __spreadArray(__spreadArray([], __read(shapeAnimation), false), [animation], false);
    }).call(function(selection) {
      var transitions = get_default(selection, "_transitions").flat().filter(defined2);
      onAnimatesFinished(transitions, function() {
        overlapHandler.call(container, attr2);
      });
    });
  }, function(exit) {
    return exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut_default(this.childNodes[0], animate2.exit);
      onAnimateFinished(animation, function() {
        return select2(_this2).remove();
      });
      return animation;
    });
  }).transitions();
}

// node_modules/@antv/component/esm/ui/axis/guides/ticks.js
function getTickVector(value2, attr2) {
  return getDirectionVector(value2, attr2.tickDirection, attr2);
}
function getTickPoints(unitVector, tickLength) {
  var _a2 = __read(unitVector, 2), dx = _a2[0], dy = _a2[1];
  return [
    [0, 0],
    [dx * tickLength, dy * tickLength]
  ];
}
function getTickLineLayout(datum, index3, data2, tickVector, attr2) {
  var tickLength = attr2.tickLength;
  var _a2 = __read(getTickPoints(tickVector, getCallbackValue(tickLength, [datum, index3, data2])), 2), _b = __read(_a2[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1];
  return { x1: x12, x2: x22, y1: y12, y2: y22 };
}
function createTickEl(container, datum, index3, data2, attr2) {
  var formatter2 = attr2.tickFormatter;
  var tickVector = getTickVector(datum.value, attr2);
  var el = "line";
  if (isFunction(formatter2))
    el = function() {
      return getCallbackValue(formatter2, [datum, index3, data2, tickVector]);
    };
  return container.append(el).attr("className", CLASS_NAMES3.tickItem.name);
}
function applyTickStyle(datum, index3, data2, tick3, group3, attr2, style) {
  var tickVector = getTickVector(datum.value, attr2);
  var _a2 = getTickLineLayout(datum, index3, data2, tickVector, attr2), x12 = _a2.x1, x22 = _a2.x2, y12 = _a2.y1, y22 = _a2.y2;
  var _b = __read(splitStyle(getCallbackStyle(style, [datum, index3, data2, tickVector])), 2), tickStyle = _b[0], groupStyle = _b[1];
  tick3.node().nodeName === "line" && tick3.styles(__assign({ x1: x12, x2: x22, y1: y12, y2: y22 }, tickStyle));
  group3.attr(groupStyle);
  tick3.styles(tickStyle);
}
function createTick(datum, index3, data2, attr2, tickAttr, animate2) {
  var tick3 = createTickEl(select2(this), datum, index3, data2, attr2);
  applyTickStyle(datum, index3, data2, tick3, this, attr2, tickAttr);
  var _a2 = __read(getValuePos(datum.value, attr2), 2), x3 = _a2[0], y3 = _a2[1];
  return transition(this, { transform: "translate(".concat(x3, ", ").concat(y3, ")") }, animate2);
}
function renderTicks(container, axisData, attr2, animate2) {
  var finalData = filterExec(axisData, attr2.tickFilter);
  var tickAttr = subStyleProps(attr2, "tick");
  return container.selectAll(CLASS_NAMES3.tick.class).data(finalData, function(d3) {
    return d3.id || d3.label;
  }).join(function(enter) {
    return enter.append("g").attr("className", CLASS_NAMES3.tick.name).transition(function(datum, index3) {
      return createTick.call(this, datum, index3, finalData, attr2, tickAttr, false);
    });
  }, function(update2) {
    return update2.transition(function(datum, index3) {
      this.removeChildren();
      return createTick.call(this, datum, index3, finalData, attr2, tickAttr, animate2.update);
    });
  }, function(exit) {
    return exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut_default(this.childNodes[0], animate2.exit);
      onAnimateFinished(animation, function() {
        return _this2.remove();
      });
      return animation;
    });
  }).transitions();
}

// node_modules/@antv/component/esm/ui/title/index.js
var CLASS_NAMES5 = classNames({
  text: "text"
}, "title");
function parsePosition(position) {
  if (!/\S+-\S+/g.test(position))
    return position.length > 2 ? [position[0]] : position.split("");
  return position.split("-").map(function(str7) {
    return str7[0];
  });
}
function getBBox(title, content) {
  var _a2 = title.attributes, position = _a2.position, spacing = _a2.spacing, inset = _a2.inset, text = _a2.text;
  var titleBBox = title.getBBox();
  var contentBBox = content.getBBox();
  var pos = parsePosition(position);
  var _b = __read(parseSeriesAttr(text ? spacing : 0), 4), spacingTop = _b[0], spacingRight = _b[1], spacingBottom = _b[2], spacingLeft = _b[3];
  var _c = __read(parseSeriesAttr(inset), 4), insetTop = _c[0], insetRight = _c[1], insetBottom = _c[2], insetLeft = _c[3];
  var _d = __read([spacingLeft + spacingRight, spacingTop + spacingBottom], 2), spacingWidth = _d[0], spacingHeight = _d[1];
  var _e = __read([insetLeft + insetRight, insetTop + insetBottom], 2), insetWidth = _e[0], insetHeight = _e[1];
  if (pos[0] === "l") {
    return new BBox(titleBBox.x, titleBBox.y, contentBBox.width + titleBBox.width + spacingWidth + insetWidth, Math.max(contentBBox.height + insetHeight, titleBBox.height));
  }
  if (pos[0] === "t") {
    return new BBox(titleBBox.x, titleBBox.y, Math.max(contentBBox.width + insetWidth, titleBBox.width), contentBBox.height + titleBBox.height + spacingHeight + insetHeight);
  }
  var _f = __read([
    content.attributes.width || contentBBox.width,
    content.attributes.height || contentBBox.height
  ], 2), contentWidth = _f[0], contentHeight = _f[1];
  return new BBox(contentBBox.x, contentBBox.y, contentWidth + titleBBox.width + spacingWidth + insetWidth, contentHeight + titleBBox.height + spacingHeight + insetHeight);
}
function mayApplyStyle(el, style) {
  var finalStyle = Object.entries(style).reduce(function(acc, _a2) {
    var _b = __read(_a2, 2), key = _b[0], value2 = _b[1];
    var currAttr = el.node().attr(key);
    if (!currAttr)
      acc[key] = value2;
    return acc;
  }, {});
  el.styles(finalStyle);
}
function getTitleLayout(cfg) {
  var _a2, _b, _c, _d;
  var _e = cfg, width = _e.width, height = _e.height, position = _e.position;
  var _f = __read([+width / 2, +height / 2], 2), hW = _f[0], hH = _f[1];
  var _g = __read([+hW, +hH, "center", "middle"], 4), x3 = _g[0], y3 = _g[1], textAlign = _g[2], textBaseline = _g[3];
  var pos = parsePosition(position);
  if (pos.includes("l"))
    _a2 = __read([0, "start"], 2), x3 = _a2[0], textAlign = _a2[1];
  if (pos.includes("r"))
    _b = __read([+width, "end"], 2), x3 = _b[0], textAlign = _b[1];
  if (pos.includes("t"))
    _c = __read([0, "top"], 2), y3 = _c[0], textBaseline = _c[1];
  if (pos.includes("b"))
    _d = __read([+height, "bottom"], 2), y3 = _d[0], textBaseline = _d[1];
  return { x: x3, y: y3, textAlign, textBaseline };
}
var Title = (
  /** @class */
  function(_super) {
    __extends(Title3, _super);
    function Title3(options) {
      return _super.call(this, options, {
        text: "",
        width: 0,
        height: 0,
        fill: "#4a505a",
        fontWeight: "bold",
        fontSize: 12,
        fontFamily: "sans-serif",
        inset: 0,
        spacing: 0,
        position: "top-left"
      }) || this;
    }
    Title3.prototype.getAvailableSpace = function() {
      var container = this;
      var _a2 = this.attributes, containerWidth = _a2.width, containerHeight = _a2.height, position = _a2.position, spacing = _a2.spacing, inset = _a2.inset;
      var title = container.querySelector(CLASS_NAMES5.text.class);
      if (!title)
        return new BBox(0, 0, +containerWidth, +containerHeight);
      var _b = title.getBBox(), titleWidth = _b.width, titleHeight = _b.height;
      var _c = __read(parseSeriesAttr(spacing), 4), spacingTop = _c[0], spacingRight = _c[1], spacingBottom = _c[2], spacingLeft = _c[3];
      var _d = __read([0, 0, +containerWidth, +containerHeight], 4), x3 = _d[0], y3 = _d[1], width = _d[2], height = _d[3];
      var pos = parsePosition(position);
      if (pos.includes("i"))
        return new BBox(x3, y3, width, height);
      pos.forEach(function(p2, i) {
        var _a3, _b2, _c2, _d2;
        if (p2 === "t")
          _a3 = __read(i === 0 ? [titleHeight + spacingBottom, +containerHeight - titleHeight - spacingBottom] : [0, +containerHeight], 2), y3 = _a3[0], height = _a3[1];
        if (p2 === "r")
          _b2 = __read([+containerWidth - titleWidth - spacingLeft], 1), width = _b2[0];
        if (p2 === "b")
          _c2 = __read([+containerHeight - titleHeight - spacingTop], 1), height = _c2[0];
        if (p2 === "l")
          _d2 = __read(i === 0 ? [titleWidth + spacingRight, +containerWidth - titleWidth - spacingRight] : [0, +containerWidth], 2), x3 = _d2[0], width = _d2[1];
      });
      var _e = __read(parseSeriesAttr(inset), 4), insetTop = _e[0], insetRight = _e[1], insetBottom = _e[2], insetLeft = _e[3];
      var _f = __read([insetLeft + insetRight, insetTop + insetBottom], 2), insetWidth = _f[0], insetHeight = _f[1];
      return new BBox(x3 + insetLeft, y3 + insetTop, width - insetWidth, height - insetHeight);
    };
    Title3.prototype.getBBox = function() {
      if (this.title)
        return this.title.getBBox();
      return new BBox(0, 0, 0, 0);
    };
    Title3.prototype.render = function(attributes, container) {
      var _this2 = this;
      var width = attributes.width, height = attributes.height, position = attributes.position, spacing = attributes.spacing, restStyle = __rest(attributes, ["width", "height", "position", "spacing"]);
      var _a2 = __read(splitStyle(restStyle), 1), titleStyle = _a2[0];
      var _b = getTitleLayout(attributes), x3 = _b.x, y3 = _b.y, textAlign = _b.textAlign, textBaseline = _b.textBaseline;
      ifShow(!!restStyle.text, select2(container), function(group3) {
        _this2.title = group3.maybeAppendByClassName(CLASS_NAMES5.text, "text").styles(titleStyle).call(mayApplyStyle, { x: x3, y: y3, textAlign, textBaseline }).node();
      });
    };
    return Title3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/axis/guides/title.js
function getTitlePosition(mainGroup, titleGroup, attr2) {
  var _a2 = attr2.titlePosition, position = _a2 === void 0 ? "lb" : _a2, spacing = attr2.titleSpacing;
  var pos = parsePosition(position);
  var _b = mainGroup.node().getLocalBounds(), _c = __read(_b.min, 2), mainX = _c[0], mainY = _c[1], _d = __read(_b.halfExtents, 2), mainHalfWidth = _d[0], mainHalfHeight = _d[1];
  var _e = __read(titleGroup.node().getLocalBounds().halfExtents, 2), titleHalfWidth = _e[0], titleHalfHeight = _e[1];
  var _f = __read([mainX + mainHalfWidth, mainY + mainHalfHeight], 2), x3 = _f[0], y3 = _f[1];
  var _g = __read(parseSeriesAttr(spacing), 4), spacingTop = _g[0], spacingRight = _g[1], spacingBottom = _g[2], spacingLeft = _g[3];
  if (["start", "end"].includes(position) && attr2.type === "linear") {
    var startPos = attr2.startPos, endPos = attr2.endPos;
    var _h = __read(position === "start" ? [startPos, endPos] : [endPos, startPos], 2), from = _h[0], to = _h[1];
    var direction3 = normalize7([-to[0] + from[0], -to[1] + from[1]]);
    var _j = __read(scale8(direction3, spacingTop), 2), dx = _j[0], dy = _j[1];
    return { x: from[0] + dx, y: from[1] + dy };
  }
  if (pos.includes("t"))
    y3 -= mainHalfHeight + titleHalfHeight + spacingTop;
  if (pos.includes("r"))
    x3 += mainHalfWidth + titleHalfWidth + spacingRight;
  if (pos.includes("l"))
    x3 -= mainHalfWidth + titleHalfWidth + spacingLeft;
  if (pos.includes("b"))
    y3 += mainHalfHeight + titleHalfHeight + spacingBottom;
  return { x: x3, y: y3 };
}
function inferTransform(n, direction3, position) {
  var halfExtents = n.getGeometryBounds().halfExtents;
  var height = halfExtents[1] * 2;
  if (direction3 === "vertical") {
    if (position === "left")
      return "rotate(-90) translate(0, ".concat(height / 2, ")");
    if (position === "right")
      return "rotate(-90) translate(0, -".concat(height / 2, ")");
  }
  return "";
}
function applyTitleStyle(title, group3, axis, attr2, animate2) {
  var style = subStyleProps(attr2, "title");
  var _a2 = __read(splitStyle(style), 2), titleStyle = _a2[0], _b = _a2[1], specified = _b.transform, transformOrigin = _b.transformOrigin, groupStyle = __rest(_b, ["transform", "transformOrigin"]);
  group3.styles(groupStyle);
  var transform2 = specified || inferTransform(title.node(), titleStyle.direction, titleStyle.position);
  title.styles(__assign(__assign({}, titleStyle), { transformOrigin }));
  percentTransform(title.node(), transform2);
  var _c = getTitlePosition(
    // @ts-ignore
    select2(axis._offscreen || axis.querySelector(CLASS_NAMES3.mainGroup.class)),
    group3,
    attr2
  ), x3 = _c.x, y3 = _c.y;
  var animation = transition(group3.node(), { transform: "translate(".concat(x3, ", ").concat(y3, ")") }, animate2);
  return animation;
}
function renderTitle(container, axis, attr2, animate2) {
  var titleText = attr2.titleText;
  return container.selectAll(CLASS_NAMES3.title.class).data([{ title: titleText }].filter(function(d3) {
    return !!d3.title;
  }), function(d3, i) {
    return d3.title;
  }).join(function(enter) {
    return enter.append(function() {
      return renderExtDo(titleText);
    }).attr("className", CLASS_NAMES3.title.name).transition(function() {
      return applyTitleStyle(select2(this), container, axis, attr2, animate2.enter);
    });
  }, function(update2) {
    return update2.transition(function() {
      return applyTitleStyle(select2(this), container, axis, attr2, animate2.update);
    });
  }, function(exit) {
    return exit.remove();
  }).transitions();
}

// node_modules/@antv/component/esm/ui/axis/axis.js
function renderAxisMain(attributes, container, data2, animation) {
  var showLine = attributes.showLine, showTick = attributes.showTick, showLabel = attributes.showLabel;
  var lineGroup = container.maybeAppendByClassName(CLASS_NAMES3.lineGroup, "g");
  var lineTransitions = ifShow(showLine, lineGroup, function(group3) {
    return renderAxisLine(group3, attributes, animation);
  }) || [];
  var tickGroup = container.maybeAppendByClassName(CLASS_NAMES3.tickGroup, "g");
  var tickTransitions = ifShow(showTick, tickGroup, function(group3) {
    return renderTicks(group3, data2, attributes, animation);
  }) || [];
  var labelGroup = container.maybeAppendByClassName(CLASS_NAMES3.labelGroup, "g");
  var labelTransitions = ifShow(showLabel, labelGroup, function(group3) {
    return renderLabels(group3, data2, attributes, animation);
  }) || [];
  return __spreadArray(__spreadArray(__spreadArray([], __read(lineTransitions), false), __read(tickTransitions), false), __read(labelTransitions), false).filter(function(t) {
    return !!t;
  });
}
var Axis = (
  /** @class */
  function(_super) {
    __extends(Axis2, _super);
    function Axis2(options) {
      return _super.call(this, options, AXIS_BASE_DEFAULT_ATTR) || this;
    }
    Axis2.prototype.render = function(attributes, container, specificAnimation) {
      var _this2 = this;
      var titleText = attributes.titleText, data2 = attributes.data, animate2 = attributes.animate, showTitle = attributes.showTitle, showGrid = attributes.showGrid, dataThreshold = attributes.dataThreshold, truncRange = attributes.truncRange;
      var sampledData = sampling(data2, dataThreshold).filter(function(_a2) {
        var value2 = _a2.value;
        if (truncRange && value2 > truncRange[0] && value2 < truncRange[1])
          return false;
        return true;
      });
      var finalAnimation = parseAnimationOption(specificAnimation === void 0 ? animate2 : specificAnimation);
      var gridGroup = select2(container).maybeAppendByClassName(CLASS_NAMES3.gridGroup, "g");
      var gridTransitions = ifShow(showGrid, gridGroup, function(group3) {
        return renderGrid(group3, sampledData, attributes, finalAnimation);
      }) || [];
      var mainGroup = select2(container).maybeAppendByClassName(CLASS_NAMES3.mainGroup, "g");
      if (titleText && (!this.initialized && finalAnimation.enter || this.initialized && finalAnimation.update)) {
        renderAxisMain(attributes, select2(this.offscreenGroup), sampledData, parseAnimationOption(false));
      }
      var mainTransitions = renderAxisMain(attributes, select2(mainGroup.node()), sampledData, finalAnimation);
      var titleGroup = select2(container).maybeAppendByClassName(CLASS_NAMES3.titleGroup, "g");
      var titleTransitions = ifShow(showTitle, titleGroup, function(group3) {
        return renderTitle(group3, _this2, attributes, finalAnimation);
      }) || [];
      return __spreadArray(__spreadArray(__spreadArray([], __read(gridTransitions), false), __read(mainTransitions), false), __read(titleTransitions), false).flat().filter(function(t) {
        return !!t;
      });
    };
    return Axis2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/timeline/index.js
var Timeline = (
  /** @class */
  function() {
    function Timeline2() {
    }
    return Timeline2;
  }()
);

// node_modules/@antv/component/esm/ui/navigator/index.js
var CLASS_NAMES6 = classNames({
  prevBtnGroup: "prev-btn-group",
  prevBtn: "prev-btn",
  nextBtnGroup: "next-btn-group",
  nextBtn: "next-btn",
  pageInfoGroup: "page-info-group",
  pageInfo: "page-info",
  playWindow: "play-window",
  contentGroup: "content-group",
  controller: "controller",
  clipPath: "clip-path"
}, "navigator");
var Navigator = (
  /** @class */
  function(_super) {
    __extends(Navigator2, _super);
    function Navigator2(options) {
      var _this2 = _super.call(this, options, {
        x: 0,
        y: 0,
        animate: {
          easing: "linear",
          duration: 200,
          fill: "both"
        },
        buttonCursor: "pointer",
        buttonFill: "black",
        buttonD: button(0, 0, 6),
        buttonSize: 12,
        controllerPadding: 5,
        controllerSpacing: 5,
        formatter: function(curr, total) {
          return "".concat(curr, "/").concat(total);
        },
        defaultPage: 0,
        loop: false,
        orientation: "horizontal",
        pageNumFill: "black",
        pageNumFontSize: 12,
        pageNumTextAlign: "start",
        pageNumTextBaseline: "middle"
      }) || this;
      _this2.playState = "idle";
      _this2.contentGroup = _this2.appendChild(new Group2({ class: CLASS_NAMES6.contentGroup.name }));
      _this2.playWindow = _this2.contentGroup.appendChild(new Group2({ class: CLASS_NAMES6.playWindow.name }));
      _this2.innerCurrPage = _this2.defaultPage;
      return _this2;
    }
    Object.defineProperty(Navigator2.prototype, "defaultPage", {
      get: function() {
        var defaultPage = this.attributes.defaultPage;
        return clamp_default(defaultPage, 0, Math.max(this.pageViews.length - 1, 0));
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "pageViews", {
      get: function() {
        return this.playWindow.children;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "controllerShape", {
      // todo fixme
      get: function() {
        return this.totalPages > 1 ? { width: 55, height: 0 } : { width: 0, height: 0 };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "pageShape", {
      get: function() {
        var pageViews = this.pageViews;
        var _a2 = __read(transpose4(pageViews.map(function(pageView) {
          var _a3 = pageView.getBBox(), width = _a3.width, height = _a3.height;
          return [width, height];
        })).map(function(arr) {
          return Math.max.apply(Math, __spreadArray([], __read(arr), false));
        }), 2), maxWidth = _a2[0], maxHeight = _a2[1];
        var _b = this.attributes, _c = _b.pageWidth, pageWidth = _c === void 0 ? maxWidth : _c, _d = _b.pageHeight, pageHeight = _d === void 0 ? maxHeight : _d;
        return { pageWidth, pageHeight };
      },
      enumerable: false,
      configurable: true
    });
    Navigator2.prototype.getContainer = function() {
      return this.playWindow;
    };
    Object.defineProperty(Navigator2.prototype, "totalPages", {
      get: function() {
        return this.pageViews.length;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "currPage", {
      get: function() {
        return this.innerCurrPage;
      },
      enumerable: false,
      configurable: true
    });
    Navigator2.prototype.getBBox = function() {
      var _a2 = _super.prototype.getBBox.call(this), x3 = _a2.x, y3 = _a2.y;
      var controllerShape = this.controllerShape;
      var _b = this.pageShape, pageWidth = _b.pageWidth, pageHeight = _b.pageHeight;
      return new BBox(x3, y3, pageWidth + controllerShape.width, pageHeight);
    };
    Navigator2.prototype.goTo = function(pageNum) {
      var _this2 = this;
      var animateOptions = this.attributes.animate;
      var _a2 = this, currPage = _a2.currPage, playState = _a2.playState, playWindow = _a2.playWindow, pageViews = _a2.pageViews;
      if (playState !== "idle" || pageNum < 0 || pageViews.length <= 0 || pageNum >= pageViews.length)
        return null;
      pageViews[currPage].setLocalPosition(0, 0);
      this.prepareFollowingPage(pageNum);
      var _b = __read(this.getFollowingPageDiff(pageNum), 2), dx = _b[0], dy = _b[1];
      this.playState = "running";
      var animation = animate(playWindow, [{ transform: "translate(0, 0)" }, { transform: "translate(".concat(-dx, ", ").concat(-dy, ")") }], animateOptions);
      onAnimateFinished(animation, function() {
        _this2.innerCurrPage = pageNum;
        _this2.playState = "idle";
        _this2.setVisiblePages([pageNum]);
        _this2.updatePageInfo();
      });
      return animation;
    };
    Navigator2.prototype.prev = function() {
      var loop = this.attributes.loop;
      var pages = this.pageViews.length;
      var page = this.currPage;
      if (!loop && page <= 0)
        return null;
      var following = loop ? (page - 1 + pages) % pages : clamp_default(page - 1, 0, pages);
      return this.goTo(following);
    };
    Navigator2.prototype.next = function() {
      var loop = this.attributes.loop;
      var pages = this.pageViews.length;
      var page = this.currPage;
      if (!loop && page >= pages - 1)
        return null;
      var following = loop ? (page + 1) % pages : clamp_default(page + 1, 0, pages);
      return this.goTo(following);
    };
    Navigator2.prototype.renderClipPath = function(container) {
      var _a2 = this.pageShape, pageWidth = _a2.pageWidth, pageHeight = _a2.pageHeight;
      if (!pageWidth || !pageHeight) {
        this.contentGroup.style.clipPath = void 0;
        return;
      }
      this.clipPath = container.maybeAppendByClassName(CLASS_NAMES6.clipPath, "rect").styles({
        width: pageWidth,
        height: pageHeight
      });
      this.contentGroup.attr("clipPath", this.clipPath.node());
    };
    Navigator2.prototype.setVisiblePages = function(pages) {
      this.playWindow.children.forEach(function(page, index3) {
        if (pages.includes(index3))
          show(page);
        else
          hide(page);
      });
    };
    Navigator2.prototype.adjustControllerLayout = function() {
      var _a2 = this, prevBtn = _a2.prevBtnGroup, nextBtn = _a2.nextBtnGroup, pageNum = _a2.pageInfoGroup;
      var _b = this.attributes, orientation = _b.orientation, padding = _b.controllerPadding;
      var _c = pageNum.getBBox(), pW = _c.width, pH = _c.height;
      var _d = __read(orientation === "horizontal" ? [-180, 0] : [-90, 90], 2), r1 = _d[0], r2 = _d[1];
      prevBtn.setLocalEulerAngles(r1);
      nextBtn.setLocalEulerAngles(r2);
      var _e = prevBtn.getBBox(), bpW = _e.width, bpH = _e.height;
      var _f = nextBtn.getBBox(), bnW = _f.width, bnH = _f.height;
      var maxWidth = Math.max(bpW, pW, bnW);
      var _g = orientation === "horizontal" ? {
        offset: [
          [0, 0],
          [bpW / 2 + padding, 0],
          [bpW + pW + padding * 2, 0]
        ],
        textAlign: "start"
      } : {
        offset: [
          [maxWidth / 2, -bpH - padding],
          [maxWidth / 2, 0],
          [maxWidth / 2, bnH + padding]
        ],
        textAlign: "center"
      }, _h = __read(_g.offset, 3), _j = __read(_h[0], 2), o1x = _j[0], o1y = _j[1], _k = __read(_h[1], 2), o2x = _k[0], o2y = _k[1], _l = __read(_h[2], 2), o3x = _l[0], o3y = _l[1], textAlign = _g.textAlign;
      var pageNumText = pageNum.querySelector("text");
      pageNumText && (pageNumText.style.textAlign = textAlign);
      prevBtn.setLocalPosition(o1x, o1y);
      pageNum.setLocalPosition(o2x, o2y);
      nextBtn.setLocalPosition(o3x, o3y);
    };
    Navigator2.prototype.updatePageInfo = function() {
      var _a2;
      var _b = this, currPage = _b.currPage, pageViews = _b.pageViews, formatter2 = _b.attributes.formatter;
      if (pageViews.length < 2)
        return;
      (_a2 = this.pageInfoGroup.querySelector(CLASS_NAMES6.pageInfo.class)) === null || _a2 === void 0 ? void 0 : _a2.attr("text", formatter2(currPage + 1, pageViews.length));
      this.adjustControllerLayout();
    };
    Navigator2.prototype.getFollowingPageDiff = function(pageNum) {
      var currPage = this.currPage;
      if (currPage === pageNum)
        return [0, 0];
      var orientation = this.attributes.orientation;
      var _a2 = this.pageShape, pageWidth = _a2.pageWidth, pageHeight = _a2.pageHeight;
      var sign3 = pageNum < currPage ? -1 : 1;
      return orientation === "horizontal" ? [sign3 * pageWidth, 0] : [0, sign3 * pageHeight];
    };
    Navigator2.prototype.prepareFollowingPage = function(pageNum) {
      var _a2 = this, currPage = _a2.currPage, pageViews = _a2.pageViews;
      this.setVisiblePages([pageNum, currPage]);
      if (pageNum !== currPage) {
        var _b = __read(this.getFollowingPageDiff(pageNum), 2), dx = _b[0], dy = _b[1];
        pageViews[pageNum].setLocalPosition(dx, dy);
      }
    };
    Navigator2.prototype.renderController = function(container) {
      var _this2 = this;
      var spacing = this.attributes.controllerSpacing;
      var _a2 = this.pageShape, pageWidth = _a2.pageWidth, pageHeight = _a2.pageHeight;
      var visible = this.pageViews.length >= 2;
      var group3 = container.maybeAppendByClassName(CLASS_NAMES6.controller, "g");
      visibility(group3.node(), visible);
      if (!visible)
        return;
      var style = subStyleProps(this.attributes, "button");
      var textStyle = subStyleProps(this.attributes, "pageNum");
      var _b = __read(splitStyle(style), 2), _c = _b[0], groupStyle = _b[1], size3 = _c.size, pathStyle = __rest(_c, ["size"]);
      var whetherToAddEventListener = !group3.select(CLASS_NAMES6.prevBtnGroup.class).node();
      var prevBtnGroup = group3.maybeAppendByClassName(CLASS_NAMES6.prevBtnGroup, "g").styles(groupStyle);
      this.prevBtnGroup = prevBtnGroup.node();
      var prevBtn = prevBtnGroup.maybeAppendByClassName(CLASS_NAMES6.prevBtn, "path");
      var nextBtnGroup = group3.maybeAppendByClassName(CLASS_NAMES6.nextBtnGroup, "g").styles(groupStyle);
      this.nextBtnGroup = nextBtnGroup.node();
      var nextBtn = nextBtnGroup.maybeAppendByClassName(CLASS_NAMES6.nextBtn, "path");
      [prevBtn, nextBtn].forEach(function(btn) {
        btn.styles(__assign(__assign({}, pathStyle), { transformOrigin: "center" }));
        scaleToPixel(btn.node(), size3, true);
      });
      var pageInfoGroup = group3.maybeAppendByClassName(CLASS_NAMES6.pageInfoGroup, "g");
      this.pageInfoGroup = pageInfoGroup.node();
      pageInfoGroup.maybeAppendByClassName(CLASS_NAMES6.pageInfo, "text").styles(textStyle);
      this.updatePageInfo();
      group3.node().setLocalPosition(pageWidth + spacing, pageHeight / 2);
      if (whetherToAddEventListener) {
        this.prevBtnGroup.addEventListener("click", function() {
          _this2.prev();
        });
        this.nextBtnGroup.addEventListener("click", function() {
          _this2.next();
        });
      }
    };
    Navigator2.prototype.render = function(attributes, container) {
      var _a2 = attributes.x, x3 = _a2 === void 0 ? 0 : _a2, _b = attributes.y, y3 = _b === void 0 ? 0 : _b;
      this.attr("transform", "translate(".concat(x3, ", ").concat(y3, ")"));
      var containerSelection = select2(container);
      this.renderClipPath(containerSelection);
      this.renderController(containerSelection);
      this.setVisiblePages([this.defaultPage]);
      this.goTo(this.defaultPage);
    };
    Navigator2.prototype.bindEvents = function() {
      var _this2 = this;
      var render3 = debounce_default(function() {
        return _this2.render(_this2.attributes, _this2);
      }, 50);
      this.playWindow.addEventListener(ElementEvent.INSERTED, render3);
      this.playWindow.addEventListener(ElementEvent.REMOVED, render3);
    };
    return Navigator2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/utils.js
function getStepValueByValue(value2, step2, min10) {
  var count4 = Math.round((value2 - min10) / step2);
  return min10 + count4 * step2;
}
function hiddenHandle(x3, y3, r) {
  var ratio = 1.4;
  var diffY = ratio * r;
  return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 - diffY], ["L", x3 + r, y3 + diffY], ["L", x3 - r, y3 + diffY], ["Z"]];
}
var HANDLE_HEIGHT_RATIO = 1.4;
var HANDLE_TRIANGLE_RATIO = 0.4;
function verticalHandle(x3, y3, r) {
  var width = r;
  var height = width * HANDLE_HEIGHT_RATIO;
  var halfWidth = width / 2;
  var oneSixthWidth = width / 6;
  var triangleX = x3 + height * HANDLE_TRIANGLE_RATIO;
  return [
    ["M", x3, y3],
    ["L", triangleX, y3 + halfWidth],
    ["L", x3 + height, y3 + halfWidth],
    ["L", x3 + height, y3 - halfWidth],
    ["L", triangleX, y3 - halfWidth],
    ["Z"],
    // 绘制两条横线
    ["M", triangleX, y3 + oneSixthWidth],
    ["L", x3 + height - 2, y3 + oneSixthWidth],
    ["M", triangleX, y3 - oneSixthWidth],
    ["L", x3 + height - 2, y3 - oneSixthWidth]
  ];
}
function horizontalHandle(x3, y3, r) {
  var width = r;
  var height = width * HANDLE_HEIGHT_RATIO;
  var halfWidth = width / 2;
  var oneSixthWidth = width / 6;
  var triangleY = y3 + height * HANDLE_TRIANGLE_RATIO;
  return [
    ["M", x3, y3],
    ["L", x3 - halfWidth, triangleY],
    ["L", x3 - halfWidth, y3 + height],
    ["L", x3 + halfWidth, y3 + height],
    ["L", x3 + halfWidth, triangleY],
    ["Z"],
    // 绘制两条竖线
    ["M", x3 - oneSixthWidth, triangleY],
    ["L", x3 - oneSixthWidth, y3 + height - 2],
    ["M", x3 + oneSixthWidth, triangleY],
    ["L", x3 + oneSixthWidth, y3 + height - 2]
  ];
}
Marker.registerSymbol("hiddenHandle", hiddenHandle);
Marker.registerSymbol("verticalHandle", verticalHandle);
Marker.registerSymbol("horizontalHandle", horizontalHandle);
function getSafetySelections(domain, newSelection, oldSelection, precision) {
  var _a2;
  if (precision === void 0) {
    precision = 4;
  }
  var _b = __read(domain, 2), min10 = _b[0], max11 = _b[1];
  var _c = __read(newSelection, 2), start = _c[0], end = _c[1];
  var _d = __read(oldSelection, 2), prevStart = _d[0], prevEnd = _d[1];
  var _e = __read([start, end], 2), startVal = _e[0], endVal = _e[1];
  var range3 = endVal - startVal;
  if (startVal > endVal) {
    _a2 = __read([endVal, startVal], 2), startVal = _a2[0], endVal = _a2[1];
  }
  if (range3 > max11 - min10) {
    return [min10, max11];
  }
  if (startVal < min10) {
    if (prevStart === min10 && prevEnd === endVal) {
      return [min10, endVal];
    }
    return [min10, range3 + min10];
  }
  if (endVal > max11) {
    if (prevEnd === max11 && prevStart === startVal) {
      return [startVal, max11];
    }
    return [max11 - range3, max11];
  }
  return [startVal, endVal];
}
function ifHorizontal(orientation, a4, b) {
  if (orientation === void 0) {
    orientation = "horizontal";
  }
  return orientation === "horizontal" ? a4 : b;
}

// node_modules/@antv/component/esm/ui/legend/category/item.js
var CLASS_NAMES7 = classNames({
  layout: "flex",
  markerGroup: "marker-group",
  marker: "marker",
  labelGroup: "label-group",
  label: "label",
  valueGroup: "value-group",
  value: "value",
  backgroundGroup: "background-group",
  background: "background"
}, "legend-category-item");
function styleOfMarker(group3) {
  var marker = group3.querySelector(CLASS_NAMES7.marker.class);
  if (marker)
    return marker.style;
  return {};
}
var CategoryItem = (
  /** @class */
  function(_super) {
    __extends(CategoryItem2, _super);
    function CategoryItem2(options) {
      return _super.call(this, options, {
        span: [1, 1],
        marker: function() {
          return new Circle({ style: { r: 6 } });
        },
        markerSize: 10,
        labelFill: "#646464",
        valueFill: "#646464",
        labelFontSize: 12,
        valueFontSize: 12,
        labelTextBaseline: "middle",
        valueTextBaseline: "middle"
      }) || this;
    }
    Object.defineProperty(CategoryItem2.prototype, "showValue", {
      get: function() {
        var valueText = this.attributes.valueText;
        if (!valueText)
          return false;
        if (typeof valueText === "string" || typeof valueText === "number")
          return valueText !== "";
        if (typeof valueText === "function")
          return true;
        return valueText.attr("text") !== "";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "actualSpace", {
      get: function() {
        var label = this.labelGroup;
        var value2 = this.valueGroup;
        var markerSize = this.attributes.markerSize;
        var _a2 = label.node().getBBox(), labelWidth = _a2.width, labelHeight = _a2.height;
        var _b = value2.node().getBBox(), valueWidth = _b.width, valueHeight = _b.height;
        return {
          markerWidth: markerSize,
          labelWidth,
          valueWidth,
          height: Math.max(markerSize, labelHeight, valueHeight)
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "span", {
      get: function() {
        var span = this.attributes.span;
        if (!span)
          return [1, 1];
        var _a2 = __read(parseSeriesAttr(span), 2), span1 = _a2[0], innerSpan = _a2[1];
        var span2 = this.showValue ? innerSpan : 0;
        var basis2 = span1 + span2;
        return [span1 / basis2, span2 / basis2];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "shape", {
      get: function() {
        var _a2;
        var _b = this.attributes, markerSize = _b.markerSize, fullWidth = _b.width;
        var actualSpace = this.actualSpace;
        var markerWidth = actualSpace.markerWidth, height = actualSpace.height;
        var _c = this.actualSpace, labelWidth = _c.labelWidth, valueWidth = _c.valueWidth;
        var _d = __read(this.spacing, 2), spacing1 = _d[0], spacing2 = _d[1];
        if (fullWidth) {
          var width_1 = fullWidth - markerSize - spacing1 - spacing2;
          var _e = __read(this.span, 2), span1 = _e[0], span2 = _e[1];
          _a2 = __read([span1 * width_1, span2 * width_1], 2), labelWidth = _a2[0], valueWidth = _a2[1];
        }
        var width = markerWidth + labelWidth + valueWidth + spacing1 + spacing2;
        return { width, height, markerWidth, labelWidth, valueWidth };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "spacing", {
      get: function() {
        var spacing = this.attributes.spacing;
        if (!spacing)
          return [0, 0];
        var _a2 = __read(parseSeriesAttr(spacing), 2), spacing1 = _a2[0], spacing2 = _a2[1];
        if (this.showValue)
          return [spacing1, spacing2];
        return [spacing1, 0];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "layout", {
      get: function() {
        var _a2 = this.shape, markerWidth = _a2.markerWidth, labelWidth = _a2.labelWidth, valueWidth = _a2.valueWidth, width = _a2.width, height = _a2.height;
        var _b = __read(this.spacing, 2), spacing1 = _b[0], spacing2 = _b[1];
        return {
          height,
          width,
          markerWidth,
          labelWidth,
          valueWidth,
          position: [markerWidth / 2, markerWidth + spacing1, markerWidth + labelWidth + spacing1 + spacing2]
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "scaleSize", {
      get: function() {
        var markerShapeStyle = styleOfMarker(this.markerGroup.node());
        var _a2 = this.attributes, markerSize = _a2.markerSize, _b = _a2.markerStrokeWidth, markerStrokeWidth = _b === void 0 ? markerShapeStyle.strokeWidth : _b, _c = _a2.markerLineWidth, markerLineWidth = _c === void 0 ? markerShapeStyle.lineWidth : _c, _d = _a2.markerStroke, markerStroke = _d === void 0 ? markerShapeStyle.stroke : _d;
        var strokeWidth = +(markerStrokeWidth || markerLineWidth || (markerStroke ? 1 : 0)) * Math.sqrt(2);
        var _e = this.markerGroup.node().getBBox(), width = _e.width, height = _e.height;
        return (1 - strokeWidth / Math.max(width, height)) * markerSize;
      },
      enumerable: false,
      configurable: true
    });
    CategoryItem2.prototype.renderMarker = function(container) {
      var _this2 = this;
      var marker = this.attributes.marker;
      var style = subStyleProps(this.attributes, "marker");
      this.markerGroup = container.maybeAppendByClassName(CLASS_NAMES7.markerGroup, "g").style("zIndex", 0);
      ifShow(!!marker, this.markerGroup, function() {
        var _a2;
        var parent = _this2.markerGroup.node();
        var oldMarker = (_a2 = parent.childNodes) === null || _a2 === void 0 ? void 0 : _a2[0];
        var newMarker = typeof marker === "string" ? new Marker({ style: { symbol: marker }, className: CLASS_NAMES7.marker.name }) : marker();
        if (!oldMarker) {
          if (!(newMarker instanceof Marker))
            select2(newMarker).attr("className", CLASS_NAMES7.marker.name).styles(style);
          parent.appendChild(newMarker);
        } else if (newMarker.nodeName === oldMarker.nodeName) {
          if (oldMarker instanceof Marker)
            oldMarker.update(__assign(__assign({}, style), { symbol: marker }));
          else {
            copyAttributes2(oldMarker, newMarker);
            select2(oldMarker).styles(style);
          }
        } else {
          oldMarker.remove();
          select2(newMarker).attr("className", CLASS_NAMES7.marker.name).styles(style);
          parent.appendChild(newMarker);
        }
        _this2.markerGroup.node().scale(1 / _this2.markerGroup.node().getScale()[0]);
        var scale11 = scaleToPixel(_this2.markerGroup.node(), _this2.scaleSize, true);
        _this2.markerGroup.node().style._transform = "scale(".concat(scale11, ")");
      });
    };
    CategoryItem2.prototype.renderLabel = function(container) {
      var _a2 = subStyleProps(this.attributes, "label"), label = _a2.text, style = __rest(_a2, ["text"]);
      this.labelGroup = container.maybeAppendByClassName(CLASS_NAMES7.labelGroup, "g").style("zIndex", 0);
      this.labelGroup.maybeAppendByClassName(CLASS_NAMES7.label, function() {
        return renderExtDo(label);
      }).styles(style);
    };
    CategoryItem2.prototype.renderValue = function(container) {
      var _this2 = this;
      var _a2 = subStyleProps(this.attributes, "value"), value2 = _a2.text, style = __rest(_a2, ["text"]);
      this.valueGroup = container.maybeAppendByClassName(CLASS_NAMES7.valueGroup, "g").style("zIndex", 0);
      ifShow(this.showValue, this.valueGroup, function() {
        _this2.valueGroup.maybeAppendByClassName(CLASS_NAMES7.value, function() {
          return renderExtDo(value2);
        }).styles(style);
      });
    };
    CategoryItem2.prototype.renderBackground = function(container) {
      var _a2 = this.shape, width = _a2.width, height = _a2.height;
      var style = subStyleProps(this.attributes, "background");
      this.background = container.maybeAppendByClassName(CLASS_NAMES7.backgroundGroup, "g").style("zIndex", -1);
      this.background.maybeAppendByClassName(CLASS_NAMES7.background, "rect").styles(__assign({ width, height }, style));
    };
    CategoryItem2.prototype.adjustLayout = function() {
      var _a2 = this.layout, labelWidth = _a2.labelWidth, valueWidth = _a2.valueWidth, height = _a2.height, _b = __read(_a2.position, 3), markerX = _b[0], labelX = _b[1], valueX = _b[2];
      var halfHeight = height / 2;
      this.markerGroup.styles({
        transform: "translate(".concat(markerX, ", ").concat(halfHeight, ")").concat(this.markerGroup.node().style._transform)
      });
      this.labelGroup.styles({ transform: "translate(".concat(labelX, ", ").concat(halfHeight, ")") });
      ellipsisIt(this.labelGroup.select(CLASS_NAMES7.label.class).node(), Math.ceil(labelWidth));
      if (this.showValue) {
        this.valueGroup.styles({ transform: "translate(".concat(valueX, ", ").concat(halfHeight, ")") });
        ellipsisIt(this.valueGroup.select(CLASS_NAMES7.value.class).node(), Math.ceil(valueWidth));
      }
    };
    CategoryItem2.prototype.render = function(attributes, container) {
      var ctn = select2(container);
      var _a2 = attributes.x, x3 = _a2 === void 0 ? 0 : _a2, _b = attributes.y, y3 = _b === void 0 ? 0 : _b;
      ctn.styles({ transform: "translate(".concat(x3, ", ").concat(y3, ")") });
      this.renderMarker(ctn);
      this.renderLabel(ctn);
      this.renderValue(ctn);
      this.renderBackground(ctn);
      this.adjustLayout();
    };
    return CategoryItem2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/category/items.js
var CLASS_NAMES8 = classNames({
  page: "item-page",
  navigator: "navigator",
  item: "item"
}, "items");
var ifSatisfied = function(value2, rule, defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = true;
  }
  if (value2) {
    return rule(value2);
  }
  return defaultValue;
};
var CategoryItems = (
  /** @class */
  function(_super) {
    __extends(CategoryItems2, _super);
    function CategoryItems2(options) {
      var _this2 = _super.call(this, options, {
        data: [],
        gridRow: Infinity,
        gridCol: void 0,
        padding: 0,
        width: 1e3,
        height: 100,
        rowPadding: 0,
        colPadding: 0,
        layout: "flex",
        orientation: "horizontal",
        click: noop_default,
        mouseenter: noop_default,
        mouseleave: noop_default
      }) || this;
      _this2.navigatorShape = [0, 0];
      return _this2;
    }
    Object.defineProperty(CategoryItems2.prototype, "pageViews", {
      get: function() {
        return this.navigator.getContainer();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItems2.prototype, "grid", {
      get: function() {
        var _a2 = this.attributes, gridRow = _a2.gridRow, gridCol = _a2.gridCol, data2 = _a2.data;
        if (!gridRow && !gridCol)
          throw new Error("gridRow and gridCol can not be set null at the same time");
        if (!!gridRow && !!gridCol)
          return [gridRow, gridCol];
        if (gridRow)
          return [gridRow, data2.length];
        return [data2.length, gridCol];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItems2.prototype, "renderData", {
      get: function() {
        var _a2 = this.attributes, data2 = _a2.data, layout = _a2.layout;
        var style = subStyleProps(this.attributes, "item");
        var d3 = data2.map(function(datum, index3) {
          var _a3 = datum.id, id4 = _a3 === void 0 ? index3 : _a3, labelText = datum.label, valueText = datum.value;
          return {
            id: "".concat(id4),
            index: index3,
            style: __assign({ layout, labelText, valueText }, Object.fromEntries(Object.entries(style).map(function(_a4) {
              var _b = __read(_a4, 2), key = _b[0], val = _b[1];
              return [key, getCallbackValue(val, [datum, index3, data2])];
            })))
          };
        });
        return d3;
      },
      enumerable: false,
      configurable: true
    });
    CategoryItems2.prototype.getGridLayout = function() {
      var _this2 = this;
      var _a2 = this.attributes, orientation = _a2.orientation, width = _a2.width, rowPadding = _a2.rowPadding, colPadding = _a2.colPadding;
      var _b = __read(this.navigatorShape, 1), navWidth = _b[0];
      var _c = __read(this.grid, 2), gridRow = _c[0], gridCol = _c[1];
      var pageSize = gridCol * gridRow;
      var prevOffset = 0;
      return this.pageViews.children.map(function(item, index3) {
        var _a3, _b2;
        var page = Math.floor(index3 / pageSize);
        var pageIndex = index3 % pageSize;
        var dir = _this2.ifHorizontal(gridCol, gridRow);
        var pos = [Math.floor(pageIndex / dir), pageIndex % dir];
        if (orientation === "vertical")
          pos.reverse();
        var _c2 = __read(pos, 2), row2 = _c2[0], col = _c2[1];
        var colWidth = (width - navWidth - (gridCol - 1) * colPadding) / gridCol;
        var rowHeight = item.getBBox().height;
        var _d = __read([0, 0], 2), x3 = _d[0], y3 = _d[1];
        if (orientation === "horizontal") {
          _a3 = __read([prevOffset, row2 * (rowHeight + rowPadding)], 2), x3 = _a3[0], y3 = _a3[1];
          prevOffset = col === gridCol - 1 ? 0 : prevOffset + colWidth + colPadding;
        } else {
          _b2 = __read([col * (colWidth + colPadding), prevOffset], 2), x3 = _b2[0], y3 = _b2[1];
          prevOffset = row2 === gridRow - 1 ? 0 : prevOffset + rowHeight + rowPadding;
        }
        return { page, index: index3, row: row2, col, pageIndex, width: colWidth, height: rowHeight, x: x3, y: y3 };
      });
    };
    CategoryItems2.prototype.getFlexLayout = function() {
      var _a2 = this.attributes, maxWidth = _a2.width, maxHeight = _a2.height, rowPadding = _a2.rowPadding, cP = _a2.colPadding;
      var _b = __read(this.navigatorShape, 1), navWidth = _b[0];
      var _c = __read(this.grid, 2), gridRow = _c[0], gridCol = _c[1];
      var _d = __read([maxWidth - navWidth, maxHeight], 2), limitWidth = _d[0], limitHeight = _d[1];
      var _e = __read([0, 0, 0, 0, 0, 0, 0, 0], 8), x3 = _e[0], y3 = _e[1], page = _e[2], pageIndex = _e[3], col = _e[4], row2 = _e[5], prevWidth = _e[6], prevHeight = _e[7];
      return this.pageViews.children.map(function(item, index3) {
        var _a3, _b2, _c2, _d2;
        var _e2 = item.getBBox(), width = _e2.width, height = _e2.height;
        var colPadding = prevWidth === 0 ? 0 : cP;
        var nextWidth = prevWidth + colPadding + width;
        if (nextWidth <= limitWidth && ifSatisfied(col, function(c5) {
          return c5 < gridCol;
        })) {
          _a3 = __read([prevWidth + colPadding, prevHeight, nextWidth], 3), x3 = _a3[0], y3 = _a3[1], prevWidth = _a3[2];
          return { width, height, x: x3, y: y3, page, index: index3, pageIndex: pageIndex++, row: row2, col: col++ };
        }
        _b2 = __read([row2 + 1, 0, 0, prevHeight + height + rowPadding], 4), row2 = _b2[0], col = _b2[1], prevWidth = _b2[2], prevHeight = _b2[3];
        var nextHeight = prevHeight + height;
        if (nextHeight <= limitHeight && ifSatisfied(row2, function(r) {
          return r < gridRow;
        })) {
          _c2 = __read([prevWidth, prevHeight, width], 3), x3 = _c2[0], y3 = _c2[1], prevWidth = _c2[2];
          return { width, height, x: x3, y: y3, page, index: index3, pageIndex: pageIndex++, row: row2, col: col++ };
        }
        _d2 = __read([0, 0, width, 0, page + 1, 0, 0, 0], 8), x3 = _d2[0], y3 = _d2[1], prevWidth = _d2[2], prevHeight = _d2[3], page = _d2[4], pageIndex = _d2[5], row2 = _d2[6], col = _d2[7];
        return { width, height, x: x3, y: y3, page, index: index3, pageIndex: pageIndex++, row: row2, col: col++ };
      });
    };
    Object.defineProperty(CategoryItems2.prototype, "itemsLayout", {
      get: function() {
        this.navigatorShape = [0, 0];
        var cb = this.attributes.layout === "grid" ? this.getGridLayout : this.getFlexLayout;
        var layout = cb.call(this);
        if (layout.slice(-1)[0].page > 0) {
          this.navigatorShape = [55, 0];
          return cb.call(this);
        }
        return layout;
      },
      enumerable: false,
      configurable: true
    });
    CategoryItems2.prototype.ifHorizontal = function(a4, b) {
      var orientation = this.attributes.orientation;
      return ifHorizontal(orientation, a4, b);
    };
    CategoryItems2.prototype.flattenPage = function(container) {
      container.querySelectorAll(CLASS_NAMES8.item.class).forEach(function(item) {
        container.appendChild(item);
      });
      container.querySelectorAll(CLASS_NAMES8.page.class).forEach(function(page) {
        var removedPage = container.removeChild(page);
        removedPage.destroy();
      });
    };
    CategoryItems2.prototype.renderItems = function(container) {
      var _a2 = this.attributes, click = _a2.click, mouseenter = _a2.mouseenter, mouseleave = _a2.mouseleave;
      this.flattenPage(container);
      var dispatchCustomEvent = this.dispatchCustomEvent.bind(this);
      select2(container).selectAll(CLASS_NAMES8.item.class).data(this.renderData, function(d3) {
        return d3.id;
      }).join(function(enter) {
        return enter.append(function(_a3) {
          var style = _a3.style;
          return new CategoryItem({ style });
        }).attr("className", CLASS_NAMES8.item.name).on("click", function() {
          click === null || click === void 0 ? void 0 : click(this);
          dispatchCustomEvent("itemClick", { item: this });
        }).on("pointerenter", function() {
          mouseenter === null || mouseenter === void 0 ? void 0 : mouseenter(this);
          dispatchCustomEvent("itemMouseenter", { item: this });
        }).on("pointerleave", function() {
          mouseleave === null || mouseleave === void 0 ? void 0 : mouseleave(this);
          dispatchCustomEvent("itemMouseleave", { item: this });
        });
      }, function(update2) {
        return update2.each(function(_a3) {
          var style = _a3.style;
          this.update(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    CategoryItems2.prototype.relayoutNavigator = function() {
      var _a2;
      var _b = this.attributes, layout = _b.layout, width = _b.width;
      var height = ((_a2 = this.pageViews.children[0]) === null || _a2 === void 0 ? void 0 : _a2.getBBox().height) || 0;
      var _c = __read(this.navigatorShape, 2), navWidth = _c[0], navHeight = _c[1];
      this.navigator.update(layout === "grid" ? { pageWidth: width - navWidth, pageHeight: height - navHeight } : {});
    };
    CategoryItems2.prototype.adjustLayout = function() {
      var _this2 = this;
      var itemsLayouts = Object.entries(groupBy(this.itemsLayout, "page")).map(function(_a2) {
        var _b = __read(_a2, 2), page = _b[0], layouts = _b[1];
        return {
          page,
          layouts
        };
      });
      var categoryItems = __spreadArray([], __read(this.navigator.getContainer().children), false);
      itemsLayouts.forEach(function(_a2) {
        var layouts = _a2.layouts;
        var page = _this2.pageViews.appendChild(new Group2({ className: CLASS_NAMES8.page.name }));
        layouts.forEach(function(layout) {
          var x3 = layout.x, y3 = layout.y, index3 = layout.index, width = layout.width, height = layout.height;
          var item = categoryItems[index3];
          page.appendChild(item);
          set_default(item, "__layout__", layout);
          item.update({ x: x3, y: y3, width, height });
        });
      });
      this.relayoutNavigator();
    };
    CategoryItems2.prototype.renderNavigator = function(container) {
      var orientation = this.attributes.orientation;
      var navStyle = subStyleProps(this.attributes, "nav");
      var style = deepAssign2({ orientation }, navStyle);
      var that = this;
      container.selectAll(CLASS_NAMES8.navigator.class).data(["nav"]).join(function(enter) {
        return enter.append(function() {
          return new Navigator({ style });
        }).attr("className", CLASS_NAMES8.navigator.name).each(function() {
          that.navigator = this;
        });
      }, function(update2) {
        return update2.each(function() {
          this.update(style);
        });
      }, function(exit) {
        return exit.remove();
      });
      return this.navigator;
    };
    CategoryItems2.prototype.getBBox = function() {
      return this.navigator.getBBox();
    };
    CategoryItems2.prototype.render = function(attributes, container) {
      var data2 = this.attributes.data;
      if (!data2 || data2.length === 0)
        return;
      var navigator = this.renderNavigator(select2(container));
      this.renderItems(navigator.getContainer());
      this.adjustLayout();
    };
    CategoryItems2.prototype.dispatchCustomEvent = function(type, payload) {
      var evt = new CustomEvent(type, {
        detail: payload
      });
      this.dispatchEvent(evt);
    };
    return CategoryItems2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/continuous/handle.js
var CLASS_NAMES9 = classNames({
  markerGroup: "marker-group",
  marker: "marker",
  labelGroup: "label-group",
  label: "label"
}, "handle");
var DEFAULT_HANDLE_CFG = {
  showLabel: true,
  formatter: function(val) {
    return val.toString();
  },
  markerSize: 25,
  markerStroke: "#c5c5c5",
  markerFill: "#fff",
  markerLineWidth: 1,
  labelFontSize: 12,
  labelFill: "#c5c5c5",
  labelText: "",
  orientation: "vertical",
  spacing: 0
};
var Handle2 = (
  /** @class */
  function(_super) {
    __extends(Handle3, _super);
    function Handle3(options) {
      return _super.call(this, options, DEFAULT_HANDLE_CFG) || this;
    }
    Handle3.prototype.render = function(attributes, container) {
      var markerGroup = select2(container).maybeAppendByClassName(CLASS_NAMES9.markerGroup, "g");
      this.renderMarker(markerGroup);
      var labelGroup = select2(container).maybeAppendByClassName(CLASS_NAMES9.labelGroup, "g");
      this.renderLabel(labelGroup);
    };
    Handle3.prototype.renderMarker = function(container) {
      var _this2 = this;
      var _a2 = this.attributes, orientation = _a2.orientation, _b = _a2.markerSymbol, markerSymbol = _b === void 0 ? ifHorizontal(orientation, "horizontalHandle", "verticalHandle") : _b;
      ifShow(!!markerSymbol, container, function(group3) {
        var handleStyle = subStyleProps(_this2.attributes, "marker");
        var markerStyle = __assign({ symbol: markerSymbol }, handleStyle);
        _this2.marker = group3.maybeAppendByClassName(CLASS_NAMES9.marker, function() {
          return new Marker({ style: markerStyle });
        }).update(markerStyle);
      });
    };
    Handle3.prototype.renderLabel = function(container) {
      var _this2 = this;
      var _a2 = this.attributes, showLabel = _a2.showLabel, orientation = _a2.orientation, _b = _a2.spacing, spacing = _b === void 0 ? 0 : _b, formatter2 = _a2.formatter;
      ifShow(showLabel, container, function(group3) {
        var _a3;
        var _b2 = subStyleProps(_this2.attributes, "label"), text = _b2.text, labelStyle = __rest(_b2, ["text"]);
        var _c = ((_a3 = group3.select(CLASS_NAMES9.marker.class)) === null || _a3 === void 0 ? void 0 : _a3.node().getBBox()) || {}, _d = _c.width, width = _d === void 0 ? 0 : _d, _e = _c.height, height = _e === void 0 ? 0 : _e;
        var _f = __read(ifHorizontal(orientation, [0, height + spacing, "center", "top"], [width + spacing, 0, "start", "middle"]), 4), x3 = _f[0], y3 = _f[1], textAlign = _f[2], textBaseline = _f[3];
        group3.maybeAppendByClassName(CLASS_NAMES9.label, "text").styles(__assign(__assign({}, labelStyle), { x: x3, y: y3, text: formatter2(text).toString(), textAlign, textBaseline }));
      });
    };
    return Handle3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/constant.js
var LEGEND_BASE_DEFAULT_OPTIONS = {
  showTitle: true,
  padding: 0,
  orientation: "horizontal",
  backgroundFill: "transparent",
  titleText: "",
  titleSpacing: 4,
  titlePosition: "top-left",
  titleFill: "#2C3542",
  titleFontWeight: "bold",
  titleFontFamily: "sans-serif",
  titleFontSize: 12
};
var CATEGORY_DEFAULT_OPTIONS = deepAssign2({}, LEGEND_BASE_DEFAULT_OPTIONS, {});
var CONTINUOUS_DEFAULT_OPTIONS = deepAssign2({}, LEGEND_BASE_DEFAULT_OPTIONS, superStyleProps(DEFAULT_HANDLE_CFG, "handle"), {
  color: [
    "#d0e3fa",
    "#acc7f6",
    "#8daaf2",
    "#6d8eea",
    "#4d73cd",
    "#325bb1",
    "#5a3e75",
    "#8c3c79",
    "#e23455",
    "#e7655b"
  ],
  indicatorBackgroundFill: "#262626",
  indicatorLabelFill: "white",
  indicatorLabelFontSize: 12,
  indicatorVisibility: "hidden",
  labelAlign: "value",
  labelDirection: "positive",
  labelSpacing: 5,
  showHandle: true,
  showIndicator: true,
  showLabel: true,
  slidable: true,
  titleText: "",
  type: "continuous"
});
var STEP_RATIO = 0.01;
var CLASS_NAMES10 = classNames({
  title: "title",
  titleGroup: "title-group",
  items: "items",
  itemsGroup: "items-group",
  contentGroup: "content-group",
  ribbonGroup: "ribbon-group",
  ribbon: "ribbon",
  handlesGroup: "handles-group",
  handle: "handle",
  startHandle: "start-handle",
  endHandle: "end-handle",
  labelGroup: "label-group",
  label: "label",
  indicator: "indicator"
}, "legend");

// node_modules/@antv/component/esm/ui/legend/category.js
var Category = (
  /** @class */
  function(_super) {
    __extends(Category2, _super);
    function Category2(options) {
      return _super.call(this, options, CATEGORY_DEFAULT_OPTIONS) || this;
    }
    Category2.prototype.renderTitle = function(container, width, height) {
      var _a2 = this.attributes, showTitle = _a2.showTitle, titleText = _a2.titleText;
      var style = subStyleProps(this.attributes, "title");
      var _b = __read(splitStyle(style), 2), titleStyle = _b[0], groupStyle = _b[1];
      this.titleGroup = container.maybeAppendByClassName(CLASS_NAMES10.titleGroup, "g").styles(groupStyle);
      var finalTitleStyle = __assign(__assign({ width, height }, titleStyle), { text: showTitle ? titleText : "" });
      this.title = this.titleGroup.maybeAppendByClassName(CLASS_NAMES10.title, function() {
        return new Title({ style: finalTitleStyle });
      }).update(finalTitleStyle);
    };
    Category2.prototype.renderItems = function(container, bbox) {
      var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
      var style = subStyleProps(this.attributes, "title", true);
      var _a2 = __read(splitStyle(style), 2), partialItemStyle = _a2[0], groupStyle = _a2[1];
      var itemStyle = __assign(__assign({}, partialItemStyle), { width, height, x: 0, y: 0 });
      this.itemsGroup = container.maybeAppendByClassName(CLASS_NAMES10.itemsGroup, "g").styles(__assign(__assign({}, groupStyle), { transform: "translate(".concat(x3, ", ").concat(y3, ")") }));
      var that = this;
      this.itemsGroup.selectAll(CLASS_NAMES10.items.class).data(["items"]).join(function(enter) {
        return enter.append(function() {
          return new CategoryItems({ style: itemStyle });
        }).attr("className", CLASS_NAMES10.items.name).each(function() {
          that.items = select2(this);
        });
      }, function(update2) {
        return update2.update(itemStyle);
      }, function(exit) {
        return exit.remove();
      });
    };
    Category2.prototype.adjustLayout = function() {
      var showTitle = this.attributes.showTitle;
      if (showTitle) {
        var _a2 = this.title.node().getAvailableSpace(), x3 = _a2.x, y3 = _a2.y;
        this.itemsGroup.node().style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
      }
    };
    Object.defineProperty(Category2.prototype, "availableSpace", {
      get: function() {
        var _a2 = this.attributes, showTitle = _a2.showTitle, width = _a2.width, height = _a2.height;
        if (!showTitle)
          return new BBox(0, 0, width, height);
        return this.title.node().getAvailableSpace();
      },
      enumerable: false,
      configurable: true
    });
    Category2.prototype.getBBox = function() {
      var _a2, _b;
      var title = (_a2 = this.title) === null || _a2 === void 0 ? void 0 : _a2.node();
      var items = (_b = this.items) === null || _b === void 0 ? void 0 : _b.node();
      if (!title || !items)
        return _super.prototype.getBBox.call(this);
      return getBBox(title, items);
    };
    Category2.prototype.render = function(attributes, container) {
      var _a2 = this.attributes, width = _a2.width, height = _a2.height, _b = _a2.x, x3 = _b === void 0 ? 0 : _b, _c = _a2.y, y3 = _c === void 0 ? 0 : _c;
      var ctn = select2(container);
      container.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
      this.renderTitle(ctn, width, height);
      this.renderItems(ctn, this.availableSpace);
      this.adjustLayout();
    };
    return Category2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/indicator/constant.js
var DEFAULT_INDICATOR_STYLE_PROPS = {
  backgroundFill: "#262626",
  backgroundLineCap: "round",
  backgroundLineWidth: 1,
  backgroundStroke: "#333",
  backgroundZIndex: -1,
  formatter: function(val) {
    return val.toString();
  },
  labelFill: "#fff",
  labelFontSize: 12,
  labelTextBaseline: "middle",
  padding: [2, 4],
  position: "right",
  radius: 0,
  zIndex: 999
};

// node_modules/@antv/component/esm/ui/indicator/indicator.js
var CLASS_NAMES11 = classNames({
  background: "background",
  labelGroup: "label-group",
  label: "label"
}, "indicator");
var Indicator = (
  /** @class */
  function(_super) {
    __extends(Indicator2, _super);
    function Indicator2(options) {
      var _this2 = _super.call(this, options, DEFAULT_INDICATOR_STYLE_PROPS) || this;
      _this2.point = [0, 0];
      _this2.group = _this2.appendChild(new Group2({}));
      _this2.isMutationObserved = true;
      return _this2;
    }
    Indicator2.prototype.renderBackground = function() {
      if (!this.label)
        return;
      var _a2 = this.attributes, position = _a2.position, padding = _a2.padding;
      var _b = __read(parseSeriesAttr(padding), 4), t = _b[0], r = _b[1], b = _b[2], l = _b[3];
      var _c = this.label.node().getLocalBounds(), min10 = _c.min, max11 = _c.max;
      var bbox = new BBox(min10[0] - l, min10[1] - t, max11[0] + r - min10[0] + l, max11[1] + b - min10[1] + t);
      var path2 = this.getPath(position, bbox);
      var style = subStyleProps(this.attributes, "background");
      this.background = select2(this.group).maybeAppendByClassName(CLASS_NAMES11.background, "path").styles(__assign(__assign({}, style), { d: path2 }));
      this.group.appendChild(this.label.node());
    };
    Indicator2.prototype.renderLabel = function() {
      var _a2 = this.attributes, formatter2 = _a2.formatter, labelText = _a2.labelText;
      var style = subStyleProps(this.attributes, "label");
      var _b = __read(splitStyle(style), 2), _c = _b[0], groupStyle = _b[1], rawText = _c.text, textStyle = __rest(_c, ["text"]);
      this.label = select2(this.group).maybeAppendByClassName(CLASS_NAMES11.labelGroup, "g").styles(groupStyle);
      if (!labelText)
        return;
      var text = this.label.maybeAppendByClassName(CLASS_NAMES11.label, function() {
        return renderExtDo(formatter2(labelText));
      }).style("text", formatter2(labelText).toString());
      text.selectAll("text").styles(textStyle);
    };
    Indicator2.prototype.adjustLayout = function() {
      var _a2 = __read(this.point, 2), dx = _a2[0], dy = _a2[1];
      var _b = this.attributes, x3 = _b.x, y3 = _b.y;
      this.group.attr("transform", "translate(".concat(x3 - dx, ", ").concat(y3 - dy, ")"));
    };
    Indicator2.prototype.getPath = function(position, bbox) {
      var r = this.attributes.radius;
      var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
      var pathArray = [
        // 0 开始路径
        ["M", x3 + r, y3],
        // 1 上边线
        ["L", x3 + width - r, y3],
        // 2 右上角圆弧
        ["A", r, r, 0, 0, 1, x3 + width, y3 + r],
        // 3 右边线
        ["L", x3 + width, y3 + height - r],
        // 4 右下角圆弧
        ["A", r, r, 0, 0, 1, x3 + width - r, y3 + height],
        // 5 下边线
        ["L", x3 + r, y3 + height],
        // 6 左下角圆弧
        ["A", r, r, 0, 0, 1, x3, y3 + height - r],
        // 7 左边线
        ["L", x3, y3 + r],
        // 8 左上角圆弧
        ["A", r, r, 0, 0, 1, x3 + r, y3],
        // 9 关闭路径
        ["Z"]
      ];
      var revertPositionMap = { top: 4, right: 6, bottom: 0, left: 2 };
      var index3 = revertPositionMap[position];
      var newPath = this.createCorner([pathArray[index3].slice(-2), pathArray[index3 + 1].slice(-2)]);
      pathArray.splice.apply(pathArray, __spreadArray([index3 + 1, 1], __read(newPath), false));
      pathArray[0][0] = "M";
      return pathArray;
    };
    Indicator2.prototype.createCorner = function(edge, size3) {
      if (size3 === void 0) {
        size3 = 10;
      }
      var cornerScale = 0.8;
      var isH = isHorizontal.apply(void 0, __spreadArray([], __read(edge), false));
      var _a2 = __read(edge, 2), _b = __read(_a2[0], 2), x05 = _b[0], y05 = _b[1], _c = __read(_a2[1], 2), x12 = _c[0], y12 = _c[1];
      var _d = __read(isH ? [x12 - x05, [x05, x12]] : [y12 - y05, [y05, y12]], 2), len5 = _d[0], _e = __read(_d[1], 2), b0 = _e[0], b1 = _e[1];
      var hL = len5 / 2;
      var sign3 = len5 / Math.abs(len5);
      var cL = size3 * sign3;
      var hCL = cL / 2;
      var cS = cL * Math.sqrt(3) / 2 * cornerScale;
      var _f = __read([b0, b0 + hL - hCL, b0 + hL, b0 + hL + hCL, b1], 5), a0 = _f[0], a1 = _f[1], a22 = _f[2], a32 = _f[3], a4 = _f[4];
      if (isH) {
        this.point = [a22, y05 - cS];
        return [
          ["L", a0, y05],
          ["L", a1, y05],
          ["L", a22, y05 - cS],
          ["L", a32, y05],
          ["L", a4, y05]
        ];
      }
      this.point = [x05 + cS, a22];
      return [
        ["L", x05, a0],
        ["L", x05, a1],
        ["L", x05 + cS, a22],
        ["L", x05, a32],
        ["L", x05, a4]
      ];
    };
    Indicator2.prototype.applyVisibility = function() {
      var visibility2 = this.attributes.visibility;
      if (visibility2 === "hidden")
        hide(this);
      else
        show(this);
    };
    Indicator2.prototype.bindEvents = function() {
      this.label.on(ElementEvent.BOUNDS_CHANGED, this.renderBackground);
    };
    Indicator2.prototype.render = function() {
      this.renderLabel();
      this.renderBackground();
      this.adjustLayout();
      this.applyVisibility();
    };
    return Indicator2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/continuous/utils.js
function search(array2, value2) {
  for (var i = 1; i < array2.length; i += 1) {
    var st = array2[i - 1];
    var end = array2[i];
    if (value2 >= st && value2 <= end) {
      return [st, end];
    }
  }
  return [value2, value2];
}
function getBlockColor(partition2, color3, orientation) {
  var colors = Array.from(color3);
  var count4 = partition2.length;
  return new Array(count4).fill(0).reduce(function(r, v, idx) {
    var c5 = colors[idx % colors.length];
    return r += " ".concat(partition2[idx], ":").concat(c5).concat(idx < count4 - 1 ? " ".concat(partition2[idx + 1], ":").concat(c5) : "");
  }, "l(".concat(orientation === "horizontal" ? "0" : "270", ")"));
}
function getNextTickValue(ticks2, value2) {
  var _a2 = __read(search(ticks2, value2), 2), v1 = _a2[0], v2 = _a2[1];
  return { tick: value2 > (v1 + v2) / 2 ? v2 : v1, range: [v1, v2] };
}

// node_modules/@antv/component/esm/ui/legend/continuous/ribbon.js
var CLASS_NAMES12 = classNames({
  trackGroup: "background-group",
  track: "background",
  selectionGroup: "ribbon-group",
  selection: "ribbon",
  clipPath: "clip-path"
}, "ribbon");
function getShape(attr2) {
  var orientation = attr2.orientation, size3 = attr2.size, length5 = attr2.length;
  return ifHorizontal(orientation, [length5, size3], [size3, length5]);
}
function getTrackPath(attr2) {
  var type = attr2.type;
  var _a2 = __read(getShape(attr2), 2), cw2 = _a2[0], ch2 = _a2[1];
  if (type === "size") {
    return [["M", 0, ch2], ["L", 0 + cw2, 0], ["L", 0 + cw2, ch2], ["Z"]];
  }
  return [["M", 0, ch2], ["L", 0, 0], ["L", 0 + cw2, 0], ["L", 0 + cw2, ch2], ["Z"]];
}
function getSelectionPath(attr2) {
  return getTrackPath(attr2);
}
function getColor(attr2) {
  var orientation = attr2.orientation, color3 = attr2.color, block = attr2.block, partition2 = attr2.partition;
  var colors;
  if (isFunction(color3)) {
    var len5 = 20;
    colors = new Array(len5).fill(0).map(function(_2, index3, arr) {
      return color3(index3 / (arr.length - 1));
    });
  } else
    colors = color3;
  var count4 = colors.length;
  var genericColor = colors.map(function(c5) {
    return parseColor(c5).toString();
  });
  if (!count4)
    return "";
  if (count4 === 1)
    return genericColor[0];
  if (block)
    return getBlockColor(partition2, genericColor, orientation);
  return genericColor.reduce(function(r, c5, idx) {
    return r += " ".concat(idx / (count4 - 1), ":").concat(c5);
  }, "l(".concat(ifHorizontal(orientation, "0", "270"), ")"));
}
function getClipPath(attr2) {
  var orientation = attr2.orientation, range3 = attr2.range;
  if (!range3)
    return [];
  var _a2 = __read(getShape(attr2), 2), width = _a2[0], height = _a2[1];
  var _b = __read(range3, 2), st = _b[0], et = _b[1];
  var x3 = ifHorizontal(orientation, st * width, 0);
  var y3 = ifHorizontal(orientation, 0, st * height);
  var w = ifHorizontal(orientation, et * width, width);
  var h = ifHorizontal(orientation, height, et * height);
  return [["M", x3, y3], ["L", x3, h], ["L", w, h], ["L", w, y3], ["Z"]];
}
function renderTrack(container, attr2) {
  var style = subStyleProps(attr2, "track");
  container.maybeAppendByClassName(CLASS_NAMES12.track, "path").styles(__assign({ d: getTrackPath(attr2) }, style));
}
function renderSelection(container, attr2) {
  var style = subStyleProps(attr2, "selection");
  var fill = getColor(attr2);
  var ribbon = container.maybeAppendByClassName(CLASS_NAMES12.selection, "path").styles(__assign({ d: getSelectionPath(attr2), fill }, style));
  var clipPath = ribbon.maybeAppendByClassName(CLASS_NAMES12.clipPath, "path").styles({ d: getClipPath(attr2) }).node();
  ribbon.style("clipPath", clipPath);
}
var Ribbon = (
  /** @class */
  function(_super) {
    __extends(Ribbon3, _super);
    function Ribbon3(options) {
      return _super.call(this, options, {
        type: "color",
        orientation: "horizontal",
        size: 30,
        range: [0, 1],
        length: 200,
        block: false,
        partition: [],
        color: ["#fff", "#000"],
        trackFill: "#e5e5e5"
      }) || this;
    }
    Ribbon3.prototype.render = function(attribute, container) {
      var trackGroup = select2(container).maybeAppendByClassName(CLASS_NAMES12.trackGroup, "g");
      renderTrack(trackGroup, attribute);
      var ribbonGroup = select2(container).maybeAppendByClassName(CLASS_NAMES12.selectionGroup, "g");
      renderSelection(ribbonGroup, attribute);
    };
    return Ribbon3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/continuous.js
function getMinMax(data2) {
  return {
    min: Math.min.apply(Math, __spreadArray([], __read(data2.map(function(d3) {
      return d3.value;
    })), false)),
    max: Math.max.apply(Math, __spreadArray([], __read(data2.map(function(d3) {
      return d3.value;
    })), false))
  };
}
var Continuous2 = (
  /** @class */
  function(_super) {
    __extends(Continuous3, _super);
    function Continuous3(options) {
      var _this2 = _super.call(this, options, CONTINUOUS_DEFAULT_OPTIONS) || this;
      _this2.eventToOffsetScale = new Linear({});
      _this2.innerRibbonScale = new Linear({});
      _this2.cacheLabelBBox = null;
      _this2.cacheHandleBBox = null;
      _this2.onHovering = function(e) {
        var _a2 = _this2.attributes, data2 = _a2.data, block = _a2.block;
        e.stopPropagation();
        var value2 = _this2.getValueByCanvasPoint(e);
        if (block) {
          var range3 = getNextTickValue(data2.map(function(_a3) {
            var value3 = _a3.value;
            return value3;
          }), value2).range;
          var selection = _this2.getRealSelection(range3);
          _this2.showIndicator((range3[0] + range3[1]) / 2, "".concat(selection[0], "-").concat(selection[1]));
          _this2.dispatchIndicated(value2, range3);
        } else {
          var safetyValue = _this2.getTickValue(value2);
          _this2.showIndicator(safetyValue, "".concat(_this2.getRealValue(safetyValue)));
          _this2.dispatchIndicated(safetyValue);
        }
      };
      _this2.onDragStart = function(target) {
        return function(e) {
          e.stopPropagation();
          if (!_this2.attributes.slidable)
            return;
          _this2.target = target;
          _this2.prevValue = _this2.getTickValue(_this2.getValueByCanvasPoint(e));
          document.addEventListener("mousemove", _this2.onDragging);
          document.addEventListener("touchmove", _this2.onDragging);
          document.addEventListener("mouseleave", _this2.onDragEnd);
          document.addEventListener("mouseup", _this2.onDragEnd);
          document.addEventListener("mouseup", _this2.onDragEnd);
          document.addEventListener("touchend", _this2.onDragEnd);
        };
      };
      _this2.onDragging = function(e) {
        var target = _this2.target;
        _this2.updateMouse();
        var _a2 = __read(_this2.selection, 2), start = _a2[0], end = _a2[1];
        var currValue = _this2.getTickValue(_this2.getValueByCanvasPoint(e));
        var diffValue = currValue - _this2.prevValue;
        if (target === "start")
          start !== currValue && _this2.updateSelection(currValue, end);
        else if (target === "end")
          end !== currValue && _this2.updateSelection(start, currValue);
        else if (target === "ribbon" && diffValue !== 0) {
          _this2.prevValue = currValue;
          _this2.updateSelection(diffValue, diffValue, true);
        }
      };
      _this2.onDragEnd = function() {
        _this2.style.cursor = "pointer";
        document.removeEventListener("mousemove", _this2.onDragging);
        document.removeEventListener("touchmove", _this2.onDragging);
        document.removeEventListener("mouseup", _this2.onDragEnd);
        document.removeEventListener("touchend", _this2.onDragEnd);
      };
      return _this2;
    }
    Object.defineProperty(Continuous3.prototype, "handleOffsetRatio", {
      get: function() {
        return this.ifHorizontal(0.5, 0.5);
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.getBBox = function() {
      var _a2 = this.attributes, width = _a2.width, height = _a2.height;
      return new BBox(0, 0, width, height);
    };
    Continuous3.prototype.render = function(attributes, container) {
      var _this2 = this;
      var showLabel = attributes.showLabel;
      this.renderTitle(select2(container));
      var _a2 = this.availableSpace, x3 = _a2.x, y3 = _a2.y;
      var contentGroup = select2(container).maybeAppendByClassName(CLASS_NAMES10.contentGroup, "g").styles({ transform: "translate(".concat(x3, ", ").concat(y3, ")") });
      var labelGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES10.labelGroup, "g").styles({ zIndex: 1 });
      ifShow(!!showLabel, labelGroup, function(group3) {
        _this2.renderLabel(group3);
      });
      var ribbonGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES10.ribbonGroup, "g").styles({ zIndex: 0 });
      this.handlesGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES10.handlesGroup, "g").styles({ zIndex: 2 });
      this.renderHandles();
      this.renderRibbon(ribbonGroup);
      this.renderIndicator(contentGroup);
      this.adjustLabel();
      this.adjustHandles();
    };
    Object.defineProperty(Continuous3.prototype, "range", {
      get: function() {
        var _a2 = this.attributes, data2 = _a2.data, domain = _a2.domain;
        return domain ? { min: domain[0], max: domain[1] } : getMinMax(data2);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "ribbonScale", {
      get: function() {
        var _a2 = this.range, min10 = _a2.min, max11 = _a2.max;
        this.innerRibbonScale.update({
          domain: [min10, max11],
          range: [0, 1]
        });
        return this.innerRibbonScale;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "ribbonRange", {
      get: function() {
        var _a2 = __read(this.selection, 2), min10 = _a2[0], max11 = _a2[1];
        var scale11 = this.ribbonScale;
        return [scale11.map(min10), scale11.map(max11)];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "selection", {
      get: function() {
        var _a2 = this.range, min10 = _a2.min, max11 = _a2.max;
        var _b = this.attributes.defaultValue, _c = _b === void 0 ? [min10, max11] : _b, _d = __read(_c, 2), start = _d[0], end = _d[1];
        return [start, end];
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.ifHorizontal = function(a4, b) {
      return ifHorizontal(this.attributes.orientation, typeof a4 === "function" ? a4() : a4, typeof b === "function" ? b() : b);
    };
    Continuous3.prototype.renderTitle = function(container) {
      var _a2 = this.attributes, showTitle = _a2.showTitle, titleText = _a2.titleText, width = _a2.width, height = _a2.height;
      var style = subStyleProps(this.attributes, "title");
      var finalTitleStyle = __assign(__assign({}, style), { width, height, text: titleText });
      var that = this;
      container.selectAll(CLASS_NAMES10.title.class).data(showTitle ? [titleText] : []).join(function(enter) {
        return enter.append(function() {
          return new Title({ style: finalTitleStyle });
        }).attr("className", CLASS_NAMES10.title.name).each(function() {
          that.title = this;
        });
      }, function(update2) {
        return update2.update(finalTitleStyle);
      }, function(exit) {
        return exit.each(function() {
          that.title = void 0;
        }).remove();
      });
    };
    Object.defineProperty(Continuous3.prototype, "availableSpace", {
      get: function() {
        if (this.title)
          return this.title.getAvailableSpace();
        var _a2 = this.attributes, width = _a2.width, height = _a2.height;
        return new BBox(0, 0, width, height);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelFixedSpacing", {
      get: function() {
        var showTick = this.attributes.showTick;
        return showTick ? 5 : 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelPosition", {
      get: function() {
        var _a2 = this.attributes, orientation = _a2.orientation, labelDirection = _a2.labelDirection;
        var positions = {
          vertical: { positive: "right", negative: "left" },
          horizontal: { positive: "bottom", negative: "top" }
        };
        return positions[orientation][labelDirection];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelBBox", {
      get: function() {
        var _a2;
        var showLabel = this.attributes.showLabel;
        if (!showLabel)
          return new BBox(0, 0, 0, 0);
        if (this.cacheLabelBBox)
          return this.cacheLabelBBox;
        var _b = ((_a2 = this.label.querySelector(CLASS_NAMES3.labelGroup.class)) === null || _a2 === void 0 ? void 0 : _a2.children.slice(-1)[0]).getBBox(), width = _b.width, height = _b.height;
        this.cacheLabelBBox = new BBox(0, 0, width, height);
        return this.cacheLabelBBox;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelShape", {
      get: function() {
        var _a2 = this.attributes, showLabel = _a2.showLabel, _b = _a2.labelSpacing, labelSpacing = _b === void 0 ? 0 : _b;
        if (!showLabel)
          return { width: 0, height: 0, size: 0, length: 0 };
        var _c = this.labelBBox, width = _c.width, height = _c.height;
        var size3 = this.ifHorizontal(height, width) + labelSpacing + this.labelFixedSpacing;
        var length5 = this.ifHorizontal(width, height);
        return { width, height, size: size3, length: length5 };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "ribbonBBox", {
      get: function() {
        var _a2 = this.attributes, showHandle = _a2.showHandle, userDefinedRibbonSize = _a2.ribbonSize;
        var _b = this.availableSpace, availableWidth = _b.width, availableHeight = _b.height;
        var _c = this.labelShape, labelSize = _c.size, labelLength = _c.length;
        var _d = __read(this.ifHorizontal([availableHeight, availableWidth], [availableWidth, availableHeight]), 2), availableSize = _d[0], availableLength = _d[1];
        var _e = showHandle ? this.handleShape : { size: 0, length: 0 }, handleSize = _e.size, handleLength = _e.length;
        var handleRatio = this.handleOffsetRatio;
        var ribbonSize = 0;
        var labelPosition = this.labelPosition;
        if (userDefinedRibbonSize) {
          ribbonSize = userDefinedRibbonSize;
        } else if (["bottom", "right"].includes(labelPosition)) {
          ribbonSize = Math.min(availableSize - labelSize, (availableSize - handleSize) / handleRatio);
        } else if (availableSize * (1 - handleRatio) > handleSize) {
          ribbonSize = Math.max(availableSize - labelSize, 0);
        } else
          ribbonSize = Math.max((availableSize - labelSize - handleSize) / handleRatio, 0);
        var edgeLength = Math.max(handleLength, labelLength);
        var ribbonLength = availableLength - edgeLength;
        var _f = __read(this.ifHorizontal([ribbonLength, ribbonSize], [ribbonSize, ribbonLength]), 2), width = _f[0], height = _f[1];
        var finalLabelOccupy = ["top", "left"].includes(labelPosition) ? labelSize : 0;
        var _g = __read(this.ifHorizontal([edgeLength / 2, finalLabelOccupy], [finalLabelOccupy, edgeLength / 2]), 2), x3 = _g[0], y3 = _g[1];
        return new BBox(x3, y3, width, height);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "ribbonShape", {
      get: function() {
        var _a2 = this.ribbonBBox, width = _a2.width, height = _a2.height;
        return this.ifHorizontal({ size: height, length: width }, { size: width, length: height });
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.renderRibbon = function(container) {
      var _a2 = this.attributes, data2 = _a2.data, type = _a2.type, orientation = _a2.orientation, color3 = _a2.color, block = _a2.block;
      var ribbonStyle = subStyleProps(this.attributes, "ribbon");
      var _b = this.range, min10 = _b.min, max11 = _b.max;
      var _c = this.ribbonBBox, x3 = _c.x, y3 = _c.y;
      var _d = this.ribbonShape, length5 = _d.length, size3 = _d.size;
      var style = deepAssign2({
        transform: "translate(".concat(x3, ", ").concat(y3, ")"),
        length: length5,
        size: size3,
        type,
        orientation,
        color: color3,
        block,
        partition: data2.map(function(d3) {
          return (d3.value - min10) / (max11 - min10);
        }),
        range: this.ribbonRange
      }, ribbonStyle);
      this.ribbon = container.maybeAppendByClassName(CLASS_NAMES10.ribbon, function() {
        return new Ribbon({ style });
      }).update(style);
    };
    Continuous3.prototype.getHandleClassName = function(type) {
      return "".concat(CLASS_NAMES10.prefix("".concat(type, "-handle")));
    };
    Continuous3.prototype.renderHandles = function() {
      var _a2 = this.attributes, showHandle = _a2.showHandle, orientation = _a2.orientation;
      var handleStyle = subStyleProps(this.attributes, "handle");
      var _b = __read(this.selection, 2), min10 = _b[0], max11 = _b[1];
      var style = __assign(__assign({}, handleStyle), { orientation });
      var _c = handleStyle.shape, shape23 = _c === void 0 ? "slider" : _c;
      var HandleCtor = shape23 === "basic" ? Handle2 : Handle;
      var that = this;
      this.handlesGroup.selectAll(CLASS_NAMES10.handle.class).data(showHandle ? [
        { value: min10, type: "start" },
        { value: max11, type: "end" }
      ] : [], function(d3) {
        return d3.type;
      }).join(function(enter) {
        return enter.append(function() {
          return new HandleCtor({ style });
        }).attr("className", function(_a3) {
          var type = _a3.type;
          return "".concat(CLASS_NAMES10.handle, " ").concat(that.getHandleClassName(type));
        }).each(function(_a3) {
          var type = _a3.type, labelText = _a3.value;
          this.update({ labelText });
          var name2 = "".concat(type, "Handle");
          that[name2] = this;
          this.addEventListener("pointerdown", that.onDragStart(type));
        });
      }, function(update2) {
        return update2.update(style).each(function(_a3) {
          var labelText = _a3.value;
          this.update({ labelText });
        });
      }, function(exit) {
        return exit.each(function(_a3) {
          var type = _a3.type;
          var name2 = "".concat(type, "Handle");
          that[name2] = void 0;
        }).remove();
      });
    };
    Continuous3.prototype.adjustHandles = function() {
      var _a2 = __read(this.selection, 2), min10 = _a2[0], max11 = _a2[1];
      this.setHandlePosition("start", min10);
      this.setHandlePosition("end", max11);
    };
    Object.defineProperty(Continuous3.prototype, "handleBBox", {
      get: function() {
        if (this.cacheHandleBBox)
          return this.cacheHandleBBox;
        if (!this.attributes.showHandle)
          return new BBox(0, 0, 0, 0);
        var _a2 = this.startHandle.getBBox(), startHandleWidth = _a2.width, startHandleHeight = _a2.height;
        var _b = this.endHandle.getBBox(), endHandleWidth = _b.width, endHandleHeight = _b.height;
        var _c = __read([Math.max(startHandleWidth, endHandleWidth), Math.max(startHandleHeight, endHandleHeight)], 2), width = _c[0], height = _c[1];
        this.cacheHandleBBox = new BBox(0, 0, width, height);
        return this.cacheHandleBBox;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "handleShape", {
      /**
       *  因为 handle label 的宽高是动态的，所以 handle bbox 是第一次渲染时的 bbox
       */
      get: function() {
        var _a2 = this.handleBBox, width = _a2.width, height = _a2.height;
        var _b = __read(this.ifHorizontal([height, width], [width, height]), 2), size3 = _b[0], length5 = _b[1];
        return { width, height, size: size3, length: length5 };
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.setHandlePosition = function(type, value2) {
      var handleFormatter = this.attributes.handleFormatter;
      var _a2 = this.ribbonBBox, ribbonX = _a2.x, ribbonY = _a2.y;
      var ribbonSize = this.ribbonShape.size;
      var offset2 = this.getOffset(value2);
      var _b = __read(this.ifHorizontal([ribbonX + offset2, ribbonY + ribbonSize * this.handleOffsetRatio], [ribbonX + ribbonSize * this.handleOffsetRatio, ribbonY + offset2]), 2), x3 = _b[0], y3 = _b[1];
      var handle = this.handlesGroup.select(".".concat(this.getHandleClassName(type))).node();
      handle === null || handle === void 0 ? void 0 : handle.update({ transform: "translate(".concat(x3, ", ").concat(y3, ")"), formatter: handleFormatter });
    };
    Continuous3.prototype.renderIndicator = function(container) {
      var style = subStyleProps(this.attributes, "indicator");
      this.indicator = container.maybeAppendByClassName(CLASS_NAMES10.indicator, function() {
        return new Indicator({});
      }).update(style);
    };
    Object.defineProperty(Continuous3.prototype, "labelData", {
      get: function() {
        var _this2 = this;
        var data2 = this.attributes.data;
        return data2.reduce(function(acc, curr, index3, arr) {
          var _a2, _b;
          var id4 = (_a2 = curr === null || curr === void 0 ? void 0 : curr.id) !== null && _a2 !== void 0 ? _a2 : index3.toString();
          acc.push(__assign(__assign({}, curr), { id: id4, index: index3, type: "value", label: (_b = curr === null || curr === void 0 ? void 0 : curr.label) !== null && _b !== void 0 ? _b : curr.value.toString(), value: _this2.ribbonScale.map(curr.value) }));
          if (index3 < arr.length - 1) {
            var next = arr[index3 + 1];
            var _c = __read([curr.value, next.value], 2), cr = _c[0], nx = _c[1];
            var midVal = (cr + nx) / 2;
            acc.push(__assign(__assign({}, curr), { id: id4, index: index3, type: "range", range: [cr, nx], label: [cr, nx].join("~"), value: _this2.ribbonScale.map(midVal) }));
          }
          return acc;
        }, []);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelStyle", {
      get: function() {
        var _a2 = __read(["center", "middle"], 2), labelTextAlign = _a2[0], labelTextBaseline = _a2[1];
        var labelPosition = this.labelPosition;
        if (labelPosition === "top")
          labelTextBaseline = "bottom";
        else if (labelPosition === "bottom")
          labelTextBaseline = "top";
        else if (labelPosition === "left")
          labelTextAlign = "end";
        else if (labelPosition === "right")
          labelTextAlign = "start";
        return {
          labelTextAlign,
          labelTextBaseline
        };
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.renderLabel = function(container) {
      var _a2 = this.attributes, _b = _a2.showTick, showTick = _b === void 0 ? false : _b, labelFilter = _a2.labelFilter, labelFormatter2 = _a2.labelFormatter;
      var tickStyle = subStyleProps(this.attributes, "tick");
      var labelStyle = subStyleProps(this.attributes, "label");
      var align = labelStyle.align;
      var style = deepAssign2(__assign({ showLine: false, showGrid: false, showTick, type: "linear", startPos: [0, 0], endPos: [0, 0], tickDirection: "negative", labelTransform: "rotate(0)" }, this.labelStyle), superStyleProps(tickStyle, "tick"), superStyleProps(labelStyle, "label"), { data: this.labelData });
      var functionStyle = {
        tickFilter: function(datum, index3, data2) {
          if ((datum === null || datum === void 0 ? void 0 : datum.type) !== "value")
            return false;
          if (labelFilter)
            return labelFilter(datum, datum.index, data2.filter(function(d3) {
              return d3.type !== "value";
            }));
          return true;
        },
        labelFilter: function(datum, index3, data2) {
          if ((datum === null || datum === void 0 ? void 0 : datum.type) !== align)
            return false;
          if (labelFilter)
            return labelFilter(datum, datum.index, data2.filter(function(d3) {
              return d3.type === align;
            }));
          return true;
        },
        labelFormatter: labelFormatter2
      };
      var finalLabelStyle = __assign(__assign(__assign({}, style), functionStyle), { labelOverlap: [{ type: "hide" }] });
      this.label = container.maybeAppendByClassName(CLASS_NAMES10.label, function() {
        return new Axis({ style: finalLabelStyle });
      }).node();
      this.label.update(finalLabelStyle, false);
    };
    Object.defineProperty(Continuous3.prototype, "labelAxisStyle", {
      get: function() {
        var _a2 = this.attributes, showTick = _a2.showTick, labelDirection = _a2.labelDirection, labelSpacing = _a2.labelSpacing, definedTickLength = _a2.tickLength;
        var ribbonSize = this.ribbonShape.size;
        var labelPosition = this.labelPosition;
        var labelFixedSpacing = this.labelFixedSpacing;
        var _b = __read([0, 0, 0], 3), offset2 = _b[0], spacing = _b[1], tickLength = _b[2];
        var internalVal = definedTickLength !== null && definedTickLength !== void 0 ? definedTickLength : ribbonSize;
        if (showTick) {
          tickLength = internalVal;
          spacing = labelFixedSpacing;
          if (labelDirection === "positive") {
            if (labelPosition === "right") {
              offset2 = internalVal;
              tickLength = internalVal;
            } else if (labelPosition === "bottom")
              offset2 = tickLength;
          } else if (labelDirection === "negative") {
            if (labelPosition === "top")
              offset2 = ribbonSize;
            else if (labelPosition === "left")
              offset2 = ribbonSize;
          }
        } else if (labelDirection === "positive") {
          if (labelPosition === "right")
            spacing = internalVal;
          else if (labelPosition === "bottom") {
            offset2 = ribbonSize + labelFixedSpacing;
            spacing = labelSpacing;
          }
        } else if (labelDirection === "negative") {
          if (labelPosition === "left")
            spacing = labelSpacing;
          else if (labelPosition === "top")
            spacing = labelSpacing;
        }
        return { offset: offset2, spacing, tickLength };
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.adjustLabel = function() {
      var showLabel = this.attributes.showLabel;
      if (!showLabel)
        return;
      var _a2 = this.ribbonBBox, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
      var _b = this.labelAxisStyle, axisOffset = _b.offset, axisSpacing = _b.spacing, axisTickLength = _b.tickLength;
      var _c = __read(this.ifHorizontal([
        [x3, y3 + axisOffset],
        [x3 + width, y3 + axisOffset]
      ], [
        [x3 + axisOffset, y3 + height],
        [x3 + axisOffset, y3]
      ]), 2), startPos = _c[0], endPos = _c[1];
      this.label.update({
        startPos,
        endPos,
        tickLength: axisTickLength,
        labelSpacing: axisSpacing
      }, false);
    };
    Continuous3.prototype.bindEvents = function() {
      this.style.cursor = "pointer";
      this.ribbon.on("pointerdown", this.onDragStart("ribbon"));
      this.ribbon.on("pointermove", this.onHovering);
      this.addEventListener("pointerout", this.hideIndicator);
    };
    Continuous3.prototype.showIndicator = function(value2, text) {
      if (text === void 0) {
        text = "".concat(value2);
      }
      var showIndicator = this.attributes.showIndicator;
      if (!showIndicator || typeof value2 !== "number") {
        this.hideIndicator();
        return;
      }
      var _a2 = this.range, min10 = _a2.min, max11 = _a2.max;
      var _b = this.ribbonBBox, x3 = _b.x, y3 = _b.y;
      var safeValue = clamp_default(value2, min10, max11);
      var offset2 = this.getOffset(safeValue);
      var pos = this.ifHorizontal([offset2 + x3, y3], [x3, offset2 + y3]);
      this.indicator.update({
        x: pos[0],
        y: pos[1],
        position: this.ifHorizontal("top", "left"),
        labelText: text
      });
      show(this.indicator.node());
    };
    Continuous3.prototype.hideIndicator = function() {
      hide(this.indicator.node());
    };
    Continuous3.prototype.updateMouse = function() {
      if (this.attributes.slidable)
        this.style.cursor = "grabbing";
    };
    Continuous3.prototype.setSelection = function(start, end) {
      this.updateSelection(start, end);
    };
    Continuous3.prototype.updateSelection = function(stVal, endVal, isOffset) {
      var _a2;
      if (isOffset === void 0) {
        isOffset = false;
      }
      var _b = __read(this.selection, 2), currSt = _b[0], currEnd = _b[1];
      var _c = __read([stVal, endVal], 2), start = _c[0], end = _c[1];
      if (isOffset) {
        start += currSt;
        end += currEnd;
      }
      var _d = this.range, min10 = _d.min, max11 = _d.max;
      _a2 = __read(getSafetySelections([min10, max11], [start, end], this.selection), 2), start = _a2[0], end = _a2[1];
      this.update({ defaultValue: [start, end] });
      this.dispatchSelection();
    };
    Object.defineProperty(Continuous3.prototype, "step", {
      get: function() {
        var _a2 = this.attributes.step, step2 = _a2 === void 0 ? 1 : _a2;
        var _b = this.range, min10 = _b.min, max11 = _b.max;
        if (is_undefined_default(step2))
          return toPrecision((max11 - min10) * STEP_RATIO, 0);
        return step2;
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.getTickValue = function(value2) {
      var _a2 = this.attributes, data2 = _a2.data, block = _a2.block;
      var min10 = this.range.min;
      if (block)
        return getNextTickValue(data2.map(function(_a3) {
          var value3 = _a3.value;
          return value3;
        }), value2).tick;
      return getStepValueByValue(value2, this.step, min10);
    };
    Continuous3.prototype.getValueByCanvasPoint = function(e) {
      var _a2 = this.range, min10 = _a2.min, max11 = _a2.max;
      var _b = __read(this.ribbon.node().getPosition(), 2), x3 = _b[0], y3 = _b[1];
      var startPos = this.ifHorizontal(x3, y3);
      var currValue = this.ifHorizontal.apply(this, __spreadArray([], __read(getEventPos(e)), false));
      var offset2 = currValue - startPos;
      var value2 = clamp_default(this.getOffset(offset2, true), min10, max11);
      return value2;
    };
    Continuous3.prototype.getOffset = function(value2, reverse2) {
      if (reverse2 === void 0) {
        reverse2 = false;
      }
      var _a2 = this.range, min10 = _a2.min, max11 = _a2.max;
      var ribbonLen = this.ribbonShape.length;
      var scale11 = this.eventToOffsetScale;
      scale11.update({ domain: [min10, max11], range: [0, ribbonLen] });
      if (reverse2)
        return scale11.invert(value2);
      return scale11.map(value2);
    };
    Continuous3.prototype.getRealSelection = function(range3) {
      var max11 = this.range.max;
      var _a2 = __read(range3, 2), start = _a2[0], end = _a2[1];
      return this.ifHorizontal([start, end], [max11 - end, max11 - start]);
    };
    Continuous3.prototype.getRealValue = function(value2) {
      var max11 = this.range.max;
      return this.ifHorizontal(value2, max11 - value2);
    };
    Continuous3.prototype.dispatchSelection = function() {
      var selection = this.getRealSelection(this.selection);
      var evt = new CustomEvent("valuechange", {
        detail: {
          value: selection
        }
      });
      this.dispatchEvent(evt);
    };
    Continuous3.prototype.dispatchIndicated = function(value2, range3) {
      var _this2 = this;
      var max11 = this.range.max;
      var detail = this.ifHorizontal(function() {
        return {
          value: value2,
          range: range3
        };
      }, function() {
        return {
          value: max11 - value2,
          range: range3 ? _this2.getRealSelection(range3) : void 0
        };
      });
      var evt = new CustomEvent("indicate", {
        detail
      });
      this.dispatchEvent(evt);
    };
    return Continuous3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/tooltip/constant.js
function getClassNames(prefixCls) {
  if (prefixCls === void 0) {
    prefixCls = "";
  }
  return {
    CONTAINER: "".concat(prefixCls, "tooltip"),
    TITLE: "".concat(prefixCls, "tooltip-title"),
    LIST: "".concat(prefixCls, "tooltip-list"),
    LIST_ITEM: "".concat(prefixCls, "tooltip-list-item"),
    NAME: "".concat(prefixCls, "tooltip-list-item-name"),
    MARKER: "".concat(prefixCls, "tooltip-list-item-marker"),
    NAME_LABEL: "".concat(prefixCls, "tooltip-list-item-name-label"),
    VALUE: "".concat(prefixCls, "tooltip-list-item-value"),
    CROSSHAIR_X: "".concat(prefixCls, "tooltip-crosshair-x"),
    CROSSHAIR_Y: "".concat(prefixCls, "tooltip-crosshair-y")
  };
}
var TEXT_OVERFLOW_STYLE = {
  overflow: "hidden",
  "white-space": "nowrap",
  "text-overflow": "ellipsis"
};
function getDefaultTooltipStyle(prefixCls) {
  var _a2;
  if (prefixCls === void 0) {
    prefixCls = "";
  }
  var CLASS_NAME2 = getClassNames(prefixCls);
  return _a2 = {}, _a2[".".concat(CLASS_NAME2.CONTAINER)] = {
    position: "absolute",
    visibility: "visible",
    // 'white-space': 'nowrap',
    "z-index": 8,
    transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)",
    "background-color": "rgba(255, 255, 255, 0.96)",
    "box-shadow": "0 6px 12px 0 rgba(0, 0, 0, 0.12)",
    "border-radius": "4px",
    color: "rgba(0, 0, 0, 0.65)",
    "font-size": "12px",
    // 'font-family': ,
    "line-height": "20px",
    padding: "12px",
    "min-width": "120px",
    "max-width": "360px",
    "font-family": "Roboto-Regular"
  }, _a2[".".concat(CLASS_NAME2.TITLE)] = {
    color: "rgba(0, 0, 0, 0.45)"
  }, _a2[".".concat(CLASS_NAME2.LIST)] = {
    margin: "0px",
    "list-style-type": "none",
    padding: "0px"
  }, _a2[".".concat(CLASS_NAME2.LIST_ITEM)] = {
    "list-style-type": "none",
    display: "flex",
    "line-height": "2em",
    "align-items": "center",
    "justify-content": "space-between",
    "white-space": "nowrap"
  }, _a2[".".concat(CLASS_NAME2.MARKER)] = {
    width: "8px",
    height: "8px",
    "border-radius": "50%",
    display: "inline-block",
    "margin-right": "4px"
  }, _a2[".".concat(CLASS_NAME2.NAME)] = {
    display: "flex",
    "align-items": "center",
    "max-width": "216px"
  }, _a2[".".concat(CLASS_NAME2.NAME_LABEL)] = __assign({ flex: 1 }, TEXT_OVERFLOW_STYLE), _a2[".".concat(CLASS_NAME2.VALUE)] = __assign({ display: "inline-block", float: "right", flex: 1, "text-align": "right", "min-width": "28px", "margin-left": "30px", color: "rgba(0, 0, 0, 0.85)" }, TEXT_OVERFLOW_STYLE), _a2[".".concat(CLASS_NAME2.CROSSHAIR_X)] = {
    position: "absolute",
    width: "1px",
    "background-color": "rgba(0, 0, 0, 0.25)"
  }, _a2[".".concat(CLASS_NAME2.CROSSHAIR_Y)] = {
    position: "absolute",
    height: "1px",
    "background-color": "rgba(0, 0, 0, 0.25)"
  }, _a2;
}

// node_modules/@antv/component/esm/ui/tooltip/index.js
var Tooltip = (
  /** @class */
  function(_super) {
    __extends(Tooltip3, _super);
    function Tooltip3(options) {
      var _this2 = this;
      var _a2, _b;
      var prefixCls = (_b = (_a2 = options.style) === null || _a2 === void 0 ? void 0 : _a2.template) === null || _b === void 0 ? void 0 : _b.prefixCls;
      var CLASS_NAME2 = getClassNames(prefixCls);
      _this2 = _super.call(this, options, {
        data: [],
        x: 0,
        y: 0,
        visibility: "visible",
        title: "",
        position: "bottom-right",
        offset: [5, 5],
        enterable: false,
        container: {
          x: 0,
          y: 0
        },
        bounding: null,
        template: {
          prefixCls: "",
          container: '<div class="'.concat(CLASS_NAME2.CONTAINER, '"></div>'),
          title: '<div class="'.concat(CLASS_NAME2.TITLE, '"></div>'),
          item: '<li class="'.concat(CLASS_NAME2.LIST_ITEM, '" data-index={index}>\n        <span class="').concat(CLASS_NAME2.NAME, '">\n          <span class="').concat(CLASS_NAME2.MARKER, '" style="background:{color}"></span>\n          <span class="').concat(CLASS_NAME2.NAME_LABEL, '" title="{name}">{name}</span>\n        </span>\n        <span class="').concat(CLASS_NAME2.VALUE, '" title="{value}">{value}</span>\n      </li>')
        },
        style: getDefaultTooltipStyle(prefixCls)
      }) || this;
      _this2.timestamp = -1;
      _this2.prevCustomContentKey = _this2.attributes.contentKey;
      _this2.initShape();
      _this2.render(_this2.attributes, _this2);
      return _this2;
    }
    Object.defineProperty(Tooltip3.prototype, "HTMLTooltipElement", {
      get: function() {
        return this.element;
      },
      enumerable: false,
      configurable: true
    });
    Tooltip3.prototype.getContainer = function() {
      return this.element;
    };
    Object.defineProperty(Tooltip3.prototype, "elementSize", {
      get: function() {
        var width = this.element.offsetWidth;
        var height = this.element.offsetHeight;
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Tooltip3.prototype, "HTMLTooltipItemsElements", {
      get: function() {
        var _a2 = this.attributes, data2 = _a2.data, template = _a2.template;
        return data2.map(function(_a3, idx) {
          var _b = _a3.name, name2 = _b === void 0 ? "" : _b, _c = _a3.color, color3 = _c === void 0 ? "black" : _c, index3 = _a3.index, rest = __rest(_a3, ["name", "color", "index"]);
          var datum = __assign({ name: name2, color: color3, index: index3 !== null && index3 !== void 0 ? index3 : idx }, rest);
          return createDOM(substitute_default(template.item, datum));
        });
      },
      enumerable: false,
      configurable: true
    });
    Tooltip3.prototype.render = function(attributes, container) {
      this.renderHTMLTooltipElement();
      this.updatePosition();
    };
    Tooltip3.prototype.destroy = function() {
      var _a2;
      (_a2 = this.element) === null || _a2 === void 0 ? void 0 : _a2.remove();
      _super.prototype.destroy.call(this);
    };
    Tooltip3.prototype.show = function(x3, y3) {
      var _this2 = this;
      if (x3 !== void 0 && y3 !== void 0) {
        var isToggle = this.element.style.visibility === "hidden";
        var setPosition = function() {
          _this2.attributes.x = x3 !== null && x3 !== void 0 ? x3 : _this2.attributes.x;
          _this2.attributes.y = y3 !== null && y3 !== void 0 ? y3 : _this2.attributes.y;
          _this2.updatePosition();
        };
        isToggle ? this.closeTransition(setPosition) : setPosition();
      }
      this.element.style.visibility = "visible";
    };
    Tooltip3.prototype.hide = function(x3, y3) {
      if (x3 === void 0) {
        x3 = 0;
      }
      if (y3 === void 0) {
        y3 = 0;
      }
      var enterable = this.attributes.enterable;
      if (enterable && this.isCursorEntered(x3, y3))
        return;
      this.element.style.visibility = "hidden";
    };
    Tooltip3.prototype.initShape = function() {
      var template = this.attributes.template;
      this.element = createDOM(template.container);
      if (this.id)
        this.element.setAttribute("id", this.id);
    };
    Tooltip3.prototype.renderCustomContent = function() {
      if (this.prevCustomContentKey !== void 0 && this.prevCustomContentKey === this.attributes.contentKey)
        return;
      this.prevCustomContentKey = this.attributes.contentKey;
      var content = this.attributes.content;
      if (!content)
        return;
      if (typeof content === "string")
        this.element.innerHTML = content;
      else
        replaceChildren(this.element, content);
    };
    Tooltip3.prototype.renderHTMLTooltipElement = function() {
      var _a2, _b;
      var _c = this.attributes, template = _c.template, title = _c.title, enterable = _c.enterable, style = _c.style, content = _c.content;
      var CLASS_NAME2 = getClassNames(template.prefixCls);
      var container = this.element;
      this.element.style.pointerEvents = enterable ? "auto" : "none";
      if (content)
        this.renderCustomContent();
      else {
        if (title) {
          container.innerHTML = template.title;
          container.getElementsByClassName(CLASS_NAME2.TITLE)[0].innerHTML = title;
        } else
          (_b = (_a2 = container.getElementsByClassName(CLASS_NAME2.TITLE)) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.remove();
        var itemsElements = this.HTMLTooltipItemsElements;
        var ul = document.createElement("ul");
        ul.className = CLASS_NAME2.LIST;
        replaceChildren(ul, itemsElements);
        var list = this.element.querySelector(".".concat(CLASS_NAME2.LIST));
        if (list)
          list.replaceWith(ul);
        else
          container.appendChild(ul);
      }
      applyStyleSheet(container, style);
    };
    Tooltip3.prototype.getRelativeOffsetFromCursor = function(assignPosition) {
      var _a2 = this.attributes, position = _a2.position, offset2 = _a2.offset;
      var interPosition = assignPosition || position;
      var finalPosition = interPosition.split("-");
      var positionScore = { left: [-1, 0], right: [1, 0], top: [0, -1], bottom: [0, 1] };
      var _b = this.elementSize, width = _b.width, height = _b.height;
      var absolutelyOffset = [-width / 2, -height / 2];
      finalPosition.forEach(function(pos) {
        var _a3 = __read(absolutelyOffset, 2), abs1 = _a3[0], abs22 = _a3[1];
        var _b2 = __read(positionScore[pos], 2), pos1 = _b2[0], pos2 = _b2[1];
        absolutelyOffset = [abs1 + (width / 2 + offset2[0]) * pos1, abs22 + (height / 2 + offset2[1]) * pos2];
      });
      return absolutelyOffset;
    };
    Tooltip3.prototype.setOffsetPosition = function(_a2) {
      var _b = __read(_a2, 2), offsetX = _b[0], offsetY = _b[1];
      var _c = this.attributes, _d = _c.x, x3 = _d === void 0 ? 0 : _d, _e = _c.y, y3 = _e === void 0 ? 0 : _e, _f = _c.container, cx = _f.x, cy = _f.y;
      this.element.style.left = "".concat(+x3 + cx + offsetX, "px");
      this.element.style.top = "".concat(+y3 + cy + offsetY, "px");
    };
    Tooltip3.prototype.updatePosition = function() {
      var _a2 = this.attributes.showDelay, showDelay = _a2 === void 0 ? 60 : _a2;
      var currentTimestamp = Date.now();
      if (this.timestamp > 0 && currentTimestamp - this.timestamp < showDelay)
        return;
      this.timestamp = currentTimestamp;
      this.setOffsetPosition(this.autoPosition(this.getRelativeOffsetFromCursor()));
    };
    Tooltip3.prototype.autoPosition = function(_a2) {
      var _b = __read(_a2, 2), offsetX = _b[0], offsetY = _b[1];
      var _c = this.attributes, cursorX = _c.x, cursorY = _c.y, bounding = _c.bounding, position = _c.position;
      if (!bounding)
        return [offsetX, offsetY];
      var _d = this.element, offsetWidth = _d.offsetWidth, offsetHeight = _d.offsetHeight;
      var _e = __read([+cursorX + offsetX, +cursorY + offsetY], 2), expectLeft = _e[0], expectTop = _e[1];
      var inversion = {
        left: "right",
        right: "left",
        top: "bottom",
        bottom: "top"
      };
      var boundingX = bounding.x, boundingY = bounding.y, boundingWidth = bounding.width, boundingHeight = bounding.height;
      var edgeCompare = {
        left: expectLeft < boundingX,
        right: expectLeft + offsetWidth > boundingX + boundingWidth,
        top: expectTop < boundingY,
        bottom: expectTop + offsetHeight > boundingY + boundingHeight
      };
      var correctivePosition = [];
      position.split("-").forEach(function(pos) {
        if (edgeCompare[pos])
          correctivePosition.push(inversion[pos]);
        else
          correctivePosition.push(pos);
      });
      var correctedPositionString = correctivePosition.join("-");
      return this.getRelativeOffsetFromCursor(correctedPositionString);
    };
    Tooltip3.prototype.isCursorEntered = function(clientX, clientY) {
      if (this.element) {
        var _a2 = this.element.getBoundingClientRect(), x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
        return new BBox(x3, y3, width, height).isPointIn(clientX, clientY);
      }
      return false;
    };
    Tooltip3.prototype.closeTransition = function(callback) {
      var _this2 = this;
      var transition2 = this.element.style.transition;
      this.element.style.transition = "none";
      callback();
      setTimeout(function() {
        _this2.element.style.transition = transition2;
      }, 10);
    };
    Tooltip3.tag = "tooltip";
    return Tooltip3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/switch/constant.js
var SIZE_STYLE2 = {
  default: {
    sizeStyle: {
      width: 44,
      height: 22,
      radius: 11
    },
    tagStyle: {
      textStyle: {
        fontSize: 12,
        lineHeight: 16,
        fill: "#fff"
      },
      padding: 0
    },
    markerStyle: {
      size: 11
    }
  },
  small: {
    sizeStyle: {
      width: 28,
      height: 16,
      radius: 8
    },
    tagStyle: {
      textStyle: {
        fontSize: 10,
        lineHeight: 14,
        fill: "#fff"
      },
      padding: 0
    },
    markerStyle: {
      size: 8
    }
  },
  mini: {
    sizeStyle: {
      width: 20,
      height: 14,
      radius: 7
    },
    tagStyle: {
      textStyle: {
        fontSize: 7,
        lineHeight: 10,
        fill: "#fff"
      },
      padding: 0
    },
    markerStyle: {
      size: 7
    }
  }
};

// node_modules/@antv/component/esm/ui/switch/index.js
var OPTION_COLOR = "#1890FF";
var CLOSE_COLOR = "#00000040";
function getHandleShapeStyle(shape23, spacing, checked) {
  if (spacing === void 0) {
    spacing = 0;
  }
  if (checked === void 0) {
    checked = true;
  }
  var size3 = Number(shape23.style.height) - spacing * 2;
  return {
    x: checked ? Number(shape23.style.width) + Number(shape23.style.x) - spacing - size3 : Number(shape23.style.x) + spacing,
    y: Number(shape23.style.y) + spacing,
    width: size3,
    height: size3,
    radius: size3 / 2
  };
}
function getTagShapeStyle(backgroundStyle, _a2, spacing, checked) {
  var width = _a2.width, height = _a2.height;
  if (spacing === void 0) {
    spacing = 0;
  }
  if (checked === void 0) {
    checked = true;
  }
  return {
    x: checked ? Number(backgroundStyle.x) + spacing : Number(backgroundStyle.width) + Number(backgroundStyle.x) - width,
    y: Number(backgroundStyle.y) + (Number(backgroundStyle.height) - height) / 2
  };
}
var Switch = (
  /** @class */
  function(_super) {
    __extends(Switch2, _super);
    function Switch2(options) {
      return _super.call(this, options, {
        x: 0,
        y: 0,
        size: "default",
        spacing: 2,
        checked: true,
        disabled: false
      }) || this;
    }
    Switch2.prototype.render = function(attributes, container) {
      var _this2 = this;
      var size3 = attributes.size, spacing = attributes.spacing, disabled = attributes.disabled, checked = attributes.checked, unCheckedChildren = attributes.unCheckedChildren, checkedChildren = attributes.checkedChildren;
      var group3 = select2(container).maybeAppendByClassName("switch-content", "g").node();
      var bounds = group3.getLocalBounds();
      var _a2 = get_default(SIZE_STYLE2, size3, SIZE_STYLE2.default), sizeStyle = _a2.sizeStyle, tagStyle = _a2.tagStyle;
      var cursor = disabled ? "no-drop" : "pointer";
      var color3 = checked ? OPTION_COLOR : CLOSE_COLOR;
      var backgroundStyle = sizeStyle;
      var tagCfg = checked ? checkedChildren : unCheckedChildren;
      if (checkedChildren || unCheckedChildren) {
        select2(group3).maybeAppendByClassName("switch-tag", function() {
          return new Tag({});
        }).call(function(selection) {
          var tagShape = selection.node();
          tagShape.update(__assign(__assign({ cursor, backgroundStyle: null, text: false, marker: false }, tagStyle), tagCfg));
          var _a3 = (tagShape === null || tagShape === void 0 ? void 0 : tagShape.getLocalBounds()) || {}, max11 = _a3.max, min10 = _a3.min;
          var width = max11[0] - min10[0] + sizeStyle.radius;
          var height = max11[1] - min10[1];
          var backgroundWidth = Math.max(width + sizeStyle.height + 2, sizeStyle.width);
          backgroundStyle = __assign(__assign({}, sizeStyle), { width: backgroundWidth });
          tagShape.update(getTagShapeStyle({
            x: bounds.min[0],
            y: bounds.min[1],
            width: backgroundWidth,
            height: backgroundStyle.height
          }, { width, height }, backgroundStyle.radius, checked));
        });
      }
      var backgroundShape = select2(group3).maybeAppendByClassName("switch-background", "rect").styles(__assign({ zIndex: (group3.style.zIndex || 0) - 1, x: bounds.min[0], y: bounds.min[1], fill: color3, cursor, fillOpacity: disabled ? 0.4 : 1 }, backgroundStyle)).node();
      var backgroundStrokeShape = select2(group3).maybeAppendByClassName("switch-background-stroke", "rect").styles(__assign({ zIndex: (group3.style.zIndex || 0) - 2, x: bounds.min[0], y: bounds.min[1], stroke: color3, lineWidth: 0 }, backgroundStyle)).node();
      select2(group3).maybeAppendByClassName("switch-handle", "rect").styles({
        fill: "#fff",
        cursor
      }).call(function(selection) {
        var _a3, _b;
        var handleShape = selection.node();
        var newHandleShapeStyle = getHandleShapeStyle(backgroundShape, spacing, checked);
        var oldHandleShapeStyle = getHandleShapeStyle(backgroundShape, spacing, !checked);
        if (handleShape.attr("x") && !is_equal_default(newHandleShapeStyle, oldHandleShapeStyle) && _this2.checked !== checked) {
          handleShape.attr(oldHandleShapeStyle);
          (_a3 = handleShape.getAnimations()[0]) === null || _a3 === void 0 ? void 0 : _a3.cancel();
          (_b = backgroundStrokeShape.getAnimations()[0]) === null || _b === void 0 ? void 0 : _b.cancel();
          handleShape.animate([{ x: oldHandleShapeStyle.x }, { x: newHandleShapeStyle.x }], {
            duration: 120,
            fill: "both"
          });
          backgroundStrokeShape.animate([
            { lineWidth: 0, strokeOpacity: 0.5 },
            { lineWidth: 14, strokeOpacity: 0 }
          ], {
            duration: 400,
            easing: "ease-on"
          });
        } else {
          handleShape.attr(newHandleShapeStyle);
        }
      });
      this.checked = !!checked;
    };
    Switch2.tag = "switch";
    return Switch2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/crosshair/constant.js
var CROSSHAIR_BASE_DEFAULT_STYLE = {
  tagText: "",
  lineStroke: "#416180",
  lineStrokeOpacity: 0.45,
  lineLineWidth: 1,
  lineLineDash: [5, 5]
};
var LINE_CROSSHAIR_DEFAULT_STYLE = deepAssign2({}, CROSSHAIR_BASE_DEFAULT_STYLE, {
  type: "line",
  tagPosition: "start",
  tagAlign: "center",
  tagVerticalAlign: "bottom"
});
var CIRCLE_CROSSHAIR_DEFAULT_STYLE = deepAssign2({}, CROSSHAIR_BASE_DEFAULT_STYLE, {
  type: "circle",
  defaultRadius: 0
});
var POLYGON_CROSSHAIR_DEFAULT_STYLE = deepAssign2({}, CROSSHAIR_BASE_DEFAULT_STYLE, {
  type: "polygon",
  defaultRadius: 0,
  startAngle: 0
});

// node_modules/@antv/component/esm/ui/crosshair/base.js
var CrosshairBase = (
  /** @class */
  function(_super) {
    __extends(CrosshairBase2, _super);
    function CrosshairBase2(options) {
      return _super.call(this, options, CROSSHAIR_BASE_DEFAULT_STYLE) || this;
    }
    Object.defineProperty(CrosshairBase2.prototype, "localPointer", {
      /**
       * 获得 pointer 的相对坐标
       */
      get: function() {
        var _a2 = __read(this.getPosition(), 2), bx = _a2[0], by = _a2[1];
        var _b = __read(this.pointer, 2), x3 = _b[0], y3 = _b[1];
        return [x3 - bx, y3 - by];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CrosshairBase2.prototype, "tagStyle", {
      get: function() {
        var style = subStyleProps(this.attributes, "tag");
        return style;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CrosshairBase2.prototype, "crosshairStyle", {
      get: function() {
        var style = subStyleProps(this.attributes, "line");
        return __assign(__assign({}, style), { d: this.crosshairPath });
      },
      enumerable: false,
      configurable: true
    });
    CrosshairBase2.prototype.render = function(attributes, container) {
      var group3 = select2(container).maybeAppendByClassName(".crosshair-group", "g").node();
      this.shapesGroup = group3;
      var tagStyle = this.tagStyle;
      var crosshairStyle = this.crosshairStyle;
      this.tagShape = select2(group3).maybeAppendByClassName("crosshair-tag", function() {
        return new Tag({ style: tagStyle });
      }).styles(tagStyle).node();
      this.crosshairShape = select2(group3).maybeAppendByClassName(".crosshair-path", "path").styles(crosshairStyle).node();
      this.adjustLayout();
    };
    CrosshairBase2.prototype.setPointer = function(pointer) {
      this.pointer = pointer;
    };
    CrosshairBase2.tag = "crosshair-base";
    return CrosshairBase2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/crosshair/line.js
var LineCrosshair = (
  /** @class */
  function(_super) {
    __extends(LineCrosshair2, _super);
    function LineCrosshair2(options) {
      return _super.call(this, deepAssign2({}, LineCrosshair2.defaultOptions, options)) || this;
    }
    Object.defineProperty(LineCrosshair2.prototype, "crosshairPath", {
      get: function() {
        var _a2 = this.attributes, _b = __read(_a2.startPos, 2), sx = _b[0], sy = _b[1], _c = __read(_a2.endPos, 2), ex = _c[0], ey = _c[1];
        var path2 = [["M", 0, 0], ["L", ex - sx, ey - sy], ["Z"]];
        return path2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LineCrosshair2.prototype, "localPointer", {
      /**
       * 获得 pointer 的相对坐标
       */
      get: function() {
        if (!this.pointer)
          return this.attributes.startPos;
        var _a2 = __read(this.getPosition(), 2), bx = _a2[0], by = _a2[1];
        var _b = __read(this.pointer, 2), x3 = _b[0], y3 = _b[1];
        return [x3 - bx, y3 - by];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LineCrosshair2.prototype, "isVertical", {
      get: function() {
        var _a2 = this.attributes, _b = __read(_a2.startPos, 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2.endPos, 2), x22 = _c[0], y22 = _c[1];
        return x12 === x22 && y12 !== y22;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LineCrosshair2.prototype, "tagShapeSpace", {
      get: function() {
        var _a2 = getShapeSpace(this.tagShape), width = _a2.width, height = _a2.height;
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    LineCrosshair2.prototype.update = function(cfg) {
      _super.prototype.update.call(this, cfg);
    };
    LineCrosshair2.prototype.setPointer = function(pointer) {
      _super.prototype.setPointer.call(this, pointer);
      this.adjustPosition();
    };
    LineCrosshair2.prototype.setText = function(text) {
      this.tagShape.update({ text });
      this.adjustTag();
    };
    LineCrosshair2.prototype.adjustLayout = function() {
      this.adjustPosition();
      this.adjustTag();
    };
    LineCrosshair2.prototype.adjustPosition = function() {
      var _a2 = __read(this.localPointer, 2), lx = _a2[0], ly = _a2[1];
      var _b = __read(this.attributes.startPos, 2), sx = _b[0], sy = _b[1];
      var targetPos = this.getOrientVal([sx, ly], [lx, sy]);
      this.shapesGroup.setLocalPosition(targetPos);
    };
    LineCrosshair2.prototype.adjustTag = function() {
      var _a2 = this.attributes, tagText = _a2.tagText, tagPosition = _a2.tagPosition, _b = __read(_a2.startPos, 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2.endPos, 2), x22 = _c[0], y22 = _c[1];
      if (!tagText || tagText === "") {
        hide(this.tagShape);
        return;
      }
      show(this.tagShape);
      var _d = this.tagShapeSpace, width = _d.width, height = _d.height;
      var _e = __read(this.getOrientVal({
        start: [-width / 2, height / 2],
        end: [x22 - x12 + width / 2, height / 2]
      }, {
        start: [0, 0],
        end: [0, y22 - y12 + height]
      })[tagPosition], 2), xOffset = _e[0], yOffset = _e[1];
      this.tagShape.setLocalPosition(xOffset, yOffset);
    };
    LineCrosshair2.prototype.getOrientVal = function(v1, v2) {
      return this.isVertical ? v2 : v1;
    };
    LineCrosshair2.tag = "line-crosshair";
    LineCrosshair2.defaultOptions = {
      style: LINE_CROSSHAIR_DEFAULT_STYLE
    };
    return LineCrosshair2;
  }(CrosshairBase)
);

// node_modules/@antv/component/esm/ui/crosshair/circle.js
var CircleCrosshair = (
  /** @class */
  function(_super) {
    __extends(CircleCrosshair2, _super);
    function CircleCrosshair2(options) {
      return _super.call(this, deepAssign2({}, CircleCrosshair2.defaultOptions, options)) || this;
    }
    Object.defineProperty(CircleCrosshair2.prototype, "crosshairPath", {
      get: function() {
        return this.createCirclePath();
      },
      enumerable: false,
      configurable: true
    });
    CircleCrosshair2.prototype.update = function(cfg) {
      _super.prototype.update.call(this, cfg);
    };
    CircleCrosshair2.prototype.setPointer = function(_a2) {
      var _b = __read(_a2, 2), x3 = _b[0], y3 = _b[1];
      _super.prototype.setPointer.call(this, [x3, y3]);
      var _c = __read(this.localPointer, 2), lx = _c[0], ly = _c[1];
      var _d = __read(this.attributes.center, 2), cx = _d[0], cy = _d[1];
      var path2 = this.createCirclePath(Math.pow(Math.pow(lx - cx, 2) + Math.pow(ly - cy, 2), 0.5));
      this.crosshairShape.attr({ d: path2 });
    };
    CircleCrosshair2.prototype.adjustLayout = function() {
      hide(this.tagShape);
    };
    CircleCrosshair2.prototype.createCirclePath = function(radius) {
      var _a2 = this.attributes, _b = __read(_a2.center, 2), x3 = _b[0], y3 = _b[1], defaultRadius2 = _a2.defaultRadius;
      return circle(x3, y3, radius || defaultRadius2);
    };
    CircleCrosshair2.tag = "circle-crosshair";
    CircleCrosshair2.defaultOptions = {
      style: CIRCLE_CROSSHAIR_DEFAULT_STYLE
    };
    return CircleCrosshair2;
  }(CrosshairBase)
);

// node_modules/@antv/component/esm/ui/crosshair/polygon.js
var PolygonCrosshair = (
  /** @class */
  function(_super) {
    __extends(PolygonCrosshair2, _super);
    function PolygonCrosshair2(options) {
      return _super.call(this, deepAssign2({}, PolygonCrosshair2.defaultOptions, options)) || this;
    }
    Object.defineProperty(PolygonCrosshair2.prototype, "crosshairPath", {
      get: function() {
        return this.createPolygonPath();
      },
      enumerable: false,
      configurable: true
    });
    PolygonCrosshair2.prototype.update = function(cfg) {
      _super.prototype.update.call(this, cfg);
    };
    Object.defineProperty(PolygonCrosshair2.prototype, "points", {
      /**
       * 得到从中心出发，各个点方向的单位向量
       */
      get: function() {
        var _a2 = this.attributes, startAngle = _a2.startAngle, sides = _a2.sides;
        var a4 = Math.PI * 2 / sides;
        var unit = [1, 0];
        var points = [];
        for (var i = 0; i < sides; i += 1) {
          points.push(rotate5(unit, [0, 0], startAngle / 180 * Math.PI + a4 * i));
        }
        return points;
      },
      enumerable: false,
      configurable: true
    });
    PolygonCrosshair2.prototype.setPointer = function(_a2) {
      var _b = __read(_a2, 2), x3 = _b[0], y3 = _b[1];
      _super.prototype.setPointer.call(this, [x3, y3]);
      var _c = __read(this.localPointer, 2), lx = _c[0], ly = _c[1];
      var center2 = this.attributes.center;
      var _d = __read(this.intersection([lx, ly]), 2), ix = _d[0], iy = _d[1];
      if (!ix || !iy)
        return;
      var equivalentRadius = lineLen(center2, [lx, ly]) / lineLen(center2, [ix, iy]);
      var path2 = this.createPolygonPath(equivalentRadius);
      this.crosshairShape.attr({ d: path2 });
    };
    PolygonCrosshair2.prototype.adjustLayout = function() {
      hide(this.tagShape);
    };
    PolygonCrosshair2.prototype.createPolygonPath = function(radius) {
      var _a2 = this.attributes, defaultRadius2 = _a2.defaultRadius, _b = __read(_a2.center, 2), cx = _b[0], cy = _b[1];
      var path2 = this.points.map(function(_a3, index3) {
        var _b2 = __read(_a3, 2), x3 = _b2[0], y3 = _b2[1];
        var _c = __read(scale8([x3, y3], radius || defaultRadius2), 2), tx = _c[0], ty = _c[1];
        return [index3 === 0 ? "M" : "L", cx + tx, cy + ty];
      });
      path2.push(["Z"]);
      return path2;
    };
    PolygonCrosshair2.prototype.intersection = function(_a2) {
      var _b;
      var _c = __read(_a2, 2), x3 = _c[0], y3 = _c[1];
      var points = this.points;
      var _d = __read(this.attributes.center, 2), cx = _d[0], cy = _d[1];
      var ix;
      var iy;
      for (var i = 1; i <= points.length; i += 1) {
        var _e = __read(points[i - 1], 2), sx = _e[0], sy = _e[1];
        var _f = __read(points[i % points.length], 2), ex = _f[0], ey = _f[1];
        var inter = intersection2([x3, y3], [cx, cy], [sx + cx, sy + cy], [ex + cx, ey + cy]);
        if (inter.length !== 0) {
          _b = __read(inter, 2), ix = _b[0], iy = _b[1];
        }
      }
      return [ix, iy];
    };
    PolygonCrosshair2.tag = "polygon-crosshair";
    PolygonCrosshair2.defaultOptions = {
      style: POLYGON_CROSSHAIR_DEFAULT_STYLE
    };
    return PolygonCrosshair2;
  }(CrosshairBase)
);

// node_modules/@antv/component/esm/ui/checkbox/constant.js
var LABEL_TEXT_STYLE = superStyleProps({
  fill: "rgba(0,0,0,0.45)",
  fontSize: 10,
  textAlign: "start",
  textBaseline: "middle",
  overflow: "clip"
}, "label");
var CHECKBOX_RECT_STYLE = {
  default: {
    width: 12,
    height: 12,
    radius: 2,
    stroke: "#dadada",
    lineWidth: 1,
    fill: "#ffffff",
    cursor: "pointer"
  },
  selected: {
    width: 12,
    height: 12,
    radius: 2,
    stroke: "#3471F9",
    lineWidth: 1,
    fill: "#3471F9",
    cursor: "pointer"
  }
};
var CHECKED_SHAPE_PATH = [
  ["M", 3, 6],
  ["L", "5", "8.5"],
  ["L", "8.5", "4"]
];
var CHECKED_SHAPE_STYLE = {
  d: CHECKED_SHAPE_PATH,
  lineWidth: 1,
  cursor: "pointer"
};

// node_modules/@antv/component/esm/ui/checkbox/index.js
function getLablePosition(shape23, spacing) {
  var bounds = shape23.getLocalBounds();
  return {
    x: bounds.halfExtents[0] ? bounds.max[0] + (spacing || 0) : shape23.style.x,
    y: bounds.halfExtents[1] ? (bounds.min[1] + bounds.max[1]) / 2 : shape23.style.y
  };
}
var Checkbox = (
  /** @class */
  function(_super) {
    __extends(Checkbox2, _super);
    function Checkbox2(options) {
      return _super.call(this, options, __assign({ labelText: "", spacing: 4, checked: false }, LABEL_TEXT_STYLE)) || this;
    }
    Checkbox2.prototype.render = function(attributes, container) {
      var checked = attributes.checked, spacing = attributes.spacing;
      this.checked = !!checked;
      var group3 = maybeAppend(container, ".checkbox-content", "g").attr("className", "checkbox-content").node();
      var boxStyle = subStyleProps(attributes, "box");
      var checkedStyle = subStyleProps(attributes, "checked");
      var labelStyle = subStyleProps(attributes, "label");
      var checkboxStyle = __assign(__assign({}, this.checked ? CHECKBOX_RECT_STYLE.selected : CHECKBOX_RECT_STYLE.default), boxStyle);
      var checkboxBoxCheckedStyle = __assign(__assign({}, CHECKED_SHAPE_STYLE), checkedStyle);
      this.checkboxBoxShape = maybeAppend(group3, ".checkbox-box", "rect").styles(__assign({ className: "checkbox-box", zIndex: (group3.style.zIndex || 0) - 1 }, checkboxStyle)).node();
      maybeAppend(this.checkboxBoxShape, ".checkbox-checked", "path").styles(__assign({ className: "checkbox-box-checked", stroke: "#fff" }, checkboxBoxCheckedStyle));
      var _a2 = getLablePosition(this.checkboxBoxShape, Number(spacing)), x3 = _a2.x, y3 = _a2.y;
      maybeAppend(group3, ".checkbox-label", "text").styles(__assign({ className: "checkbox-label", x: x3, y: y3 }, labelStyle));
    };
    Checkbox2.tag = "checkbox";
    return Checkbox2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/poptip/constant.js
var _a;
var POPTIP_ID = "component-poptip";
var CLASS_NAME = {
  CONTAINER: "component-poptip",
  ARROW: "component-poptip-arrow",
  TEXT: "component-poptip-text"
};
var POPTIP_STYLE = (_a = {}, // 容器 默认 style
_a[".".concat(CLASS_NAME.CONTAINER)] = {
  visibility: "visible",
  position: "absolute",
  "background-color": "rgba(0, 0, 0)",
  "box-shadow": "0px 0px 10px #aeaeae",
  "border-radius": "3px",
  color: "#fff",
  opacity: 0.8,
  "font-size": "12px",
  padding: "4px 6px",
  display: "flex",
  "justify-content": "center",
  "align-items": "center",
  "z-index": 8,
  transition: "visibility 50ms"
}, // 文本内容 默认 style
_a[".".concat(CLASS_NAME.TEXT)] = {
  "text-align": "center"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top']")] = {
  transform: "translate(-50%, -100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left']")] = {
  transform: "translate(-100%, -50%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right']")] = {
  transform: "translate(0, -50%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom']")] = {
  transform: "translate(-50%, 0)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-left']")] = {
  transform: "translate(0,-100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-right']")] = {
  transform: "translate(-100%,-100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-top']")] = {
  transform: "translate(-100%, 0)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-bottom']")] = {
  transform: "translate(-100%, -100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-top']")] = {
  transform: "translate(0, 0)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-bottom']")] = {
  transform: "translate(0, -100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-left']")] = {
  transform: "translate(0, 0)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-right']")] = {
  transform: "translate(-100%, 0)"
}, _a[".".concat(CLASS_NAME.ARROW)] = {
  width: "4px",
  height: "4px",
  transform: "rotate(45deg)",
  "background-color": "rgba(0, 0, 0)",
  position: "absolute",
  "z-index": -1
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top']")] = {
  transform: "translate(-50%, calc(-100% - 5px))"
}, _a["[data-position='top'] .".concat(CLASS_NAME.ARROW)] = {
  bottom: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left']")] = {
  transform: "translate(calc(-100% - 5px), -50%)"
}, _a["[data-position='left'] .".concat(CLASS_NAME.ARROW)] = {
  right: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right']")] = {
  transform: "translate(5px, -50%)"
}, _a["[data-position='right'] .".concat(CLASS_NAME.ARROW)] = {
  left: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom']")] = {
  transform: "translate(-50%, 5px)"
}, _a["[data-position='bottom'] .".concat(CLASS_NAME.ARROW)] = {
  top: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-left']")] = {
  transform: "translate(0, calc(-100% - 5px))"
}, _a["[data-position='top-left'] .".concat(CLASS_NAME.ARROW)] = {
  left: "10px",
  bottom: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-right']")] = {
  transform: "translate(-100%, calc(-100% - 5px))"
}, _a["[data-position='top-right'] .".concat(CLASS_NAME.ARROW)] = {
  right: "10px",
  bottom: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-top']")] = {
  transform: "translate(calc(-100% - 5px), 0)"
}, _a["[data-position='left-top'] .".concat(CLASS_NAME.ARROW)] = {
  right: "-2px",
  top: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-bottom']")] = {
  transform: "translate(calc(-100% - 5px), -100%)"
}, _a["[data-position='left-bottom'] .".concat(CLASS_NAME.ARROW)] = {
  right: "-2px",
  bottom: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-top']")] = {
  transform: "translate(5px, 0)"
}, _a["[data-position='right-top'] .".concat(CLASS_NAME.ARROW)] = {
  left: "-2px",
  top: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-bottom']")] = {
  transform: "translate(5px, -100%)"
}, _a["[data-position='right-bottom'] .".concat(CLASS_NAME.ARROW)] = {
  left: "-2px",
  bottom: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-left']")] = {
  transform: "translate(0, 5px)"
}, _a["[data-position='bottom-left'] .".concat(CLASS_NAME.ARROW)] = {
  top: "-2px",
  left: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-right']")] = {
  transform: "translate(-100%, 5px)"
}, _a["[data-position='bottom-right'] .".concat(CLASS_NAME.ARROW)] = {
  top: "-2px",
  right: "8px"
}, _a);

// node_modules/@antv/component/esm/ui/poptip/utils.js
var _this = void 0;
function getPositionXY(clientX, clientY, target, position, arrowPointAtCenter, follow) {
  if (arrowPointAtCenter === void 0) {
    arrowPointAtCenter = false;
  }
  if (follow === void 0) {
    follow = false;
  }
  if (follow)
    return [clientX, clientY];
  var _a2 = target.getBoundingClientRect(), x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
  switch (position) {
    case "top":
      return arrowPointAtCenter ? [x3 + width / 2, y3] : [clientX, y3];
    case "left":
      return arrowPointAtCenter ? [x3, y3 + height / 2] : [x3, clientY];
    case "bottom":
      return arrowPointAtCenter ? [x3 + width / 2, y3 + height] : [clientX, y3 + height];
    case "right":
      return arrowPointAtCenter ? [x3 + width, y3 + height / 2] : [x3 + width, clientY];
    case "top-right":
    case "right-top":
      return [x3 + width, y3];
    case "left-bottom":
    case "bottom-left":
      return [x3, y3 + height];
    case "right-bottom":
    case "bottom-right":
      return [x3 + width, y3 + height];
    case "top-left":
    case "left-top":
    default:
      return [x3, y3];
  }
}
var getSingleTon = function(fn) {
  var instance;
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!instance)
      instance = fn.apply(_this, args);
    return instance;
  };
};
function createElement2(id4) {
  var div4 = id4 && document.getElementById(id4);
  if (!div4) {
    div4 = document.createElement("div");
    div4.setAttribute("id", id4);
    document.body.appendChild(div4);
  }
  return div4;
}
function getSingleTonElement(id4) {
  var element = getSingleTon(createElement2)(id4);
  return element;
}

// node_modules/@antv/component/esm/ui/poptip/index.js
var Poptip = (
  /** @class */
  function(_super) {
    __extends(Poptip3, _super);
    function Poptip3(options) {
      var _this2 = _super.call(this, deep_mix_default({ style: { id: POPTIP_ID } }, Poptip3.defaultOptions, options)) || this;
      _this2.visibility = "visible";
      _this2.map = /* @__PURE__ */ new Map();
      _this2.domStyles = "";
      _this2.initShape();
      _this2.render(_this2.attributes, _this2);
      return _this2;
    }
    Object.defineProperty(Poptip3.prototype, "visible", {
      get: function() {
        return this.visibility === "visible";
      },
      enumerable: false,
      configurable: true
    });
    Poptip3.prototype.render = function(attributes, container) {
      this.visibility = this.style.visibility;
      this.updatePoptipElement();
    };
    Poptip3.prototype.update = function(cfg) {
      this.attr(deep_mix_default({}, this.style, cfg));
      this.render(this.attributes, this);
    };
    Poptip3.prototype.bind = function(element, callback) {
      var _this2 = this;
      if (!element)
        return;
      var defaultText = this.style.text;
      var onmousemove = function(e) {
        var target = element;
        var options = _this2.style;
        var text = defaultText;
        if (callback) {
          var _a2 = typeof callback === "function" ? callback.call(null, e) : callback, html = _a2.html, ele = _a2.target, restOptions = __rest(_a2, ["html", "target"]);
          options = mix({}, _this2.style, restOptions);
          if (ele || ele === false)
            target = ele;
          if (typeof html === "string")
            text = html;
        }
        var position = options.position, arrowPointAtCenter = options.arrowPointAtCenter, follow = options.follow, offset2 = options.offset;
        if (target) {
          var _b = e, clientX = _b.clientX, clientY = _b.clientY;
          var _c = __read(getPositionXY(clientX, clientY, target, position, arrowPointAtCenter, follow), 2), x3 = _c[0], y3 = _c[1];
          _this2.showTip(x3, y3, { text, position, offset: offset2 });
        } else {
          _this2.hideTip();
        }
      };
      var onmouseleave = function() {
        _this2.hideTip();
      };
      element.addEventListener("mousemove", onmousemove);
      element.addEventListener("mouseleave", onmouseleave);
      this.map.set(element, [onmousemove, onmouseleave]);
    };
    Poptip3.prototype.unbind = function(element) {
      if (this.map.has(element)) {
        var _a2 = __read(this.map.get(element) || [], 2), listener1 = _a2[0], listener2 = _a2[1];
        listener1 && element.removeEventListener("mousemove", listener1);
        listener2 && element.removeEventListener("mouseleave", listener2);
        this.map.delete(element);
      }
    };
    Poptip3.prototype.clear = function() {
      this.container.innerHTML = "";
    };
    Poptip3.prototype.destroy = function() {
      var _this2 = this;
      var _a2;
      __spreadArray([], __read(this.map.keys()), false).forEach(function(ele) {
        return _this2.unbind(ele);
      });
      (_a2 = this.container) === null || _a2 === void 0 ? void 0 : _a2.remove();
      _super.prototype.destroy.call(this);
    };
    Poptip3.prototype.showTip = function(x3, y3, options) {
      var text = get_default(options, "text");
      if (text && typeof text !== "string")
        return;
      this.applyStyles();
      if (x3 && y3 && options) {
        var offset2 = options.offset, position = options.position;
        position && this.container.setAttribute("data-position", position);
        this.setOffsetPosition(x3, y3, offset2);
        if (typeof text === "string") {
          var textElement = this.container.querySelector(".".concat(CLASS_NAME.TEXT));
          if (textElement) {
            textElement.innerHTML = text;
          }
        }
        this.visibility = "visible";
        this.container.style.visibility = "visible";
      }
    };
    Poptip3.prototype.hideTip = function() {
      this.visibility = "hidden";
      this.container.style.visibility = "hidden";
    };
    Poptip3.prototype.getContainer = function() {
      return this.container;
    };
    Poptip3.prototype.getClassName = function() {
      var containerClassName = this.style.containerClassName;
      return "".concat(CLASS_NAME.CONTAINER).concat(containerClassName ? " ".concat(containerClassName) : "");
    };
    Poptip3.prototype.initShape = function() {
      var _this2 = this;
      var id4 = this.style.id;
      this.container = getSingleTonElement(id4);
      this.container.className = this.getClassName();
      this.container.addEventListener("mousemove", function() {
        return _this2.showTip();
      });
      this.container.addEventListener("mouseleave", function() {
        return _this2.hideTip();
      });
    };
    Poptip3.prototype.updatePoptipElement = function() {
      var container = this.container;
      this.clear();
      var _a2 = this.style, id4 = _a2.id, template = _a2.template, text = _a2.text;
      this.container.setAttribute("id", id4);
      this.container.className = this.getClassName();
      var arrowNode = '<span class="'.concat(CLASS_NAME.ARROW, '"></span>');
      container.innerHTML = arrowNode;
      if (isString(template)) {
        container.innerHTML += template;
      } else if (template && isElement(template)) {
        container.appendChild(template);
      }
      if (text) {
        container.getElementsByClassName(CLASS_NAME.TEXT)[0].textContent = text;
      }
      this.applyStyles();
      this.container.style.visibility = this.visibility;
    };
    Poptip3.prototype.applyStyles = function() {
      var styles = deepAssign2({}, POPTIP_STYLE, this.style.domStyles);
      var styleStr = Object.entries(styles).reduce(function(r, _a2) {
        var _b = __read(_a2, 2), key = _b[0], value2 = _b[1];
        var styleStr2 = Object.entries(value2).reduce(function(r2, _a3) {
          var _b2 = __read(_a3, 2), k2 = _b2[0], v = _b2[1];
          return "".concat(r2).concat(k2, ": ").concat(v, ";");
        }, "");
        return "".concat(r).concat(key, "{").concat(styleStr2, "}");
      }, "");
      if (this.domStyles !== styleStr) {
        this.domStyles = styleStr;
        var styleDOM = this.container.querySelector("style");
        if (styleDOM)
          this.container.removeChild(styleDOM);
        styleDOM = document.createElement("style");
        styleDOM.innerHTML = styleStr;
        this.container.appendChild(styleDOM);
      }
    };
    Poptip3.prototype.setOffsetPosition = function(x3, y3, offset2) {
      if (offset2 === void 0) {
        offset2 = this.style.offset;
      }
      var _a2 = __read(offset2, 2), _b = _a2[0], offsetX = _b === void 0 ? 0 : _b, _c = _a2[1], offsetY = _c === void 0 ? 0 : _c;
      this.container.style.left = "".concat(x3 + offsetX, "px");
      this.container.style.top = "".concat(y3 + offsetY, "px");
    };
    Poptip3.tag = "poptip";
    Poptip3.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        target: null,
        visibility: "hidden",
        text: "",
        position: "top",
        follow: false,
        offset: [0, 0],
        domStyles: POPTIP_STYLE,
        template: '<div class="'.concat(CLASS_NAME.TEXT, '"></div>')
      }
    };
    return Poptip3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/layout/layout.js
var Layout = (
  /** @class */
  function(_super) {
    __extends(Layout2, _super);
    function Layout2(options) {
      var _this2 = _super.call(this, options) || this;
      _this2.layoutEvents = [ElementEvent.BOUNDS_CHANGED, ElementEvent.INSERTED, ElementEvent.REMOVED];
      _this2.$margin = parseSeriesAttr(0);
      _this2.$padding = parseSeriesAttr(0);
      var _a2 = options.style || {}, _b = _a2.margin, margin = _b === void 0 ? 0 : _b, _c = _a2.padding, padding = _c === void 0 ? 0 : _c;
      _this2.margin = margin;
      _this2.padding = padding;
      _this2.isMutationObserved = true;
      _this2.bindEvents();
      return _this2;
    }
    Object.defineProperty(Layout2.prototype, "margin", {
      get: function() {
        return this.$margin;
      },
      set: function(value2) {
        this.$margin = parseSeriesAttr(value2);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Layout2.prototype, "padding", {
      get: function() {
        return this.$padding;
      },
      set: function(value2) {
        this.$padding = parseSeriesAttr(value2);
      },
      enumerable: false,
      configurable: true
    });
    Layout2.prototype.getBBox = function() {
      var _a2 = this.attributes, _b = _a2.x, x3 = _b === void 0 ? 0 : _b, _c = _a2.y, y3 = _c === void 0 ? 0 : _c, width = _a2.width, height = _a2.height;
      var _d = __read(this.$margin, 4), marginTop = _d[0], marginRight = _d[1], marginBottom = _d[2], marginLeft = _d[3];
      return new BBox(x3 - marginLeft, y3 - marginTop, width + marginLeft + marginRight, height + marginTop + marginBottom);
    };
    Layout2.prototype.appendChild = function(child, index3) {
      child.isMutationObserved = true;
      _super.prototype.appendChild.call(this, child, index3);
      return child;
    };
    Layout2.prototype.getAvailableSpace = function() {
      var _a2 = this.attributes, width = _a2.width, height = _a2.height;
      var _b = __read(this.$padding, 4), paddingTop = _b[0], paddingRight = _b[1], paddingBottom = _b[2], paddingLeft = _b[3];
      var _c = __read(this.$margin, 4), marginTop = _c[0], marginLeft = _c[3];
      return new BBox(paddingLeft + marginLeft, paddingTop + marginTop, width - paddingLeft - paddingRight, height - paddingTop - paddingBottom);
    };
    Layout2.prototype.layout = function() {
      if (!this.attributes.display || !this.isConnected)
        return;
      if (this.children.some(function(child) {
        return !child.isConnected;
      }))
        return;
      try {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y;
        this.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
        var bboxes_1 = executer_default(this.getAvailableSpace(), this.children.map(function(child) {
          return child.getBBox();
        }), this.attributes);
        this.children.forEach(function(child, index3) {
          var _a3 = bboxes_1[index3], x4 = _a3.x, y4 = _a3.y;
          child.style.transform = "translate(".concat(x4, ", ").concat(y4, ")");
        });
      } catch (e) {
      }
    };
    Layout2.prototype.bindEvents = function() {
      var _this2 = this;
      this.layoutEvents.forEach(function(event) {
        _this2.addEventListener(event, function(e) {
          if (!e.target)
            return;
          e.target.isMutationObserved = true;
          _this2.layout();
        });
      });
    };
    Layout2.prototype.attributeChangedCallback = function(name2, oldValue, newValue) {
      if (name2 === "margin")
        this.margin = newValue;
      else if (name2 === "padding")
        this.padding = newValue;
      this.layout();
    };
    return Layout2;
  }(Group2)
);

// node_modules/@antv/component/esm/ui/select/option.js
var Option = (
  /** @class */
  function(_super) {
    __extends(Option2, _super);
    function Option2(options) {
      var _this2 = _super.call(this, deepAssign2({}, Option2.defaultOptions, options)) || this;
      _this2.hoverColor = "#f5f5f5";
      _this2.selectedColor = "#e6f7ff";
      _this2.background = _this2.appendChild(new Rect({}));
      _this2.label = _this2.background.appendChild(new Group2({}));
      return _this2;
    }
    Object.defineProperty(Option2.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(this.style.padding);
      },
      enumerable: false,
      configurable: true
    });
    Option2.prototype.renderLabel = function() {
      var _a2 = this.style, label = _a2.label, value2 = _a2.value;
      var labelStyle = subStyleProps(this.attributes, "label");
      select2(this.label).maybeAppend(".label", function() {
        return renderExtDo(label);
      }).attr("className", "label").styles(labelStyle);
      this.label.attr("__data__", value2);
    };
    Option2.prototype.renderBackground = function() {
      var labelBBox = this.label.getBBox();
      var _a2 = __read(this.padding, 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
      var labelWidth = labelBBox.width, labelHeight = labelBBox.height;
      var backgroundWidth = labelWidth + left2 + right2;
      var backgroundHeight = labelHeight + top + bottom;
      var backgroundStyle = subStyleProps(this.attributes, "background");
      var _b = this.style, _c = _b.width, styleWidth = _c === void 0 ? 0 : _c, _d = _b.height, styleHeight = _d === void 0 ? 0 : _d, selected = _b.selected;
      this.background.attr(__assign(__assign({}, backgroundStyle), { width: Math.max(backgroundWidth, styleWidth), height: Math.max(backgroundHeight, styleHeight), fill: selected ? this.selectedColor : "#fff" }));
      this.label.attr({ transform: "translate(".concat(left2, ", ").concat((backgroundHeight - labelHeight) / 2, ")") });
    };
    Option2.prototype.render = function() {
      this.renderLabel();
      this.renderBackground();
    };
    Option2.prototype.bindEvents = function() {
      var _this2 = this;
      this.addEventListener("pointerenter", function() {
        if (_this2.style.selected)
          return;
        _this2.background.attr("fill", _this2.hoverColor);
      });
      this.addEventListener("pointerleave", function() {
        if (_this2.style.selected)
          return;
        _this2.background.attr("fill", _this2.style.backgroundFill);
      });
      var item = this;
      this.addEventListener("click", function() {
        var _a2 = _this2.style, label = _a2.label, value2 = _a2.value, onClick = _a2.onClick;
        onClick === null || onClick === void 0 ? void 0 : onClick(value2, { label, value: value2 }, item);
      });
    };
    Option2.defaultOptions = {
      style: {
        value: "",
        label: "",
        cursor: "pointer"
      }
    };
    return Option2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/select/select.js
var Select2 = (
  /** @class */
  function(_super) {
    __extends(Select3, _super);
    function Select3(options) {
      var _a2, _b;
      var _this2 = _super.call(this, deepAssign2({}, Select3.defaultOptions, options)) || this;
      _this2.currentValue = (_a2 = Select3.defaultOptions.style) === null || _a2 === void 0 ? void 0 : _a2.defaultValue;
      _this2.isPointerInSelect = false;
      _this2.select = _this2.appendChild(new Rect({
        className: "select",
        style: {
          cursor: "pointer",
          width: 0,
          height: 0
        }
      }));
      _this2.dropdown = _this2.appendChild(new Rect({
        className: "dropdown"
      }));
      var defaultValue = _this2.style.defaultValue;
      if (defaultValue && ((_b = _this2.style.options) === null || _b === void 0 ? void 0 : _b.some(function(option) {
        return option.value === defaultValue;
      }))) {
        _this2.currentValue = defaultValue;
      }
      return _this2;
    }
    Select3.prototype.setValue = function(value2) {
      this.currentValue = value2;
      this.render();
    };
    Select3.prototype.getValue = function() {
      return this.currentValue;
    };
    Object.defineProperty(Select3.prototype, "dropdownPadding", {
      get: function() {
        return parseSeriesAttr(this.style.dropdownPadding);
      },
      enumerable: false,
      configurable: true
    });
    Select3.prototype.renderSelect = function() {
      var _this2 = this;
      var _a2;
      var _b = this.style, x3 = _b.x, y3 = _b.y, width = _b.width, height = _b.height, bordered = _b.bordered, showDropdownIcon = _b.showDropdownIcon;
      var selectStyle = subStyleProps(this.attributes, "select");
      var placeholderStyle = subStyleProps(this.attributes, "placeholder");
      this.select.attr(__assign(__assign({ x: x3, y: y3, width, height }, selectStyle), { fill: "#fff", strokeWidth: bordered ? 1 : 0 }));
      var padding = this.dropdownPadding;
      var iconSize = 10;
      if (showDropdownIcon) {
        select2(this.select).maybeAppend(".dropdown-icon", "path").style("d", "M-5,-3.5 L0,3.5 L5,-3.5").style("transform", "translate(".concat(x3 + width - iconSize - padding[1] - padding[3], ", ").concat(y3 + height / 2, ")")).style("lineWidth", 1).style("stroke", this.select.style.stroke);
      }
      var currentOption = (_a2 = this.style.options) === null || _a2 === void 0 ? void 0 : _a2.find(function(option) {
        return option.value === _this2.currentValue;
      });
      var finalPlaceholderStyle = __assign({ x: x3 + padding[3] }, placeholderStyle);
      select2(this.select).selectAll(".placeholder").data(!currentOption ? [1] : []).join(function(enter) {
        return enter.append("text").attr("className", "placeholder").styles(finalPlaceholderStyle).style("y", function() {
          var bbox = this.getBBox();
          return y3 + (height - bbox.height) / 2;
        });
      }, function(update2) {
        return update2.styles(finalPlaceholderStyle);
      }, function(exit) {
        return exit.remove();
      });
      var labelStyle = subStyleProps(this.attributes, "optionLabel");
      var finalValueStyle = __assign({ x: x3 + padding[3] }, labelStyle);
      select2(this.select).selectAll(".value").data(currentOption ? [currentOption] : []).join(function(enter) {
        return enter.append(function(datum) {
          return renderExtDo(datum.label);
        }).attr("className", "value").styles(finalValueStyle).style("y", function() {
          var bbox = this.getBBox();
          return y3 + (height - bbox.height) / 2;
        });
      }, function(update2) {
        return update2.styles(finalValueStyle);
      }, function(exit) {
        return exit.remove();
      });
    };
    Select3.prototype.renderDropdown = function() {
      var _this2 = this;
      var _a2, _b;
      var _c = this.style, x3 = _c.x, y3 = _c.y, width = _c.width, height = _c.height, options = _c.options, onSelect = _c.onSelect, open = _c.open;
      var dropdownStyle = subStyleProps(this.attributes, "dropdown");
      var optionStyle = subStyleProps(this.attributes, "option");
      var padding = this.dropdownPadding;
      select2(this.dropdown).maybeAppend(".dropdown-container", "g").attr("className", "dropdown-container").selectAll(".dropdown-item").data(options, function(datum) {
        return datum.value;
      }).join(function(enter) {
        return enter.append(function(datum) {
          return new Option({
            className: "dropdown-item",
            style: __assign(__assign(__assign({}, datum), optionStyle), { width: width - padding[1] - padding[3], selected: datum.value === _this2.currentValue, onClick: function(value2, option, item) {
              _this2.setValue(value2);
              onSelect === null || onSelect === void 0 ? void 0 : onSelect(value2, option, item);
              _this2.dispatchEvent(new CustomEvent("change", { detail: { value: value2, option, item } }));
              hide(_this2.dropdown);
            } })
          });
        }).each(function(datum, i) {
          var _a3;
          var nodes = (_a3 = this.parentNode) === null || _a3 === void 0 ? void 0 : _a3.children;
          var accHeight = nodes.reduce(function(acc, curr, index3) {
            if (index3 < i) {
              acc += curr.getBBox().height;
            }
            return acc;
          }, 0);
          this.attr("transform", "translate(".concat(padding[3], ", ").concat(padding[0] + accHeight, ")"));
        });
      }, function(update2) {
        return update2.update(function(datum) {
          return { selected: datum.value === _this2.currentValue };
        });
      }, function(exit) {
        return exit.remove();
      });
      var bbox = (_b = (_a2 = this.dropdown.getElementsByClassName("dropdown-container")) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.getBBox();
      var spacing = dropdownStyle.spacing;
      this.dropdown.attr(__assign({ transform: "translate(".concat(x3, ", ").concat(y3 + height + spacing, ")"), width: bbox.width + padding[1] + padding[3], height: bbox.height + padding[0] + padding[2] }, dropdownStyle));
      !open && hide(this.dropdown);
    };
    Select3.prototype.render = function() {
      this.renderSelect();
      this.renderDropdown();
    };
    Select3.prototype.bindEvents = function() {
      var _this2 = this;
      this.addEventListener("click", function(e) {
        e.stopPropagation();
      });
      this.select.addEventListener("click", function() {
        if (_this2.dropdown.style.visibility === "visible")
          hide(_this2.dropdown);
        else {
          show(_this2.dropdown);
        }
      });
      this.addEventListener("pointerenter", function() {
        _this2.isPointerInSelect = true;
      });
      this.addEventListener("pointerleave", function() {
        _this2.isPointerInSelect = false;
      });
      document === null || document === void 0 ? void 0 : document.addEventListener("click", function() {
        if (!_this2.isPointerInSelect) {
          hide(_this2.dropdown);
        }
      });
    };
    Select3.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        width: 140,
        height: 32,
        options: [],
        bordered: true,
        defaultValue: "",
        selectRadius: 8,
        selectStroke: "#d9d9d9",
        showDropdownIcon: true,
        placeholderText: "请选择",
        placeholderFontSize: 12,
        placeholderTextBaseline: "top",
        placeholderFill: "#c2c2c2",
        dropdownFill: "#fff",
        dropdownStroke: "#d9d9d9",
        dropdownRadius: 8,
        dropdownShadowBlur: 4,
        dropdownShadowColor: "rgba(0, 0, 0, 0.08)",
        dropdownPadding: 8,
        dropdownSpacing: 10,
        optionPadding: [8, 12],
        optionFontSize: 12,
        optionTextBaseline: "top",
        optionBackgroundFill: "#fff",
        optionBackgroundRadius: 4,
        optionLabelFontSize: 12,
        optionLabelTextBaseline: "top"
      }
    };
    return Select3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/timebar/icons.js
var IconBase = (
  /** @class */
  function(_super) {
    __extends(IconBase2, _super);
    function IconBase2(options) {
      var _this2 = _super.call(this, deepAssign2({}, { style: { backgroundOpacity: IconBase2.backgroundOpacities.default } }, IconBase2.defaultOptions, options)) || this;
      _this2.showBackground = true;
      _this2.background = _this2.appendChild(new Rect({}));
      _this2.icon = _this2.appendChild(new Group2({}));
      return _this2;
    }
    Object.defineProperty(IconBase2.prototype, "label", {
      get: function() {
        return "BaseIcon";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IconBase2.prototype, "lineWidth", {
      get: function() {
        return Math.log10(this.attributes.size);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IconBase2.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(this.attributes.size / 5);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IconBase2.prototype, "iconSize", {
      get: function() {
        var size3 = this.attributes.size;
        var _a2 = __read(this.padding, 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
        return Math.max(size3 - Math.max(left2 + right2, top + bottom), this.lineWidth * 2 + 1);
      },
      enumerable: false,
      configurable: true
    });
    IconBase2.prototype.renderBackground = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, size3 = _a2.size;
      var halfSize = size3 / 2;
      var backgroundStyle = subStyleProps(this.attributes, "background");
      this.background.attr(__assign({ x: x3 - halfSize, y: y3 - halfSize, width: size3, height: size3 }, backgroundStyle));
    };
    IconBase2.prototype.showIndicator = function() {
      if (!this.label)
        return;
      var size3 = this.attributes.size;
      var _a2 = this.background.getBBox(), x3 = _a2.x, y3 = _a2.y;
      this.indicator.update({ x: x3 + size3 / 2, y: y3 - 5, labelText: this.label, visibility: "visible" });
    };
    IconBase2.prototype.hideIndicator = function() {
      this.indicator.update({ visibility: "hidden" });
    };
    IconBase2.prototype.connectedCallback = function() {
      var _a2;
      _super.prototype.connectedCallback.call(this);
      var size3 = this.attributes.size;
      var _b = this.background.getBBox(), x3 = _b.x, y3 = _b.y;
      var canvas = (_a2 = this.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView;
      if (canvas) {
        this.indicator = canvas.appendChild(new Indicator({
          style: {
            x: x3 + size3 / 2,
            y: y3 - size3 / 2,
            visibility: "hidden",
            position: "top",
            radius: 3,
            zIndex: 100
          }
        }));
      }
    };
    IconBase2.prototype.disconnectedCallback = function() {
      this.indicator.destroy();
    };
    IconBase2.prototype.render = function() {
      this.renderIcon();
      if (this.showBackground)
        this.renderBackground();
    };
    IconBase2.prototype.bindEvents = function() {
      var _this2 = this;
      var onClick = this.attributes.onClick;
      this.addEventListener("click", function() {
        onClick === null || onClick === void 0 ? void 0 : onClick(_this2);
      });
      if (this.showBackground) {
        var resetBackground_1 = function() {
          return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.default });
        };
        var hoverBackground_1 = function() {
          return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.hover });
        };
        var activeBackground_1 = function() {
          return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.active });
        };
        this.addEventListener("pointerenter", function() {
          hoverBackground_1();
          _this2.showIndicator();
        });
        this.addEventListener("pointerleave", function() {
          resetBackground_1();
          _this2.hideIndicator();
        });
        this.addEventListener("pointerdown", function() {
          activeBackground_1();
        });
        this.addEventListener("pointerup", function() {
          resetBackground_1();
        });
      }
    };
    IconBase2.tag = "IconBase";
    IconBase2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        size: 10,
        color: "#565758",
        backgroundRadius: 4,
        backgroundFill: "#e2e2e2"
      }
    };
    IconBase2.backgroundOpacities = {
      default: 0,
      hover: 0.8,
      active: 1
    };
    return IconBase2;
  }(Component)
);
var arrow = function(size3, color3) {
  if (color3 === void 0) {
    color3 = "#565758";
  }
  return new Path2({
    style: {
      fill: color3,
      d: "M ".concat(size3, ",").concat(size3, " L -").concat(size3, ",0 L ").concat(size3, ",-").concat(size3, " Z"),
      transformOrigin: "center"
    }
  });
};
var Reset = (
  /** @class */
  function(_super) {
    __extends(Reset2, _super);
    function Reset2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Reset2.prototype.arcPath = function(cx, cy, radius) {
      var _a2 = __read([radius, radius], 2), rx = _a2[0], ry = _a2[1];
      var getPosByAngle = function(angle4) {
        return [cx + radius * Math.cos(angle4), cy + radius * Math.sin(angle4)];
      };
      var _b = __read(getPosByAngle(-5 / 4 * Math.PI), 2), x12 = _b[0], y12 = _b[1];
      var _c = __read(getPosByAngle(1 / 4 * Math.PI), 2), x22 = _c[0], y22 = _c[1];
      return "M".concat(x12, ",").concat(y12, ",A").concat(rx, ",").concat(ry, ",0,1,1,").concat(x22, ",").concat(y22);
    };
    Object.defineProperty(Reset2.prototype, "label", {
      get: function() {
        return "重置";
      },
      enumerable: false,
      configurable: true
    });
    Reset2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color3 = _a2.color;
      var size3 = this.iconSize;
      var lineWidth = this.lineWidth;
      var arrowSize = lineWidth + 0.5;
      select2(this.icon).maybeAppend(".reset", "path").styles({
        stroke: color3,
        lineWidth,
        d: this.arcPath(x3, y3, size3 / 2 - lineWidth),
        markerStart: arrow(arrowSize, color3)
      });
    };
    return Reset2;
  }(IconBase)
);
var Backward = (
  /** @class */
  function(_super) {
    __extends(Backward2, _super);
    function Backward2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Backward2.prototype, "label", {
      get: function() {
        return "快退";
      },
      enumerable: false,
      configurable: true
    });
    Backward2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color3 = _a2.color;
      var size3 = this.iconSize;
      var deltaX = size3 / 2;
      var deltaY = size3 / 2 / Math.pow(3, 0.5);
      var points = [
        [x3, y3],
        [x3, y3 - deltaY],
        [x3 - deltaX, y3],
        [x3, y3 + deltaY],
        [x3, y3],
        [x3 + deltaX, y3 - deltaY],
        [x3 + deltaX, y3 + deltaY],
        [x3, y3]
      ];
      select2(this.icon).maybeAppend(".backward", "polygon").styles({
        points,
        fill: color3
      });
    };
    return Backward2;
  }(IconBase)
);
var Forward = (
  /** @class */
  function(_super) {
    __extends(Forward2, _super);
    function Forward2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Forward2.prototype, "label", {
      get: function() {
        return "快进";
      },
      enumerable: false,
      configurable: true
    });
    Forward2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color3 = _a2.color;
      var size3 = this.iconSize;
      var deltaX = size3 / 2;
      var deltaY = size3 / 2 / Math.pow(3, 0.5);
      var points = [
        [x3, y3],
        [x3, y3 - deltaY],
        [x3 + deltaX, y3],
        [x3, y3 + deltaY],
        [x3, y3],
        [x3 - deltaX, y3 - deltaY],
        [x3 - deltaX, y3 + deltaY],
        [x3, y3]
      ];
      select2(this.icon).maybeAppend(".forward", "polygon").styles({
        points,
        fill: color3
      });
    };
    return Forward2;
  }(IconBase)
);
var Play = (
  /** @class */
  function(_super) {
    __extends(Play2, _super);
    function Play2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Play2.prototype, "label", {
      get: function() {
        return "播放";
      },
      enumerable: false,
      configurable: true
    });
    Play2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color3 = _a2.color;
      var size3 = this.iconSize;
      var deltaX = size3 / 3 * Math.pow(3, 0.5) * 0.8;
      var points = [
        [x3 + deltaX, y3],
        [x3 - deltaX / 2, y3 - size3 / 2 * 0.8],
        [x3 - deltaX / 2, y3 + size3 / 2 * 0.8],
        [x3 + deltaX, y3]
      ];
      select2(this.icon).maybeAppend(".play", "polygon").styles({
        points,
        fill: color3
      });
    };
    return Play2;
  }(IconBase)
);
var Pause = (
  /** @class */
  function(_super) {
    __extends(Pause2, _super);
    function Pause2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Pause2.prototype, "label", {
      get: function() {
        return "暂停";
      },
      enumerable: false,
      configurable: true
    });
    Pause2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color3 = _a2.color;
      var size3 = this.iconSize;
      var deltaX = size3 / 3;
      var points = [
        [x3 - deltaX, y3 - size3 / 2],
        [x3 - deltaX, y3 + size3 / 2],
        [x3 - deltaX / 2, y3 + size3 / 2],
        [x3 - deltaX / 2, y3 - size3 / 2],
        [x3 - deltaX, y3 - size3 / 2],
        [x3 + deltaX / 2, y3 - size3 / 2],
        [x3 + deltaX / 2, y3 + size3 / 2],
        [x3 + deltaX, y3 + size3 / 2],
        [x3 + deltaX, y3 - size3 / 2]
      ];
      select2(this.icon).maybeAppend(".pause", "polygon").styles({
        points,
        fill: color3
      });
    };
    return Pause2;
  }(IconBase)
);
var Range = (
  /** @class */
  function(_super) {
    __extends(Range3, _super);
    function Range3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Range3.prototype, "label", {
      get: function() {
        return "范围时间";
      },
      enumerable: false,
      configurable: true
    });
    Range3.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color3 = _a2.color;
      var _b = this, size3 = _b.iconSize, lineWidth = _b.lineWidth;
      var gap = lineWidth;
      select2(this.icon).maybeAppend(".left-line", "line").styles({
        x1: x3 - size3 / 2,
        y1: y3 - size3 / 2,
        x2: x3 - size3 / 2,
        y2: y3 + size3 / 2,
        stroke: color3,
        lineWidth
      });
      select2(this.icon).maybeAppend(".right-line", "line").styles({
        x1: x3 + size3 / 2,
        y1: y3 - size3 / 2,
        x2: x3 + size3 / 2,
        y2: y3 + size3 / 2,
        stroke: color3,
        lineWidth
      });
      select2(this.icon).maybeAppend(".left-arrow", "line").styles({
        x1: x3,
        y1: y3,
        x2: x3 - size3 / 2 + gap * 2,
        y2: y3,
        stroke: color3,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color3)
      });
      select2(this.icon).maybeAppend(".right-arrow", "line").styles({
        x1: x3,
        y1: y3,
        x2: x3 + size3 / 2 - gap * 2,
        y2: y3,
        stroke: color3,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color3)
      });
    };
    return Range3;
  }(IconBase)
);
var Value = (
  /** @class */
  function(_super) {
    __extends(Value2, _super);
    function Value2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Value2.prototype, "label", {
      get: function() {
        return "单一时间";
      },
      enumerable: false,
      configurable: true
    });
    Value2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color3 = _a2.color;
      var _b = this, size3 = _b.iconSize, lineWidth = _b.lineWidth;
      select2(this.icon).maybeAppend(".line", "line").styles({
        x1: x3,
        y1: y3 - size3 / 2,
        x2: x3,
        y2: y3 + size3 / 2,
        stroke: color3,
        lineWidth
      });
      var gap = lineWidth;
      select2(this.icon).maybeAppend(".left-arrow", "line").styles({
        x1: x3 - size3 / 2 - gap * 2,
        y1: y3,
        x2: x3 - gap * 2,
        y2: y3,
        stroke: color3,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color3)
      });
      select2(this.icon).maybeAppend(".right-arrow", "line").styles({
        x1: x3 + size3 / 2 + gap * 2,
        y1: y3,
        x2: x3 + gap * 2,
        y2: y3,
        stroke: color3,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color3)
      });
    };
    return Value2;
  }(IconBase)
);
var getCoordinatePoints = function(size3) {
  return [
    [-size3 / 2, -size3 / 2],
    [-size3 / 2, size3 / 2],
    [size3 / 2, size3 / 2]
  ];
};
var LineChart = (
  /** @class */
  function(_super) {
    __extends(LineChart3, _super);
    function LineChart3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(LineChart3.prototype, "label", {
      get: function() {
        return "折线图";
      },
      enumerable: false,
      configurable: true
    });
    LineChart3.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color3 = _a2.color;
      var _b = this, size3 = _b.iconSize, lineWidth = _b.lineWidth;
      var gap = lineWidth;
      var deltaX = (size3 - gap * 2 - lineWidth) / 4;
      var deltaY = (size3 - gap * 2 - lineWidth) / 2;
      var _c = __read([x3 - size3 / 2 + gap, y3 + size3 / 2 - gap * 2], 2), ox = _c[0], oy = _c[1];
      select2(this.icon).maybeAppend(".coordinate", "polyline").styles({
        points: getCoordinatePoints(size3).map(function(_a3) {
          var _b2 = __read(_a3, 2), px2 = _b2[0], py = _b2[1];
          return [px2 + x3, py + y3];
        }),
        stroke: color3,
        lineWidth
      });
      select2(this.icon).maybeAppend(".line", "polyline").styles({
        points: [
          [ox, oy],
          [ox + deltaX, oy - deltaY],
          [ox + deltaX * 2, oy],
          [ox + deltaX * 4, oy - deltaY * 2]
        ],
        stroke: color3,
        lineWidth
      });
    };
    return LineChart3;
  }(IconBase)
);
var BarChart = (
  /** @class */
  function(_super) {
    __extends(BarChart3, _super);
    function BarChart3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BarChart3.prototype, "label", {
      get: function() {
        return "条形图";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BarChart3.prototype, "data", {
      get: function() {
        return [1, 4, 2, 4, 3];
      },
      enumerable: false,
      configurable: true
    });
    BarChart3.prototype.renderIcon = function() {
      var data2 = this.data;
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color3 = _a2.color;
      var _b = this, size3 = _b.iconSize, lineWidth = _b.lineWidth;
      var gap = lineWidth;
      var deltaX = (size3 - gap) / data2.length;
      var deltaY = (size3 - gap * 2) / 4;
      var _c = __read([x3 - size3 / 2 + gap * 2, y3 + size3 / 2 - gap], 2), ox = _c[0], oy = _c[1];
      select2(this.icon).maybeAppend(".coordinate", "polyline").styles({
        points: getCoordinatePoints(size3).map(function(_a3) {
          var _b2 = __read(_a3, 2), px2 = _b2[0], py = _b2[1];
          return [px2 + x3, py + y3];
        }),
        stroke: color3,
        lineWidth
      });
      select2(this.icon).maybeAppend(".bars", "g").selectAll(".column").data(this.data.map(function(value2, index3) {
        return { value: value2, index: index3 };
      })).join(function(enter) {
        return enter.append("line").attr("className", "column").style("x1", function(_a3) {
          var index3 = _a3.index;
          return ox + deltaX * index3;
        }).style("y1", oy).style("x2", function(_a3) {
          var index3 = _a3.index;
          return ox + deltaX * index3;
        }).style("y2", function(_a3) {
          var value2 = _a3.value;
          return oy - deltaY * value2;
        }).styles({
          y1: oy,
          stroke: color3,
          lineWidth
        });
      });
    };
    return BarChart3;
  }(IconBase)
);
var Split = (
  /** @class */
  function(_super) {
    __extends(Split2, _super);
    function Split2(options) {
      var _this2 = _super.call(this, deepAssign2({}, { style: { color: "#d8d9d9" } }, options)) || this;
      _this2.showBackground = false;
      return _this2;
    }
    Split2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color3 = _a2.color;
      var _b = this, size3 = _b.iconSize, lineWidth = _b.lineWidth;
      select2(this.icon).maybeAppend(".split", "line").styles({
        x1: x3,
        y1: y3 - size3 / 2,
        x2: x3,
        y2: y3 + size3 / 2,
        stroke: color3,
        lineWidth
      });
    };
    return Split2;
  }(IconBase)
);
var SpeedSelect = (
  /** @class */
  function(_super) {
    __extends(SpeedSelect2, _super);
    function SpeedSelect2() {
      var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this2.showBackground = false;
      return _this2;
    }
    Object.defineProperty(SpeedSelect2.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(0);
      },
      enumerable: false,
      configurable: true
    });
    SpeedSelect2.prototype.renderIcon = function() {
      var iconSize = this.iconSize;
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, _b = _a2.speed, speed = _b === void 0 ? 1 : _b;
      var inheritStyle = omit_default(this.attributes, [
        "x",
        "y",
        "transform",
        "transformOrigin",
        "width",
        "height",
        "size",
        "color",
        "speed"
      ]);
      var width = clamp_default(iconSize, 20, Infinity);
      var height = 20;
      var style = __assign(__assign({}, inheritStyle), { x: x3 - width / 2, y: y3 - height / 2, width, height, defaultValue: speed, bordered: false, showDropdownIcon: false, selectRadius: 2, dropdownPadding: this.padding, dropdownRadius: 2, dropdownSpacing: iconSize / 5, placeholderFontSize: iconSize / 2, optionPadding: 0, optionLabelFontSize: iconSize / 2, optionBackgroundRadius: 1, options: [
        { label: "1x", value: 1 },
        { label: "1.5x", value: 1.5 },
        { label: "2x", value: 2 }
      ] });
      select2(this.icon).maybeAppend(".speed", function() {
        return new Select2({ style });
      }).attr("className", "speed").each(function() {
        this.update(style);
      });
    };
    SpeedSelect2.tag = "SpeedSelect";
    return SpeedSelect2;
  }(IconBase)
);
var ToggleIcon = (
  /** @class */
  function(_super) {
    __extends(ToggleIcon2, _super);
    function ToggleIcon2(options) {
      var _this2 = _super.call(this, options) || this;
      _this2.icon = _this2.appendChild(new Group2({}));
      _this2.currentType = _this2.attributes.type;
      return _this2;
    }
    ToggleIcon2.prototype.getType = function() {
      return this.currentType;
    };
    ToggleIcon2.prototype.render = function() {
      var _this2 = this;
      var _a2 = this.attributes, onChange = _a2.onChange, restStyles = __rest(_a2, ["onChange"]);
      select2(this.icon).selectAll(".icon").data([this.currentType]).join(function(enter) {
        return enter.append(function(type) {
          var _a3;
          var Ctor = (_a3 = _this2.toggles.find(function(_a4) {
            var _b = __read(_a4, 1), key = _b[0];
            return key === type;
          })) === null || _a3 === void 0 ? void 0 : _a3[1];
          if (!Ctor)
            throw new Error("Invalid type: ".concat(type));
          return new Ctor({});
        }).attr("className", "icon").styles(restStyles, false).update({});
      }, function(update2) {
        return update2.styles({ restStyles }).update({});
      }, function(exit) {
        return exit.remove();
      });
    };
    ToggleIcon2.prototype.bindEvents = function() {
      var _this2 = this;
      var onChange = this.attributes.onChange;
      this.addEventListener("click", function(e) {
        e.preventDefault();
        e.stopPropagation();
        var nextIndex = (_this2.toggles.findIndex(function(_a2) {
          var _b = __read(_a2, 1), key = _b[0];
          return key === _this2.currentType;
        }) + 1) % _this2.toggles.length;
        var nextType = _this2.toggles[nextIndex][0];
        onChange === null || onChange === void 0 ? void 0 : onChange(_this2.currentType);
        _this2.currentType = nextType;
        _this2.render();
      });
    };
    ToggleIcon2.tag = "ToggleIcon";
    return ToggleIcon2;
  }(Component)
);
var PlayPause = (
  /** @class */
  function(_super) {
    __extends(PlayPause2, _super);
    function PlayPause2(options) {
      var _this2 = _super.call(this, deepAssign2({}, { style: { type: "play" } }, options)) || this;
      _this2.toggles = [
        ["play", Play],
        ["pause", Pause]
      ];
      return _this2;
    }
    return PlayPause2;
  }(ToggleIcon)
);
var SelectionType = (
  /** @class */
  function(_super) {
    __extends(SelectionType2, _super);
    function SelectionType2(options) {
      var _this2 = _super.call(this, deepAssign2({}, { style: { type: "range" } }, options)) || this;
      _this2.toggles = [
        ["range", Range],
        ["value", Value]
      ];
      return _this2;
    }
    return SelectionType2;
  }(ToggleIcon)
);
var ChartType = (
  /** @class */
  function(_super) {
    __extends(ChartType2, _super);
    function ChartType2(options) {
      var _this2 = _super.call(this, deepAssign2({}, { style: { type: "column" } }, options)) || this;
      _this2.toggles = [
        ["line", LineChart],
        ["column", BarChart]
      ];
      return _this2;
    }
    return ChartType2;
  }(ToggleIcon)
);

// node_modules/@antv/component/esm/ui/timebar/controller.js
var componentsMap = {
  reset: Reset,
  speed: SpeedSelect,
  backward: Backward,
  playPause: PlayPause,
  forward: Forward,
  selectionType: SelectionType,
  chartType: ChartType,
  split: Split
};
var Controller = (
  /** @class */
  function(_super) {
    __extends(Controller3, _super);
    function Controller3(options) {
      var _this2 = _super.call(this, deepAssign2({}, Controller3.defaultOptions, options)) || this;
      _this2.background = _this2.appendChild(new Rect({}));
      _this2.functions = _this2.appendChild(new Group2({}));
      return _this2;
    }
    Object.defineProperty(Controller3.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(this.attributes.padding);
      },
      enumerable: false,
      configurable: true
    });
    Controller3.prototype.renderBackground = function() {
      var _a2 = this.style, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
      var backgroundStyle = subStyleProps(this.attributes, "background");
      this.background.attr(__assign({ x: x3, y: y3, width, height }, backgroundStyle));
    };
    Controller3.prototype.renderFunctions = function() {
      var _this2 = this;
      var _a2;
      var _b = this.attributes, functions = _b.functions, iconSize = _b.iconSize, iconSpacing = _b.iconSpacing, x3 = _b.x, y3 = _b.y, width = _b.width, height = _b.height, align = _b.align;
      var _c = __read(this.padding, 4), right2 = _c[1], left2 = _c[3];
      var components = functions.reduce(function(prev, curr) {
        if (prev.length && curr.length) {
          return prev.concat.apply(prev, __spreadArray(["split"], __read(curr), false));
        }
        return prev.concat.apply(prev, __spreadArray([], __read(curr), false));
      }, []);
      var componentsWidth = components.length * (iconSize + iconSpacing) - iconSpacing;
      var xOffset = {
        left: left2 + iconSize / 2,
        center: (width - componentsWidth) / 2 + iconSize / 2,
        right: width - componentsWidth - left2 - right2 + iconSize / 2
      }[align] || 0;
      (_a2 = this.speedSelect) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      this.functions.removeChildren();
      components.forEach(function(name2, index3) {
        var _a3;
        var Ctor = componentsMap[name2];
        var style = {
          x: x3 + index3 * (iconSize + iconSpacing) + xOffset,
          y: y3 + height / 2,
          size: iconSize
        };
        if (Ctor === SpeedSelect) {
          style.speed = _this2.attributes.speed;
          style.onSelect = function(value2) {
            return _this2.handleFunctionChange(name2, { value: value2 });
          };
        } else if ([PlayPause, SelectionType, ChartType].includes(Ctor)) {
          style.onChange = function(value2) {
            return _this2.handleFunctionChange(name2, { value: value2 });
          };
          if (Ctor === PlayPause)
            style.type = _this2.attributes.state === "play" ? "pause" : "play";
          if (Ctor === SelectionType)
            style.type = _this2.attributes.selectionType === "range" ? "value" : "range";
          if (Ctor === ChartType)
            style.type = _this2.attributes.chartType === "line" ? "column" : "line";
        } else {
          style.onClick = function() {
            return _this2.handleFunctionChange(name2, { value: name2 });
          };
        }
        if (Ctor === SpeedSelect) {
          var canvas = (_a3 = _this2.ownerDocument) === null || _a3 === void 0 ? void 0 : _a3.defaultView;
          if (canvas) {
            _this2.speedSelect = new Ctor({ style: __assign(__assign({}, style), { zIndex: 100 }) });
            canvas.appendChild(_this2.speedSelect);
          }
        } else {
          _this2.functions.appendChild(new Ctor({ style }));
        }
      });
    };
    Controller3.prototype.disconnectedCallback = function() {
      var _a2;
      _super.prototype.disconnectedCallback.call(this);
      (_a2 = this.speedSelect) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    };
    Controller3.prototype.render = function() {
      this.renderBackground();
      this.renderFunctions();
    };
    Controller3.prototype.handleFunctionChange = function(name2, value2) {
      var onChange = this.attributes.onChange;
      onChange === null || onChange === void 0 ? void 0 : onChange(name2, value2);
    };
    Controller3.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        width: 300,
        height: 40,
        padding: 0,
        align: "center",
        iconSize: 25,
        iconSpacing: 0,
        speed: 1,
        state: "pause",
        chartType: "line",
        selectionType: "range",
        backgroundFill: "#fbfdff",
        backgroundStroke: "#ebedf0",
        functions: [
          ["reset", "speed"],
          ["backward", "playPause", "forward"],
          ["selectionType", "chartType"]
        ]
      }
    };
    return Controller3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/timebar/handle.js
var TimeModeHandle = (
  /** @class */
  function(_super) {
    __extends(TimeModeHandle2, _super);
    function TimeModeHandle2(options) {
      var _this2 = _super.call(this, deepAssign2({}, TimeModeHandle2.defaultOptions, options)) || this;
      _this2.bindEvents();
      return _this2;
    }
    TimeModeHandle2.prototype.bindEvents = function() {
      var _this2 = this;
      this.addEventListener("mouseenter", function() {
        _this2.attr("lineWidth", Math.ceil(+(_this2.style.r || 0) / 2));
      });
      this.addEventListener("mouseleave", function() {
        _this2.attr("lineWidth", 0);
      });
    };
    TimeModeHandle2.defaultOptions = {
      style: {
        r: 5,
        fill: "#3f7cf7",
        lineWidth: 0,
        stroke: "#3f7cf7",
        strokeOpacity: 0.5,
        cursor: "pointer"
      }
    };
    return TimeModeHandle2;
  }(Circle)
);
var ChartModeHandle = (
  /** @class */
  function(_super) {
    __extends(ChartModeHandle2, _super);
    function ChartModeHandle2(options) {
      return _super.call(this, deepAssign2({}, ChartModeHandle2.defaultOptions, options)) || this;
    }
    ChartModeHandle2.prototype.renderBackground = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
      var style = subStyleProps(this.attributes, "background");
      select2(this).maybeAppend("background", "rect").attr("className", "background").styles(__assign({ x: x3 - width / 2, y: y3 - height / 2, width, height }, style));
    };
    ChartModeHandle2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, iconSize = _a2.iconSize;
      var style = subStyleProps(this.attributes, "icon");
      var diffX = 1;
      var diffY = iconSize / 2;
      select2(this).maybeAppend("icon-left-line", "line").attr("className", "icon-left-line").styles(__assign({ x1: x3 - diffX, y1: y3 - diffY, x2: x3 - diffX, y2: y3 + diffY }, style));
      select2(this).maybeAppend("icon-right-line", "line").attr("className", "icon-right-line").styles(__assign({ x1: x3 + diffX, y1: y3 - diffY, x2: x3 + diffX, y2: y3 + diffY }, style));
    };
    ChartModeHandle2.prototype.renderBorder = function() {
      var _a2 = this.attributes, xx = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height, type = _a2.type;
      var style = subStyleProps(this.attributes, "border");
      var x3 = type === "start" ? +width / 2 : -width / 2;
      select2(this).maybeAppend("border", "line").attr("className", "border").styles(__assign({ x1: x3 + xx, y1: y3 - height / 2, x2: x3 + xx, y2: y3 + height / 2 }, style));
    };
    ChartModeHandle2.prototype.render = function() {
      this.renderBackground();
      this.renderIcon();
      this.renderBorder();
    };
    ChartModeHandle2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        width: 10,
        height: 50,
        iconSize: 10,
        type: "start",
        backgroundFill: "#fff",
        backgroundFillOpacity: 0.5,
        iconStroke: "#9a9a9a",
        iconLineWidth: 1,
        borderStroke: "#e8e8e8",
        borderLineWidth: 1
      }
    };
    return ChartModeHandle2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/timebar/utils.js
function labelFormatter(time, interval2) {
  if (typeof time === "number") {
    return parseBySeries(time);
  }
  return parseByTime(time, interval2);
}
function parseByTime(time, interval2) {
  var date = new Date(time);
  switch (interval2) {
    case "half-hour":
    case "hour":
    case "four-hour":
      if ([0, 6, 12, 18].includes(date.getHours()) && date.getMinutes() === 0) {
        return formatTime(date, "HH:mm\nYYYY-MM-DD");
      }
      return formatTime(date, "HH:mm");
    case "half-day":
      if (date.getHours() < 12) {
        return "AM\n".concat(formatTime(date, "YYYY-MM-DD"));
      }
      return "PM";
    case "day":
      if ([1, 10, 20].includes(date.getDate())) {
        return formatTime(date, "DD\nYYYY-MM");
      }
      return formatTime(date, "DD");
    case "week":
      if (date.getDate() <= 7) {
        return formatTime(date, "DD\nYYYY-MM");
      }
      return formatTime(date, "DD");
    case "month":
      if ([0, 6].includes(date.getMonth())) {
        return formatTime(date, "MM月\nYYYY");
      }
      return formatTime(date, "MM月");
    case "season":
      if ([0].includes(date.getMonth())) {
        return formatTime(date, "MM月\nYYYY");
      }
      return formatTime(date, "MM月");
    case "year":
      return formatTime(date, "YYYY");
    default:
      return formatTime(date, "YYYY-MM-DD HH:mm");
  }
}
function parseBySeries(time) {
  var hours = String(Math.floor(time / 3600)).padStart(2, "0");
  var minutes = String(Math.floor(time % 3600 / 60)).padStart(2, "0");
  var seconds = String(Math.floor(time % 60)).padStart(2, "0");
  if (time < 3600) {
    return "".concat(minutes, ":").concat(seconds);
  }
  return "".concat(hours, ":").concat(minutes, ":").concat(seconds);
}

// node_modules/@antv/component/esm/ui/timebar/timebar.js
var Timebar = (
  /** @class */
  function(_super) {
    __extends(Timebar2, _super);
    function Timebar2(options) {
      var _this2 = _super.call(this, deepAssign2({}, Timebar2.defaultOptions, options)) || this;
      _this2.axis = _this2.appendChild(new Axis({
        style: { type: "linear", startPos: [0, 0], endPos: [0, 0], data: [], showArrow: false, animate: false }
      }));
      _this2.timeline = _this2.appendChild(new Slider({
        style: {
          onChange: function(values5) {
            _this2.handleSliderChange(values5);
          }
        }
      }));
      _this2.controller = _this2.appendChild(new Controller({}));
      _this2.states = {};
      _this2.handleSliderChange = function(values5) {
        var prevValues = function() {
          var val = _this2.states.values;
          if (Array.isArray(val))
            return __spreadArray([], __read(val), false);
          return val;
        }();
        _this2.setBySliderValues(values5);
        _this2.dispatchOnChange(prevValues);
      };
      var _a2 = _this2.attributes, selectionType = _a2.selectionType, chartType = _a2.chartType, speed = _a2.speed, state = _a2.state, playMode = _a2.playMode, values4 = _a2.values;
      _this2.states = { chartType, playMode, selectionType, speed, state };
      _this2.setByTimebarValues(values4);
      return _this2;
    }
    Object.defineProperty(Timebar2.prototype, "data", {
      get: function() {
        var data2 = this.attributes.data;
        var compareFn = function(a4, b) {
          if (a4.time < b.time)
            return -1;
          if (a4.time > b.time)
            return 1;
          return 0;
        };
        return data2.sort(compareFn);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Timebar2.prototype, "space", {
      /** 计算空间分配 */
      get: function() {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height, type = _a2.type, controllerHeight = _a2.controllerHeight;
        var availableTimelineHeight = clamp_default(+height - controllerHeight, 0, +height);
        var controllerBBox = new BBox(x3, y3 + +height - controllerHeight, +width, controllerHeight);
        var axisBBox;
        var axisHeight = 0;
        if (type === "chart") {
          axisHeight = 35;
          axisBBox = new BBox(x3, y3 + availableTimelineHeight - axisHeight, +width, axisHeight);
        } else
          axisBBox = new BBox();
        var timelineHeight = type === "time" ? 10 : availableTimelineHeight;
        var timelineBBox = new BBox(x3, y3 + (type === "time" ? availableTimelineHeight : availableTimelineHeight - timelineHeight), +width, timelineHeight - axisHeight);
        return { axisBBox, controllerBBox, timelineBBox };
      },
      enumerable: false,
      configurable: true
    });
    Timebar2.prototype.setBySliderValues = function(val) {
      var _a2, _b;
      var data2 = this.data;
      var _c = __read(Array.isArray(val) ? val : [0, val], 2), startRatio = _c[0], endRatio = _c[1];
      var length5 = data2.length;
      var startDatum = data2[Math.floor(startRatio * length5)];
      var endDatum = data2[Math.ceil(endRatio * length5) - (Array.isArray(val) ? 0 : 1)];
      this.states.values = [(_a2 = startDatum === null || startDatum === void 0 ? void 0 : startDatum.time) !== null && _a2 !== void 0 ? _a2 : data2[0].time, (_b = endDatum === null || endDatum === void 0 ? void 0 : endDatum.time) !== null && _b !== void 0 ? _b : Infinity];
    };
    Timebar2.prototype.setByTimebarValues = function(val) {
      var _a2, _b, _c;
      var data2 = this.data;
      var _d = __read(Array.isArray(val) ? val : [void 0, val], 2), start = _d[0], end = _d[1];
      var startDatum = data2.find(function(_a3) {
        var time = _a3.time;
        return time === start;
      });
      var endDatum = data2.find(function(_a3) {
        var time = _a3.time;
        return time === end;
      });
      this.states.values = [(_a2 = startDatum === null || startDatum === void 0 ? void 0 : startDatum.time) !== null && _a2 !== void 0 ? _a2 : (_b = data2[0]) === null || _b === void 0 ? void 0 : _b.time, (_c = endDatum === null || endDatum === void 0 ? void 0 : endDatum.time) !== null && _c !== void 0 ? _c : Infinity];
    };
    Timebar2.prototype.setByIndex = function(index3) {
      var _a2, _b, _c, _d;
      var data2 = this.data;
      var _e = __read(index3, 2), startIndex = _e[0], endIndex = _e[1];
      this.states.values = [(_b = (_a2 = data2[startIndex]) === null || _a2 === void 0 ? void 0 : _a2.time) !== null && _b !== void 0 ? _b : data2[0].time, (_d = (_c = this.data[endIndex]) === null || _c === void 0 ? void 0 : _c.time) !== null && _d !== void 0 ? _d : Infinity];
    };
    Object.defineProperty(Timebar2.prototype, "sliderValues", {
      /**
       * 获取 timebar 的 values
       */
      get: function() {
        var _a2 = this.states, values4 = _a2.values, selectionType = _a2.selectionType;
        var _b = __read(Array.isArray(values4) ? values4 : [void 0, values4], 2), start = _b[0], end = _b[1];
        var data2 = this.data;
        var length5 = data2.length;
        var isValue = selectionType === "value";
        var getStartValue = function() {
          var startDatumIndex = data2.findIndex(function(_a3) {
            var time = _a3.time;
            return time === start;
          });
          if (isValue)
            return 0;
          if (startDatumIndex > -1)
            return startDatumIndex / length5;
          return 0;
        };
        var getEndValue = function() {
          if (end === Infinity)
            return 1;
          var endDatumIndex = data2.findIndex(function(_a3) {
            var time = _a3.time;
            return time === end;
          });
          if (endDatumIndex > -1)
            return endDatumIndex / length5;
          if (isValue)
            return 0.5;
          return 1;
        };
        return [getStartValue(), getEndValue()];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Timebar2.prototype, "values", {
      get: function() {
        var _a2 = this.states, values4 = _a2.values, selectionType = _a2.selectionType;
        var _b = __read(Array.isArray(values4) ? values4 : [this.data[0].time, values4], 2), start = _b[0], end = _b[1];
        if (selectionType === "value")
          return end;
        return [start, end];
      },
      enumerable: false,
      configurable: true
    });
    Timebar2.prototype.getDatumByRatio = function(ratio) {
      var data2 = this.data;
      var length5 = data2.length;
      var index3 = Math.floor(ratio * (length5 - 1));
      return data2[index3];
    };
    Object.defineProperty(Timebar2.prototype, "chartHandleIconShape", {
      get: function() {
        var selectionType = this.states.selectionType;
        var height = this.space.timelineBBox.height;
        if (selectionType === "range")
          return function(type) {
            return new ChartModeHandle({ style: { type, height, iconSize: height / 6 } });
          };
        return function() {
          return new Line({ style: { x1: 0, y1: -height / 2, x2: 0, y2: height / 2, lineWidth: 2, stroke: "#c8c8c8" } });
        };
      },
      enumerable: false,
      configurable: true
    });
    Timebar2.prototype.getChartStyle = function(bbox) {
      var _this2 = this;
      var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
      var _a2 = this.states, selectionType = _a2.selectionType, chartType = _a2.chartType;
      var data2 = this.data;
      var _b = this.attributes, type = _b.type, userDefinedLabelFormatter = _b.labelFormatter;
      var _c = subStyleProps(this.attributes, "chart"), ignoreType = _c.type, userDefinedChartStyle = __rest(_c, ["type"]);
      var isRange = selectionType === "range";
      if (type === "time") {
        return __assign({
          handleIconShape: function() {
            return new TimeModeHandle({});
          },
          selectionFill: "#2e7ff8",
          selectionFillOpacity: 1,
          showLabelOnInteraction: true,
          handleLabelDy: isRange ? -15 : 0,
          autoFitLabel: isRange,
          handleSpacing: isRange ? -15 : 0,
          trackFill: "#edeeef",
          trackLength: width,
          trackOpacity: 0.5,
          trackRadius: height / 2,
          trackSize: height / 2,
          type: selectionType,
          values: this.sliderValues,
          formatter: function(value2) {
            if (userDefinedLabelFormatter)
              return userDefinedLabelFormatter(value2);
            var time = _this2.getDatumByRatio(value2).time;
            if (typeof time === "number")
              return parseBySeries(time);
            return formatTime(time, "YYYY-MM-DD HH:mm:ss");
          },
          transform: "translate(".concat(x3, ", ").concat(y3, ")"),
          // x,
          // y,
          zIndex: 1
        }, userDefinedChartStyle);
      }
      var handleIconOffset = selectionType === "range" ? 5 : 0;
      var sparklineData = data2.map(function(_a3) {
        var value2 = _a3.value;
        return value2;
      });
      return __assign({
        handleIconOffset,
        handleIconShape: this.chartHandleIconShape,
        selectionFill: "#fff",
        selectionFillOpacity: 0.5,
        selectionType: "invert",
        sparklineSpacing: 0.1,
        sparklineColumnLineWidth: 0,
        sparklineColor: "#d4e5fd",
        sparklineAreaOpacity: 1,
        sparklineAreaLineWidth: 0,
        sparklineData,
        sparklineType: chartType,
        sparklineScale: 0.8,
        trackLength: width,
        trackSize: height,
        type: selectionType,
        values: this.sliderValues,
        // x,
        // y,
        transform: "translate(".concat(x3, ", ").concat(y3, ")"),
        zIndex: 1
      }, userDefinedChartStyle);
    };
    Timebar2.prototype.renderChart = function(bbox) {
      if (bbox === void 0) {
        bbox = this.space.timelineBBox;
      }
      this.timeline.update(this.getChartStyle(bbox));
    };
    Timebar2.prototype.updateSelection = function() {
      this.timeline.setValues(this.sliderValues, true);
      this.handleSliderChange(this.sliderValues);
    };
    Timebar2.prototype.getAxisStyle = function(bbox) {
      var data2 = this.data;
      var _a2 = this.attributes, interval2 = _a2.interval, userDefinedLabelFormatter = _a2.labelFormatter;
      var userDefinedAxisStyle = subStyleProps(this.attributes, "axis");
      var x3 = bbox.x, y3 = bbox.y, width = bbox.width;
      var axisData = __spreadArray(__spreadArray([], __read(data2), false), [{ time: 0 }], false).map(function(_a3, index3, arr) {
        var time = _a3.time;
        return {
          label: "".concat(time),
          value: index3 / (arr.length - 1),
          time
        };
      });
      var style = __assign({
        startPos: [x3, y3],
        endPos: [x3 + width, y3],
        data: axisData,
        // hide last label
        labelFilter: function(_datum, index3) {
          return index3 < axisData.length - 1;
        },
        labelFormatter: function(_a3) {
          var time = _a3.time;
          return userDefinedLabelFormatter ? userDefinedLabelFormatter(time) : labelFormatter(time, interval2);
        }
      }, userDefinedAxisStyle);
      return style;
    };
    Timebar2.prototype.renderAxis = function(bbox) {
      if (bbox === void 0) {
        bbox = this.space.axisBBox;
      }
      var type = this.attributes.type;
      if (type !== "chart")
        return;
      this.axis.update(this.getAxisStyle(bbox));
    };
    Timebar2.prototype.renderController = function(bbox) {
      if (bbox === void 0) {
        bbox = this.space.controllerBBox;
      }
      var type = this.attributes.type;
      var _a2 = this.states, state = _a2.state, speed = _a2.speed, selectionType = _a2.selectionType, chartType = _a2.chartType;
      var userDefinedControllerStyle = subStyleProps(this.attributes, "controller");
      var that = this;
      var style = __assign(__assign(__assign({}, bbox), { iconSize: 20, speed, state, selectionType, chartType, onChange: function(type2, _a3) {
        var value2 = _a3.value;
        switch (type2) {
          case "reset":
            that.internalReset();
            break;
          case "speed":
            that.handleSpeedChange(value2);
            break;
          case "backward":
            that.internalBackward();
            break;
          case "playPause":
            if (value2 === "play")
              that.internalPlay();
            else
              that.internalPause();
            break;
          case "forward":
            that.internalForward();
            break;
          case "selectionType":
            that.handleSelectionTypeChange(value2);
            break;
          case "chartType":
            that.handleChartTypeChange(value2);
            break;
          default:
            break;
        }
      } }), userDefinedControllerStyle);
      if (type === "time") {
        style.functions = [["reset", "speed"], ["backward", "playPause", "forward"], ["selectionType"]];
      }
      this.controller.update(style);
    };
    Timebar2.prototype.dispatchOnChange = function(prevValues) {
      var data2 = this.data;
      var onChange = this.attributes.onChange;
      var _a2 = this.states, values4 = _a2.values, selectionType = _a2.selectionType;
      var _b = __read(values4, 2), start = _b[0], end = _b[1];
      var endTime = end === Infinity ? data2.at(-1).time : end;
      var newValues = selectionType === "range" ? [start, endTime] : endTime;
      var isEqual3 = function(val1, val2) {
        if (Array.isArray(val1)) {
          if (!Array.isArray(val2))
            return false;
          if (val1[0] === val2[0]) {
            if (val1[1] === val2[1])
              return true;
            if (val1[1] === Infinity || val2[1] === Infinity)
              return true;
          }
          return false;
        }
        if (Array.isArray(val2))
          return false;
        return val1 === val2;
      };
      if (!prevValues || !isEqual3(prevValues, newValues)) {
        onChange === null || onChange === void 0 ? void 0 : onChange(selectionType === "range" ? [start, endTime] : endTime);
      }
    };
    Timebar2.prototype.internalReset = function(preventEvent) {
      var _a2, _b;
      var selectionType = this.states.selectionType;
      this.internalPause();
      this.setBySliderValues(selectionType === "range" ? [0, 1] : [0, 0]);
      this.renderController();
      this.updateSelection();
      if (!preventEvent) {
        (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onReset) === null || _b === void 0 ? void 0 : _b.call(_a2);
        this.dispatchOnChange();
      }
    };
    Timebar2.prototype.reset = function() {
      this.internalReset();
    };
    Timebar2.prototype.moveSelection = function(direction3, preventEvent) {
      var data2 = this.data;
      var length5 = data2.length;
      var _a2 = this.states, values4 = _a2.values, selectionType = _a2.selectionType, playMode = _a2.playMode;
      var _b = __read(values4, 2), startTime = _b[0], endTime = _b[1];
      var startIndex = data2.findIndex(function(_a3) {
        var time = _a3.time;
        return time === startTime;
      });
      var endIndex = data2.findIndex(function(_a3) {
        var time = _a3.time;
        return time === endTime;
      });
      if (endIndex === -1)
        endIndex = length5;
      var diff = direction3 === "backward" ? -1 : 1;
      var currentIndexes;
      if (selectionType === "range") {
        if (playMode === "acc") {
          currentIndexes = [startIndex, endIndex + diff];
          if (diff === -1 && startIndex === endIndex) {
            currentIndexes = [startIndex, length5];
          }
        } else
          currentIndexes = [startIndex + diff, endIndex + diff];
      } else
        currentIndexes = [startIndex, endIndex + diff];
      var normalizeIndexes = function(indexes2) {
        var _a3 = __read(indexes2.sort(function(a4, b) {
          return a4 - b;
        }), 2), start = _a3[0], end = _a3[1];
        var clampIndex = function(index3) {
          return clamp_default(index3, 0, length5);
        };
        if (end > length5) {
          if (selectionType === "value")
            return [0, 0];
          if (playMode === "acc")
            return [clampIndex(start), clampIndex(start)];
          return [0, clampIndex(end - start)];
        }
        if (start < 0) {
          if (playMode === "acc")
            return [0, clampIndex(end)];
          return [clampIndex(start + length5 - end), length5];
        }
        return [clampIndex(start), clampIndex(end)];
      };
      var normalizedIndexes = normalizeIndexes(currentIndexes);
      this.setByIndex(normalizedIndexes);
      this.updateSelection();
      return normalizedIndexes;
    };
    Timebar2.prototype.internalBackward = function(preventEvent) {
      var _a2, _b;
      var indexes2 = this.moveSelection("backward", preventEvent);
      if (!preventEvent) {
        (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onBackward) === null || _b === void 0 ? void 0 : _b.call(_a2);
        this.dispatchOnChange();
      }
      return indexes2;
    };
    Timebar2.prototype.backward = function() {
      this.internalBackward();
    };
    Timebar2.prototype.internalPlay = function(preventEvent) {
      var _this2 = this;
      var _a2, _b;
      var data2 = this.data;
      var loop = this.attributes.loop;
      var _c = this.states.speed, speed = _c === void 0 ? 1 : _c;
      this.playInterval = window.setInterval(function() {
        var indexes2 = _this2.internalForward();
        if (indexes2[1] === data2.length && !loop) {
          _this2.internalPause();
          _this2.renderController();
        }
      }, 1e3 / speed);
      this.states.state = "play";
      !preventEvent && ((_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onPlay) === null || _b === void 0 ? void 0 : _b.call(_a2));
    };
    Timebar2.prototype.play = function() {
      this.internalPlay();
    };
    Timebar2.prototype.internalPause = function(preventEvent) {
      var _a2, _b;
      clearInterval(this.playInterval);
      this.states.state = "pause";
      !preventEvent && ((_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onPause) === null || _b === void 0 ? void 0 : _b.call(_a2));
    };
    Timebar2.prototype.pause = function() {
      this.internalPause();
    };
    Timebar2.prototype.internalForward = function(preventEvent) {
      var _a2, _b;
      var indexes2 = this.moveSelection("forward", preventEvent);
      if (!preventEvent) {
        (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onForward) === null || _b === void 0 ? void 0 : _b.call(_a2);
        this.dispatchOnChange();
      }
      return indexes2;
    };
    Timebar2.prototype.forward = function() {
      this.internalForward();
    };
    Timebar2.prototype.handleSpeedChange = function(value2) {
      var _a2, _b;
      this.states.speed = value2;
      var state = this.states.state;
      if (state === "play") {
        this.internalPause(true);
        this.internalPlay(true);
      }
      (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onSpeedChange) === null || _b === void 0 ? void 0 : _b.call(_a2, value2);
    };
    Timebar2.prototype.handleSelectionTypeChange = function(type) {
      var _a2, _b;
      this.states.selectionType = type;
      this.renderChart();
      (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onSelectionTypeChange) === null || _b === void 0 ? void 0 : _b.call(_a2, type);
    };
    Timebar2.prototype.handleChartTypeChange = function(type) {
      var _a2, _b;
      this.states.chartType = type;
      this.renderChart();
      (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onChartTypeChange) === null || _b === void 0 ? void 0 : _b.call(_a2, type);
    };
    Timebar2.prototype.render = function() {
      var _a2 = this.space, axisBBox = _a2.axisBBox, controllerBBox = _a2.controllerBBox, timelineBBox = _a2.timelineBBox;
      this.renderController(controllerBBox);
      this.renderAxis(axisBBox);
      this.renderChart(timelineBBox);
      if (this.states.state === "play")
        this.internalPlay();
    };
    Timebar2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.internalPause(true);
    };
    Timebar2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        axisLabelFill: "#6e6e6e",
        axisLabelTextAlign: "left",
        axisLabelTextBaseline: "top",
        axisLabelTransform: "translate(5, -12)",
        axisLineLineWidth: 1,
        axisLineStroke: "#cacdd1",
        axisTickLength: 15,
        axisTickLineWidth: 1,
        axisTickStroke: "#cacdd1",
        chartShowLabel: false,
        chartType: "line",
        controllerAlign: "center",
        controllerHeight: 40,
        data: [],
        interval: "day",
        loop: false,
        playMode: "acc",
        selectionType: "range",
        type: "time"
      }
    };
    return Timebar2;
  }(Component)
);

// node_modules/@antv/g2/esm/shape/text/advance.js
var __rest22 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function getConnectorPoint(shape23) {
  const { min: [x05, y05], max: [x12, y12] } = shape23.getLocalBounds();
  let x3 = 0;
  let y3 = 0;
  if (x05 > 0)
    x3 = x05;
  if (x12 < 0)
    x3 = x12;
  if (y05 > 0)
    y3 = y05;
  if (y12 < 0)
    y3 = y12;
  return [x3, y3];
}
function inferBackgroundBounds(textShape, padding = []) {
  const [top = 0, right2 = 0, bottom = top, left2 = right2] = padding;
  const container = textShape.parentNode;
  const angle4 = container.getEulerAngles();
  container.setEulerAngles(0);
  const { min: min10, halfExtents } = textShape.getLocalBounds();
  const [x3, y3] = min10;
  const [hw, hh] = halfExtents;
  container.setEulerAngles(angle4);
  return {
    x: x3 - left2,
    y: y3 - top,
    width: hw * 2 + left2 + right2,
    height: hh * 2 + top + bottom
  };
}
function inferConnectorPath(shape23, end, control, coordCenter, left2 = true, top = true) {
  const path2 = (points) => line_default()(points);
  if (!end[0] && !end[1])
    return path2([getConnectorPoint(shape23), end]);
  if (!control.length)
    return path2([[0, 0], end]);
  const [inflection, start] = control;
  const p1 = [...start];
  const p2 = [...inflection];
  if (start[0] !== inflection[0]) {
    const offset2 = left2 ? -4 : 4;
    p1[1] = start[1];
    if (top && !left2) {
      p1[0] = Math.max(inflection[0], start[0] - offset2);
      if (start[1] < inflection[1]) {
        p2[1] = p1[1];
      } else {
        p2[1] = inflection[1];
        p2[0] = Math.max(p2[0], p1[0] - offset2);
      }
    }
    if (!top && !left2) {
      p1[0] = Math.max(inflection[0], start[0] - offset2);
      if (start[1] > inflection[1]) {
        p2[1] = p1[1];
      } else {
        p2[1] = inflection[1];
        p2[0] = Math.max(p2[0], p1[0] - offset2);
      }
    }
    if (!top && left2) {
      p1[0] = Math.min(inflection[0], start[0] - offset2);
      if (start[1] > inflection[1]) {
        p2[1] = p1[1];
      } else {
        p2[1] = inflection[1];
        p2[0] = Math.min(p2[0], p1[0] - offset2);
      }
    }
    if (top && left2) {
      p1[0] = Math.min(inflection[0], start[0] - offset2);
      if (start[1] < inflection[1]) {
        p2[1] = p1[1];
      } else {
        p2[1] = inflection[1];
        p2[0] = Math.min(p2[0], p1[0] - offset2);
      }
    }
  }
  return path2([start, p1, p2, inflection, end]);
}
var Advance = createElement((g) => {
  const _a2 = g.attributes, {
    className: className2,
    // Do not pass className
    class: _c,
    transform: transform2,
    rotate: rotate7,
    labelTransform,
    labelTransformOrigin,
    x: x3,
    y: y3,
    x0: x05 = x3,
    y0: y05 = y3,
    text,
    background,
    connector,
    startMarker,
    endMarker,
    coordCenter,
    innerHTML
  } = _a2, rest = __rest22(_a2, ["className", "class", "transform", "rotate", "labelTransform", "labelTransformOrigin", "x", "y", "x0", "y0", "text", "background", "connector", "startMarker", "endMarker", "coordCenter", "innerHTML"]);
  g.style.transform = `translate(${x3}, ${y3})`;
  if ([x3, y3, x05, y05].some((v) => !isNumber(v))) {
    g.children.forEach((d3) => d3.remove());
    return;
  }
  const _b = subObject(rest, "background"), { padding } = _b, backgroundStyle = __rest22(_b, ["padding"]);
  const _d = subObject(rest, "connector"), { points: controlPoints2 = [] } = _d, connectorStyle = __rest22(_d, ["points"]);
  let textShape;
  if (innerHTML) {
    textShape = select(g).maybeAppend("html", "html", className2).style("zIndex", 0).style("innerHTML", innerHTML).call(applyStyle, Object.assign({ transform: labelTransform, transformOrigin: labelTransformOrigin }, rest)).node();
  } else {
    textShape = select(g).maybeAppend("text", "text").style("zIndex", 0).style("text", text).call(applyStyle, Object.assign({ textBaseline: "middle", transform: labelTransform, transformOrigin: labelTransformOrigin }, rest)).node();
  }
  const rect4 = select(g).maybeAppend("background", "rect").style("zIndex", -1).call(applyStyle, inferBackgroundBounds(textShape, padding)).call(applyStyle, background ? backgroundStyle : {}).node();
  const left2 = +x05 < coordCenter[0];
  const top = +y05 < coordCenter[1];
  const end = [+x05 - +x3, +y05 - +y3];
  const connectorPath = inferConnectorPath(rect4, end, controlPoints2, coordCenter, left2, top);
  const markerStart = startMarker && new Marker({
    id: "startMarker",
    style: Object.assign({ x: 0, y: 0 }, subObject(rest, "startMarker"))
  });
  const markerEnd = endMarker && new Marker({
    id: "endMarker",
    style: Object.assign({ x: 0, y: 0 }, subObject(rest, "endMarker"))
  });
  select(g).maybeAppend("connector", "path").style("zIndex", 0).style("d", connectorPath).style("markerStart", markerStart).style("markerEnd", markerEnd).call(applyStyle, connector ? connectorStyle : {});
});

// node_modules/@antv/g2/esm/shape/text/text.js
var Text3 = (options, context) => {
  const { coordinate } = context;
  return (points, value2, defaults4) => {
    const { color: color3, text = "", fontSize, rotate: rotate7 = 0, transform: transform2 = "" } = value2;
    const textStyle = {
      text: String(text),
      stroke: color3,
      fill: color3,
      fontSize
    };
    const [[x05, y05]] = points;
    return select(new Advance()).style("x", x05).style("y", y05).call(applyStyle, defaults4).style("transform", `${transform2}rotate(${+rotate7})`).style("coordCenter", coordinate.getCenter()).call(applyStyle, textStyle).call(applyStyle, options).node();
  };
};
Text3.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/text/badge.js
var __rest23 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function getPath(r) {
  const offset2 = r / Math.sqrt(2);
  const dy = r * Math.sqrt(2);
  const [p0x, p0y] = [-offset2, offset2 - dy];
  const [p1x, p1y] = [0, 0];
  const [p2x, p2y] = [offset2, offset2 - dy];
  return [
    ["M", p0x, p0y],
    ["A", r, r, 0, 1, 1, p2x, p2y],
    ["L", p1x, p1y],
    ["Z"]
  ];
}
function inferTextPosition(shape23) {
  const { min: min10, max: max11 } = shape23.getLocalBounds();
  return [(min10[0] + max11[0]) * 0.5, (min10[1] + max11[1]) * 0.5];
}
var BadgeShape = createElement((g) => {
  const _a2 = g.attributes, { class: className2, x: x05, y: y05, transform: transform2 } = _a2, rest = __rest23(_a2, ["class", "x", "y", "transform"]);
  const markerStyle = subObject(rest, "marker");
  const { size: size3 = 24 } = markerStyle;
  const symbol = () => getPath(size3 / 2);
  const bgShape = select(g).maybeAppend("marker", () => new Marker({})).call((selection) => selection.node().update(Object.assign({ symbol }, markerStyle))).node();
  const [x3, y3] = inferTextPosition(bgShape);
  select(g).maybeAppend("text", "text").style("x", x3).style("y", y3).call(applyStyle, rest);
});
var Badge = (options, context) => {
  const style = __rest23(options, []);
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest23(defaults4, ["color"]);
    const { color: color3 = defaultColor, text = "" } = value2;
    const textStyle = {
      text: String(text),
      stroke: color3,
      fill: color3
    };
    const [[x05, y05]] = points;
    return select(new BadgeShape()).call(applyStyle, rest).style("transform", `translate(${x05},${y05})`).call(applyStyle, textStyle).call(applyStyle, style).node();
  };
};
Badge.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/text/tag.js
var Tag2 = (options, context) => {
  const { coordinate } = context;
  return (points, value2, defaults4) => {
    const { color: color3, text = "", fontSize, rotate: rotate7 = 0, transform: transform2 = "" } = value2;
    const textStyle = {
      text: String(text),
      stroke: color3,
      fill: color3,
      fontSize,
      textAlign: "center",
      textBaseline: "middle"
    };
    const [[x05, y05]] = points;
    const n = select(new Text()).style("x", x05).style("y", y05).call(applyStyle, defaults4).style("transformOrigin", "center center").style("transform", `${transform2}rotate(${rotate7}deg)`).style("coordCenter", coordinate.getCenter()).call(applyStyle, textStyle).call(applyStyle, options).node();
    return n;
  };
};
Tag2.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/area/curve.js
var __rest24 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function segmentation2(points, defined4) {
  const definedPointsY1 = [];
  const definedPointsY0 = [];
  const segments = [];
  let m3 = false;
  let dp = null;
  const mid2 = points.length / 2;
  for (let i = 0; i < mid2; i++) {
    const y12 = points[i];
    const y05 = points[i + mid2];
    if ([...y12, ...y05].some((v) => !defined4(v)))
      m3 = true;
    else {
      definedPointsY1.push(y12);
      definedPointsY0.push(y05);
      if (m3 && dp) {
        m3 = false;
        const [dpy1, dpy0] = dp;
        segments.push([dpy1, y12, dpy0, y05]);
      }
      dp = [y12, y05];
    }
  }
  return [definedPointsY1.concat(definedPointsY0), segments];
}
var DoubleArea = createElement((g) => {
  const { areaPath, connectPath, areaStyle, connectStyle } = g.attributes;
  const document2 = g.ownerDocument;
  select(g).maybeAppend("connect-path", () => document2.createElement("path", {})).style("d", connectPath).call(applyStyle, connectStyle);
  select(g).maybeAppend("area-path", () => document2.createElement("path", {})).style("d", areaPath).call(applyStyle, areaStyle);
});
var Curve2 = (options, context) => {
  const { curve, gradient: gradient2 = false, defined: defined4 = (d3) => !Number.isNaN(d3) && d3 !== void 0 && d3 !== null, connect: connectNulls = false } = options, style = __rest24(options, ["curve", "gradient", "defined", "connect"]);
  const { coordinate, document: document2 } = context;
  return (P, value2, defaults4) => {
    const { color: defaultColor } = defaults4;
    const { color: color3 = defaultColor, seriesColor: sc, seriesX: sx, seriesY: sy } = value2;
    const tpShape = isTranspose(coordinate);
    const transform2 = getTransform(coordinate, value2);
    const fill = gradient2 && sc ? computeGradient(sc, sx, sy, gradient2, void 0, tpShape) : color3;
    const finalStyle = Object.assign(Object.assign(Object.assign(Object.assign({}, defaults4), { stroke: fill, fill }), transform2 && { transform: transform2 }), style);
    const [DP, MS] = segmentation2(P, defined4);
    const connectStyle = subObject(finalStyle, "connect");
    const missing = !!MS.length;
    const getPathNode = (path2) => {
      return select(document2.createElement("path", {})).style("d", path2 || "").call(applyStyle, finalStyle).node();
    };
    if (!isPolar(coordinate)) {
      const areaPath = (points) => {
        const Y12 = points.slice(0, points.length / 2);
        const Y02 = points.slice(points.length / 2);
        return tpShape ? area_default().y((_2, idx) => Y12[idx][1]).x1((_2, idx) => Y12[idx][0]).x0((_2, idx) => Y02[idx][0]).defined((_2, idx) => [...Y12[idx], ...Y02[idx]].every(defined4)).curve(curve)(Y12) : area_default().x((_2, idx) => Y12[idx][0]).y1((_2, idx) => Y12[idx][1]).y0((_2, idx) => Y02[idx][1]).defined((_2, idx) => [...Y12[idx], ...Y02[idx]].every(defined4)).curve(curve)(Y12);
      };
      if (!missing || connectNulls && !Object.keys(connectStyle).length) {
        return getPathNode(areaPath(DP));
      }
      if (missing && !connectNulls) {
        return getPathNode(areaPath(P));
      }
      return select(new DoubleArea()).style("areaStyle", finalStyle).style("connectStyle", Object.assign(Object.assign({}, connectStyle), style)).style("areaPath", areaPath(P)).style("connectPath", MS.map(areaPath).join("")).node();
    } else {
      const areaRadialPath = (points) => {
        const center2 = coordinate.getCenter();
        const Y12 = points.slice(0, points.length / 2);
        const Y02 = points.slice(points.length / 2);
        return areaRadial_default().angle((_2, idx) => angleWithQuadrant(sub6(Y12[idx], center2))).outerRadius((_2, idx) => dist4(Y12[idx], center2)).innerRadius((_2, idx) => dist4(Y02[idx], center2)).defined((_2, idx) => [...Y12[idx], ...Y02[idx]].every(defined4)).curve(curve)(Y02);
      };
      if (!missing || connectNulls && !Object.keys(connectStyle).length) {
        return getPathNode(areaRadialPath(DP));
      }
      if (missing && !connectNulls) {
        return getPathNode(areaRadialPath(P));
      }
      return select(new DoubleArea()).style("areaStyle", finalStyle).style("connectStyle", Object.assign(Object.assign({}, connectStyle), style)).style("areaPath", areaRadialPath(P)).style("connectPath", MS.map(areaRadialPath).join("")).node();
    }
  };
};
Curve2.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/area/area.js
var Area = (options, context) => {
  const { coordinate } = context;
  return (...params) => {
    const curve = isPolar(coordinate) ? linearClosed_default : linear_default;
    return Curve2(Object.assign({ curve }, options), context)(...params);
  };
};
Area.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "square" });

// node_modules/@antv/g2/esm/shape/area/smooth.js
var __rest25 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var Smooth2 = (options, context) => {
  const rest = __rest25(options, []);
  const { coordinate } = context;
  return (...params) => {
    const curve = isPolar(coordinate) ? catmullRomClosed_default : isTranspose(coordinate) ? monotoneY : monotoneX;
    return Curve2(Object.assign({ curve }, rest), context)(...params);
  };
};
Smooth2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "smooth" });

// node_modules/@antv/g2/esm/shape/area/hvh.js
var HVH2 = (options, context) => {
  return (...params) => {
    return Curve2(Object.assign({ curve: step_default }, options), context)(...params);
  };
};
HVH2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "hvh" });

// node_modules/@antv/g2/esm/shape/area/vh.js
var VH2 = (options, context) => {
  return (...params) => {
    return Curve2(Object.assign({ curve: stepBefore }, options), context)(...params);
  };
};
VH2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "vh" });

// node_modules/@antv/g2/esm/shape/area/hv.js
var HV2 = (options, context) => {
  return (...params) => {
    return Curve2(Object.assign({ curve: stepAfter }, options), context)(...params);
  };
};
HV2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "hv" });

// node_modules/@antv/g2/esm/shape/link/link.js
var Link = (options, context) => {
  const { arrow: arrow2 = false } = options;
  return (...params) => {
    return Vector(Object.assign(Object.assign({}, options), { arrow: arrow2 }), context)(...params);
  };
};
Link.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/link/smooth.js
var __rest26 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var Smooth3 = (options, context) => {
  const style = __rest26(options, []);
  const { document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest26(defaults4, ["color"]);
    const { color: color3 = defaultColor, transform: transform2 } = value2;
    const [from, to] = points;
    const path2 = path();
    path2.moveTo(from[0], from[1]);
    path2.bezierCurveTo(from[0] / 2 + to[0] / 2, from[1], from[0] / 2 + to[0] / 2, to[1], to[0], to[1]);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color3).style("transform", transform2).call(applyStyle, style).node();
  };
};
Smooth3.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/link/vhv.js
var __rest27 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function getVHVPath(from, to, coordinate, ratio) {
  const path2 = path();
  if (isPolar(coordinate)) {
    const center2 = coordinate.getCenter();
    const a4 = dist4(from, center2);
    const b = dist4(to, center2);
    const radius = (b - a4) * ratio + a4;
    path2.moveTo(from[0], from[1]);
    appendArc(path2, from, to, center2, radius);
    path2.lineTo(to[0], to[1]);
    return path2;
  }
  if (isTranspose(coordinate)) {
    path2.moveTo(from[0], from[1]);
    path2.lineTo(from[0] + (to[0] - from[0]) * ratio, from[1]);
    path2.lineTo(from[0] + (to[0] - from[0]) * ratio, to[1]);
    path2.lineTo(to[0], to[1]);
    return path2;
  }
  path2.moveTo(from[0], from[1]);
  path2.lineTo(from[0], from[1] + (to[1] - from[1]) * ratio);
  path2.lineTo(to[0], from[1] + (to[1] - from[1]) * ratio);
  path2.lineTo(to[0], to[1]);
  return path2;
}
var VHV = (options, context) => {
  const { cornerRatio = 1 / 3 } = options, style = __rest27(options, ["cornerRatio"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { defaultColor } = defaults4, rest = __rest27(defaults4, ["defaultColor"]);
    const { color: color3 = defaultColor, transform: transform2 } = value2;
    const [from, to] = points;
    const path2 = getVHVPath(from, to, coordinate, cornerRatio);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color3).style("transform", transform2).call(applyStyle, style).node();
  };
};
VHV.props = {
  defaultMarker: "vhv",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/link/arc.js
var __rest28 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var Arc = (options, context) => {
  const style = __rest28(options, []);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest28(defaults4, ["color"]);
    const { color: color3 = defaultColor, transform: transform2 } = value2;
    const [from, to] = points;
    const path2 = path();
    path2.moveTo(from[0], from[1]);
    if (isPolar(coordinate)) {
      const center2 = coordinate.getCenter();
      path2.quadraticCurveTo(center2[0], center2[1], to[0], to[1]);
    } else {
      const center2 = mid(from, to);
      const raduis = dist4(from, to) / 2;
      appendArc(path2, from, to, center2, raduis);
    }
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color3).style("transform", transform2).call(applyStyle, style).node();
  };
};
Arc.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/mark/utils.js
function baseChannels(options = {}) {
  const { shapes } = options;
  return [
    { name: "color" },
    { name: "opacity" },
    { name: "shape", range: shapes },
    { name: "enterType" },
    { name: "enterDelay", scaleKey: "enter" },
    { name: "enterDuration", scaleKey: "enter" },
    { name: "enterEasing" },
    { name: "key", scale: "identity" },
    { name: "groupKey", scale: "identity" },
    { name: "label", scale: "identity" }
  ];
}
function baseGeometryChannels(options = {}) {
  return [...baseChannels(options), { name: "title", scale: "identity" }];
}
function tooltip2d() {
  return [
    { type: MaybeTitle, channel: "color" },
    { type: MaybeTooltip, channel: ["x", "y"] }
  ];
}
function tooltip1d() {
  return [
    { type: MaybeTitle, channel: "x" },
    { type: MaybeTooltip, channel: ["y"] }
  ];
}
function tooltipXd() {
  return [
    { type: MaybeTitle, channel: "color" },
    { type: MaybeTooltip, channel: ["position"] }
  ];
}
function baseAnnotationChannels(options = {}) {
  return baseChannels(options);
}
function basePreInference() {
  return [{ type: MaybeKey }];
}
function basePostInference() {
  return [];
}
function bandWidth(scale11, x3) {
  return scale11.getBandWidth(scale11.invert(x3));
}
function createBandOffset(scale11, value2, options = {}) {
  const { x: X, y: Y, series: S } = value2;
  const { x: x3, y: y3, series } = scale11;
  const { style: { bandOffset = series ? 0 : 0.5, bandOffsetX = bandOffset, bandOffsetY = bandOffset } = {} } = options;
  const isBandX = !!(x3 === null || x3 === void 0 ? void 0 : x3.getBandWidth);
  const isBandY = !!(y3 === null || y3 === void 0 ? void 0 : y3.getBandWidth);
  const isSeries = !!(series === null || series === void 0 ? void 0 : series.getBandWidth);
  if (!isBandX && !isBandY)
    return (d3) => d3;
  return (d3, i) => {
    const widthX = isBandX ? bandWidth(x3, X[i]) : 0;
    const widthY = isBandY ? bandWidth(y3, Y[i]) : 0;
    const f = () => (bandWidth(series, S[i]) / 2 + +S[i]) * widthX;
    const offset2 = isSeries && S ? f() : 0;
    const [x05, y05] = d3;
    return [x05 + bandOffsetX * widthX + offset2, y05 + bandOffsetY * widthY];
  };
}
function p(d3) {
  return parseFloat(d3) / 100;
}
function visualMark(index3, scale11, value2, coordinate) {
  const { x: X, y: Y } = value2;
  const { innerWidth, innerHeight } = coordinate.getOptions();
  const P = Array.from(index3, (i) => {
    const x05 = X[i];
    const y05 = Y[i];
    const x3 = typeof x05 === "string" ? p(x05) * innerWidth : +x05;
    const y3 = typeof y05 === "string" ? p(y05) * innerHeight : +y05;
    return [[x3, y3]];
  });
  return [index3, P];
}
function field(encode) {
  return typeof encode === "function" ? encode : (d3) => d3[encode];
}
function valueof(data2, encode) {
  return Array.from(data2, field(encode));
}
function initializeData(data2, encode) {
  const { source = (d3) => d3.source, target = (d3) => d3.target, value: value2 = (d3) => d3.value } = encode;
  const { links, nodes } = data2;
  const LS = valueof(links, source);
  const LT = valueof(links, target);
  const LV = valueof(links, value2);
  return {
    links: links.map((_2, i) => ({
      target: LT[i],
      source: LS[i],
      value: LV[i]
    })),
    nodes: nodes || Array.from(/* @__PURE__ */ new Set([...LS, ...LT]), (key) => ({ key }))
  };
}

// node_modules/@antv/g2/esm/shape/image/image.js
var __rest29 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var Image3 = (options, context) => {
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest29(defaults4, ["color"]);
    const { color: color3 = defaultColor, src = "", size: size3 = 32, transform: transform2 = "" } = value2;
    let { width = size3, height = size3 } = options;
    const [[x05, y05]] = points;
    const [w, h] = coordinate.getSize();
    width = typeof width === "string" ? p(width) * w : width;
    height = typeof height === "string" ? p(height) * h : height;
    const x3 = x05 - Number(width) / 2;
    const y3 = y05 - Number(height) / 2;
    return select(document2.createElement("image", {})).call(applyStyle, rest).style("x", x3).style("y", y3).style("src", src).style("stroke", color3).style("transform", transform2).call(applyStyle, options).style("width", width).style("height", height).node();
  };
};
Image3.props = {
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/polygon/polygon.js
var __rest30 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function getPolygonPath(points, coordinate) {
  const path2 = path();
  if (isPolar(coordinate)) {
    const center2 = coordinate.getCenter();
    const closedPoints = [...points, points[0]];
    const dists = closedPoints.map((p2) => dist4(p2, center2));
    closedPoints.forEach((curr, idx) => {
      if (idx === 0) {
        path2.moveTo(curr[0], curr[1]);
        return;
      }
      const currDist = dists[idx];
      const prev = points[idx - 1];
      const prevDist = dists[idx - 1];
      if (prevDist !== void 0 && Math.abs(currDist - prevDist) < 1e-10) {
        appendArc(path2, prev, curr, center2, currDist);
      } else {
        path2.lineTo(curr[0], curr[1]);
      }
    });
    path2.closePath();
    return path2;
  }
  return appendPolygon(path2, points);
}
var Polygon2 = (options, context) => {
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest30(defaults4, ["color"]);
    const { color: color3 = defaultColor, transform: transform2 } = value2;
    const path2 = getPolygonPath(points, coordinate);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color3).style("fill", color3).style("transform", transform2).call(applyStyle, options).node();
  };
};
Polygon2.props = {
  defaultMarker: "square",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/polygon/ribbon.js
var __rest31 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function getRibbonPath(points, coordinate) {
  const [p0, p1, p2, p3] = points;
  const path2 = path();
  if (isPolar(coordinate)) {
    const center2 = coordinate.getCenter();
    const radius = dist4(center2, p0);
    path2.moveTo(p0[0], p0[1]);
    path2.quadraticCurveTo(center2[0], center2[1], p2[0], p2[1]);
    appendArc(path2, p2, p3, center2, radius);
    path2.quadraticCurveTo(center2[0], center2[1], p1[0], p1[1]);
    appendArc(path2, p1, p0, center2, radius);
    path2.closePath();
    return path2;
  }
  path2.moveTo(p0[0], p0[1]);
  path2.bezierCurveTo(p0[0] / 2 + p2[0] / 2, p0[1], p0[0] / 2 + p2[0] / 2, p2[1], p2[0], p2[1]);
  path2.lineTo(p3[0], p3[1]);
  path2.bezierCurveTo(p3[0] / 2 + p1[0] / 2, p3[1], p3[0] / 2 + p1[0] / 2, p1[1], p1[0], p1[1]);
  path2.lineTo(p0[0], p0[1]);
  path2.closePath();
  return path2;
}
var Ribbon2 = (options, context) => {
  const style = __rest31(options, []);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest31(defaults4, ["color"]);
    const { color: color3 = defaultColor, transform: transform2 } = value2;
    const path2 = getRibbonPath(points, coordinate);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("fill", color3 || defaultColor).style("stroke", color3 || defaultColor).style("transform", transform2).call(applyStyle, style).node();
  };
};
Ribbon2.props = {
  defaultMarker: "square",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/box/box.js
var __rest32 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function getPath2(points, coordinate) {
  const path2 = path();
  if (!isPolar(coordinate)) {
    path2.moveTo(...points[0]);
    path2.lineTo(...points[1]);
    path2.moveTo(...points[2]);
    path2.lineTo(...points[3]);
    path2.moveTo(...points[4]);
    path2.lineTo(...points[5]);
    path2.lineTo(...points[6]);
    path2.lineTo(...points[7]);
    path2.closePath();
    path2.moveTo(...points[8]);
    path2.lineTo(...points[9]);
    path2.moveTo(...points[10]);
    path2.lineTo(...points[11]);
    path2.moveTo(...points[12]);
    path2.lineTo(...points[13]);
  } else {
    const center2 = coordinate.getCenter();
    const [x3, y3] = center2;
    const startAngle = angle3(sub6(points[0], center2));
    const endAngle = angle3(sub6(points[1], center2));
    const radiusHigh = dist4(center2, points[2]);
    const radiusQ3 = dist4(center2, points[3]);
    const radiusMedian = dist4(center2, points[8]);
    const radiusQ1 = dist4(center2, points[10]);
    const radiusLow = dist4(center2, points[11]);
    path2.moveTo(...points[0]);
    path2.arc(x3, y3, radiusHigh, startAngle, endAngle);
    path2.arc(x3, y3, radiusHigh, endAngle, startAngle, true);
    path2.moveTo(...points[2]);
    path2.lineTo(...points[3]);
    path2.moveTo(...points[4]);
    path2.arc(x3, y3, radiusQ3, startAngle, endAngle);
    path2.lineTo(...points[6]);
    path2.arc(x3, y3, radiusQ1, endAngle, startAngle, true);
    path2.closePath();
    path2.moveTo(...points[8]);
    path2.arc(x3, y3, radiusMedian, startAngle, endAngle);
    path2.arc(x3, y3, radiusMedian, endAngle, startAngle, true);
    path2.moveTo(...points[10]);
    path2.lineTo(...points[11]);
    path2.moveTo(...points[12]);
    path2.arc(x3, y3, radiusLow, startAngle, endAngle);
    path2.arc(x3, y3, radiusLow, endAngle, startAngle, true);
  }
  return path2;
}
var Box = (options, context) => {
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: color3, transform: transform2 } = value2;
    const { color: defaultColor, fill = defaultColor, stroke: stroke2 = defaultColor } = defaults4, rest = __rest32(defaults4, ["color", "fill", "stroke"]);
    const path2 = getPath2(points, coordinate);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", stroke2).style("fill", color3 || fill).style("transform", transform2).call(applyStyle, options).node();
  };
};
Box.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/box/violin.js
var __rest33 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function getPath3(p2, coordinate, size3 = 4) {
  const path2 = path();
  if (!isPolar(coordinate)) {
    path2.moveTo(...p2[2]);
    path2.lineTo(...p2[3]);
    path2.lineTo(p2[3][0] - size3, p2[3][1]);
    path2.lineTo(p2[10][0] - size3, p2[10][1]);
    path2.lineTo(p2[10][0] + size3, p2[10][1]);
    path2.lineTo(p2[3][0] + size3, p2[3][1]);
    path2.lineTo(...p2[3]);
    path2.closePath();
    path2.moveTo(...p2[10]);
    path2.lineTo(...p2[11]);
    path2.moveTo(p2[3][0] + size3 / 2, p2[8][1]);
    path2.arc(p2[3][0], p2[8][1], size3 / 2, 0, Math.PI * 2);
    path2.closePath();
    return path2;
  }
  const center2 = coordinate.getCenter();
  const [x3, y3] = center2;
  const radiusQ3 = dist4(center2, p2[3]);
  const radiusMedian = dist4(center2, p2[8]);
  const radiusQ1 = dist4(center2, p2[10]);
  const middleAngle = angle3(sub6(p2[2], center2));
  const rectAngle = Math.asin(size3 / radiusMedian);
  const startAngle = middleAngle - rectAngle;
  const endAngle = middleAngle + rectAngle;
  path2.moveTo(...p2[2]);
  path2.lineTo(...p2[3]);
  path2.moveTo(Math.cos(startAngle) * radiusQ3 + x3, Math.sin(startAngle) * radiusQ3 + y3);
  path2.arc(x3, y3, radiusQ3, startAngle, endAngle);
  path2.lineTo(Math.cos(endAngle) * radiusQ1 + x3, Math.sin(endAngle) * radiusQ1 + y3);
  path2.arc(x3, y3, radiusQ1, endAngle, startAngle, true);
  path2.lineTo(Math.cos(startAngle) * radiusQ3 + x3, Math.sin(startAngle) * radiusQ3 + y3);
  path2.closePath();
  path2.moveTo(...p2[10]);
  path2.lineTo(...p2[11]);
  const a4 = (startAngle + endAngle) / 2;
  path2.moveTo(Math.cos(a4) * (radiusMedian + size3 / 2) + x3, Math.sin(a4) * (radiusMedian + size3 / 2) + y3);
  path2.arc(Math.cos(a4) * radiusMedian + x3, Math.sin(a4) * radiusMedian + y3, size3 / 2, a4, Math.PI * 2 + a4);
  path2.closePath();
  return path2;
}
var Violin = (options, context) => {
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: color3, transform: transform2 } = value2;
    const size3 = 4;
    const { color: defaultColor, fill = defaultColor, stroke: stroke2 = defaultColor } = defaults4, rest = __rest33(defaults4, ["color", "fill", "stroke"]);
    const path2 = getPath3(points, coordinate, size3);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", stroke2).style("fill", color3 || fill).style("transform", transform2).call(applyStyle, options).node();
  };
};
Violin.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/lineXY/line.js
var __rest34 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function getArrowMarker(document2, arrowSize, arrowStyle) {
  const arrowMarker = document2.createElement("path", {
    style: Object.assign({ d: `M ${arrowSize},${arrowSize} L -${arrowSize},0 L ${arrowSize},-${arrowSize} L 0,0 Z`, transformOrigin: "center" }, arrowStyle)
  });
  return arrowMarker;
}
function getPath4(points, coordinate) {
  if (!isPolar(coordinate))
    return line_default().x((d3) => d3[0]).y((d3) => d3[1])(points);
  const center2 = coordinate.getCenter();
  return arc_default()({
    startAngle: 0,
    endAngle: Math.PI * 2,
    outerRadius: dist4(points[0], center2),
    innerRadius: dist4(points[1], center2)
  });
}
function getTransform2(coordinate, transform2) {
  if (!isPolar(coordinate))
    return transform2;
  const [cx, cy] = coordinate.getCenter();
  return `translate(${cx}, ${cy}) ${transform2 || ""}`;
}
var Line4 = (options, context) => {
  const { arrow: arrow2, arrowSize = 4 } = options, style = __rest34(options, ["arrow", "arrowSize"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor, lineWidth } = defaults4, shapeTheme = __rest34(defaults4, ["color", "lineWidth"]);
    const { color: color3 = defaultColor, size: size3 = lineWidth } = value2;
    const arrowMarker = arrow2 ? getArrowMarker(document2, arrowSize, Object.assign({ fill: style.stroke || color3, stroke: style.stroke || color3 }, subObject(style, "arrow"))) : null;
    const path2 = getPath4(points, coordinate);
    const transform2 = getTransform2(coordinate, value2.transform);
    return select(document2.createElement("path", {})).call(applyStyle, shapeTheme).style("d", path2).style("stroke", color3).style("lineWidth", size3).style("transform", transform2).style("markerEnd", arrowMarker).call(applyStyle, style).node();
  };
};
Line4.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/connector/connector.js
var __rest35 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function inferSymbol(x3, y3, r) {
  return [["M", x3, y3], ["L", x3 + 2 * r, y3 - r], ["L", x3 + 2 * r, y3 + r], ["Z"]];
}
function inferConnectorPath2(points) {
  return line_default().x((d3) => d3[0]).y((d3) => d3[1])(points);
}
function getPoints(coordinate, points, offset1, offset2, length1 = 0) {
  const [[x05, y05], [x12, y12]] = points;
  if (isTranspose(coordinate)) {
    const X02 = x05 + offset1;
    const X12 = x12 + offset2;
    const X = X02 + length1;
    return [
      [X02, y05],
      [X, y05],
      [X, y12],
      [X12, y12]
    ];
  }
  const Y02 = y05 - offset1;
  const Y12 = y12 - offset2;
  const Y = Y02 - length1;
  return [
    [x05, Y02],
    [x05, Y],
    [x12, Y],
    [x12, Y12]
  ];
}
var Connector = (options, context) => {
  const { offset: offset2 = 0, offset1 = offset2, offset2: offset22 = offset2, connectLength1: length1, endMarker = true } = options, style = __rest35(options, ["offset", "offset1", "offset2", "connectLength1", "endMarker"]);
  const { coordinate } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor, connectLength1 } = defaults4, rest = __rest35(defaults4, ["color", "connectLength1"]);
    const { color: color3, transform: transform2 } = value2;
    const P = getPoints(coordinate, points, offset1, offset22, length1 !== null && length1 !== void 0 ? length1 : connectLength1);
    const makerStyle = subObject(Object.assign(Object.assign({}, style), defaults4), "endMarker");
    return select(new Path2()).call(applyStyle, rest).style("d", inferConnectorPath2(P)).style("stroke", color3 || defaultColor).style("transform", transform2).style("markerEnd", endMarker ? new Marker({
      className: "marker",
      style: Object.assign(Object.assign({}, makerStyle), { symbol: inferSymbol })
    }) : null).call(applyStyle, style).node();
  };
};
Connector.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/utils/string.js
function camelCase(s3) {
  return s3.replace(/-(\w)/g, function(_2, letter) {
    return letter.toUpperCase();
  });
}
function kebabCase(s3) {
  return s3.replace(/([A-Z])/g, "-$1").toLowerCase();
}

// node_modules/@antv/g2/esm/shape/label/position/index.js
var position_exports = {};
__export(position_exports, {
  area: () => area,
  bottom: () => getDefaultStyle,
  bottomLeft: () => getDefaultStyle,
  bottomRight: () => getDefaultStyle,
  inside: () => getDefaultStyle,
  left: () => getDefaultStyle,
  outside: () => outside,
  right: () => getDefaultStyle,
  spider: () => spider,
  surround: () => surround,
  top: () => getDefaultStyle,
  topLeft: () => getDefaultStyle,
  topRight: () => getDefaultStyle
});

// node_modules/@antv/g2/esm/shape/label/position/area.js
function area(position, points, value2, coordinate) {
  const l = points.length / 2;
  const Y12 = points.slice(0, l);
  const Y02 = points.slice(l);
  let idx = maxIndex(Y12, (p2, i) => Math.abs(p2[1] - Y02[i][1]));
  idx = Math.max(Math.min(idx, l - 2), 1);
  const mid2 = (i) => [Y12[i][0], (Y12[i][1] + Y02[i][1]) / 2];
  const point7 = mid2(idx);
  const prev = mid2(idx - 1);
  const next = mid2(idx + 1);
  const rotate7 = angle3(sub6(next, prev)) / Math.PI * 180;
  return {
    x: point7[0],
    y: point7[1],
    transform: `rotate(${rotate7})`,
    textAlign: "center",
    textBaseline: "middle"
  };
}

// node_modules/@antv/g2/esm/shape/label/position/default.js
function inferNonCircularStyle(position, points, value2, coordinate) {
  const { bounds } = value2;
  const [[x05, y05], [x12, y12]] = bounds;
  const w = x12 - x05;
  const h = y12 - y05;
  const xy = (options) => {
    const { x: ox, y: oy } = options;
    const px2 = maybePercentage(value2.x, w);
    const py = maybePercentage(value2.y, h);
    return Object.assign(Object.assign({}, options), { x: (px2 || ox) + x05, y: (py || oy) + y05 });
  };
  if (position === "left")
    return xy({ x: 0, y: h / 2, textAlign: "start", textBaseline: "middle" });
  if (position === "right")
    return xy({ x: w, y: h / 2, textAlign: "end", textBaseline: "middle" });
  if (position === "top")
    return xy({ x: w / 2, y: 0, textAlign: "center", textBaseline: "top" });
  if (position === "bottom")
    return xy({ x: w / 2, y: h, textAlign: "center", textBaseline: "bottom" });
  if (position === "top-left")
    return xy({ x: 0, y: 0, textAlign: "start", textBaseline: "top" });
  if (position === "top-right")
    return xy({ x: w, y: 0, textAlign: "end", textBaseline: "top" });
  if (position === "bottom-left")
    return xy({ x: 0, y: h, textAlign: "start", textBaseline: "bottom" });
  if (position === "bottom-right")
    return xy({ x: w, y: h, textAlign: "end", textBaseline: "bottom" });
  return xy({
    x: w / 2,
    y: h / 2,
    textAlign: "center",
    textBaseline: "middle"
  });
}
function inferRadialStyle(position, points, value2, coordinate) {
  const { y: y3, y1: y12, autoRotate, rotateToAlignArc } = value2;
  const center2 = coordinate.getCenter();
  const arcObject = getArcObject(coordinate, points, [y3, y12]);
  const { innerRadius, outerRadius, startAngle, endAngle } = arcObject;
  const angle4 = position === "inside" ? (startAngle + endAngle) / 2 : endAngle;
  const rotate7 = inferRotation(angle4, autoRotate, rotateToAlignArc);
  const point7 = (() => {
    const [p0, p1] = points;
    const radius = innerRadius + (outerRadius - innerRadius) * 0.5;
    const [x3, y4] = position === "inside" ? pointOfArc(center2, angle4, radius) : mid(p0, p1);
    return { x: x3, y: y4 };
  })();
  return Object.assign(Object.assign({}, point7), { textAlign: position === "inside" ? "center" : "start", textBaseline: "middle", rotate: rotate7 });
}
function pointOfArc(center2, angle4, radius) {
  return [
    center2[0] + Math.sin(angle4) * radius,
    center2[1] - Math.cos(angle4) * radius
  ];
}
function inferRotation(angle4, autoRotate, rotateToAlignArc) {
  if (!autoRotate)
    return 0;
  const append3 = rotateToAlignArc ? 0 : Math.sin(angle4) < 0 ? 90 : -90;
  return angle4 / Math.PI * 180 + append3;
}
function inferInnerCircularStyle(position, points, value2, coordinate) {
  const { y: y3, y1: y12, autoRotate, rotateToAlignArc, radius: radiusRatio = 0.5, offset: offset2 = 0 } = value2;
  const arcObject = getArcObject(coordinate, points, [y3, y12]);
  const { startAngle, endAngle } = arcObject;
  const center2 = coordinate.getCenter();
  const angle4 = (startAngle + endAngle) / 2;
  const rotate7 = inferRotation(angle4, autoRotate, rotateToAlignArc);
  const textStyle = { textAlign: "center", textBaseline: "middle", rotate: rotate7 };
  const { innerRadius, outerRadius } = arcObject;
  const r0 = innerRadius + (outerRadius - innerRadius) * radiusRatio;
  const r1 = r0 + offset2;
  const [x05, y05] = pointOfArc(center2, angle4, r1);
  return Object.assign({ x: x05, y: y05 }, textStyle);
}
function maybeUndefined(d3) {
  return d3 === void 0 ? null : d3;
}
function inferIdentityStyle(position, points, value2, coordinate) {
  const { bounds } = value2;
  const [p2] = bounds;
  return {
    x: maybeUndefined(p2[0]),
    y: maybeUndefined(p2[1])
  };
}
function getDefaultStyle(position, points, value2, coordinate) {
  const { bounds } = value2;
  if (bounds.length === 1) {
    return inferIdentityStyle(position, points, value2, coordinate);
  }
  const inferDefaultStyle2 = isRadial(coordinate) ? inferRadialStyle : isCircular(coordinate) ? inferInnerCircularStyle : inferNonCircularStyle;
  return inferDefaultStyle2(position, points, value2, coordinate);
}

// node_modules/@antv/g2/esm/shape/label/position/outside.js
function linePoints(center2, angle4, radius, radius1, offsetX) {
  const [x05, y05] = pointOfArc(center2, angle4, radius);
  const [x12, y12] = pointOfArc(center2, angle4, radius1);
  const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
  return [
    [x05, y05],
    [x12, y12],
    [x12 + sign3 * offsetX, y12]
  ];
}
function radiusOf2(points, value2, coordinate) {
  const arcObject = getArcObject(coordinate, points, [value2.y, value2.y1]);
  const { innerRadius, outerRadius } = arcObject;
  return innerRadius + (outerRadius - innerRadius);
}
function angleOf2(points, value2, coordinate) {
  const arcObject = getArcObject(coordinate, points, [value2.y, value2.y1]);
  const { startAngle, endAngle } = arcObject;
  return (startAngle + endAngle) / 2;
}
function inferOutsideCircularStyle(position, points, value2, coordinate) {
  const { autoRotate, rotateToAlignArc, offset: offset2 = 0, connector = true, connectorLength = offset2, connectorLength2 = 0, connectorDistance = 0 } = value2;
  const center2 = coordinate.getCenter();
  const angle4 = angleOf2(points, value2, coordinate);
  const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
  const rotate7 = inferRotation(angle4, autoRotate, rotateToAlignArc);
  const textStyle = {
    textAlign: sign3 > 0 || isRadial(coordinate) ? "start" : "end",
    textBaseline: "middle",
    rotate: rotate7
  };
  const radius = radiusOf2(points, value2, coordinate);
  const radius1 = radius + (connector ? connectorLength : offset2);
  const [[x05, y05], [x12, y12], [x22, y22]] = linePoints(center2, angle4, radius, radius1, connector ? connectorLength2 : 0);
  const dx = connector ? +connectorDistance * sign3 : 0;
  const x3 = x22 + dx;
  const y3 = y22;
  const connectorStyle = {
    connector,
    connectorPoints: [
      [x12 - x3, y12 - y3],
      [x22 - x3, y22 - y3]
    ]
  };
  return Object.assign(Object.assign({
    x0: x05,
    y0: y05,
    x: x22 + dx,
    y: y22
  }, textStyle), connectorStyle);
}
function outside(position, points, value2, coordinate) {
  const { bounds } = value2;
  if (bounds.length === 1) {
    return inferIdentityStyle(position, points, value2, coordinate);
  }
  const inferDefaultStyle2 = isRadial(coordinate) ? inferRadialStyle : isCircular(coordinate) ? inferOutsideCircularStyle : inferNonCircularStyle;
  return inferDefaultStyle2(position, points, value2, coordinate);
}

// node_modules/@antv/g2/esm/shape/label/position/utils.js
function dodgeY(labels, options = {}) {
  const { labelHeight = 14, height } = options;
  const sortedLabels = sort(labels, (d3) => d3.y);
  const n = sortedLabels.length;
  const boxes = new Array(n);
  for (let i2 = 0; i2 < n; i2++) {
    const label = sortedLabels[i2];
    const { y: y3 } = label;
    boxes[i2] = { y: y3, y1: y3 + labelHeight, labels: [y3] };
  }
  let overlap = true;
  while (overlap) {
    overlap = false;
    for (let i2 = boxes.length - 1; i2 > 0; i2--) {
      const box2 = boxes[i2];
      const preBox = boxes[i2 - 1];
      if (preBox.y1 > box2.y) {
        overlap = true;
        preBox.labels.push(...box2.labels);
        boxes.splice(i2, 1);
        preBox.y1 += box2.y1 - box2.y;
        const newHeight = preBox.y1 - preBox.y;
        preBox.y1 = Math.max(Math.min(preBox.y1, height), newHeight);
        preBox.y = preBox.y1 - newHeight;
      }
    }
  }
  let i = 0;
  for (const box2 of boxes) {
    const { y: y3, labels: labels2 } = box2;
    let prevY = y3 - labelHeight;
    for (const curY of labels2) {
      const label = sortedLabels[i++];
      const expectedY = prevY + labelHeight;
      const dy = expectedY - curY;
      label.connectorPoints[0][1] -= dy;
      label.y = prevY + labelHeight;
      prevY += labelHeight;
    }
  }
}
function hideAndDodgeY(unsorted, options) {
  const labels = sort(unsorted, (d3) => d3.y);
  const { height, labelHeight = 14 } = options;
  const maxCount = Math.ceil(height / labelHeight);
  if (labels.length <= maxCount)
    return dodgeY(labels, options);
  const filtered = [];
  for (let i = 0; i < labels.length; i++) {
    if (i < labels.length - maxCount) {
      labels[i].opacity = 0;
      labels[i].connector = false;
    } else
      filtered.push(labels[i]);
  }
  dodgeY(filtered, options);
}

// node_modules/@antv/g2/esm/shape/label/position/spider.js
var __rest36 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var styleByPoints = /* @__PURE__ */ new WeakMap();
function compute(points, value2, coordinate) {
  const { connectorLength, connectorLength2, connectorDistance } = value2;
  const style = __rest36(inferOutsideCircularStyle("outside", points, value2, coordinate), []);
  const center2 = coordinate.getCenter();
  const radius = radiusOf2(points, value2, coordinate);
  const angle4 = angleOf2(points, value2, coordinate);
  const radius1 = radius + connectorLength + connectorLength2;
  const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
  const newX = center2[0] + (radius1 + +connectorDistance) * sign3;
  const { x: originX } = style;
  const dx = newX - originX;
  style.x += dx;
  style.connectorPoints[0][0] -= dx;
  return style;
}
function spider(position, points, value2, coordinate, options, labels) {
  if (!isCircular(coordinate))
    return {};
  if (styleByPoints.has(points))
    return styleByPoints.get(points);
  const computed = labels.map((points2) => compute(points2, value2, coordinate));
  const { width, height } = coordinate.getOptions();
  const left2 = computed.filter((d3) => d3.x < width / 2);
  const right2 = computed.filter((d3) => d3.x >= width / 2);
  const extendedOptions = Object.assign(Object.assign({}, options), { height });
  hideAndDodgeY(left2, extendedOptions);
  hideAndDodgeY(right2, extendedOptions);
  computed.forEach((style, i) => styleByPoints.set(labels[i], style));
  return styleByPoints.get(points);
}

// node_modules/@antv/g2/esm/shape/label/position/surround.js
var __rest37 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function surround(position, points, value2, coordinate) {
  if (!isCircular(coordinate))
    return {};
  const { connectorLength, connectorLength2, connectorDistance } = value2;
  const style = __rest37(inferOutsideCircularStyle("outside", points, value2, coordinate), []);
  const { x0: x05, y0: y05 } = style;
  const center2 = coordinate.getCenter();
  const radius = getRadius(coordinate);
  const radius1 = radius + connectorLength;
  const angle4 = angleWithQuadrant([x05 - center2[0], y05 - center2[1]]);
  const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
  const [newX, newY] = pointOfArc(center2, angle4, radius1);
  style.x = newX + (connectorLength2 + connectorDistance) * sign3;
  style.y = newY;
  return style;
}

// node_modules/@antv/g2/esm/shape/label/label.js
var __rest38 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function inferPosition(position, coordinate) {
  if (position !== void 0)
    return position;
  if (isCircular(coordinate))
    return "inside";
  if (isTranspose(coordinate))
    return "right";
  return "top";
}
function getDefaultStyle2(points, value2, coordinate, theme, options, labels) {
  const { position } = value2;
  const { render: render3 } = options;
  const p2 = inferPosition(position, coordinate);
  const labelType = render3 ? "htmlLabel" : p2 === "inside" ? "innerLabel" : "label";
  const t = theme[labelType];
  const v = Object.assign({}, t, value2);
  const processor = position_exports[camelCase(p2)];
  if (!processor) {
    throw new Error(`Unknown position: ${p2}`);
  }
  return Object.assign(Object.assign({}, t), processor(p2, points, v, coordinate, options, labels));
}
var Label = (options, context) => {
  const { coordinate, theme } = context;
  const { render: render3 } = options;
  return (points, value2, style, labels) => {
    const { text, x: x3, y: y3, transform: specifiedTS = "", transformOrigin, className: className2 = "" } = value2, overrideStyle = __rest38(value2, ["text", "x", "y", "transform", "transformOrigin", "className"]);
    const _a2 = getDefaultStyle2(points, value2, coordinate, theme, options, labels), { rotate: rotate7 = 0, transform: transform2 = "" } = _a2, defaultStyle2 = __rest38(_a2, ["rotate", "transform"]);
    return select(new Advance()).call(applyStyle, defaultStyle2).style("text", `${text}`).style("className", `${className2} g2-label`).style("innerHTML", render3 ? render3(text, value2.datum, value2.index) : void 0).style("labelTransform", `${transform2} rotate(${+rotate7}) ${specifiedTS}`.trim()).style("labelTransformOrigin", transformOrigin).style("coordCenter", coordinate.getCenter()).call(applyStyle, overrideStyle).node();
  };
};
Label.props = {
  defaultMarker: "point"
};

// node_modules/@antv/g2/esm/shape/path/color.js
var __rest39 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var Color4 = (options, context) => {
  const { arrow: arrow2, colorAttribute } = options, style = __rest39(options, ["arrow", "colorAttribute"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor, stroke: stroke2 } = defaults4, rest = __rest39(defaults4, ["color", "stroke"]);
    const { d: d3, color: color3 = defaultColor } = value2;
    const [width, height] = coordinate.getSize();
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", typeof d3 === "function" ? d3({ width, height }) : d3).style(colorAttribute, color3).call(applyStyle, style).node();
  };
};
Color4.props = {
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/path/path.js
var Path3 = (options, context) => {
  return Color4(Object.assign({ colorAttribute: "fill" }, options), context);
};
Path3.props = {
  defaultMarker: "hvh",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/path/hollow.js
var Hollow2 = (options, context) => {
  return Color4(Object.assign({ fill: "none", colorAttribute: "stroke" }, options), context);
};
Hollow2.props = {
  defaultMarker: "hvh",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/density/density.js
var __rest40 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var Density = (options, context) => {
  const { document: document2 } = context;
  return (points, value2, defaults4) => {
    const { transform: transform2 } = value2;
    const { color: defaultColor } = defaults4, rest = __rest40(defaults4, ["color"]);
    const { color: color3 = defaultColor } = value2;
    const [first3, ...p2] = points;
    const path2 = path();
    path2.moveTo(...first3);
    p2.forEach(([x3, y3]) => {
      path2.lineTo(x3, y3);
    });
    path2.closePath();
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color3 || defaultColor).style("fill", color3 || defaultColor).style("fillOpacity", 0.4).style("transform", transform2).call(applyStyle, options).node();
  };
};
Density.props = {
  defaultMarker: "square",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/flru/dist/flru.mjs
function flru_default(max11) {
  var num, curr, prev;
  var limit = max11 || 1;
  function keep(key, value2) {
    if (++num > limit) {
      prev = curr;
      reset(1);
      ++num;
    }
    curr[key] = value2;
  }
  function reset(isPartial) {
    num = 0;
    curr = /* @__PURE__ */ Object.create(null);
    isPartial || (prev = /* @__PURE__ */ Object.create(null));
  }
  reset();
  return {
    clear: reset,
    has: function(key) {
      return curr[key] !== void 0 || prev[key] !== void 0;
    },
    get: function(key) {
      var val = curr[key];
      if (val !== void 0)
        return val;
      if ((val = prev[key]) !== void 0) {
        keep(key, val);
        return val;
      }
    },
    set: function(key, value2) {
      if (curr[key] !== void 0) {
        curr[key] = value2;
      } else {
        keep(key, value2);
      }
    }
  };
}

// node_modules/@antv/g2/esm/utils/lru.js
var cache = flru_default(3);
function lru(fn, keyFn = (...args) => `${args[0]}`, maxSize = 16) {
  const cache2 = flru_default(maxSize);
  return (...args) => {
    const key = keyFn(...args);
    let v = cache2.get(key);
    if (cache2.has(key))
      return cache2.get(key);
    v = fn(...args);
    cache2.set(key, v);
    return v;
  };
}

// node_modules/@antv/g2/esm/shape/heatmap/renderer/gradient.js
function parseGradient2(gradient2) {
  if (typeof gradient2 === "string") {
    return gradient2.split(" ").map((stop) => {
      const [r, c5] = stop.split(":");
      return [+r, c5];
    });
  }
  return gradient2;
}

// node_modules/@antv/g2/esm/shape/heatmap/renderer/index.js
function newCanvas(createCanvas, width, height) {
  const c5 = createCanvas ? createCanvas() : document.createElement("canvas");
  c5.width = width;
  c5.height = height;
  return c5;
}
var getPointTemplate = lru((radius, blurFactor, createCanvas) => {
  const tplCanvas = newCanvas(createCanvas, radius * 2, radius * 2);
  const tplCtx = tplCanvas.getContext("2d");
  const x3 = radius;
  const y3 = radius;
  if (blurFactor === 1) {
    tplCtx.beginPath();
    tplCtx.arc(x3, y3, radius, 0, 2 * Math.PI, false);
    tplCtx.fillStyle = "rgba(0,0,0,1)";
    tplCtx.fill();
  } else {
    const gradient2 = tplCtx.createRadialGradient(x3, y3, radius * blurFactor, x3, y3, radius);
    gradient2.addColorStop(0, "rgba(0,0,0,1)");
    gradient2.addColorStop(1, "rgba(0,0,0,0)");
    tplCtx.fillStyle = gradient2;
    tplCtx.fillRect(0, 0, 2 * radius, 2 * radius);
  }
  return tplCanvas;
}, (radius) => `${radius}`);
function getColorPalette(gradientConfig, createCanvas) {
  const paletteCanvas = newCanvas(createCanvas, 256, 1);
  const paletteCtx = paletteCanvas.getContext("2d");
  const gradient2 = paletteCtx.createLinearGradient(0, 0, 256, 1);
  parseGradient2(gradientConfig).forEach(([r, c5]) => {
    gradient2.addColorStop(r, c5);
  });
  paletteCtx.fillStyle = gradient2;
  paletteCtx.fillRect(0, 0, 256, 1);
  return paletteCtx.getImageData(0, 0, 256, 1).data;
}
function drawAlpha(shadowCtx, min10, max11, data2, options, createCanvas) {
  const { blur: blur3 } = options;
  let len5 = data2.length;
  while (len5--) {
    const { x: x3, y: y3, value: v, radius } = data2[len5];
    const value2 = Math.min(v, max11);
    const rectX = x3 - radius;
    const rectY = y3 - radius;
    const tpl = getPointTemplate(radius, 1 - blur3, createCanvas);
    const templateAlpha = (value2 - min10) / (max11 - min10);
    shadowCtx.globalAlpha = Math.max(templateAlpha, 1e-3);
    shadowCtx.drawImage(tpl, rectX, rectY);
  }
  return shadowCtx;
}
function colorize(shadowCtx, maxWidth, maxHeight, palette, options) {
  const { minOpacity, opacity, maxOpacity, useGradientOpacity } = options;
  const x3 = 0;
  const y3 = 0;
  const width = maxWidth;
  const height = maxHeight;
  const img = shadowCtx.getImageData(x3, y3, width, height);
  const imgData = img.data;
  const len5 = imgData.length;
  for (let i = 3; i < len5; i += 4) {
    const alpha = imgData[i];
    const offset2 = alpha * 4;
    if (!offset2) {
      continue;
    }
    const finalAlpha = opacity || Math.max(0, Math.min(maxOpacity, Math.max(minOpacity, alpha)));
    imgData[i - 3] = palette[offset2];
    imgData[i - 2] = palette[offset2 + 1];
    imgData[i - 1] = palette[offset2 + 2];
    imgData[i] = useGradientOpacity ? palette[offset2 + 3] : finalAlpha;
  }
  return img;
}
function HeatmapRenderer(width, height, min10, max11, data2, options, createCanvas) {
  const opts = Object.assign({ blur: 0.85, minOpacity: 0, opacity: 0.6, maxOpacity: 1, gradient: [
    [0.25, "rgb(0,0,255)"],
    [0.55, "rgb(0,255,0)"],
    [0.85, "yellow"],
    [1, "rgb(255,0,0)"]
  ] }, options);
  opts.minOpacity *= 255;
  opts.opacity *= 255;
  opts.maxOpacity *= 255;
  const shadowCanvas = newCanvas(createCanvas, width, height);
  const shadowCtx = shadowCanvas.getContext("2d");
  const palette = getColorPalette(opts.gradient, createCanvas);
  shadowCtx.clearRect(0, 0, width, height);
  drawAlpha(shadowCtx, min10, max11, data2, opts, createCanvas);
  const img = colorize(shadowCtx, width, height, palette, opts);
  const canvas = newCanvas(createCanvas, width, height);
  const ctx4 = canvas.getContext("2d");
  ctx4.putImageData(img, 0, 0);
  return ctx4;
}

// node_modules/@antv/g2/esm/shape/heatmap/heatmap.js
var __rest41 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function deleteKey(obj, fn) {
  return Object.keys(obj).reduce((r, k2) => {
    const v = obj[k2];
    if (!fn(v, k2))
      r[k2] = v;
    return r;
  }, {});
}
var Heatmap = (options, context) => {
  const { gradient: gradient2, opacity, maxOpacity, minOpacity, blur: blur3, useGradientOpacity } = options, style = __rest41(options, ["gradient", "opacity", "maxOpacity", "minOpacity", "blur", "useGradientOpacity"]);
  const { coordinate, createCanvas, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { transform: transform2 } = value2;
    const [width, height] = coordinate.getSize();
    const data2 = points.map((p2) => ({
      x: p2[0],
      y: p2[1],
      value: p2[2],
      radius: p2[3]
    }));
    const min10 = min4(points, (p2) => p2[2]);
    const max11 = max5(points, (p2) => p2[2]);
    const options2 = {
      gradient: gradient2,
      opacity,
      minOpacity,
      maxOpacity,
      blur: blur3,
      useGradientOpacity
    };
    const ctx4 = width && height ? HeatmapRenderer(width, height, min10, max11, data2, deleteKey(options2, (v) => v === void 0), createCanvas) : { canvas: null };
    return select(document2.createElement("image", {})).call(applyStyle, defaults4).style("x", 0).style("y", 0).style("width", width).style("height", height).style("src", ctx4.canvas.toDataURL()).style("transform", transform2).call(applyStyle, style).node();
  };
};
Heatmap.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/shape/shape.js
var __rest42 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var Shape2 = (options, context) => {
  const { render: render3 } = options, rest = __rest42(options, ["render"]);
  return (points) => {
    const [[x05, y05]] = points;
    return render3(Object.assign(Object.assign({}, rest), { x: x05, y: y05 }), context);
  };
};
Shape2.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/liquid/wave.js
var DURATION = 5e3;
function lerp5(min10, max11, factor) {
  return min10 + (max11 - min10) * factor;
}
function getWaterWavePositions(x3, stage, waveLength, amplitude) {
  if (stage === 0) {
    return [
      [x3 + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2],
      [x3 + 1 / 2 * waveLength / Math.PI, amplitude],
      [x3 + waveLength / 4, amplitude]
    ];
  }
  if (stage === 1) {
    return [
      [x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude],
      [
        x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),
        amplitude / 2
      ],
      [x3 + waveLength / 4, 0]
    ];
  }
  if (stage === 2) {
    return [
      [x3 + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2],
      [x3 + 1 / 2 * waveLength / Math.PI, -amplitude],
      [x3 + waveLength / 4, -amplitude]
    ];
  }
  return [
    [x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude],
    [
      x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),
      -amplitude / 2
    ],
    [x3 + waveLength / 4, 0]
  ];
}
function getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {
  const curves = Math.ceil(2 * radius / waveLength * 4) * 4;
  const path2 = [];
  let _phase = phase;
  while (_phase < -Math.PI * 2) {
    _phase += Math.PI * 2;
  }
  while (_phase > 0) {
    _phase -= Math.PI * 2;
  }
  _phase = _phase / Math.PI / 2 * waveLength;
  const left2 = cx - radius + _phase - radius * 2;
  path2.push(["M", left2, waterLevel]);
  let waveRight = 0;
  for (let c5 = 0; c5 < curves; ++c5) {
    const stage = c5 % 4;
    const pos = getWaterWavePositions(c5 * waveLength / 4, stage, waveLength, amplitude);
    path2.push([
      "C",
      pos[0][0] + left2,
      -pos[0][1] + waterLevel,
      pos[1][0] + left2,
      -pos[1][1] + waterLevel,
      pos[2][0] + left2,
      -pos[2][1] + waterLevel
    ]);
    if (c5 === curves - 1) {
      waveRight = pos[2][0];
    }
  }
  path2.push(["L", waveRight + left2, cy + radius]);
  path2.push(["L", left2, cy + radius]);
  path2.push(["Z"]);
  return path2;
}
function addWave(x3, y3, level, waveCount, waveAttrs, group3, minY, radius, waveLength, animation, document2) {
  const { fill, fillOpacity, opacity } = waveAttrs;
  for (let idx = 0; idx < waveCount; idx++) {
    const factor = waveCount <= 1 ? 1 : idx / (waveCount - 1);
    const path2 = getWaterWavePath(
      radius,
      minY + radius * level,
      waveLength,
      0,
      // Amplitude height.
      radius / 40,
      x3,
      y3
    );
    const wave = document2.createElement("path", {
      style: {
        d: path2,
        fill,
        opacity: lerp5(0.2, 0.9, factor) * Number(opacity || fillOpacity)
      }
    });
    group3.appendChild(wave);
    try {
      if (animation === false)
        return;
      const keyframes = [
        {
          transform: "translate(0, 0)"
        },
        {
          transform: `translate(${waveLength * 2}, 0)`
        }
      ];
      wave.animate(keyframes, {
        duration: lerp5(0.5 * DURATION, DURATION, factor) * 2,
        iterations: Infinity
      });
    } catch (e) {
      console.warn("off-screen group animate error!");
    }
  }
}

// node_modules/@antv/g2/esm/shape/liquid/shapes.js
function circle2(x3, y3, r) {
  return `
      M ${x3} ${y3 - r} 
      a ${r} ${r} 0 1 0 0 ${r * 2}
      a ${r} ${r} 0 1 0 0 ${-r * 2}
      Z
    `;
}
function rect3(x3, y3, r) {
  const GOLDEN_SECTION_RATIO = 0.618;
  const w = r * GOLDEN_SECTION_RATIO;
  return `
      M ${x3 - w} ${y3 - r}
      L ${x3 + w} ${y3 - r}
      L ${x3 + w} ${y3 + r}
      L ${x3 - w} ${y3 + r}
      Z
    `;
}
function diamond3(x3, y3, r) {
  return `
      M ${x3} ${y3 - r}
      L ${x3 + r} ${y3}
      L ${x3} ${y3 + r}
      L ${x3 - r} ${y3}
      Z
    `;
}
function triangle3(x3, y3, r) {
  return `
      M ${x3} ${y3 - r}
      L ${x3 + r} ${y3 + r}
      L ${x3 - r} ${y3 + r}
      Z
    `;
}
function pin(x3, y3, radius) {
  const w = radius * 4 / 3;
  const h = Math.max(w, radius * 2);
  const r = w / 2;
  const cx = x3;
  const cy = r + y3 - h / 2;
  const theta = Math.asin(r / ((h - r) * 0.85));
  const dy = Math.sin(theta) * r;
  const dx = Math.cos(theta) * r;
  const x05 = cx - dx;
  const y05 = cy + dy;
  const cpX = x3;
  const cpY = cy + r / Math.sin(theta);
  return `
      M ${x05} ${y05}
      A ${r} ${r} 0 1 1 ${x05 + dx * 2} ${y05}
      Q ${cpX} ${cpY} ${x3} ${y3 + h / 2}
      Q ${cpX} ${cpY} ${x05} ${y05}
      Z 
    `;
}
var LiquidShapesPath = {
  pin,
  rect: rect3,
  circle: circle2,
  diamond: diamond3,
  triangle: triangle3
};

// node_modules/@antv/g2/esm/shape/liquid/liquid.js
var __rest43 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var getLiquidShape = (shape23 = "circle") => LiquidShapesPath[shape23] || LiquidShapesPath.circle;
var Liquid = (options, context) => {
  if (!context)
    return;
  const { coordinate } = context;
  const { liquidOptions, styleOptions } = options;
  const { liquidShape, percent: percent2 } = liquidOptions;
  const { background: backgroundStyle, outline = {}, wave = {} } = styleOptions, attr2 = __rest43(styleOptions, ["background", "outline", "wave"]);
  const { border = 2, distance: distance7 = 0 } = outline, outlineStyle = __rest43(outline, ["border", "distance"]);
  const { length: length5 = 192, count: count4 = 3 } = wave;
  return (points, cfg, defaultAttr) => {
    const { document: document2 } = context.canvas;
    const { color: color3, fillOpacity } = defaultAttr;
    const attrs = Object.assign(Object.assign({ fill: color3 }, defaultAttr), attr2);
    const g = document2.createElement("g", {});
    const [centerX, centerY] = coordinate.getCenter();
    const size3 = coordinate.getSize();
    const radius = Math.min(...size3) / 2;
    const buildPath = isFunction(liquidShape) ? liquidShape : getLiquidShape(liquidShape);
    const shapePath = buildPath(centerX, centerY, radius, ...size3);
    if (Object.keys(backgroundStyle).length) {
      const backgroundShape = document2.createElement("path", {
        style: Object.assign({ d: shapePath, fill: "#fff" }, backgroundStyle)
      });
      g.appendChild(backgroundShape);
    }
    if (percent2 > 0) {
      const clipShape = document2.createElement("path", {
        style: {
          d: shapePath
        }
      });
      g.appendChild(clipShape);
      g.style.clipPath = clipShape;
      addWave(centerX, centerY, 1 - percent2, count4, attrs, g, clipShape.getBBox().y, radius * 2, length5, true, document2);
    }
    const distanceShape = document2.createElement("path", {
      style: {
        d: shapePath,
        fill: "transparent",
        lineWidth: border + 2 * distance7,
        stroke: "#fff"
      }
    });
    const borderShape = document2.createElement("path", {
      style: Object.assign(Object.assign(Object.assign({ d: shapePath, stroke: color3, strokeOpacity: fillOpacity, lineWidth: border }, attrs), outlineStyle), { fill: "transparent" })
    });
    g.appendChild(distanceShape);
    g.appendChild(borderShape);
    return g;
  };
};
Liquid.props = {};

// node_modules/@antv/g2/esm/shape/gauge/round.js
var getR = (point1, point22) => {
  return Math.sqrt(Math.pow(point1[0] - point22[0], 2) + Math.pow(point1[1] - point22[1], 2)) / 2;
};
var Round = (options, context) => {
  if (!context)
    return;
  const { coordinate } = context;
  if (!(coordinate === null || coordinate === void 0 ? void 0 : coordinate.getCenter))
    return;
  const center2 = coordinate.getCenter();
  return (points, cfg, defaultCfg) => {
    const { document: document2 } = context.canvas;
    const { color: color3, index: index3 } = cfg;
    const g = document2.createElement("g", {});
    const minR = getR(points[0], points[1]);
    const maxR = getR(points[0], center2) * 2;
    const roundPath2 = document2.createElement("path", {
      style: Object.assign(Object.assign(Object.assign({ d: [
        ["M", ...points[0]],
        ["A", minR, minR, 0, 1, 0, ...points[1]],
        ["A", maxR + minR * 2, maxR + minR * 2, 0, 0, 0, ...points[2]],
        ["A", minR, minR, 0, 1, index3 === 0 ? 0 : 1, ...points[3]],
        ["A", maxR, maxR, 0, 0, 1, ...points[0]],
        ["Z"]
      ] }, defaultCfg), omit_default(options, ["shape", "last", "first"])), { fill: color3 || defaultCfg.color })
    });
    g.appendChild(roundPath2);
    return g;
  };
};

// node_modules/@antv/g2/esm/mark/interval.js
function bandWidth2(scale11, x3) {
  return scale11.getBandWidth(scale11.invert(x3));
}
var shape = {
  rect: Rect2,
  hollow: Hollow,
  funnel: Funnel,
  pyramid: Pyramid
};
var Interval = () => {
  return (index3, scale11, value2, coordinate) => {
    const { x: X, y: Y, y1: Y12, series: S, size: SZ } = value2;
    const x3 = scale11.x;
    const series = scale11.series;
    const [width] = coordinate.getSize();
    const NSZ = SZ ? SZ.map((d3) => +d3 / width) : null;
    const x1x2 = !SZ ? (x4, w, i) => [x4, x4 + w] : (x4, w, i) => {
      const mx = x4 + w / 2;
      const s3 = NSZ[i];
      return [mx - s3 / 2, mx + s3 / 2];
    };
    const P = Array.from(index3, (i) => {
      const groupWidth = bandWidth2(x3, X[i]);
      const ratio = series ? bandWidth2(series, S === null || S === void 0 ? void 0 : S[i]) : 1;
      const width2 = groupWidth * ratio;
      const offset2 = (+(S === null || S === void 0 ? void 0 : S[i]) || 0) * groupWidth;
      const x05 = +X[i] + offset2;
      const [x12, x22] = x1x2(x05, width2, i);
      const y12 = +Y[i];
      const y22 = +Y12[i];
      const p1 = [x12, y12];
      const p2 = [x22, y12];
      const p3 = [x22, y22];
      const p4 = [x12, y22];
      return [p1, p2, p3, p4].map((d3) => coordinate.map(d3));
    });
    return [index3, P];
  };
};
Interval.props = {
  defaultShape: "rect",
  defaultLabelShape: "label",
  composite: false,
  shape,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape) }),
    { name: "x", scale: "band", required: true },
    { name: "y", required: true },
    { name: "series", scale: "band" },
    { name: "size" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroY1 },
    { type: MaybeZeroX }
  ],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: { shareTooltip: true }
};

// node_modules/@antv/g2/esm/mark/rect.js
var shape2 = {
  rect: Rect2,
  hollow: Hollow
};
var Rect3 = () => {
  return (index3, scale11, value2, coordinate) => {
    const { x: X, x1: X12, y: Y, y1: Y12 } = value2;
    const P = Array.from(index3, (i) => {
      const p1 = [+X[i], +Y[i]];
      const p2 = [+X12[i], +Y[i]];
      const p3 = [+X12[i], +Y12[i]];
      const p4 = [+X[i], +Y12[i]];
      return [p1, p2, p3, p4].map((d3) => coordinate.map(d3));
    });
    return [index3, P];
  };
};
Rect3.props = {
  defaultShape: "rect",
  defaultLabelShape: "label",
  composite: false,
  shape: shape2,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape2) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeZeroY1 }],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: {
    shareTooltip: true
  }
};

// node_modules/@antv/g2/esm/mark/line.js
var shape3 = {
  line: Line2,
  smooth: Smooth,
  hv: HV,
  vh: VH,
  hvh: HVH,
  trail: Trail
};
var line3 = (index3, scale11, value2, coordinate) => {
  var _a2, _b;
  const { series: S, x: X, y: Y } = value2;
  const { x: x3, y: y3 } = scale11;
  if (X === void 0 || Y === void 0) {
    throw new Error("Missing encode for x or y channel.");
  }
  const series = S ? Array.from(group(index3, (i) => S[i]).values()) : [index3];
  const I = series.map((group3) => group3[0]).filter((i) => i !== void 0);
  const xoffset = (((_a2 = x3 === null || x3 === void 0 ? void 0 : x3.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(x3)) || 0) / 2;
  const yoffset = (((_b = y3 === null || y3 === void 0 ? void 0 : y3.getBandWidth) === null || _b === void 0 ? void 0 : _b.call(y3)) || 0) / 2;
  const P = Array.from(series, (I2) => {
    return I2.map((i) => coordinate.map([+X[i] + xoffset, +Y[i] + yoffset]));
  });
  return [I, P, series];
};
var parallel = (index3, scale11, value2, coordinate) => {
  const PV = Object.entries(value2).filter(([key]) => key.startsWith("position")).map(([, value3]) => value3);
  if (PV.length === 0) {
    throw new Error("Missing encode for position channel.");
  }
  const P = Array.from(index3, (i) => {
    const vector = PV.map((pv) => +pv[i]);
    const vectors = coordinate.map(vector);
    const points = [];
    for (let i2 = 0; i2 < vectors.length; i2 += 2) {
      points.push([vectors[i2], vectors[i2 + 1]]);
    }
    return points;
  });
  return [index3, P];
};
var Line5 = () => {
  return (index3, scale11, value2, coordinate) => {
    const mark2 = isParallel(coordinate) ? parallel : line3;
    return mark2(index3, scale11, value2, coordinate);
  };
};
Line5.props = {
  defaultShape: "line",
  defaultLabelShape: "label",
  composite: false,
  shape: shape3,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape3) }),
    { name: "x" },
    { name: "y" },
    { name: "position", independent: true },
    { name: "size" },
    { name: "series", scale: "band" }
  ],
  preInference: [
    ...basePreInference(),
    // !!!Note This order is very important.
    { type: MaybeGradient },
    { type: MaybeSeries }
  ],
  postInference: [...basePostInference(), ...tooltip1d(), ...tooltipXd()],
  interaction: {
    shareTooltip: true,
    seriesTooltip: true,
    crosshairs: true
  }
};

// node_modules/@antv/g2/esm/mark/point.js
var shape4 = {
  hollow: HollowPoint,
  hollowDiamond: HollowDiamond,
  hollowHexagon: HollowHexagon,
  hollowSquare: HollowSquare,
  hollowTriangleDown: HollowTriangleDown,
  hollowTriangle: HollowTriangle,
  hollowBowtie: HollowBowtie,
  hollowCircle: HollowCircle,
  point: Point3,
  plus: Plus,
  diamond: Diamond,
  square: Square,
  triangle: Triangle,
  hexagon: Hexagon,
  cross: Cross,
  bowtie: Bowtie,
  hyphen: Hyphen,
  line: Line3,
  tick: Tick,
  triangleDown: TriangleDown,
  circle: Circle2
};
var Point4 = (options) => {
  return (index3, scale11, value2, coordinate) => {
    const { x: X, y: Y, x1: X12, y1: Y12, size: S, dx: DX, dy: DY } = value2;
    const [width, height] = coordinate.getSize();
    const offset2 = createBandOffset(scale11, value2, options);
    const xy = (i) => {
      const dx = +((DX === null || DX === void 0 ? void 0 : DX[i]) || 0);
      const dy = +((DY === null || DY === void 0 ? void 0 : DY[i]) || 0);
      const x3 = X12 ? (+X[i] + +X12[i]) / 2 : +X[i];
      const y3 = Y12 ? (+Y[i] + +Y12[i]) / 2 : +Y[i];
      const cx = x3 + dx;
      const cy = y3 + dy;
      return [cx, cy];
    };
    const P = S ? Array.from(index3, (i) => {
      const [cx, cy] = xy(i);
      const r = +S[i];
      const a4 = r / width;
      const b = r / height;
      const p1 = [cx - a4, cy - b];
      const p2 = [cx + a4, cy + b];
      return [
        coordinate.map(offset2(p1, i)),
        coordinate.map(offset2(p2, i))
      ];
    }) : Array.from(index3, (i) => [coordinate.map(offset2(xy(i), i))]);
    return [index3, P];
  };
};
Point4.props = {
  defaultShape: "hollow",
  defaultLabelShape: "label",
  composite: false,
  shape: shape4,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape4) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "series", scale: "band" },
    { name: "size", quantitative: "sqrt" },
    { name: "dx", scale: "identity" },
    { name: "dy", scale: "identity" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroX },
    { type: MaybeZeroY }
  ],
  postInference: [...basePostInference(), { type: MaybeSize }, ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/text.js
var shape5 = {
  text: Text3,
  badge: Badge,
  tag: Tag2
};
var Text4 = (options) => {
  const { cartesian: cartesian3 = false } = options;
  if (cartesian3)
    return visualMark;
  return (index3, scale11, value2, coordinate) => {
    const { x: X, y: Y } = value2;
    const offset2 = createBandOffset(scale11, value2, options);
    const P = Array.from(index3, (i) => {
      const p2 = [+X[i], +Y[i]];
      return [coordinate.map(offset2(p2, i))];
    });
    return [index3, P];
  };
};
Text4.props = {
  defaultShape: "text",
  defaultLabelShape: "label",
  composite: false,
  shape: shape5,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape5) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "text", scale: "identity" },
    { name: "fontSize", scale: "identity" },
    { name: "rotate", scale: "identity" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeTuple },
    { type: MaybeVisualPosition }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/cell.js
var shape6 = {
  cell: Rect2,
  hollow: Hollow
};
var Cell = () => {
  return (index3, scale11, value2, coordinate) => {
    const { x: X, y: Y } = value2;
    const x3 = scale11.x;
    const y3 = scale11.y;
    const P = Array.from(index3, (i) => {
      const width = x3.getBandWidth(x3.invert(+X[i]));
      const height = y3.getBandWidth(y3.invert(+Y[i]));
      const x12 = +X[i];
      const y12 = +Y[i];
      const p1 = [x12, y12];
      const p2 = [x12 + width, y12];
      const p3 = [x12 + width, y12 + height];
      const p4 = [x12, y12 + height];
      return [p1, p2, p3, p4].map((d3) => coordinate.map(d3));
    });
    return [index3, P];
  };
};
Cell.props = {
  defaultShape: "cell",
  defaultLabelShape: "label",
  shape: shape6,
  composite: false,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape6) }),
    { name: "x", required: true, scale: "band" },
    { name: "y", required: true, scale: "band" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroX },
    { type: MaybeZeroY },
    { type: MaybeZeroPadding }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/area.js
var shape7 = {
  area: Area,
  smooth: Smooth2,
  hvh: HVH2,
  vh: VH2,
  hv: HV2
};
var Area2 = () => {
  return (index3, scale11, value2, coordinate) => {
    var _a2, _b;
    const { x: X, y: Y, y1: Y12, series: S } = value2;
    const { x: x3, y: y3 } = scale11;
    const series = S ? Array.from(group(index3, (i) => S[i]).values()) : [index3];
    const I = series.map((group3) => group3[0]).filter((i) => i !== void 0);
    const xoffset = (((_a2 = x3 === null || x3 === void 0 ? void 0 : x3.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(x3)) || 0) / 2;
    const yoffset = (((_b = y3 === null || y3 === void 0 ? void 0 : y3.getBandWidth) === null || _b === void 0 ? void 0 : _b.call(y3)) || 0) / 2;
    const P = Array.from(series, (SI) => {
      const l = SI.length;
      const points = new Array(l * 2);
      for (let idx = 0; idx < SI.length; idx++) {
        const i = SI[idx];
        points[idx] = coordinate.map([+X[i] + xoffset, +Y[i] + yoffset]);
        points[l + idx] = coordinate.map([+X[i] + xoffset, +Y12[i] + yoffset]);
      }
      return points;
    });
    return [I, P, series];
  };
};
Area2.props = {
  defaultShape: "area",
  defaultLabelShape: "label",
  composite: false,
  shape: shape7,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape7) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "size" },
    { name: "series", scale: "band" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeSeries },
    { type: MaybeZeroY1 },
    { type: MaybeZeroPadding }
  ],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: {
    shareTooltip: true,
    seriesTooltip: true,
    crosshairs: true
  }
};

// node_modules/@antv/g2/esm/mark/link.js
var shape8 = {
  link: Link,
  arc: Arc,
  smooth: Smooth3,
  vhv: VHV
};
var Link2 = (options) => {
  return (index3, scale11, value2, coordinate) => {
    const { x: X, y: Y, x1: X12 = X, y1: Y12 = Y } = value2;
    const offset2 = createBandOffset(scale11, value2, options);
    const P = index3.map((i) => [
      coordinate.map(offset2([+X[i], +Y[i]], i)),
      coordinate.map(offset2([+X12[i], +Y12[i]], i))
    ]);
    return [index3, P];
  };
};
Link2.props = {
  defaultShape: "link",
  defaultLabelShape: "label",
  composite: false,
  shape: shape8,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape8) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeIdentityY },
    { type: MaybeIdentityX }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/image.js
var shape9 = {
  image: Image3
};
var Image4 = (options) => {
  const { cartesian: cartesian3 } = options;
  if (cartesian3)
    return visualMark;
  return (index3, scale11, value2, coordinate) => {
    const { x: X, y: Y } = value2;
    const offset2 = createBandOffset(scale11, value2, options);
    const P = Array.from(index3, (i) => {
      const p2 = [+X[i], +Y[i]];
      return [coordinate.map(offset2(p2, i))];
    });
    return [index3, P];
  };
};
Image4.props = {
  defaultShape: "image",
  defaultLabelShape: "label",
  composite: false,
  shape: shape9,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape9) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "src", scale: "identity" },
    { name: "size" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeTuple },
    { type: MaybeVisualPosition }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/polygon.js
var shape10 = {
  polygon: Polygon2,
  ribbon: Ribbon2
};
var Polygon3 = () => {
  return (index3, scale11, value2, coordinate) => {
    const Xn2 = Object.entries(value2).filter(([key]) => key.startsWith("x")).map(([, value3]) => value3);
    const Yn2 = Object.entries(value2).filter(([key]) => key.startsWith("y")).map(([, value3]) => value3);
    const P = index3.map((i) => {
      const Pn = [];
      for (let j = 0; j < Xn2.length; j++) {
        const x3 = Xn2[j][i];
        if (x3 === void 0)
          break;
        const y3 = Yn2[j][i];
        Pn.push(coordinate.map([+x3, +y3]));
      }
      return Pn;
    });
    return [index3, P];
  };
};
Polygon3.props = {
  defaultShape: "polygon",
  defaultLabelShape: "label",
  composite: false,
  shape: shape10,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape10) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/box.js
var shape11 = {
  box: Box,
  violin: Violin
};
var Box2 = () => {
  return (index3, scale11, value2, coordinate) => {
    const { x: X, y: Y, y1: Y12, y2: Y22, y3: Y3, y4: Y4, series: S } = value2;
    const xScale = scale11.x;
    const series = scale11.series;
    const P = Array.from(index3, (i) => {
      const groupWidth = xScale.getBandWidth(xScale.invert(+X[i]));
      const ratio = series ? series.getBandWidth(series.invert(+(S === null || S === void 0 ? void 0 : S[i]))) : 1;
      const width = groupWidth * ratio;
      const offset2 = (+(S === null || S === void 0 ? void 0 : S[i]) || 0) * groupWidth;
      const x3 = +X[i] + offset2 + width / 2;
      const [low, q12, median3, q32, high] = [
        +Y[i],
        +Y12[i],
        +Y22[i],
        +Y3[i],
        +Y4[i]
      ];
      const P13 = [
        [x3 - width / 2, high],
        [x3 + width / 2, high],
        [x3, high],
        [x3, q32],
        [x3 - width / 2, q32],
        [x3 + width / 2, q32],
        [x3 + width / 2, q12],
        [x3 - width / 2, q12],
        [x3 - width / 2, median3],
        [x3 + width / 2, median3],
        [x3, q12],
        [x3, low],
        [x3 - width / 2, low],
        [x3 + width / 2, low]
      ];
      return P13.map((d3) => coordinate.map(d3));
    });
    return [index3, P];
  };
};
Box2.props = {
  defaultShape: "box",
  defaultLabelShape: "label",
  composite: false,
  shape: shape11,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape11) }),
    { name: "x", scale: "band", required: true },
    { name: "y", required: true },
    { name: "series", scale: "band" }
  ],
  preInference: [...basePreInference(), { type: MaybeZeroX }],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: {
    shareTooltip: true
  }
};

// node_modules/@antv/g2/esm/mark/vector.js
var shape12 = {
  vector: Vector
};
var Vector2 = () => {
  return (index3, scale11, value2, coordinate) => {
    const { x: X, y: Y, size: S, rotate: R } = value2;
    const [width, height] = coordinate.getSize();
    const P = index3.map((i) => {
      const angle4 = +R[i] / 180 * Math.PI;
      const s3 = +S[i];
      const a4 = s3 / width;
      const b = s3 / height;
      const vx = a4 * Math.cos(angle4);
      const vy = -b * Math.sin(angle4);
      return [
        coordinate.map([+X[i] - vx / 2, +Y[i] - vy / 2]),
        coordinate.map([+X[i] + vx / 2, +Y[i] + vy / 2])
      ];
    });
    return [index3, P];
  };
};
Vector2.props = {
  defaultShape: "vector",
  defaultLabelShape: "label",
  composite: false,
  shape: shape12,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape12) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "rotate", required: true, scale: "identity" },
    { name: "size", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/lineY.js
var shape13 = {
  line: Line4
};
var LineY = (options) => {
  return (index3, scale11, value2, coordinate) => {
    const { y: Y } = value2;
    const offset2 = createBandOffset(scale11, value2, deep_mix_default({ style: { bandOffset: 0 } }, options));
    const P = Array.from(index3, (i) => {
      const p1 = [0, Y[i]];
      const p2 = [1, Y[i]];
      return [p1, p2].map((d3) => coordinate.map(offset2(d3, i)));
    });
    return [index3, P];
  };
};
LineY.props = {
  defaultShape: "line",
  defaultLabelShape: "label",
  composite: false,
  shape: shape13,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape13) }),
    { name: "y", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeTupleY }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/lineX.js
var shape14 = {
  line: Line4
};
var LineX = (options) => {
  return (index3, scale11, value2, coordinate) => {
    const { x: X } = value2;
    const offset2 = createBandOffset(scale11, value2, deep_mix_default({ style: { bandOffset: 0 } }, options));
    const P = Array.from(index3, (i) => {
      const p1 = [X[i], 1];
      const p2 = [X[i], 0];
      return [p1, p2].map((d3) => coordinate.map(offset2(d3, i)));
    });
    return [index3, P];
  };
};
LineX.props = {
  defaultShape: "line",
  defaultLabelShape: "label",
  composite: false,
  shape: shape14,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape14) }),
    { name: "x", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeTupleX }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/connector.js
var shape15 = {
  connector: Connector
};
var Connector2 = (...args) => {
  return Link2(...args);
};
Connector2.props = {
  defaultShape: "connector",
  defaultLabelShape: "label",
  composite: false,
  shape: shape15,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape15) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/range.js
function extend2(channel, extended, value2, scale11) {
  if (extended)
    return () => [0, 1];
  const { [channel]: C4, [`${channel}1`]: C1 } = value2;
  return (i) => {
    var _a2;
    const offset2 = ((_a2 = scale11.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(scale11, scale11.invert(+C1[i]))) || 0;
    return [C4[i], C1[i] + offset2];
  };
}
function AbstractRange(options = {}) {
  const { extendX = false, extendY = false } = options;
  return (index3, scale11, value2, coordinate) => {
    const x3 = extend2("x", extendX, value2, scale11.x);
    const y3 = extend2("y", extendY, value2, scale11.y);
    const P = Array.from(index3, (i) => {
      const [x12, x22] = x3(i);
      const [y12, y22] = y3(i);
      const p1 = [x12, y12];
      const p2 = [x22, y12];
      const p3 = [x22, y22];
      const p4 = [x12, y22];
      return [p1, p2, p3, p4].map((d3) => coordinate.map(d3));
    });
    return [index3, P];
  };
}
var shape16 = { range: Rect2 };
var Range2 = () => {
  return AbstractRange();
};
Range2.props = {
  defaultShape: "range",
  defaultLabelShape: "label",
  composite: false,
  shape: shape16,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape16) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/rangeX.js
var shape17 = {
  range: Rect2
};
var RangeX = () => {
  return AbstractRange({ extendY: true });
};
RangeX.props = {
  defaultShape: "range",
  defaultLabelShape: "label",
  composite: false,
  shape: shape17,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape17) }),
    { name: "x", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeDefaultX }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/rangeY.js
var shape18 = {
  range: Rect2
};
var RangeY = () => {
  return AbstractRange({ extendX: true });
};
RangeY.props = {
  defaultShape: "range",
  defaultLabelShape: "label",
  composite: false,
  shape: shape18,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape18) }),
    { name: "y", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeDefaultY }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/data/utils/d3-sankey/align.js
function targetDepth(d3) {
  return d3.target.depth;
}
function left(node) {
  return node.depth;
}
function right(node, n) {
  return n - 1 - node.height;
}
function justify(node, n) {
  return node.sourceLinks.length ? node.depth : n - 1;
}
function center(node) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min4(node.sourceLinks, targetDepth) - 1 : 0;
}

// node_modules/@antv/g2/esm/data/utils/d3-sankey/constant.js
function constant3(x3) {
  return function() {
    return x3;
  };
}

// node_modules/@antv/g2/esm/data/utils/d3-sankey/sankey.js
function ascendingSourceBreadth(a4, b) {
  return ascendingBreadth(a4.source, b.source) || a4.index - b.index;
}
function ascendingTargetBreadth(a4, b) {
  return ascendingBreadth(a4.target, b.target) || a4.index - b.index;
}
function ascendingBreadth(a4, b) {
  return a4.y0 - b.y0;
}
function value(d3) {
  return d3.value;
}
function defaultId(d3) {
  return d3.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find4(nodeById, id4) {
  const node = nodeById.get(id4);
  if (!node)
    throw new Error("missing: " + id4);
  return node;
}
function computeLinkBreadths({ nodes }) {
  for (const node of nodes) {
    let y05 = node.y0;
    let y12 = y05;
    for (const link3 of node.sourceLinks) {
      link3.y0 = y05 + link3.width / 2;
      y05 += link3.width;
    }
    for (const link3 of node.targetLinks) {
      link3.y1 = y12 + link3.width / 2;
      y12 += link3.width;
    }
  }
}
function Sankey() {
  let x05 = 0, y05 = 0, x12 = 1, y12 = 1;
  let dx = 24;
  let dy = 8, py;
  let id4 = defaultId;
  let align = justify;
  let depth;
  let sort2;
  let linkSort;
  let nodes = defaultNodes;
  let links = defaultLinks;
  let iterations2 = 6;
  function sankey(arg) {
    const graph = {
      nodes: nodes(arg),
      links: links(arg)
    };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_2) {
    return arguments.length ? (id4 = typeof _2 === "function" ? _2 : constant3(_2), sankey) : id4;
  };
  sankey.nodeAlign = function(_2) {
    return arguments.length ? (align = typeof _2 === "function" ? _2 : constant3(_2), sankey) : align;
  };
  sankey.nodeDepth = function(_2) {
    return arguments.length ? (depth = typeof _2 === "function" ? _2 : _2, sankey) : depth;
  };
  sankey.nodeSort = function(_2) {
    return arguments.length ? (sort2 = _2, sankey) : sort2;
  };
  sankey.nodeWidth = function(_2) {
    return arguments.length ? (dx = +_2, sankey) : dx;
  };
  sankey.nodePadding = function(_2) {
    return arguments.length ? (dy = py = +_2, sankey) : dy;
  };
  sankey.nodes = function(_2) {
    return arguments.length ? (nodes = typeof _2 === "function" ? _2 : constant3(_2), sankey) : nodes;
  };
  sankey.links = function(_2) {
    return arguments.length ? (links = typeof _2 === "function" ? _2 : constant3(_2), sankey) : links;
  };
  sankey.linkSort = function(_2) {
    return arguments.length ? (linkSort = _2, sankey) : linkSort;
  };
  sankey.size = function(_2) {
    return arguments.length ? (x05 = y05 = 0, x12 = +_2[0], y12 = +_2[1], sankey) : [x12 - x05, y12 - y05];
  };
  sankey.extent = function(_2) {
    return arguments.length ? (x05 = +_2[0][0], x12 = +_2[1][0], y05 = +_2[0][1], y12 = +_2[1][1], sankey) : [
      [x05, y05],
      [x12, y12]
    ];
  };
  sankey.iterations = function(_2) {
    return arguments.length ? (iterations2 = +_2, sankey) : iterations2;
  };
  function computeNodeLinks({ nodes: nodes2, links: links2 }) {
    nodes2.forEach((node, idx) => {
      node.index = idx;
      node.sourceLinks = [];
      node.targetLinks = [];
    });
    const nodeById = new Map(nodes2.map((d3) => [id4(d3), d3]));
    links2.forEach((link3, idx) => {
      link3.index = idx;
      let { source, target } = link3;
      if (typeof source !== "object")
        source = link3.source = find4(nodeById, source);
      if (typeof target !== "object")
        target = link3.target = find4(nodeById, target);
      source.sourceLinks.push(link3);
      target.targetLinks.push(link3);
    });
    if (linkSort != null) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(linkSort);
        targetLinks.sort(linkSort);
      }
    }
  }
  function computeNodeValues({ nodes: nodes2 }) {
    for (const node of nodes2) {
      node.value = node.fixedValue === void 0 ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value)) : node.fixedValue;
    }
  }
  function computeNodeDepths({ nodes: nodes2 }) {
    const n = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x3 = 0;
    while (current.size) {
      current.forEach((node) => {
        node.depth = x3;
        for (const { target } of node.sourceLinks) {
          next.add(target);
        }
      });
      if (++x3 > n)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
    if (depth) {
      const maxDepth2 = Math.max(max5(nodes2, (d3) => d3.depth) + 1, 0);
      let node;
      for (let i = 0; i < nodes2.length; i++) {
        node = nodes2[i];
        node.depth = depth.call(null, node, maxDepth2);
      }
    }
  }
  function computeNodeHeights({ nodes: nodes2 }) {
    const n = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x3 = 0;
    while (current.size) {
      current.forEach((node) => {
        node.height = x3;
        for (const { source } of node.targetLinks) {
          next.add(source);
        }
      });
      if (++x3 > n)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeLayers({ nodes: nodes2 }) {
    const x3 = Math.max(max5(nodes2, (d3) => d3.depth) + 1, 0);
    const kx2 = (x12 - x05 - dx) / (x3 - 1);
    const columns = new Array(x3).fill(0).map(() => []);
    for (const node of nodes2) {
      const i = Math.max(0, Math.min(x3 - 1, Math.floor(align.call(null, node, x3))));
      node.layer = i;
      node.x0 = x05 + i * kx2;
      node.x1 = node.x0 + dx;
      if (columns[i])
        columns[i].push(node);
      else
        columns[i] = [node];
    }
    if (sort2)
      for (const column2 of columns) {
        column2.sort(sort2);
      }
    return columns;
  }
  function initializeNodeBreadths(columns) {
    const ky2 = min4(columns, (c5) => (y12 - y05 - (c5.length - 1) * py) / sum(c5, value));
    for (const nodes2 of columns) {
      let y3 = y05;
      for (const node of nodes2) {
        node.y0 = y3;
        node.y1 = y3 + node.value * ky2;
        y3 = node.y1 + py;
        for (const link3 of node.sourceLinks) {
          link3.width = link3.value * ky2;
        }
      }
      y3 = (y12 - y3 + py) / (nodes2.length + 1);
      for (let i = 0; i < nodes2.length; ++i) {
        const node = nodes2[i];
        node.y0 += y3 * (i + 1);
        node.y1 += y3 * (i + 1);
      }
      reorderLinks(nodes2);
    }
  }
  function computeNodeBreadths(graph) {
    const columns = computeNodeLayers(graph);
    py = Math.min(dy, (y12 - y05) / (max5(columns, (c5) => c5.length) - 1));
    initializeNodeBreadths(columns);
    for (let i = 0; i < iterations2; ++i) {
      const alpha = Math.pow(0.99, i);
      const beta = Math.max(1 - alpha, (i + 1) / iterations2);
      relaxRightToLeft(columns, alpha, beta);
      relaxLeftToRight(columns, alpha, beta);
    }
  }
  function relaxLeftToRight(columns, alpha, beta) {
    for (let i = 1, n = columns.length; i < n; ++i) {
      const column2 = columns[i];
      for (const target of column2) {
        let y3 = 0;
        let w = 0;
        for (const { source, value: value2 } of target.targetLinks) {
          const v = value2 * (target.layer - source.layer);
          y3 += targetTop(source, target) * v;
          w += v;
        }
        if (!(w > 0))
          continue;
        const dy2 = (y3 / w - target.y0) * alpha;
        target.y0 += dy2;
        target.y1 += dy2;
        reorderNodeLinks(target);
      }
      if (sort2 === void 0)
        column2.sort(ascendingBreadth);
      if (column2.length)
        resolveCollisions(column2, beta);
    }
  }
  function relaxRightToLeft(columns, alpha, beta) {
    for (let n = columns.length, i = n - 2; i >= 0; --i) {
      const column2 = columns[i];
      for (const source of column2) {
        let y3 = 0;
        let w = 0;
        for (const { target, value: value2 } of source.sourceLinks) {
          const v = value2 * (target.layer - source.layer);
          y3 += sourceTop(source, target) * v;
          w += v;
        }
        if (!(w > 0))
          continue;
        const dy2 = (y3 / w - source.y0) * alpha;
        source.y0 += dy2;
        source.y1 += dy2;
        reorderNodeLinks(source);
      }
      if (sort2 === void 0)
        column2.sort(ascendingBreadth);
      if (column2.length)
        resolveCollisions(column2, beta);
    }
  }
  function resolveCollisions(nodes2, alpha) {
    const i = nodes2.length >> 1;
    const subject = nodes2[i];
    resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i + 1, alpha);
    resolveCollisionsBottomToTop(nodes2, y12, nodes2.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, y05, 0, alpha);
  }
  function resolveCollisionsTopToBottom(nodes2, y3, i, alpha) {
    for (; i < nodes2.length; ++i) {
      const node = nodes2[i];
      const dy2 = (y3 - node.y0) * alpha;
      if (dy2 > 1e-6)
        node.y0 += dy2, node.y1 += dy2;
      y3 = node.y1 + py;
    }
  }
  function resolveCollisionsBottomToTop(nodes2, y3, i, alpha) {
    for (; i >= 0; --i) {
      const node = nodes2[i];
      const dy2 = (node.y1 - y3) * alpha;
      if (dy2 > 1e-6)
        node.y0 -= dy2, node.y1 -= dy2;
      y3 = node.y0 - py;
    }
  }
  function reorderNodeLinks({ sourceLinks, targetLinks }) {
    if (linkSort === void 0) {
      for (const { source: { sourceLinks: sourceLinks2 } } of targetLinks) {
        sourceLinks2.sort(ascendingTargetBreadth);
      }
      for (const { target: { targetLinks: targetLinks2 } } of sourceLinks) {
        targetLinks2.sort(ascendingSourceBreadth);
      }
    }
  }
  function reorderLinks(nodes2) {
    if (linkSort === void 0) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(ascendingTargetBreadth);
        targetLinks.sort(ascendingSourceBreadth);
      }
    }
  }
  function targetTop(source, target) {
    let y3 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target)
        break;
      y3 += width + py;
    }
    for (const { source: node, width } of target.targetLinks) {
      if (node === source)
        break;
      y3 -= width;
    }
    return y3;
  }
  function sourceTop(source, target) {
    let y3 = target.y0 - (target.targetLinks.length - 1) * py / 2;
    for (const { source: node, width } of target.targetLinks) {
      if (node === source)
        break;
      y3 += width + py;
    }
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target)
        break;
      y3 -= width;
    }
    return y3;
  }
  return sankey;
}

// node_modules/@antv/g2/esm/data/sankey.js
var DEFAULT_OPTIONS = {
  nodeAlign: "justify",
  nodeWidth: 8e-3,
  nodePadding: 0.03,
  nodes: (graph) => graph.nodes,
  links: (graph) => graph.links,
  nodeSort: void 0,
  linkSort: void 0,
  iterations: 6
};
var ALIGN_METHOD = {
  left,
  right,
  center,
  justify
};
function getNodeAlignFunction(nodeAlign) {
  const type = typeof nodeAlign;
  if (type === "string")
    return ALIGN_METHOD[nodeAlign] || justify;
  if (type === "function")
    return nodeAlign;
  return justify;
}
var Sankey2 = (options) => {
  return (data2) => {
    const { nodeId, nodeSort, nodeAlign, nodeWidth, nodePadding, nodeDepth, nodes: nodeNodes, links: nodeLinks, linkSort, iterations: iterations2 } = Object.assign({}, DEFAULT_OPTIONS, options);
    const sankeyProcessor = Sankey().nodeSort(nodeSort).linkSort(linkSort).links(nodeLinks).nodes(nodeNodes).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeDepth(nodeDepth).nodeAlign(getNodeAlignFunction(nodeAlign)).iterations(iterations2).extent([
      [0, 0],
      [1, 1]
    ]);
    if (typeof nodeId === "function") {
      sankeyProcessor.nodeId(nodeId);
    }
    const layoutData = sankeyProcessor(data2);
    const { nodes: N, links: L } = layoutData;
    const nodes = N.map((node) => {
      const { x0: x05, x1: x12, y0: y05, y1: y12 } = node;
      return Object.assign(Object.assign({}, node), { x: [x05, x12, x12, x05], y: [y05, y05, y12, y12] });
    });
    const links = L.map((edge) => {
      const { source, target } = edge;
      const sx = source.x1;
      const tx = target.x0;
      const offset2 = edge.width / 2;
      return Object.assign(Object.assign({}, edge), { x: [sx, sx, tx, tx], y: [
        edge.y0 + offset2,
        edge.y0 - offset2,
        edge.y1 + offset2,
        edge.y1 - offset2
      ] });
    });
    return { nodes, links };
  };
};
Sankey2.props = {};

// node_modules/@antv/g2/esm/utils/mark.js
function subTooltip(tooltip2, name2, defaults4 = {}, main = false) {
  if (isUnset(tooltip2))
    return tooltip2;
  if (Array.isArray(tooltip2) && main)
    return tooltip2;
  const sub8 = subObject(tooltip2, name2);
  return deep_mix_default(defaults4, sub8);
}
function maybeTooltip(tooltip2, defaults4 = {}) {
  if (isUnset(tooltip2))
    return tooltip2;
  if (Array.isArray(tooltip2))
    return tooltip2;
  if (!isFullTooltip(tooltip2))
    return tooltip2;
  return deep_mix_default(defaults4, tooltip2);
}
function isFullTooltip(tooltip2) {
  if (Object.keys(tooltip2).length === 0)
    return true;
  const { title, items } = tooltip2;
  return title !== void 0 || items !== void 0;
}
function maybeAnimation(animate2, sub8) {
  return typeof animate2 === "object" ? subObject(animate2, sub8) : animate2;
}

// node_modules/@antv/g2/esm/mark/sankey.js
var __rest44 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var DEFAULT_LAYOUT_OPTIONS = {
  nodeId: (d3) => d3.key,
  nodeWidth: 0.02,
  nodePadding: 0.02
};
var DEFAULT_NODE_OPTIONS = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "polygon",
    x: "x",
    y: "y"
  },
  scale: {
    x: { type: "identity" },
    y: { type: "identity" }
  },
  style: {
    stroke: "#000"
  }
};
var DEFAULT_LINK_OPTIONS = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "ribbon",
    x: "x",
    y: "y"
  },
  style: {
    fillOpacity: 0.5,
    stroke: void 0
  }
};
var DEFAULT_LABEL_OPTIONS = {
  textAlign: (d3) => d3.x[0] < 0.5 ? "start" : "end",
  position: (d3) => d3.x[0] < 0.5 ? "right" : "left",
  fontSize: 10
};
var Sankey3 = (options) => {
  const { data: data2, encode = {}, scale: scale11, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {}, interaction } = options;
  const { links, nodes } = initializeData(data2, encode);
  const nodeEncode = subObject(encode, "node");
  const linkEncode = subObject(encode, "link");
  const { key: nodeKey = (d3) => d3.key, color: color3 = nodeKey } = nodeEncode;
  const { links: linkData, nodes: nodeData } = Sankey2(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS), { nodeId: field(nodeKey) }), layout))({ links, nodes });
  const _a2 = subObject(style, "label"), { text = nodeKey, spacing = 5 } = _a2, labelStyle = __rest44(_a2, ["text", "spacing"]);
  const key1 = field(nodeKey);
  const nodeTooltip = subTooltip(tooltip2, "node", {
    title: key1,
    items: [{ field: "value" }]
  }, true);
  const linkTooltip = subTooltip(tooltip2, "link", {
    title: "",
    items: [
      (d3) => ({ name: "source", value: key1(d3.source) }),
      (d3) => ({ name: "target", value: key1(d3.target) })
    ]
  });
  return [
    deep_mix_default({}, DEFAULT_NODE_OPTIONS, {
      data: nodeData,
      encode: Object.assign(Object.assign({}, nodeEncode), { color: color3 }),
      scale: scale11,
      style: subObject(style, "node"),
      labels: [
        Object.assign(Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS), { text, dx: (d3) => d3.x[0] < 0.5 ? spacing : -spacing }), labelStyle),
        ...nodeLabels
      ],
      tooltip: nodeTooltip,
      animate: maybeAnimation(animate2, "node"),
      axis: false,
      interaction
    }),
    deep_mix_default({}, DEFAULT_LINK_OPTIONS, {
      data: linkData,
      encode: linkEncode,
      labels: linkLabels,
      style: Object.assign({ fill: linkEncode.color ? void 0 : "#aaa", lineWidth: 0 }, subObject(style, "link")),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate2, "link"),
      interaction
    })
  ];
};
Sankey3.props = {};

// node_modules/@antv/g2/esm/data/utils/arc/sort.js
var sort_exports = {};
__export(sort_exports, {
  frequency: () => frequency,
  id: () => id2,
  name: () => name,
  weight: () => weight
});
function weight(a4, b) {
  return b.value - a4.value;
}
function frequency(a4, b) {
  return b.frequency - a4.frequency;
}
function id2(a4, b) {
  return `${a4.id}`.localeCompare(`${b.id}`);
}
function name(a4, b) {
  return `${a4.name}`.localeCompare(`${b.name}`);
}

// node_modules/@antv/g2/esm/data/utils/arc/arc.js
var DEFAULT_OPTIONS2 = {
  y: 0,
  thickness: 0.05,
  weight: false,
  marginRatio: 0.1,
  id: (node) => node.id,
  source: (edge) => edge.source,
  target: (edge) => edge.target,
  sourceWeight: (edge) => edge.value || 1,
  targetWeight: (edge) => edge.value || 1,
  sortBy: null
};
function Arc2(options) {
  const { y: y3, thickness, weight: weight2, marginRatio, id: id4, source, target, sourceWeight, targetWeight, sortBy: sortBy2 } = Object.assign(Object.assign({}, DEFAULT_OPTIONS2), options);
  function arc(data2) {
    const nodes = data2.nodes.map((n) => Object.assign({}, n));
    const edges = data2.edges.map((n) => Object.assign({}, n));
    preprocess(nodes, edges);
    sortNodes(nodes, edges);
    layoutNodes(nodes, edges);
    layoutEdges(nodes, edges);
    return { nodes, edges };
  }
  function preprocess(nodes, edges) {
    edges.forEach((edge) => {
      edge.source = source(edge);
      edge.target = target(edge);
      edge.sourceWeight = sourceWeight(edge);
      edge.targetWeight = targetWeight(edge);
    });
    const edgesBySource = group(edges, (e) => e.source);
    const edgesByTarget = group(edges, (e) => e.target);
    nodes.forEach((node) => {
      node.id = id4(node);
      const sources = edgesBySource.has(node.id) ? edgesBySource.get(node.id) : [];
      const targets = edgesByTarget.has(node.id) ? edgesByTarget.get(node.id) : [];
      node.frequency = sources.length + targets.length;
      node.value = sum(sources, (d3) => d3.sourceWeight) + sum(targets, (d3) => d3.targetWeight);
    });
    return { nodes, edges };
  }
  function sortNodes(nodes, edges) {
    const method = typeof sortBy2 === "function" ? sortBy2 : sort_exports[sortBy2];
    if (method) {
      nodes.sort(method);
    }
  }
  function layoutNodes(nodes, edges) {
    const size3 = nodes.length;
    if (!size3) {
      throw error("Invalid nodes: it's empty!");
    }
    if (!weight2) {
      const deltaX = 1 / size3;
      nodes.forEach((node, i) => {
        node.x = (i + 0.5) * deltaX;
        node.y = y3;
      });
      return { nodes, edges };
    }
    const margin = marginRatio / (2 * size3);
    const total = nodes.reduce((prev, node) => prev += node.value, 0);
    nodes.reduce((deltaX, node) => {
      node.weight = node.value / total;
      node.width = node.weight * (1 - marginRatio);
      node.height = thickness;
      const minX = margin + deltaX;
      const maxX = minX + node.width;
      const minY = y3 - thickness / 2;
      const maxY2 = minY + thickness;
      node.x = [minX, maxX, maxX, minX];
      node.y = [minY, minY, maxY2, maxY2];
      return deltaX + node.width + 2 * margin;
    }, 0);
    return {
      nodes,
      edges
    };
  }
  function layoutEdges(nodes, edges) {
    const nodesMap = new Map(nodes.map((d3) => [d3.id, d3]));
    if (!weight2) {
      edges.forEach((edge) => {
        const sourceId = source(edge);
        const targetId = target(edge);
        const sourceNode = nodesMap.get(sourceId);
        const targetNode = nodesMap.get(targetId);
        if (sourceNode && targetNode) {
          edge.x = [sourceNode.x, targetNode.x];
          edge.y = [sourceNode.y, targetNode.y];
        }
      });
      return { nodes, edges };
    }
    edges.forEach((edge) => {
      edge.x = [0, 0, 0, 0];
      edge.y = [y3, y3, y3, y3];
    });
    const edgesBySource = group(edges, (e) => e.source);
    const edgesByTarget = group(edges, (e) => e.target);
    nodes.forEach((node) => {
      const { edges: edges2, width, x: x3, y: y4, value: value2, id: id5 } = node;
      const sourceEdges = edgesBySource.get(id5) || [];
      const targetEdges = edgesByTarget.get(id5) || [];
      let offset2 = 0;
      sourceEdges.map((edge) => {
        const w = edge.sourceWeight / value2 * width;
        edge.x[0] = x3[0] + offset2;
        edge.x[1] = x3[0] + offset2 + w;
        offset2 += w;
      });
      targetEdges.forEach((edge) => {
        const w = edge.targetWeight / value2 * width;
        edge.x[3] = x3[0] + offset2;
        edge.x[2] = x3[0] + offset2 + w;
        offset2 += w;
      });
    });
  }
  return arc;
}

// node_modules/@antv/g2/esm/data/arc.js
var Arc3 = (options) => {
  return (data2) => {
    return Arc2(options)(data2);
  };
};
Arc3.props = {};

// node_modules/@antv/g2/esm/mark/chord.js
var __rest45 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var DEFAULT_LAYOUT_OPTIONS2 = {
  y: 0,
  thickness: 0.05,
  marginRatio: 0.1,
  id: (node) => node.key,
  source: (edge) => edge.source,
  target: (edge) => edge.target,
  sourceWeight: (edge) => edge.value || 1,
  targetWeight: (edge) => edge.value || 1,
  sortBy: null
  // optional, id | weight | frequency | {function}
};
var DEFAULT_NODE_OPTIONS2 = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "polygon",
    x: "x",
    y: "y"
  },
  scale: {
    x: { type: "identity" },
    y: { type: "identity" }
  },
  style: {
    opacity: 1,
    fillOpacity: 1,
    lineWidth: 1
  }
};
var DEFAULT_LINK_OPTIONS2 = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "ribbon",
    x: "x",
    y: "y"
  },
  style: {
    opacity: 0.5,
    lineWidth: 1
  }
};
var DEFAULT_LABEL_OPTIONS2 = {
  position: "outside",
  fontSize: 10
};
var Chord = (options, context) => {
  const { data: data2, encode = {}, scale: scale11, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {} } = options;
  const { nodes, links } = initializeData(data2, encode);
  const nodeEncode = subObject(encode, "node");
  const linkEncode = subObject(encode, "link");
  const { key: nodeKey = (d3) => d3.key, color: color3 = nodeKey } = nodeEncode;
  const { linkEncodeColor = (d3) => d3.source } = linkEncode;
  const { nodeWidthRatio = DEFAULT_LAYOUT_OPTIONS2.thickness, nodePaddingRatio = DEFAULT_LAYOUT_OPTIONS2.marginRatio } = layout, restLayout = __rest45(layout, ["nodeWidthRatio", "nodePaddingRatio"]);
  const { nodes: nodeData, edges: linkData } = Arc3(Object.assign(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS2), { id: field(nodeKey), thickness: nodeWidthRatio, marginRatio: nodePaddingRatio }), restLayout), { weight: true }))({ nodes, edges: links });
  const _a2 = subObject(style, "label"), { text = nodeKey } = _a2, labelStyle = __rest45(_a2, ["text"]);
  const nodeTooltip = subTooltip(tooltip2, "node", {
    title: "",
    items: [(d3) => ({ name: d3.key, value: d3.value })]
  }, true);
  const linkTooltip = subTooltip(tooltip2, "link", {
    title: "",
    items: [(d3) => ({ name: `${d3.source} -> ${d3.target}`, value: d3.value })]
  });
  const { height, width } = context;
  const minimumLen = Math.min(height, width);
  return [
    deep_mix_default({}, DEFAULT_LINK_OPTIONS2, {
      data: linkData,
      encode: Object.assign(Object.assign({}, linkEncode), { color: linkEncodeColor }),
      labels: linkLabels,
      style: Object.assign({ fill: linkEncodeColor ? void 0 : "#aaa" }, subObject(style, "link")),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate2, "link")
    }),
    deep_mix_default({}, DEFAULT_NODE_OPTIONS2, {
      data: nodeData,
      encode: Object.assign(Object.assign({}, nodeEncode), { color: color3 }),
      scale: scale11,
      style: subObject(style, "node"),
      coordinate: {
        type: "polar",
        // Leave enough rendering space for the label.
        outerRadius: (minimumLen - 20) / minimumLen,
        startAngle: -Math.PI * 2,
        endAngle: 0
      },
      labels: [
        Object.assign(Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS2), { text }), labelStyle),
        ...nodeLabels
      ],
      tooltip: nodeTooltip,
      animate: maybeAnimation(animate2, "node"),
      axis: false
    })
  ];
};
Chord.props = {};

// node_modules/@antv/g2/esm/mark/path.js
var shape19 = {
  path: Path3,
  hollow: Hollow2
};
var Path4 = (options) => {
  return (index3, scale11, value2, coordinate) => {
    return [index3, index3.map(() => [[0, 0]])];
  };
};
Path4.props = {
  defaultShape: "path",
  defaultLabelShape: "label",
  shape: shape19,
  composite: false,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape19) }),
    { name: "d", scale: "identity" }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference()]
};

// node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a4, b) {
  return a4.parent === b.parent ? 1 : 2;
}
function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}
function meanXReduce(x3, c5) {
  return x3 + c5.x;
}
function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}
function maxYReduce(y3, c5) {
  return Math.max(y3, c5.y);
}
function leafLeft(node) {
  var children;
  while (children = node.children)
    node = children[0];
  return node;
}
function leafRight(node) {
  var children;
  while (children = node.children)
    node = children[children.length - 1];
  return node;
}
function cluster_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
  function cluster(root2) {
    var previousNode, x3 = 0;
    root2.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x3 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left2 = leafLeft(root2), right2 = leafRight(root2), x05 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;
    return root2.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root2.x) * dx;
      node.y = (root2.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x05) / (x12 - x05) * dx;
      node.y = (1 - (root2.y ? node.y / root2.y : 1)) * dy;
    });
  }
  cluster.separation = function(x3) {
    return arguments.length ? (separation = x3, cluster) : separation;
  };
  cluster.size = function(x3) {
    return arguments.length ? (nodeSize = false, dx = +x3[0], dy = +x3[1], cluster) : nodeSize ? null : [dx, dy];
  };
  cluster.nodeSize = function(x3) {
    return arguments.length ? (nodeSize = true, dx = +x3[0], dy = +x3[1], cluster) : nodeSize ? [dx, dy] : null;
  };
  return cluster;
}

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count3(node) {
  var sum4 = 0, children = node.children, i = children && children.length;
  if (!i)
    sum4 = 1;
  else
    while (--i >= 0)
      sum4 += children[i].value;
  node.value = sum4;
}
function count_default() {
  return this.eachAfter(count3);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default2(callback, that) {
  let index3 = -1;
  for (const node of this) {
    callback.call(that, node, ++index3, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children, i, index3 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index3, this);
    if (children = node.children) {
      for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children, i, n, index3 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index3, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default2(callback, that) {
  let index3 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index3, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value2) {
  return this.eachAfter(function(node) {
    var sum4 = +value2(node.data) || 0, children = node.children, i = children && children.length;
    while (--i >= 0)
      sum4 += children[i].value;
    node.value = sum4;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k2 = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k2, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a4, b) {
  if (a4 === b)
    return a4;
  var aNodes = a4.ancestors(), bNodes = b.ancestors(), c5 = null;
  a4 = aNodes.pop();
  b = bNodes.pop();
  while (a4 === b) {
    c5 = a4;
    a4 = aNodes.pop();
    b = bNodes.pop();
  }
  return c5;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root2 = this, links = [];
  root2.each(function(node) {
    if (node !== root2) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default() {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children = node.children) {
        for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data2, children) {
  if (data2 instanceof Map) {
    data2 = [void 0, data2];
    if (children === void 0)
      children = mapChildren;
  } else if (children === void 0) {
    children = objectChildren;
  }
  var root2 = new Node2(data2), node, nodes = [root2], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node2(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d3) {
  return d3.children;
}
function mapChildren(d3) {
  return Array.isArray(d3) ? d3[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node2(data2) {
  this.data = data2;
  this.depth = this.height = 0;
  this.parent = null;
}
Node2.prototype = hierarchy.prototype = {
  constructor: Node2,
  count: count_default,
  each: each_default2,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default2,
  sum: sum_default,
  sort: sort_default,
  path: path_default,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default
};

// node_modules/d3-hierarchy/src/accessors.js
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function")
    throw new Error();
  return f;
}

// node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default2(x3) {
  return function() {
    return x3;
  };
}

// node_modules/d3-hierarchy/src/lcg.js
var a2 = 1664525;
var c = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s3 = 1;
  return () => (s3 = (a2 * s3 + c) % m) / m;
}

// node_modules/d3-hierarchy/src/array.js
function array_default2(x3) {
  return typeof x3 === "object" && "length" in x3 ? x3 : Array.from(x3);
}
function shuffle(array2, random5) {
  let m3 = array2.length, t, i;
  while (m3) {
    i = random5() * m3-- | 0;
    t = array2[m3];
    array2[m3] = array2[i];
    array2[i] = t;
  }
  return array2;
}

// node_modules/d3-hierarchy/src/pack/enclose.js
function packEncloseRandom(circles, random5) {
  var i = 0, n = (circles = shuffle(Array.from(circles), random5)).length, B4 = [], p2, e;
  while (i < n) {
    p2 = circles[i];
    if (e && enclosesWeak(e, p2))
      ++i;
    else
      e = encloseBasis(B4 = extendBasis(B4, p2)), i = 0;
  }
  return e;
}
function extendBasis(B4, p2) {
  var i, j;
  if (enclosesWeakAll(p2, B4))
    return [p2];
  for (i = 0; i < B4.length; ++i) {
    if (enclosesNot(p2, B4[i]) && enclosesWeakAll(encloseBasis2(B4[i], p2), B4)) {
      return [B4[i], p2];
    }
  }
  for (i = 0; i < B4.length - 1; ++i) {
    for (j = i + 1; j < B4.length; ++j) {
      if (enclosesNot(encloseBasis2(B4[i], B4[j]), p2) && enclosesNot(encloseBasis2(B4[i], p2), B4[j]) && enclosesNot(encloseBasis2(B4[j], p2), B4[i]) && enclosesWeakAll(encloseBasis3(B4[i], B4[j], p2), B4)) {
        return [B4[i], B4[j], p2];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a4, b) {
  var dr = a4.r - b.r, dx = b.x - a4.x, dy = b.y - a4.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a4, b) {
  var dr = a4.r - b.r + Math.max(a4.r, b.r, 1) * 1e-9, dx = b.x - a4.x, dy = b.y - a4.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a4, B4) {
  for (var i = 0; i < B4.length; ++i) {
    if (!enclosesWeak(a4, B4[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B4) {
  switch (B4.length) {
    case 1:
      return encloseBasis1(B4[0]);
    case 2:
      return encloseBasis2(B4[0], B4[1]);
    case 3:
      return encloseBasis3(B4[0], B4[1], B4[2]);
  }
}
function encloseBasis1(a4) {
  return {
    x: a4.x,
    y: a4.y,
    r: a4.r
  };
}
function encloseBasis2(a4, b) {
  var x12 = a4.x, y12 = a4.y, r1 = a4.r, x22 = b.x, y22 = b.y, r2 = b.r, x21 = x22 - x12, y21 = y22 - y12, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x12 + x22 + x21 / l * r21) / 2,
    y: (y12 + y22 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a4, b, c5) {
  var x12 = a4.x, y12 = a4.y, r1 = a4.r, x22 = b.x, y22 = b.y, r2 = b.r, x3 = c5.x, y3 = c5.y, r3 = c5.r, a22 = x12 - x22, a32 = x12 - x3, b2 = y12 - y22, b3 = y12 - y3, c22 = r2 - r1, c32 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d22 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a32 * b2 - a22 * b3, xa = (b2 * d3 - b3 * d22) / (ab * 2) - x12, xb = (b3 * c22 - b2 * c32) / ab, ya = (a32 * d22 - a22 * d3) / (ab * 2) - y12, yb = (a22 * c32 - a32 * c22) / ab, A6 = xb * xb + yb * yb - 1, B4 = 2 * (r1 + xa * xb + ya * yb), C4 = xa * xa + ya * ya - r1 * r1, r = -(Math.abs(A6) > 1e-6 ? (B4 + Math.sqrt(B4 * B4 - 4 * A6 * C4)) / (2 * A6) : C4 / B4);
  return {
    x: x12 + xa + xb * r,
    y: y12 + ya + yb * r,
    r
  };
}

// node_modules/d3-hierarchy/src/pack/siblings.js
function place(b, a4, c5) {
  var dx = b.x - a4.x, x3, a22, dy = b.y - a4.y, y3, b2, d22 = dx * dx + dy * dy;
  if (d22) {
    a22 = a4.r + c5.r, a22 *= a22;
    b2 = b.r + c5.r, b2 *= b2;
    if (a22 > b2) {
      x3 = (d22 + b2 - a22) / (2 * d22);
      y3 = Math.sqrt(Math.max(0, b2 / d22 - x3 * x3));
      c5.x = b.x - x3 * dx - y3 * dy;
      c5.y = b.y - x3 * dy + y3 * dx;
    } else {
      x3 = (d22 + a22 - b2) / (2 * d22);
      y3 = Math.sqrt(Math.max(0, a22 / d22 - x3 * x3));
      c5.x = a4.x + x3 * dx - y3 * dy;
      c5.y = a4.y + x3 * dy + y3 * dx;
    }
  } else {
    c5.x = a4.x + c5.r;
    c5.y = a4.y;
  }
}
function intersects(a4, b) {
  var dr = a4.r + b.r - 1e-6, dx = b.x - a4.x, dy = b.y - a4.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a4 = node._, b = node.next._, ab = a4.r + b.r, dx = (a4.x * b.r + b.x * a4.r) / ab, dy = (a4.y * b.r + b.y * a4.r) / ab;
  return dx * dx + dy * dy;
}
function Node3(circle3) {
  this._ = circle3;
  this.next = null;
  this.previous = null;
}
function packSiblingsRandom(circles, random5) {
  if (!(n = (circles = array_default2(circles)).length))
    return 0;
  var a4, b, c5, n, aa, ca, i, j, k2, sj, sk;
  a4 = circles[0], a4.x = 0, a4.y = 0;
  if (!(n > 1))
    return a4.r;
  b = circles[1], a4.x = -b.r, b.x = a4.r, b.y = 0;
  if (!(n > 2))
    return a4.r + b.r;
  place(b, a4, c5 = circles[2]);
  a4 = new Node3(a4), b = new Node3(b), c5 = new Node3(c5);
  a4.next = c5.previous = b;
  b.next = a4.previous = c5;
  c5.next = b.previous = a4;
  pack:
    for (i = 3; i < n; ++i) {
      place(a4._, b._, c5 = circles[i]), c5 = new Node3(c5);
      j = b.next, k2 = a4.previous, sj = b._.r, sk = a4._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c5._)) {
            b = j, a4.next = b, b.previous = a4, --i;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k2._, c5._)) {
            a4 = k2, a4.next = b, b.previous = a4, --i;
            continue pack;
          }
          sk += k2._.r, k2 = k2.previous;
        }
      } while (j !== k2.next);
      c5.previous = a4, c5.next = b, a4.next = b.previous = b = c5;
      aa = score(a4);
      while ((c5 = c5.next) !== b) {
        if ((ca = score(c5)) < aa) {
          a4 = c5, aa = ca;
        }
      }
      b = a4.next;
    }
  a4 = [b._], c5 = b;
  while ((c5 = c5.next) !== b)
    a4.push(c5._);
  c5 = packEncloseRandom(a4, random5);
  for (i = 0; i < n; ++i)
    a4 = circles[i], a4.x -= c5.x, a4.y -= c5.y;
  return c5.r;
}

// node_modules/d3-hierarchy/src/pack/index.js
function defaultRadius(d3) {
  return Math.sqrt(d3.value);
}
function pack_default() {
  var radius = null, dx = 1, dy = 1, padding = constantZero;
  function pack3(root2) {
    const random5 = lcg_default();
    root2.x = dx / 2, root2.y = dy / 2;
    if (radius) {
      root2.eachBefore(radiusLeaf(radius)).eachAfter(packChildrenRandom(padding, 0.5, random5)).eachBefore(translateChild(1));
    } else {
      root2.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildrenRandom(constantZero, 1, random5)).eachAfter(packChildrenRandom(padding, root2.r / Math.min(dx, dy), random5)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root2.r)));
    }
    return root2;
  }
  pack3.radius = function(x3) {
    return arguments.length ? (radius = optional(x3), pack3) : radius;
  };
  pack3.size = function(x3) {
    return arguments.length ? (dx = +x3[0], dy = +x3[1], pack3) : [dx, dy];
  };
  pack3.padding = function(x3) {
    return arguments.length ? (padding = typeof x3 === "function" ? x3 : constant_default2(+x3), pack3) : padding;
  };
  return pack3;
}
function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}
function packChildrenRandom(padding, k2, random5) {
  return function(node) {
    if (children = node.children) {
      var children, i, n = children.length, r = padding(node) * k2 || 0, e;
      if (r)
        for (i = 0; i < n; ++i)
          children[i].r += r;
      e = packSiblingsRandom(children, random5);
      if (r)
        for (i = 0; i < n; ++i)
          children[i].r -= r;
      node.r = e + r;
    }
  };
}
function translateChild(k2) {
  return function(node) {
    var parent = node.parent;
    node.r *= k2;
    if (parent) {
      node.x = parent.x + k2 * node.x;
      node.y = parent.y + k2 * node.y;
    }
  };
}

// node_modules/d3-hierarchy/src/treemap/round.js
function round_default(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x05, y05, x12, y12) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k2 = parent.value && (x12 - x05) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y05, node.y1 = y12;
    node.x0 = x05, node.x1 = x05 += node.value * k2;
  }
}

// node_modules/d3-hierarchy/src/partition.js
function partition_default() {
  var dx = 1, dy = 1, padding = 0, round5 = false;
  function partition2(root2) {
    var n = root2.height + 1;
    root2.x0 = root2.y0 = padding;
    root2.x1 = dx;
    root2.y1 = dy / n;
    root2.eachBefore(positionNode(dy, n));
    if (round5)
      root2.eachBefore(round_default);
    return root2;
  }
  function positionNode(dy2, n) {
    return function(node) {
      if (node.children) {
        dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
      }
      var x05 = node.x0, y05 = node.y0, x12 = node.x1 - padding, y12 = node.y1 - padding;
      if (x12 < x05)
        x05 = x12 = (x05 + x12) / 2;
      if (y12 < y05)
        y05 = y12 = (y05 + y12) / 2;
      node.x0 = x05;
      node.y0 = y05;
      node.x1 = x12;
      node.y1 = y12;
    };
  }
  partition2.round = function(x3) {
    return arguments.length ? (round5 = !!x3, partition2) : round5;
  };
  partition2.size = function(x3) {
    return arguments.length ? (dx = +x3[0], dy = +x3[1], partition2) : [dx, dy];
  };
  partition2.padding = function(x3) {
    return arguments.length ? (padding = +x3, partition2) : padding;
  };
  return partition2;
}

// node_modules/d3-hierarchy/src/stratify.js
var preroot = { depth: -1 };
var ambiguous = {};
var imputed = {};
function defaultId2(d3) {
  return d3.id;
}
function defaultParentId(d3) {
  return d3.parentId;
}
function stratify_default() {
  var id4 = defaultId2, parentId = defaultParentId, path2;
  function stratify(data2) {
    var nodes = Array.from(data2), currentId = id4, currentParentId = parentId, n, d3, i, root2, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    if (path2 != null) {
      const I = nodes.map((d4, i2) => normalize8(path2(d4, i2, data2)));
      const P = I.map(parentof);
      const S = new Set(I).add("");
      for (const i2 of P) {
        if (!S.has(i2)) {
          S.add(i2);
          I.push(i2);
          P.push(parentof(i2));
          nodes.push(imputed);
        }
      }
      currentId = (_2, i2) => I[i2];
      currentParentId = (_2, i2) => P[i2];
    }
    for (i = 0, n = nodes.length; i < n; ++i) {
      d3 = nodes[i], node = nodes[i] = new Node2(d3);
      if ((nodeId = currentId(d3, i, data2)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = currentParentId(d3, i, data2)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent)
          throw new Error("missing: " + nodeId);
        if (parent === ambiguous)
          throw new Error("ambiguous: " + nodeId);
        if (parent.children)
          parent.children.push(node);
        else
          parent.children = [node];
        node.parent = parent;
      } else {
        if (root2)
          throw new Error("multiple roots");
        root2 = node;
      }
    }
    if (!root2)
      throw new Error("no root");
    if (path2 != null) {
      while (root2.data === imputed && root2.children.length === 1) {
        root2 = root2.children[0], --n;
      }
      for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
        node = nodes[i2];
        if (node.data !== imputed)
          break;
        node.data = null;
      }
    }
    root2.parent = preroot;
    root2.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root2.parent = null;
    if (n > 0)
      throw new Error("cycle");
    return root2;
  }
  stratify.id = function(x3) {
    return arguments.length ? (id4 = optional(x3), stratify) : id4;
  };
  stratify.parentId = function(x3) {
    return arguments.length ? (parentId = optional(x3), stratify) : parentId;
  };
  stratify.path = function(x3) {
    return arguments.length ? (path2 = optional(x3), stratify) : path2;
  };
  return stratify;
}
function normalize8(path2) {
  path2 = `${path2}`;
  let i = path2.length;
  if (slash(path2, i - 1) && !slash(path2, i - 2))
    path2 = path2.slice(0, -1);
  return path2[0] === "/" ? path2 : `/${path2}`;
}
function parentof(path2) {
  let i = path2.length;
  if (i < 2)
    return "";
  while (--i > 1)
    if (slash(path2, i))
      break;
  return path2.slice(0, i);
}
function slash(path2, i) {
  if (path2[i] === "/") {
    let k2 = 0;
    while (i > 0 && path2[--i] === "\\")
      ++k2;
    if ((k2 & 1) === 0)
      return true;
  }
  return false;
}

// node_modules/d3-hierarchy/src/tree.js
function defaultSeparation2(a4, b) {
  return a4.parent === b.parent ? 1 : 2;
}
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v) {
  var shift = 0, change = 0, children = v.children, i = children.length, w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node2.prototype);
function treeRoot(root2) {
  var tree = new TreeNode(root2, 0), node, nodes = [tree], child, children, i, n;
  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default() {
  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
  function tree(root2) {
    var t = treeRoot(root2);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize)
      root2.eachBefore(sizeNode);
    else {
      var left2 = root2, right2 = root2, bottom = root2;
      root2.eachBefore(function(node) {
        if (node.x < left2.x)
          left2 = node;
        if (node.x > right2.x)
          right2 = node;
        if (node.depth > bottom.depth)
          bottom = node;
      });
      var s3 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s3 - left2.x, kx2 = dx / (right2.x + s3 + tx), ky2 = dy / (bottom.depth || 1);
      root2.eachBefore(function(node) {
        node.x = (node.x + tx) * kx2;
        node.y = node.depth * ky2;
      });
    }
    return root2;
  }
  function firstWalk(v) {
    var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x3) {
    return arguments.length ? (separation = x3, tree) : separation;
  };
  tree.size = function(x3) {
    return arguments.length ? (nodeSize = false, dx = +x3[0], dy = +x3[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x3) {
    return arguments.length ? (nodeSize = true, dx = +x3[0], dy = +x3[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x05, y05, x12, y12) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k2 = parent.value && (y12 - y05) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x05, node.x1 = x12;
    node.y0 = y05, node.y1 = y05 += node.value * k2;
  }
}

// node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x05, y05, x12, y12) {
  var rows = [], nodes = parent.children, row2, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value2 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x12 - x05, dy = y12 - y05;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row2 = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row2.dice)
      dice_default(row2, x05, y05, x12, value2 ? y05 += dy * sumValue / value2 : y12);
    else
      slice_default(row2, x05, y05, value2 ? x05 += dx * sumValue / value2 : x12, y12);
    value2 -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom8(ratio) {
  function squarify(parent, x05, y05, x12, y12) {
    squarifyRatio(ratio, parent, x05, y05, x12, y12);
  }
  squarify.ratio = function(x3) {
    return custom8((x3 = +x3) > 1 ? x3 : 1);
  };
  return squarify;
}(phi);

// node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round5 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root2) {
    root2.x0 = root2.y0 = 0;
    root2.x1 = dx;
    root2.y1 = dy;
    root2.eachBefore(positionNode);
    paddingStack = [0];
    if (round5)
      root2.eachBefore(round_default);
    return root2;
  }
  function positionNode(node) {
    var p2 = paddingStack[node.depth], x05 = node.x0 + p2, y05 = node.y0 + p2, x12 = node.x1 - p2, y12 = node.y1 - p2;
    if (x12 < x05)
      x05 = x12 = (x05 + x12) / 2;
    if (y12 < y05)
      y05 = y12 = (y05 + y12) / 2;
    node.x0 = x05;
    node.y0 = y05;
    node.x1 = x12;
    node.y1 = y12;
    if (node.children) {
      p2 = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x05 += paddingLeft(node) - p2;
      y05 += paddingTop(node) - p2;
      x12 -= paddingRight(node) - p2;
      y12 -= paddingBottom(node) - p2;
      if (x12 < x05)
        x05 = x12 = (x05 + x12) / 2;
      if (y12 < y05)
        y05 = y12 = (y05 + y12) / 2;
      tile(node, x05, y05, x12, y12);
    }
  }
  treemap.round = function(x3) {
    return arguments.length ? (round5 = !!x3, treemap) : round5;
  };
  treemap.size = function(x3) {
    return arguments.length ? (dx = +x3[0], dy = +x3[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x3) {
    return arguments.length ? (tile = required(x3), treemap) : tile;
  };
  treemap.padding = function(x3) {
    return arguments.length ? treemap.paddingInner(x3).paddingOuter(x3) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x3) {
    return arguments.length ? (paddingInner = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x3) {
    return arguments.length ? treemap.paddingTop(x3).paddingRight(x3).paddingBottom(x3).paddingLeft(x3) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x3) {
    return arguments.length ? (paddingTop = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x3) {
    return arguments.length ? (paddingRight = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x3) {
    return arguments.length ? (paddingBottom = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x3) {
    return arguments.length ? (paddingLeft = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingLeft;
  };
  return treemap;
}

// node_modules/d3-hierarchy/src/treemap/binary.js
function binary_default(parent, x05, y05, x12, y12) {
  var nodes = parent.children, i, n = nodes.length, sum4, sums = new Array(n + 1);
  for (sums[0] = sum4 = i = 0; i < n; ++i) {
    sums[i + 1] = sum4 += nodes[i].value;
  }
  partition2(0, n, parent.value, x05, y05, x12, y12);
  function partition2(i2, j, value2, x06, y06, x13, y13) {
    if (i2 >= j - 1) {
      var node = nodes[i2];
      node.x0 = x06, node.y0 = y06;
      node.x1 = x13, node.y1 = y13;
      return;
    }
    var valueOffset = sums[i2], valueTarget = value2 / 2 + valueOffset, k2 = i2 + 1, hi = j - 1;
    while (k2 < hi) {
      var mid2 = k2 + hi >>> 1;
      if (sums[mid2] < valueTarget)
        k2 = mid2 + 1;
      else
        hi = mid2;
    }
    if (valueTarget - sums[k2 - 1] < sums[k2] - valueTarget && i2 + 1 < k2)
      --k2;
    var valueLeft = sums[k2] - valueOffset, valueRight = value2 - valueLeft;
    if (x13 - x06 > y13 - y06) {
      var xk = value2 ? (x06 * valueRight + x13 * valueLeft) / value2 : x13;
      partition2(i2, k2, valueLeft, x06, y06, xk, y13);
      partition2(k2, j, valueRight, xk, y06, x13, y13);
    } else {
      var yk = value2 ? (y06 * valueRight + y13 * valueLeft) / value2 : y13;
      partition2(i2, k2, valueLeft, x06, y06, x13, yk);
      partition2(k2, j, valueRight, x06, yk, x13, y13);
    }
  }
}

// node_modules/d3-hierarchy/src/treemap/sliceDice.js
function sliceDice_default(parent, x05, y05, x12, y12) {
  (parent.depth & 1 ? slice_default : dice_default)(parent, x05, y05, x12, y12);
}

// node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = function custom9(ratio) {
  function resquarify(parent, x05, y05, x12, y12) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows, row2, nodes, i, j = -1, n, m3 = rows.length, value2 = parent.value;
      while (++j < m3) {
        row2 = rows[j], nodes = row2.children;
        for (i = row2.value = 0, n = nodes.length; i < n; ++i)
          row2.value += nodes[i].value;
        if (row2.dice)
          dice_default(row2, x05, y05, x12, value2 ? y05 += (y12 - y05) * row2.value / value2 : y12);
        else
          slice_default(row2, x05, y05, value2 ? x05 += (x12 - x05) * row2.value / value2 : x12, y12);
        value2 -= row2.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x05, y05, x12, y12);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function(x3) {
    return custom9((x3 = +x3) > 1 ? x3 : 1);
  };
  return resquarify;
}(phi);

// node_modules/@antv/g2/esm/utils/treeDataTransform.js
function generateHierarchyRoot(data2, path2) {
  if (Array.isArray(data2)) {
    return typeof path2 === "function" ? stratify_default().path(path2)(data2) : stratify_default()(data2);
  }
  return hierarchy(data2);
}
function addObjectDataPath(root2, path2 = [root2.data.name]) {
  root2.id = root2.id || root2.data.name;
  root2.path = path2;
  if (root2.children) {
    root2.children.forEach((item) => {
      item.id = `${root2.id}/${item.data.name}`;
      item.path = [...path2, item.data.name];
      addObjectDataPath(item, item.path);
    });
  }
}
function addArrayDataPath(root2) {
  const name2 = get_default(root2, ["data", "name"]);
  if (name2.replaceAll) {
    root2.path = name2.replaceAll(".", "/").split("/");
  }
  if (root2.children) {
    root2.children.forEach((item) => {
      addArrayDataPath(item);
    });
  }
}
function getTileMethod(tile, ratio) {
  const tiles = {
    treemapBinary: binary_default,
    treemapDice: dice_default,
    treemapSlice: slice_default,
    treemapSliceDice: sliceDice_default,
    treemapSquarify: squarify_default,
    treemapResquarify: resquarify_default
  };
  const tileMethod = tile === "treemapSquarify" ? tiles[tile].ratio(ratio) : tiles[tile];
  if (!tileMethod) {
    throw new TypeError("Invalid tile method!");
  }
  return tileMethod;
}
function treeDataTransform(data2, layout, encode) {
  const { value: value2 } = encode;
  const tileMethod = getTileMethod(layout.tile, layout.ratio);
  const root2 = generateHierarchyRoot(data2, layout.path);
  if (isArray(data2)) {
    addArrayDataPath(root2);
  } else {
    addObjectDataPath(root2);
  }
  value2 ? root2.sum((d3) => layout.ignoreParentValue && d3.children ? 0 : field(value2)(d3)).sort(layout.sort) : root2.count();
  treemap_default().tile(tileMethod).size(layout.size).round(layout.round).paddingInner(layout.paddingInner).paddingOuter(layout.paddingOuter).paddingTop(layout.paddingTop).paddingRight(layout.paddingRight).paddingBottom(layout.paddingBottom).paddingLeft(layout.paddingLeft)(root2);
  const nodes = root2.descendants().map((d3) => Object.assign(d3, {
    id: d3.id.replace(/^\//, ""),
    x: [d3.x0, d3.x1],
    y: [d3.y0, d3.y1]
  }));
  const filterData = nodes.filter(typeof layout.layer === "function" ? layout.layer : (d3) => d3.height === layout.layer);
  return [filterData, nodes];
}

// node_modules/@antv/g2/esm/mark/treemap.js
var __rest46 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var GET_DEFAULT_LAYOUT_OPTIONS = (width, height) => ({
  tile: "treemapSquarify",
  ratio: 0.5 * (1 + Math.sqrt(5)),
  size: [width, height],
  round: false,
  ignoreParentValue: true,
  padding: 0,
  paddingInner: 0,
  paddingOuter: 0,
  paddingTop: 0,
  paddingRight: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  sort: (a4, b) => b.value - a4.value,
  layer: 0
});
var GET_DEFAULT_OPTIONS = (width, height) => ({
  type: "rect",
  axis: false,
  encode: {
    x: "x",
    y: "y",
    key: "id",
    color: (d3) => d3.path[1]
  },
  scale: {
    x: { domain: [0, width], range: [0, 1] },
    y: { domain: [0, height], range: [0, 1] }
  },
  style: {
    stroke: "#fff"
  },
  state: {
    active: { opacity: 0.6 },
    inactive: { opacity: 1 }
  }
});
var DEFAULT_LABEL_OPTIONS3 = {
  fontSize: 10,
  text: (d3) => last(d3.path),
  position: "inside",
  fill: "#000",
  textOverflow: "clip",
  wordWrap: true,
  maxLines: 1,
  wordWrapWidth: (d3) => d3.x1 - d3.x0
};
var DEFAULT_TOOLTIP_OPTIONS = {
  title: (d3) => {
    var _a2, _b;
    return (_b = (_a2 = d3.path) === null || _a2 === void 0 ? void 0 : _a2.join) === null || _b === void 0 ? void 0 : _b.call(_a2, ".");
  },
  items: [{ field: "value" }]
};
var DEFAULT_TOOLTIP_OPTIONS_DRILL = {
  title: (d3) => last(d3.path),
  items: [{ field: "value" }]
};
var Treemap = (options, context) => {
  const { width, height, options: markOptions } = context;
  const { data: data2, encode = {}, scale: scale11, style = {}, layout = {}, labels = [], tooltip: tooltip2 = {} } = options, resOptions = __rest46(options, ["data", "encode", "scale", "style", "layout", "labels", "tooltip"]);
  const treemapDrillDown = get_default(markOptions, [
    "interaction",
    "treemapDrillDown"
  ]);
  const layoutOptions = deep_mix_default({}, GET_DEFAULT_LAYOUT_OPTIONS(width, height), layout, {
    layer: treemapDrillDown ? (d3) => {
      return d3.depth === 1;
    } : layout.layer
  });
  const [transformedData, transformedDataAll] = treeDataTransform(data2, layoutOptions, encode);
  const labelStyle = subObject(style, "label");
  return deep_mix_default({}, GET_DEFAULT_OPTIONS(width, height), Object.assign(Object.assign({
    data: transformedData,
    scale: scale11,
    style,
    labels: [
      Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS3), labelStyle),
      ...labels
    ]
  }, resOptions), { encode, tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS), axis: false }), treemapDrillDown ? {
    interaction: Object.assign(Object.assign({}, resOptions.interaction), { treemapDrillDown: treemapDrillDown ? Object.assign(Object.assign({}, treemapDrillDown), { originData: transformedDataAll, layout: layoutOptions }) : void 0 }),
    encode: Object.assign({ color: (d3) => last(d3.path) }, encode),
    tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS_DRILL)
  } : {});
};
Treemap.props = {};

// node_modules/@antv/g2/esm/mark/pack.js
var __rest47 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var GET_DEFAULT_LAYOUT_OPTIONS2 = (width, height) => ({
  size: [width, height],
  padding: 0,
  sort: (a4, b) => b.value - a4.value
});
var GET_DEFAULT_OPTIONS2 = (width, height, encode) => ({
  type: "point",
  axis: false,
  legend: false,
  scale: {
    x: { domain: [0, width] },
    y: { domain: [0, height] },
    size: { type: "identity" }
  },
  encode: {
    x: "x",
    y: "y",
    size: "r",
    shape: "point"
  },
  style: {
    fill: !encode.color ? (d3) => d3.height === 0 ? "#ddd" : "#fff" : void 0,
    stroke: !encode.color ? (d3) => d3.height === 0 ? "" : "#000" : void 0
  }
});
var DEFAULT_LABEL_OPTIONS4 = {
  text: "",
  position: "inside",
  textOverflow: "clip",
  wordWrap: true,
  maxLines: 1,
  wordWrapWidth: (d3) => d3.r * 2
};
var DEFAULT_TOOLTIP_OPTIONS2 = {
  title: (d3) => d3.data.name,
  items: [{ field: "value" }]
};
var dataTransform = (data2, layout, encode) => {
  const { value: value2 } = encode;
  const root2 = isArray(data2) ? stratify_default().path(layout.path)(data2) : hierarchy(data2);
  value2 ? root2.sum((d3) => field(value2)(d3)).sort(layout.sort) : root2.count();
  pack_default().size(layout.size).padding(layout.padding)(root2);
  return root2.descendants();
};
var Pack2 = (markOptions, context) => {
  const { width, height } = context;
  const { data: data2, encode = {}, scale: scale11 = {}, style = {}, layout = {}, labels = [], tooltip: tooltip2 = {} } = markOptions, resOptions = __rest47(markOptions, ["data", "encode", "scale", "style", "layout", "labels", "tooltip"]);
  const DEFAULT_OPTIONS8 = GET_DEFAULT_OPTIONS2(width, height, encode);
  const transformedData = dataTransform(data2, deep_mix_default({}, GET_DEFAULT_LAYOUT_OPTIONS2(width, height), layout), deep_mix_default({}, DEFAULT_OPTIONS8["encode"], encode));
  const labelStyle = subObject(style, "label");
  return deep_mix_default({}, DEFAULT_OPTIONS8, Object.assign(Object.assign({
    data: transformedData,
    encode,
    scale: scale11,
    style,
    labels: [
      Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS4), labelStyle),
      ...labels
    ]
  }, resOptions), { tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS2), axis: false }));
};
Pack2.props = {};

// node_modules/@antv/g2/esm/mark/boxplot.js
var __rest48 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function min9(I, V) {
  return min4(I, (i) => V[i]);
}
function max10(I, V) {
  return max5(I, (i) => V[i]);
}
function lower(I, V) {
  const lo = q1(I, V) * 2.5 - q3(I, V) * 1.5;
  return min4(I, (i) => V[i] >= lo ? V[i] : NaN);
}
function q1(I, V) {
  return quantile(I, 0.25, (i) => V[i]);
}
function q2(I, V) {
  return quantile(I, 0.5, (i) => V[i]);
}
function q3(I, V) {
  return quantile(I, 0.75, (i) => V[i]);
}
function upper(I, V) {
  const hi = q3(I, V) * 2.5 - q1(I, V) * 1.5;
  return max5(I, (i) => V[i] <= hi ? V[i] : NaN);
}
function OutlierY() {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y: y3, x: x3 } = encode;
    const { value: V } = y3;
    const { value: X } = x3;
    const GI = Array.from(group(I, (i) => X[+i]).values());
    const FI = GI.flatMap((I2) => {
      const lo = lower(I2, V);
      const hi = upper(I2, V);
      return I2.filter((i) => V[i] < lo || V[i] > hi);
    });
    return [FI, mark2];
  };
}
var Boxplot = (options) => {
  const { data: data2, encode, style = {}, tooltip: tooltip2 = {}, transform: transform2, animate: animate2 } = options, rest = __rest48(options, ["data", "encode", "style", "tooltip", "transform", "animate"]);
  const { point: point7 = true } = style, restStyle = __rest48(style, ["point"]);
  const { y: y3 } = encode;
  const encodeY = { y: y3, y1: y3, y2: y3, y3, y4: y3 };
  const qy = { y1: q1, y2: q2, y3: q3 };
  const boxTooltip = subTooltip(tooltip2, "box", {
    items: [
      { channel: "y", name: "min" },
      { channel: "y1", name: "q1" },
      { channel: "y2", name: "q2" },
      { channel: "y3", name: "q3" },
      { channel: "y4", name: "max" }
    ]
  }, true);
  const pointTooltip = subTooltip(tooltip2, "point", {
    title: { channel: "x" },
    items: [{ name: "outlier", channel: "y" }]
  });
  if (!point7) {
    return Object.assign({ type: "box", data: data2, transform: [
      Object.assign(Object.assign({ type: "groupX", y: min9 }, qy), { y4: max10 })
    ], encode: Object.assign(Object.assign({}, encode), encodeY), style: restStyle, tooltip: boxTooltip }, rest);
  }
  const boxStyle = subObject(restStyle, "box");
  const pointStyle = subObject(restStyle, "point");
  return [
    Object.assign({ type: "box", data: data2, transform: [
      Object.assign(Object.assign({ type: "groupX", y: lower }, qy), { y4: upper })
    ], encode: Object.assign(Object.assign({}, encode), encodeY), style: boxStyle, tooltip: boxTooltip, animate: maybeAnimation(animate2, "box") }, rest),
    // Draw outliers.
    {
      type: "point",
      data: data2,
      transform: [{ type: OutlierY }],
      encode,
      style: Object.assign({}, pointStyle),
      tooltip: pointTooltip,
      animate: maybeAnimation(animate2, "point")
    }
  ];
};
Boxplot.props = {};

// node_modules/@antv/g2/esm/mark/shape.js
var shape20 = {
  shape: Shape2
};
var Shape3 = (options) => {
  const { cartesian: cartesian3 } = options;
  if (cartesian3)
    return visualMark;
  return (index3, scale11, value2, coordinate) => {
    const { x: X, y: Y } = value2;
    const offset2 = createBandOffset(scale11, value2, options);
    const P = Array.from(index3, (i) => {
      const p2 = [+X[i], +Y[i]];
      return [coordinate.map(offset2(p2, i))];
    });
    return [index3, P];
  };
};
Shape3.props = {
  defaultShape: "shape",
  defaultLabelShape: "label",
  composite: false,
  shape: shape20,
  channels: [
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeTuple },
    { type: MaybeVisualPosition },
    { type: MaybeFunctionAttribute }
  ]
};

// node_modules/d3-force/src/center.js
function center_default(x3, y3) {
  var nodes, strength = 1;
  if (x3 == null)
    x3 = 0;
  if (y3 == null)
    y3 = 0;
  function force() {
    var i, n = nodes.length, node, sx = 0, sy = 0;
    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }
    for (sx = (sx / n - x3) * strength, sy = (sy / n - y3) * strength, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
  };
  force.x = function(_2) {
    return arguments.length ? (x3 = +_2, force) : x3;
  };
  force.y = function(_2) {
    return arguments.length ? (y3 = +_2, force) : y3;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  return force;
}

// node_modules/d3-quadtree/src/add.js
function add_default(d3) {
  const x3 = +this._x.call(null, d3), y3 = +this._y.call(null, d3);
  return add9(this.cover(x3, y3), x3, y3, d3);
}
function add9(tree, x3, y3, d3) {
  if (isNaN(x3) || isNaN(y3))
    return tree;
  var parent, node = tree._root, leaf = { data: d3 }, x05 = tree._x0, y05 = tree._y0, x12 = tree._x1, y12 = tree._y1, xm, ym, xp, yp, right2, bottom, i, j;
  if (!node)
    return tree._root = leaf, tree;
  while (node.length) {
    if (right2 = x3 >= (xm = (x05 + x12) / 2))
      x05 = xm;
    else
      x12 = xm;
    if (bottom = y3 >= (ym = (y05 + y12) / 2))
      y05 = ym;
    else
      y12 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right2]))
      return parent[i] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x3 === xp && y3 === yp)
    return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right2 = x3 >= (xm = (x05 + x12) / 2))
      x05 = xm;
    else
      x12 = xm;
    if (bottom = y3 >= (ym = (y05 + y12) / 2))
      y05 = ym;
    else
      y12 = ym;
  } while ((i = bottom << 1 | right2) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i] = leaf, tree;
}
function addAll(data2) {
  var d3, i, n = data2.length, x3, y3, xz = new Array(n), yz = new Array(n), x05 = Infinity, y05 = Infinity, x12 = -Infinity, y12 = -Infinity;
  for (i = 0; i < n; ++i) {
    if (isNaN(x3 = +this._x.call(null, d3 = data2[i])) || isNaN(y3 = +this._y.call(null, d3)))
      continue;
    xz[i] = x3;
    yz[i] = y3;
    if (x3 < x05)
      x05 = x3;
    if (x3 > x12)
      x12 = x3;
    if (y3 < y05)
      y05 = y3;
    if (y3 > y12)
      y12 = y3;
  }
  if (x05 > x12 || y05 > y12)
    return this;
  this.cover(x05, y05).cover(x12, y12);
  for (i = 0; i < n; ++i) {
    add9(this, xz[i], yz[i], data2[i]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default(x3, y3) {
  if (isNaN(x3 = +x3) || isNaN(y3 = +y3))
    return this;
  var x05 = this._x0, y05 = this._y0, x12 = this._x1, y12 = this._y1;
  if (isNaN(x05)) {
    x12 = (x05 = Math.floor(x3)) + 1;
    y12 = (y05 = Math.floor(y3)) + 1;
  } else {
    var z = x12 - x05 || 1, node = this._root, parent, i;
    while (x05 > x3 || x3 >= x12 || y05 > y3 || y3 >= y12) {
      i = (y3 < y05) << 1 | x3 < x05;
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0:
          x12 = x05 + z, y12 = y05 + z;
          break;
        case 1:
          x05 = x12 - z, y12 = y05 + z;
          break;
        case 2:
          x12 = x05 + z, y05 = y12 - z;
          break;
        case 3:
          x05 = x12 - z, y05 = y12 - z;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node;
  }
  this._x0 = x05;
  this._y0 = y05;
  this._x1 = x12;
  this._y1 = y12;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default() {
  var data2 = [];
  this.visit(function(node) {
    if (!node.length)
      do
        data2.push(node.data);
      while (node = node.next);
  });
  return data2;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x05, y05, x12, y12) {
  this.node = node;
  this.x0 = x05;
  this.y0 = y05;
  this.x1 = x12;
  this.y1 = y12;
}

// node_modules/d3-quadtree/src/find.js
function find_default3(x3, y3, radius) {
  var data2, x05 = this._x0, y05 = this._y0, x12, y12, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;
  if (node)
    quads.push(new quad_default(node, x05, y05, x32, y32));
  if (radius == null)
    radius = Infinity;
  else {
    x05 = x3 - radius, y05 = y3 - radius;
    x32 = x3 + radius, y32 = y3 + radius;
    radius *= radius;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x12 = q.x0) > x32 || (y12 = q.y0) > y32 || (x22 = q.x1) < x05 || (y22 = q.y1) < y05)
      continue;
    if (node.length) {
      var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x12, ym, xm, y22),
        new quad_default(node[1], xm, y12, x22, ym),
        new quad_default(node[0], x12, y12, xm, ym)
      );
      if (i = (y3 >= ym) << 1 | x3 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x3 - +this._x.call(null, node.data), dy = y3 - +this._y.call(null, node.data), d22 = dx * dx + dy * dy;
      if (d22 < radius) {
        var d3 = Math.sqrt(radius = d22);
        x05 = x3 - d3, y05 = y3 - d3;
        x32 = x3 + d3, y32 = y3 + d3;
        data2 = node.data;
      }
    }
  }
  return data2;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default2(d3) {
  if (isNaN(x3 = +this._x.call(null, d3)) || isNaN(y3 = +this._y.call(null, d3)))
    return this;
  var parent, node = this._root, retainer, previous, next, x05 = this._x0, y05 = this._y0, x12 = this._x1, y12 = this._y1, x3, y3, xm, ym, right2, bottom, i, j;
  if (!node)
    return this;
  if (node.length)
    while (true) {
      if (right2 = x3 >= (xm = (x05 + x12) / 2))
        x05 = xm;
      else
        x12 = xm;
      if (bottom = y3 >= (ym = (y05 + y12) / 2))
        y05 = ym;
      else
        y12 = ym;
      if (!(parent = node, node = node[i = bottom << 1 | right2]))
        return this;
      if (!node.length)
        break;
      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])
        retainer = parent, j = i;
    }
  while (node.data !== d3)
    if (!(previous = node, node = node.next))
      return this;
  if (next = node.next)
    delete node.next;
  if (previous)
    return next ? previous.next = next : delete previous.next, this;
  if (!parent)
    return this._root = next, this;
  next ? parent[i] = next : delete parent[i];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer)
      retainer[j] = node;
    else
      this._root = node;
  }
  return this;
}
function removeAll(data2) {
  for (var i = 0, n = data2.length; i < n; ++i)
    this.remove(data2[i]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default() {
  var size3 = 0;
  this.visit(function(node) {
    if (!node.length)
      do
        ++size3;
      while (node = node.next);
  });
  return size3;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q, node = this._root, child, x05, y05, x12, y12;
  if (node)
    quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x05 = q.x0, y05 = q.y0, x12 = q.x1, y12 = q.y1) && node.length) {
      var xm = (x05 + x12) / 2, ym = (y05 + y12) / 2;
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x12, y12));
      if (child = node[2])
        quads.push(new quad_default(child, x05, ym, xm, y12));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y05, x12, ym));
      if (child = node[0])
        quads.push(new quad_default(child, x05, y05, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q;
  if (this._root)
    quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x05 = q.x0, y05 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x05 + x12) / 2, ym = (y05 + y12) / 2;
      if (child = node[0])
        quads.push(new quad_default(child, x05, y05, xm, ym));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y05, x12, ym));
      if (child = node[2])
        quads.push(new quad_default(child, x05, ym, xm, y12));
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x12, y12));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX(d3) {
  return d3[0];
}
function x_default(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY(d3) {
  return d3[1];
}
function y_default(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x3, y3) {
  var tree = new Quadtree(x3 == null ? defaultX : x3, y3 == null ? defaultY : y3, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x3, y3, x05, y05, x12, y12) {
  this._x = x3;
  this._y = y3;
  this._x0 = x05;
  this._y0 = y05;
  this._x1 = x12;
  this._y1 = y12;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy7 = { data: leaf.data }, next = copy7;
  while (leaf = leaf.next)
    next = next.next = { data: leaf.data };
  return copy7;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy7 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node)
    return copy7;
  if (!node.length)
    return copy7._root = leaf_copy(node), copy7;
  nodes = [{ source: node, target: copy7._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length)
          nodes.push({ source: child, target: node.target[i] = new Array(4) });
        else
          node.target[i] = leaf_copy(child);
      }
    }
  }
  return copy7;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default;
treeProto.find = find_default3;
treeProto.remove = remove_default2;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;

// node_modules/d3-force/src/constant.js
function constant_default3(x3) {
  return function() {
    return x3;
  };
}

// node_modules/d3-force/src/jiggle.js
function jiggle_default(random5) {
  return (random5() - 0.5) * 1e-6;
}

// node_modules/d3-force/src/link.js
function index2(d3) {
  return d3.index;
}
function find5(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node)
    throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id4 = index2, strength = defaultStrength, strengths, distance7 = constant_default3(30), distances, nodes, count4, bias, random5, iterations2 = 1;
  if (links == null)
    links = [];
  function defaultStrength(link3) {
    return 1 / Math.min(count4[link3.source.index], count4[link3.target.index]);
  }
  function force(alpha) {
    for (var k2 = 0, n = links.length; k2 < iterations2; ++k2) {
      for (var i = 0, link3, source, target, x3, y3, l, b; i < n; ++i) {
        link3 = links[i], source = link3.source, target = link3.target;
        x3 = target.x + target.vx - source.x - source.vx || jiggle_default(random5);
        y3 = target.y + target.vy - source.y - source.vy || jiggle_default(random5);
        l = Math.sqrt(x3 * x3 + y3 * y3);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x3 *= l, y3 *= l;
        target.vx -= x3 * (b = bias[i]);
        target.vy -= y3 * b;
        source.vx += x3 * (b = 1 - b);
        source.vy += y3 * b;
      }
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i, n = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d3, i2) => [id4(d3, i2, nodes), d3])), link3;
    for (i = 0, count4 = new Array(n); i < m3; ++i) {
      link3 = links[i], link3.index = i;
      if (typeof link3.source !== "object")
        link3.source = find5(nodeById, link3.source);
      if (typeof link3.target !== "object")
        link3.target = find5(nodeById, link3.target);
      count4[link3.source.index] = (count4[link3.source.index] || 0) + 1;
      count4[link3.target.index] = (count4[link3.target.index] || 0) + 1;
    }
    for (i = 0, bias = new Array(m3); i < m3; ++i) {
      link3 = links[i], bias[i] = count4[link3.source.index] / (count4[link3.source.index] + count4[link3.target.index]);
    }
    strengths = new Array(m3), initializeStrength();
    distances = new Array(m3), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes)
      return;
    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }
  function initializeDistance() {
    if (!nodes)
      return;
    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance7(links[i], i, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random5 = _random;
    initialize();
  };
  force.links = function(_2) {
    return arguments.length ? (links = _2, initialize(), force) : links;
  };
  force.id = function(_2) {
    return arguments.length ? (id4 = _2, force) : id4;
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations2 = +_2, force) : iterations2;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initializeStrength(), force) : strength;
  };
  force.distance = function(_2) {
    return arguments.length ? (distance7 = typeof _2 === "function" ? _2 : constant_default3(+_2), initializeDistance(), force) : distance7;
  };
  return force;
}

// node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _2 = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _2 || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _2[t] = [];
  }
  return new Dispatch(_2);
}
function Dispatch(_2) {
  this._ = _2;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name2 = "", i = t.indexOf(".");
    if (i >= 0)
      name2 = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name: name2 };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _2 = this._, T = parseTypenames(typename + "", _2), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get(_2[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _2[t] = set7(_2[t], typename.name, callback);
      else if (callback == null)
        for (t in _2)
          _2[t] = set7(_2[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy7 = {}, _2 = this._;
    for (var t in _2)
      copy7[t] = _2[t].slice();
    return new Dispatch(copy7);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get(type, name2) {
  for (var i = 0, n = type.length, c5; i < n; ++i) {
    if ((c5 = type[i]).name === name2) {
      return c5.value;
    }
  }
}
function set7(type, name2, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name2) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type.push({ name: name2, value: callback });
  return type;
}
var dispatch_default = dispatch;

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock2 = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock2.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock2.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock2.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t22, time = Infinity;
  while (t12) {
    if (t12._call) {
      if (time > t12._time)
        time = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t22 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t22 : taskHead = t22;
    }
  }
  taskTail = t02;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout = setTimeout(wake, time - clock2.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock2.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-force/src/lcg.js
var a3 = 1664525;
var c2 = 1013904223;
var m2 = 4294967296;
function lcg_default2() {
  let s3 = 1;
  return () => (s3 = (a3 * s3 + c2) % m2) / m2;
}

// node_modules/d3-force/src/simulation.js
function x2(d3) {
  return d3.x;
}
function y2(d3) {
  return d3.y;
}
var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation_default(nodes) {
  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step2), event = dispatch_default("tick", "end"), random5 = lcg_default2();
  if (nodes == null)
    nodes = [];
  function step2() {
    tick3();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick3(iterations2) {
    var i, n = nodes.length, node;
    if (iterations2 === void 0)
      iterations2 = 1;
    for (var k2 = 0; k2 < iterations2; ++k2) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null)
          node.x += node.vx *= velocityDecay;
        else
          node.x = node.fx, node.vx = 0;
        if (node.fy == null)
          node.y += node.vy *= velocityDecay;
        else
          node.y = node.fy, node.vy = 0;
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null)
        node.x = node.fx;
      if (node.fy != null)
        node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i), angle4 = i * initialAngle;
        node.x = radius * Math.cos(angle4);
        node.y = radius * Math.sin(angle4);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize)
      force.initialize(nodes, random5);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick: tick3,
    restart: function() {
      return stepper.restart(step2), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    nodes: function(_2) {
      return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_2) {
      return arguments.length ? (alpha = +_2, simulation) : alpha;
    },
    alphaMin: function(_2) {
      return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
    },
    alphaDecay: function(_2) {
      return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
    },
    alphaTarget: function(_2) {
      return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
    },
    velocityDecay: function(_2) {
      return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_2) {
      return arguments.length ? (random5 = _2, forces.forEach(initializeForce), simulation) : random5;
    },
    force: function(name2, _2) {
      return arguments.length > 1 ? (_2 == null ? forces.delete(name2) : forces.set(name2, initializeForce(_2)), simulation) : forces.get(name2);
    },
    find: function(x3, y3, radius) {
      var i = 0, n = nodes.length, dx, dy, d22, node, closest;
      if (radius == null)
        radius = Infinity;
      else
        radius *= radius;
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x3 - node.x;
        dy = y3 - node.y;
        d22 = dx * dx + dy * dy;
        if (d22 < radius)
          closest = node, radius = d22;
      }
      return closest;
    },
    on: function(name2, _2) {
      return arguments.length > 1 ? (event.on(name2, _2), simulation) : event.on(name2);
    }
  };
}

// node_modules/d3-force/src/manyBody.js
function manyBody_default() {
  var nodes, node, random5, alpha, strength = constant_default3(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_2) {
    var i, n = nodes.length, tree = quadtree(nodes, x2, y2).visitAfter(accumulate);
    for (alpha = _2, i = 0; i < n; ++i)
      node = nodes[i], tree.visit(apply);
  }
  function initialize() {
    if (!nodes)
      return;
    var i, n = nodes.length, node2;
    strengths = new Array(n);
    for (i = 0; i < n; ++i)
      node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
  }
  function accumulate(quad) {
    var strength2 = 0, q, c5, weight2 = 0, x3, y3, i;
    if (quad.length) {
      for (x3 = y3 = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c5 = Math.abs(q.value))) {
          strength2 += q.value, weight2 += c5, x3 += c5 * q.x, y3 += c5 * q.y;
        }
      }
      quad.x = x3 / weight2;
      quad.y = y3 / weight2;
    } else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    quad.value = strength2;
  }
  function apply(quad, x12, _2, x22) {
    if (!quad.value)
      return true;
    var x3 = quad.x - node.x, y3 = quad.y - node.y, w = x22 - x12, l = x3 * x3 + y3 * y3;
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x3 === 0)
          x3 = jiggle_default(random5), l += x3 * x3;
        if (y3 === 0)
          y3 = jiggle_default(random5), l += y3 * y3;
        if (l < distanceMin2)
          l = Math.sqrt(distanceMin2 * l);
        node.vx += x3 * quad.value * alpha / l;
        node.vy += y3 * quad.value * alpha / l;
      }
      return true;
    } else if (quad.length || l >= distanceMax2)
      return;
    if (quad.data !== node || quad.next) {
      if (x3 === 0)
        x3 = jiggle_default(random5), l += x3 * x3;
      if (y3 === 0)
        y3 = jiggle_default(random5), l += y3 * y3;
      if (l < distanceMin2)
        l = Math.sqrt(distanceMin2 * l);
    }
    do
      if (quad.data !== node) {
        w = strengths[quad.data.index] * alpha / l;
        node.vx += x3 * w;
        node.vy += y3 * w;
      }
    while (quad = quad.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random5 = _random;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : strength;
  };
  force.distanceMin = function(_2) {
    return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_2) {
    return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_2) {
    return arguments.length ? (theta2 = _2 * _2, force) : Math.sqrt(theta2);
  };
  return force;
}

// node_modules/d3-force/src/x.js
function x_default2(x3) {
  var strength = constant_default3(0.1), nodes, strengths, xz;
  if (typeof x3 !== "function")
    x3 = constant_default3(x3 == null ? 0 : +x3);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : strength;
  };
  force.x = function(_2) {
    return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : x3;
  };
  return force;
}

// node_modules/d3-force/src/y.js
function y_default2(y3) {
  var strength = constant_default3(0.1), nodes, strengths, yz;
  if (typeof y3 !== "function")
    y3 = constant_default3(y3 == null ? 0 : +y3);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : strength;
  };
  force.y = function(_2) {
    return arguments.length ? (y3 = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : y3;
  };
  return force;
}

// node_modules/@antv/g2/esm/mark/forceGraph.js
var __rest49 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var DEFAULT_LAYOUT_OPTIONS3 = {
  joint: true
};
var DEFAULT_LINK_OPTIONS3 = {
  type: "link",
  axis: false,
  legend: false,
  encode: {
    x: [(d3) => d3.source.x, (d3) => d3.target.x],
    y: [(d3) => d3.source.y, (d3) => d3.target.y]
  },
  style: {
    stroke: "#999",
    strokeOpacity: 0.6
  }
};
var DEFAULT_NODE_OPTIONS3 = {
  type: "point",
  axis: false,
  legend: false,
  encode: {
    x: "x",
    y: "y",
    size: 5,
    color: "group",
    shape: "point"
  },
  style: {
    stroke: "#fff"
  }
};
var DEFAULT_LABEL_OPTIONS5 = {
  text: ""
};
function dataTransform2(data2, layout, encode) {
  const { nodes, links } = data2;
  const { joint, nodeStrength, linkStrength } = layout;
  const { nodeKey = (d3) => d3.id, linkKey = (d3) => d3.id } = encode;
  const nodeForce = manyBody_default();
  const linkForce = link_default(links).id(field(linkKey));
  typeof nodeStrength === "function" && nodeForce.strength(nodeStrength);
  typeof linkStrength === "function" && linkForce.strength(linkStrength);
  const simulation = simulation_default(nodes).force("link", linkForce).force("charge", nodeForce);
  joint ? simulation.force("center", center_default()) : simulation.force("x", x_default2()).force("y", y_default2());
  simulation.stop();
  const n = Math.ceil(Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay()));
  for (let i = 0; i < n; i++)
    simulation.tick();
  return {
    nodesData: nodes,
    linksData: links
  };
}
var ForceGraph = (options) => {
  const { data: data2, encode: e = {}, scale: scale11, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {} } = options;
  const { nodeKey = (d3) => d3.id, linkKey = (d3) => d3.id } = e, restEncode = __rest49(e, ["nodeKey", "linkKey"]);
  const encode = Object.assign({ nodeKey, linkKey }, restEncode);
  const nodeEncode = subObject(encode, "node");
  const linkEncode = subObject(encode, "link");
  const { links, nodes } = initializeData(data2, encode);
  const { nodesData, linksData } = dataTransform2({ links, nodes }, deep_mix_default({}, DEFAULT_LAYOUT_OPTIONS3, layout), encode);
  const linkTooltip = subTooltip(tooltip2, "link", {
    items: [
      (d3) => ({ name: "source", value: field(linkKey)(d3.source) }),
      (d3) => ({ name: "target", value: field(linkKey)(d3.target) })
    ]
  });
  const nodeTooltip = subTooltip(tooltip2, "node", {
    items: [(d3) => ({ name: "key", value: field(nodeKey)(d3) })]
  }, true);
  return [
    deep_mix_default({}, DEFAULT_LINK_OPTIONS3, {
      data: linksData,
      encode: linkEncode,
      labels: linkLabels,
      style: subObject(style, "link"),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate2, "link")
    }),
    deep_mix_default({}, DEFAULT_NODE_OPTIONS3, {
      data: nodesData,
      encode: Object.assign({}, nodeEncode),
      scale: scale11,
      style: subObject(style, "node"),
      tooltip: nodeTooltip,
      labels: [
        Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS5), subObject(style, "label")),
        ...nodeLabels
      ],
      animate: maybeAnimation(animate2, "link")
    })
  ];
};
ForceGraph.props = {};

// node_modules/@antv/g2/esm/data/cluster.js
var hierarchyFunction = (layoutFunction) => (options) => {
  return (data2) => {
    const { field: field3 = "value", nodeSize, separation, sortBy: sortBy2, as = ["x", "y"] } = options;
    const [x3, y3] = as;
    const root2 = hierarchy(data2, (d3) => d3.children).sum((d3) => d3[field3]).sort(sortBy2);
    const c5 = layoutFunction();
    c5.size([1, 1]);
    if (nodeSize)
      c5.nodeSize(nodeSize);
    if (separation)
      c5.separation(separation);
    c5(root2);
    const nodes = [];
    root2.each((node) => {
      node[x3] = node.x;
      node[y3] = node.y;
      node.name = node.data.name;
      nodes.push(node);
    });
    const edges = root2.links();
    edges.forEach((edge) => {
      edge[x3] = [edge.source[x3], edge.target[x3]];
      edge[y3] = [edge.source[y3], edge.target[y3]];
    });
    return { nodes, edges };
  };
};
var Cluster = (options) => {
  return hierarchyFunction(cluster_default)(options);
};
Cluster.props = {};

// node_modules/@antv/g2/esm/data/tree.js
var Tree = (options) => {
  return hierarchyFunction(tree_default)(options);
};
Tree.props = {};

// node_modules/@antv/g2/esm/mark/tree.js
var DEFAULT_LAYOUT_OPTIONS4 = {
  sortBy: (a4, b) => b.value - a4.value
};
var DEFAULT_NODE_OPTIONS4 = {
  axis: false,
  legend: false,
  type: "point",
  encode: {
    x: "x",
    y: "y",
    size: 2,
    shape: "point"
  }
};
var DEFAULT_LINK_OPTIONS4 = {
  type: "link",
  encode: {
    x: "x",
    y: "y",
    shape: "smooth"
  }
};
var DEFAULT_LABEL_OPTIONS6 = {
  text: "",
  fontSize: 10
};
var Tree2 = (options) => {
  const { data: data2, encode = {}, scale: scale11 = {}, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {} } = options;
  const valueEncode = encode === null || encode === void 0 ? void 0 : encode.value;
  const { nodes, edges } = Tree(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS4), layout), { field: valueEncode }))(data2);
  const nodeTooltip = subTooltip(tooltip2, "node", {
    title: "name",
    items: ["value"]
  }, true);
  const linkTooltip = subTooltip(tooltip2, "link", {
    title: "",
    items: [
      (d3) => ({ name: "source", value: d3.source.name }),
      (d3) => ({ name: "target", value: d3.target.name })
    ]
  });
  return [
    deep_mix_default({}, DEFAULT_LINK_OPTIONS4, {
      data: edges,
      encode: subObject(encode, "link"),
      scale: subObject(scale11, "link"),
      labels: linkLabels,
      style: Object.assign({ stroke: "#999" }, subObject(style, "link")),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate2, "link")
    }),
    deep_mix_default({}, DEFAULT_NODE_OPTIONS4, {
      data: nodes,
      scale: subObject(scale11, "node"),
      encode: subObject(encode, "node"),
      labels: [
        Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS6), subObject(style, "label")),
        ...nodeLabels
      ],
      style: Object.assign({}, subObject(style, "node")),
      tooltip: nodeTooltip,
      animate: maybeAnimation(animate2, "node")
    })
  ];
};
Tree2.props = {};

// node_modules/@antv/g2/esm/mark/wordCloud.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest50 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function initializeData2(data2, encode) {
  const { text = "text", value: value2 = "value" } = encode;
  return data2.map((d3) => Object.assign(Object.assign({}, d3), { text: d3[text], value: d3[value2] }));
}
var GET_DEFAULT_OPTIONS3 = () => ({
  axis: false,
  type: "text",
  encode: {
    x: "x",
    y: "y",
    text: "text",
    rotate: "rotate",
    fontSize: "size",
    shape: "tag"
  },
  scale: {
    x: { range: [0, 1] },
    y: { range: [0, 1] }
  },
  style: {
    fontFamily: (d3) => d3.fontFamily
  }
});
var WordCloud = (options, context) => __awaiter2(void 0, void 0, void 0, function* () {
  const { width, height } = context;
  const { data: data2, encode = {}, scale: scale11, style = {}, layout = {} } = options, resOptions = __rest50(options, ["data", "encode", "scale", "style", "layout"]);
  const initializedData = initializeData2(data2, encode);
  return deep_mix_default({}, GET_DEFAULT_OPTIONS3(), Object.assign(Object.assign({
    data: {
      value: initializedData,
      transform: [
        Object.assign({ type: "wordCloud", size: [width, height] }, layout)
      ]
    },
    encode,
    scale: scale11,
    style
  }, resOptions), { axis: false }));
});
WordCloud.props = {};

// node_modules/@antv/g2/esm/mark/gauge.js
var __rest51 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var indicatorShape = (options, context) => {
  const { shape: shape23, radius } = options, style = __rest51(options, ["shape", "radius"]);
  const pointerStyle = subObject(style, "pointer");
  const pinStyle = subObject(style, "pin");
  const { shape: pointerShape } = pointerStyle, resPointerStyle = __rest51(pointerStyle, ["shape"]);
  const { shape: pinShape } = pinStyle, resPinStyle = __rest51(pinStyle, ["shape"]);
  const { coordinate, theme } = context;
  return (points, value2) => {
    const invertedPoints = points.map((p2) => coordinate.invert(p2));
    const [startAngle, endAngle, innerRadius] = getTransformOptions(coordinate, "polar");
    const newCoordinate = coordinate.clone();
    const { color: stroke2 } = value2;
    const newTransformations = Radial({
      startAngle,
      endAngle,
      innerRadius,
      outerRadius: radius
    });
    newTransformations.push(["cartesian"]);
    newCoordinate.update({
      transformations: newTransformations
    });
    const newPoints = invertedPoints.map((p2) => newCoordinate.map(p2));
    const [x3, y3] = getOrigin(newPoints);
    const [cx, cy] = coordinate.getCenter();
    const pointerAttrs = Object.assign(Object.assign({ x1: x3, y1: y3, x2: cx, y2: cy, stroke: stroke2 }, resPointerStyle), style);
    const pinAttrs = Object.assign(Object.assign({
      cx,
      cy,
      stroke: stroke2
    }, resPinStyle), style);
    const indicatorGroup = select(new Group2());
    if (!isUnset(pointerShape)) {
      typeof pointerShape === "function" ? indicatorGroup.append(() => pointerShape(newPoints, value2, newCoordinate, theme)) : indicatorGroup.append("line").call(applyStyle, pointerAttrs).node();
    }
    if (!isUnset(pinShape)) {
      typeof pinShape === "function" ? indicatorGroup.append(() => pinShape(newPoints, value2, newCoordinate, theme)) : indicatorGroup.append("circle").call(applyStyle, pinAttrs).node();
    }
    return indicatorGroup.node();
  };
};
var DEFAULT_OPTIONS3 = {
  coordinate: {
    type: "radial",
    innerRadius: 0.9,
    outerRadius: 1,
    startAngle: -11 / 10 * Math.PI,
    endAngle: 1 / 10 * Math.PI
  },
  axis: {
    x: false
  },
  legend: false,
  tooltip: false,
  encode: {
    x: "x",
    y: "y",
    color: "color"
  },
  scale: {
    color: {
      range: ["#30BF78", "#D0D0D0"]
    }
  }
};
var DEFAULT_INDICATOR_OPTIONS = {
  style: {
    shape: indicatorShape,
    lineWidth: 4,
    pointerLineCap: "round",
    pinR: 10,
    pinFill: "#fff",
    radius: 0.6
  }
};
var DEFAULT_TEXT_OPTIONS = {
  type: "text",
  style: {
    x: "50%",
    y: "60%",
    textAlign: "center",
    textBaseline: "middle",
    fontSize: 20,
    fontWeight: 800,
    fill: "#888"
  },
  tooltip: false
};
function getGaugeData(data2) {
  if (isNumber(data2)) {
    const percent2 = Math.max(0, Math.min(data2, 1));
    return {
      percent: percent2,
      target: percent2,
      total: 1
    };
  }
  return data2;
}
function dataTransform3(data2, scale11) {
  const { name: name2 = "score", target, total, percent: percent2, thresholds = [] } = getGaugeData(data2);
  const _target = percent2 || target;
  const _total = percent2 ? 1 : total;
  const newScale = Object.assign({ y: {
    domain: [0, _total]
  } }, scale11);
  if (!thresholds.length) {
    return {
      targetData: [{ x: name2, y: _target, color: "target" }],
      totalData: [
        { x: name2, y: _target, color: "target" },
        { x: name2, y: _total - _target, color: "total" }
      ],
      target: _target,
      total: _total,
      scale: newScale
    };
  }
  return {
    targetData: [{ x: name2, y: _target, color: "target" }],
    totalData: thresholds.map((d3, i) => ({
      x: name2,
      y: i >= 1 ? d3 - thresholds[i - 1] : d3,
      color: i
    })),
    target: _target,
    total: _total,
    scale: newScale
  };
}
function getTextContent(textStyle, { target, total }) {
  const { content } = textStyle;
  return content ? content(target, total) : target.toString();
}
var Gauge = (options) => {
  const { data: data2 = {}, scale: scale11 = {}, style = {}, animate: animate2 = {}, transform: transform2 = [] } = options, resOptions = __rest51(options, ["data", "scale", "style", "animate", "transform"]);
  const { targetData, totalData, target, total, scale: newScale } = dataTransform3(data2, scale11);
  const _a2 = subObject(style, "text"), { tooltip: tooltip2 } = _a2, textStyle = __rest51(_a2, ["tooltip"]);
  const indicatorStyle = filterPrefixObject(style, ["pointer", "pin"]);
  const arcStyle = subObject(style, "arc");
  const shape23 = arcStyle.shape;
  return [
    deep_mix_default({}, DEFAULT_OPTIONS3, Object.assign({ type: "interval", transform: [{ type: "stackY" }], data: totalData, scale: newScale, style: shape23 === "round" ? Object.assign(Object.assign({}, arcStyle), { shape: Round }) : arcStyle, animate: typeof animate2 === "object" ? subObject(animate2, "arc") : animate2 }, resOptions)),
    deep_mix_default({}, DEFAULT_OPTIONS3, DEFAULT_INDICATOR_OPTIONS, Object.assign({ type: "point", data: targetData, scale: newScale, style: indicatorStyle, animate: typeof animate2 === "object" ? subObject(animate2, "indicator") : animate2 }, resOptions)),
    deep_mix_default({}, DEFAULT_TEXT_OPTIONS, {
      style: Object.assign({ text: getTextContent(textStyle, { target, total }) }, textStyle),
      tooltip: tooltip2,
      animate: typeof animate2 === "object" ? subObject(animate2, "text") : animate2
    })
  ];
};
Gauge.props = {};

// node_modules/@antv/g2/esm/mark/density.js
var shape21 = {
  density: Density
};
var Density2 = () => {
  return (index3, scale11, value2, coordinate) => {
    const { x: X, series: S } = value2;
    const Yn2 = Object.entries(value2).filter(([key]) => key.startsWith("y")).map(([, value3]) => value3);
    const SZn = Object.entries(value2).filter(([key]) => key.startsWith("size")).map(([, value3]) => value3);
    if (X === void 0 || Yn2 === void 0 || SZn === void 0) {
      throw new Error("Missing encode for x or y or size channel.");
    }
    const xScale = scale11.x;
    const series = scale11.series;
    const P = Array.from(index3, (i) => {
      const groupWidth = xScale.getBandWidth(xScale.invert(+X[i]));
      const ratio = series ? series.getBandWidth(series.invert(+(S === null || S === void 0 ? void 0 : S[i]))) : 1;
      const width = groupWidth * ratio;
      const offset2 = (+(S === null || S === void 0 ? void 0 : S[i]) || 0) * groupWidth;
      const x3 = +X[i] + offset2 + width / 2;
      const PN = [
        ...Yn2.map((_2, idx) => [x3 + +SZn[idx][i] / index3.length, +Yn2[idx][i]]),
        ...Yn2.map((_2, idx) => [
          x3 - +SZn[idx][i] / index3.length,
          +Yn2[idx][i]
        ]).reverse()
        // left
      ];
      return PN.map((p2) => coordinate.map(p2));
    });
    return [index3, P];
  };
};
Density2.props = {
  defaultShape: "density",
  defaultLabelShape: "label",
  composite: false,
  shape: shape21,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape21) }),
    { name: "x", scale: "band", required: true },
    { name: "y", required: true },
    { name: "size", required: true },
    { name: "series", scale: "band" },
    { name: "size", required: true, scale: "identity" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroY1 },
    { type: MaybeZeroX }
  ],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: { shareTooltip: true }
};

// node_modules/@antv/g2/esm/mark/heatmap.js
var shape22 = {
  heatmap: Heatmap
};
var Heatmap2 = (options) => {
  return (index3, scale11, value2, coordinate) => {
    const { x: X, y: Y, size: S, color: C4 } = value2;
    const P = Array.from(index3, (i) => {
      const r = S ? +S[i] : 40;
      return [...coordinate.map([+X[i], +Y[i]]), C4[i], r];
    });
    return [[0], [P]];
  };
};
Heatmap2.props = {
  defaultShape: "heatmap",
  defaultLabelShape: "label",
  composite: false,
  shape: shape22,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape22) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "color", scale: "identity", required: true },
    { name: "size" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroX },
    { type: MaybeZeroY }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/liquid.js
var __rest52 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var DEFAULT_OPTIONS4 = {
  axis: {
    x: false,
    y: false
  },
  legend: false,
  tooltip: false,
  encode: {
    x: "type",
    y: "percent"
  },
  scale: {
    y: {
      domain: [0, 1]
    }
  },
  style: {
    shape: Liquid
  },
  animate: {
    enter: {
      type: "fadeIn"
    }
  }
};
var DEFAULT_TEXT_OPTIONS2 = {
  type: "text",
  style: {
    x: "50%",
    y: "50%",
    textAlign: "center",
    textBaseline: "middle",
    fontSize: 20,
    fontWeight: 800,
    fill: "#888"
  },
  animate: {
    enter: {
      type: "fadeIn"
    }
  }
};
var Liquid2 = (options) => {
  const { data: data2 = {}, style = {}, animate: animate2 } = options, resOptions = __rest52(options, ["data", "style", "animate"]);
  const percent2 = Math.max(0, isNumber(data2) ? data2 : data2 === null || data2 === void 0 ? void 0 : data2.percent);
  const newData = [{ percent: percent2, type: "liquid" }];
  const contentStyle = Object.assign(Object.assign({}, subObject(style, "text")), subObject(style, "content"));
  const outline = subObject(style, "outline");
  const wave = subObject(style, "wave");
  const background = subObject(style, "background");
  return [
    deep_mix_default({}, DEFAULT_OPTIONS4, Object.assign({ type: "interval", data: newData, style: {
      liquidOptions: {
        percent: percent2,
        liquidShape: style === null || style === void 0 ? void 0 : style.shape
      },
      styleOptions: Object.assign(Object.assign({}, style), {
        outline,
        wave,
        background
      })
    }, animate: animate2 }, resOptions)),
    deep_mix_default({}, DEFAULT_TEXT_OPTIONS2, {
      style: Object.assign({ text: `${prettyNumber2(percent2 * 100)} %` }, contentStyle),
      animate: animate2
    })
  ];
};
Liquid2.props = {};

// node_modules/@antv/g2/esm/palette/category10.js
var Category10 = () => {
  return [
    "#5B8FF9",
    "#5AD8A6",
    "#5D7092",
    "#F6BD16",
    "#6F5EF9",
    "#6DC8EC",
    "#945FB9",
    "#FF9845",
    "#1E9493",
    "#FF99C3"
  ];
};
Category10.props = {};

// node_modules/@antv/g2/esm/palette/category20.js
var Category20 = () => {
  return [
    "#5B8FF9",
    "#CDDDFD",
    "#5AD8A6",
    "#CDF3E4",
    "#5D7092",
    "#CED4DE",
    "#F6BD16",
    "#FCEBB9",
    "#6F5EF9",
    "#D3CEFD",
    "#6DC8EC",
    "#D3EEF9",
    "#945FB9",
    "#DECFEA",
    "#FF9845",
    "#FFE0C7",
    "#1E9493",
    "#BBDEDE",
    "#FF99C3",
    "#FFE0ED"
  ];
};
Category20.props = {};

// node_modules/@antv/g2/esm/scale/band.js
var Band2 = (options) => {
  return new Band(options);
};
Band2.props = {};

// node_modules/@antv/g2/esm/scale/linear.js
var Linear3 = (options) => {
  return new Linear(options);
};
Linear3.props = {};

// node_modules/@antv/g2/esm/scale/ordinal.js
var Ordinal2 = (options) => {
  return new Ordinal(options);
};
Ordinal2.props = {};

// node_modules/@antv/g2/esm/scale/identity.js
var Identity2 = (options) => {
  return new Identity(options);
};
Identity2.props = {};

// node_modules/@antv/g2/esm/scale/point.js
var Point5 = (options) => {
  return new Point(options);
};
Point5.props = {};

// node_modules/@antv/g2/esm/scale/time.js
var Time2 = (options) => {
  return new Time(options);
};
Time2.props = {};

// node_modules/@antv/g2/esm/scale/log.js
var Log2 = (options) => {
  return new Log(options);
};
Log2.props = {};

// node_modules/@antv/g2/esm/scale/pow.js
var Pow2 = (options) => {
  return new Pow(options);
};
Pow2.props = {};

// node_modules/@antv/g2/esm/scale/threshold.js
var Threshold2 = (options) => {
  return new Threshold(options);
};
Threshold2.props = {};

// node_modules/@antv/g2/esm/scale/quantile.js
var Quantile2 = (options) => {
  return new Quantile(options);
};
Quantile2.props = {};

// node_modules/@antv/g2/esm/scale/quantize.js
var Quantize2 = (options) => {
  return new Quantize(options);
};
Quantize2.props = {};

// node_modules/@antv/g2/esm/scale/sqrt.js
var Sqrt2 = (options) => {
  return new Sqrt(options);
};
Sqrt2.props = {};

// node_modules/@antv/g2/esm/scale/sequential.js
var Sequential3 = (options) => {
  return new Sequential(options);
};
Sequential3.props = {};

// node_modules/@antv/g2/esm/scale/constant.js
var Constant3 = (options) => {
  return new Constant2(options);
};
Constant3.props = {};

// node_modules/@antv/g2/esm/theme/create.js
function create7({ colorDefault, colorBlack, colorWhite, colorStroke, colorBackground, padding1, padding2, padding3, alpha90, alpha65, alpha45, alpha25, alpha10, category10, category20, sizeDefault = 1, padding = "auto", margin = 16 }) {
  return {
    padding,
    margin,
    size: sizeDefault,
    color: colorDefault,
    category10,
    category20,
    enter: {
      duration: 300,
      fill: "both",
      delay: 0
    },
    update: {
      duration: 300,
      fill: "both",
      delay: 0
    },
    exit: {
      duration: 300,
      fill: "both",
      delay: 0
    },
    view: {
      viewFill: colorBackground,
      plotFill: "transparent",
      mainFill: "transparent",
      contentFill: "transparent"
    },
    line: {
      line: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 1,
        lineCap: "round"
      }
    },
    point: {
      point: {
        r: 3,
        fillOpacity: 0.95,
        lineWidth: 0
      },
      hollow: {
        r: 3,
        strokeOpacity: 0.95,
        lineWidth: 1
      },
      plus: {
        r: 3,
        strokeOpacity: 0.95,
        lineWidth: 3
      },
      diamond: {
        r: 3,
        strokeOpacity: 0.95,
        lineWidth: 1
      }
    },
    interval: {
      rect: {
        fillOpacity: 0.95
      },
      hollow: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 2
      }
    },
    area: {
      area: {
        fillOpacity: 0.85,
        lineWidth: 0
      }
    },
    polygon: {
      polygon: {
        fillOpacity: 0.95
      }
    },
    cell: {
      cell: {
        fillOpacity: 0.95
      },
      hollow: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 2
      }
    },
    rect: {
      rect: {
        fillOpacity: 0.95
      },
      hollow: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 2
      }
    },
    link: {
      link: {
        fill: "",
        strokeOpacity: 1
      }
    },
    vector: {
      vector: {
        fillOpacity: 1
      }
    },
    box: {
      box: {
        fillOpacity: 0.95,
        stroke: colorBlack,
        lineWidth: 1
      }
    },
    text: {
      text: {
        fill: "#1D2129",
        fontSize: 12,
        lineWidth: 0,
        connectorStroke: colorStroke,
        connectorStrokeOpacity: 0.45,
        connectorLineWidth: 1,
        backgroundFill: colorStroke,
        backgroundFillOpacity: 0.15,
        backgroundPadding: [2, 4],
        startMarkerSymbol: "circle",
        startMarkerSize: 4,
        endMarkerSymbol: "circle",
        endMarkerSize: 4
      },
      badge: {
        fill: "#1D2129",
        fillOpacity: 0.65,
        lineWidth: 0,
        fontSize: 10,
        textAlign: "center",
        textBaseline: "middle",
        markerFill: colorStroke,
        markerFillOpacity: 0.25,
        markerStrokeOpacity: 0
      }
    },
    lineX: {
      line: {
        stroke: colorStroke,
        strokeOpacity: 0.45,
        lineWidth: 1
      }
    },
    lineY: {
      line: {
        stroke: colorStroke,
        strokeOpacity: 0.45,
        lineWidth: 1
      }
    },
    rangeX: {
      range: {
        fill: colorStroke,
        fillOpacity: 0.15,
        lineWidth: 0
      }
    },
    rangeY: {
      range: {
        fill: colorStroke,
        fillOpacity: 0.15,
        lineWidth: 0
      }
    },
    connector: {
      connector: {
        stroke: colorStroke,
        strokeOpacity: 0.45,
        lineWidth: 1,
        connectLength1: 12,
        endMarker: true,
        endMarkerSize: 6,
        endMarkerFill: colorStroke,
        endMarkerFillOpacity: 0.95
      }
    },
    axis: {
      arrow: false,
      gridLineDash: [3, 4],
      gridLineWidth: 0.5,
      gridStroke: colorBlack,
      gridStrokeOpacity: alpha10,
      labelAlign: "horizontal",
      labelFill: colorBlack,
      labelOpacity: alpha45,
      labelFontSize: 12,
      labelFontWeight: "normal",
      labelSpacing: padding1,
      line: false,
      lineLineWidth: 0.5,
      lineStroke: colorBlack,
      lineStrokeOpacity: alpha45,
      tickLength: 4,
      tickLineWidth: 1,
      tickStroke: colorBlack,
      tickOpacity: alpha45,
      titleFill: colorBlack,
      titleOpacity: alpha90,
      titleFontSize: 12,
      titleFontWeight: "normal",
      titleSpacing: 12,
      titleTransformOrigin: "center",
      lineArrowOffset: 6,
      lineArrowSize: 6
    },
    axisTop: {
      gridDirection: "positive",
      labelDirection: "negative",
      tickDirection: "negative",
      titlePosition: "top",
      titleSpacing: 12,
      labelSpacing: 4,
      titleTextBaseline: "middle"
    },
    axisBottom: {
      gridDirection: "negative",
      labelDirection: "positive",
      tickDirection: "positive",
      titlePosition: "bottom",
      titleSpacing: 12,
      labelSpacing: 4,
      titleTextBaseline: "bottom",
      titleTransform: "translate(0, 8)"
    },
    axisLeft: {
      gridDirection: "positive",
      labelDirection: "negative",
      labelSpacing: 4,
      tickDirection: "negative",
      titlePosition: "left",
      titleSpacing: 12,
      titleTextBaseline: "middle",
      titleDirection: "vertical",
      titleTransform: "rotate(-90) translate(0, -8)",
      titleTransformOrigin: "center"
    },
    axisRight: {
      gridDirection: "negative",
      labelDirection: "positive",
      labelSpacing: 4,
      tickDirection: "positive",
      titlePosition: "right",
      titleSpacing: 12,
      titleTextBaseline: "top",
      titleDirection: "vertical",
      titleTransformOrigin: "center"
    },
    axisLinear: {
      girdClosed: true,
      gridConnect: "arc",
      gridDirection: "negative",
      gridType: "surround",
      titlePosition: "top",
      titleSpacing: 0
    },
    axisArc: {
      title: false,
      titlePosition: "inner",
      line: false,
      tick: true,
      labelSpacing: 4
    },
    axisRadar: {
      girdClosed: true,
      gridStrokeOpacity: 0.3,
      gridType: "surround",
      label: false,
      tick: false,
      titlePosition: "start"
    },
    legendCategory: {
      backgroundFill: "transparent",
      itemBackgroundFill: "transparent",
      itemLabelFill: colorBlack,
      itemLabelFillOpacity: alpha90,
      itemLabelFontSize: 12,
      itemLabelFontWeight: "normal",
      itemMarkerFillOpacity: 1,
      itemMarkerSize: 8,
      itemSpacing: [padding1, padding1],
      itemValueFill: colorBlack,
      itemValueFillOpacity: 0.65,
      itemValueFontSize: 12,
      itemValueFontWeight: "normal",
      navButtonFill: colorBlack,
      navButtonFillOpacity: 0.65,
      navPageNumFill: colorBlack,
      navPageNumFillOpacity: 0.45,
      navPageNumFontSize: 12,
      padding: 8,
      title: false,
      titleFill: colorBlack,
      titleFillOpacity: 0.65,
      titleFontSize: 12,
      titleFontWeight: "normal",
      titleSpacing: 4,
      tickStroke: colorBlack,
      tickStrokeOpacity: 0.25,
      rowPadding: padding1,
      colPadding: padding2,
      maxRows: 3,
      maxCols: 3
    },
    legendContinuous: {
      handleHeight: 12,
      handleLabelFill: colorBlack,
      handleLabelFillOpacity: alpha45,
      handleLabelFontSize: 12,
      handleLabelFontWeight: "normal",
      handleMarkerFill: colorBlack,
      handleMarkerFillOpacity: 0.6,
      handleMarkerLineWidth: 1,
      handleMarkerStroke: colorBlack,
      handleMarkerStrokeOpacity: 0.25,
      handleWidth: 10,
      labelFill: colorBlack,
      labelFillOpacity: alpha45,
      labelFontSize: 12,
      labelFontWeight: "normal",
      labelSpacing: 3,
      tick: true,
      tickLength: 12,
      ribbonSize: 12,
      ribbonFill: "#aaa",
      handle: true,
      handleLabel: false,
      handleShape: "slider",
      handleIconSize: 12 / 1.8,
      indicator: false,
      titleFontSize: 12,
      titleSpacing: 4,
      titleFontWeight: "normal",
      titleFillOpacity: alpha90,
      tickStroke: colorBlack,
      tickStrokeOpacity: alpha45
    },
    label: {
      fill: colorBlack,
      fillOpacity: 0.65,
      fontSize: 12,
      fontWeight: "normal",
      stroke: void 0,
      offset: 12,
      connectorStroke: colorBlack,
      connectorStrokeOpacity: 0.45,
      connectorLineWidth: 1,
      connectorLength: 12,
      connectorLength2: 8,
      connectorDistance: 4
    },
    innerLabel: {
      fill: colorWhite,
      fontSize: 12,
      fillOpacity: 0.85,
      fontWeight: "normal",
      stroke: void 0,
      offset: 0
    },
    htmlLabel: {
      fontSize: 12,
      opacity: 0.65,
      color: colorBlack,
      fontWeight: "normal"
    },
    slider: {
      trackSize: 16,
      trackFill: colorStroke,
      trackFillOpacity: 1,
      selectionFill: colorDefault,
      selectionFillOpacity: 0.15,
      handleIconSize: 10,
      handleIconFill: "#f7f7f7",
      handleIconFillOpacity: 1,
      handleIconStroke: colorBlack,
      handleIconStrokeOpacity: 0.25,
      handleIconLineWidth: 1,
      handleIconRadius: 2,
      handleLabelFill: colorBlack,
      handleLabelFillOpacity: 0.45,
      handleLabelFontSize: 12,
      handleLabelFontWeight: "normal"
    },
    scrollbar: {
      padding: [0, 0, 0, 0],
      trackSize: 6,
      isRound: true,
      slidable: true,
      scrollable: true,
      trackFill: "#e5e5e5",
      trackFillOpacity: 0,
      thumbFill: "#000",
      thumbFillOpacity: 0.15,
      thumbHighlightedFillOpacity: 0.2
    },
    title: {
      spacing: 8,
      titleFill: colorBlack,
      titleFillOpacity: alpha90,
      titleFontSize: 16,
      titleFontWeight: "bold",
      titleTextBaseline: "top",
      subtitleFill: colorBlack,
      subtitleFillOpacity: alpha65,
      subtitleFontSize: 12,
      subtitleFontWeight: "normal",
      subtitleTextBaseline: "top"
    },
    tooltip: {
      css: {
        ".g2-tooltip": {
          "font-family": "sans-serif"
        }
      }
    }
  };
}

// node_modules/@antv/g2/esm/theme/light.js
var tokens = {
  colorBlack: "#1D2129",
  colorWhite: "#ffffff",
  colorStroke: "#416180",
  colorDefault: "#1783FF",
  colorBackground: "transparent",
  category10: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F"
  ],
  category20: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F",
    "#AABA01",
    "#BC7CFC",
    "#237CBC",
    "#2DE379",
    "#CE8032",
    "#FF7AF4",
    "#545FD3",
    "#AFE410",
    "#D8C608",
    "#FFA1E0"
  ],
  padding1: 8,
  padding2: 12,
  padding3: 20,
  alpha90: 0.9,
  alpha65: 0.65,
  alpha45: 0.45,
  alpha25: 0.25,
  alpha10: 0.1
};
var defaults = create7(tokens);
var Light = (options) => {
  return deep_mix_default({}, defaults, options);
};
Light.props = {};

// node_modules/@antv/g2/esm/theme/classic.js
var Classic = (options) => {
  return deep_mix_default({}, Light(), {
    category10: "category10",
    category20: "category20"
  }, options);
};
Classic.props = {};

// node_modules/@antv/g2/esm/theme/dark.js
var tokens2 = {
  colorBlack: "#fff",
  colorWhite: "#000",
  colorStroke: "#416180",
  colorDefault: "#1783FF",
  colorBackground: "transparent",
  category10: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F"
  ],
  category20: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F",
    "#AABA01",
    "#BC7CFC",
    "#237CBC",
    "#2DE379",
    "#CE8032",
    "#FF7AF4",
    "#545FD3",
    "#AFE410",
    "#D8C608",
    "#FFA1E0"
  ],
  padding1: 8,
  padding2: 12,
  padding3: 20,
  alpha90: 0.9,
  alpha65: 0.65,
  alpha45: 0.45,
  alpha25: 0.25,
  alpha10: 0.25
};
var defaults2 = create7(tokens2);
var Dark = (options) => {
  return deep_mix_default({}, defaults2, {
    tooltip: {
      crosshairsStroke: "#fff",
      crosshairsLineWidth: 1,
      crosshairsStrokeOpacity: 0.25,
      css: {
        ".g2-tooltip": {
          background: "#1f1f1f",
          opacity: 0.95
        },
        ".g2-tooltip-title": {
          color: "#A6A6A6"
        },
        ".g2-tooltip-list-item-name-label": {
          color: "#A6A6A6"
        },
        ".g2-tooltip-list-item-value": {
          color: "#A6A6A6"
        }
      }
    }
  }, options);
};

// node_modules/@antv/g2/esm/theme/classicDark.js
var ClassicDark = (options) => {
  return Object.assign({}, Dark(), {
    category10: "category10",
    category20: "category20"
  }, options);
};
ClassicDark.props = {};

// node_modules/@antv/g2/esm/theme/academy.js
var tokens3 = {
  colorBlack: "#000",
  colorWhite: "#fff",
  colorStroke: "#888",
  colorDefault: "#4e79a7",
  colorBackground: "transparent",
  category10: [
    "#4e79a7",
    "#f28e2c",
    "#e15759",
    "#76b7b2",
    "#59a14f",
    "#edc949",
    "#af7aa1",
    "#ff9da7",
    "#9c755f",
    "#bab0ab"
  ],
  category20: [
    "#4e79a7",
    "#f28e2c",
    "#e15759",
    "#76b7b2",
    "#59a14f",
    "#edc949",
    "#af7aa1",
    "#ff9da7",
    "#9c755f",
    "#bab0ab"
  ],
  padding1: 8,
  padding2: 12,
  padding3: 20,
  alpha90: 0.9,
  alpha65: 0.65,
  alpha45: 0.45,
  alpha25: 0.25,
  alpha10: 0.1
};
var defaults3 = create7(tokens3);
var Academy = (options) => {
  return deep_mix_default({}, defaults3, {
    text: { text: { fontSize: 10 } },
    axis: {
      gridLineDash: [0, 0],
      gridLineWidth: 1,
      gridStroke: "#ddd",
      gridStrokeOpacity: 1,
      labelOpacity: 1,
      labelStrokeOpacity: 1,
      labelFontSize: 10,
      line: true,
      lineLineWidth: 1,
      lineStroke: "#888",
      lineStrokeOpacity: 1,
      tickLength: 5,
      tickStrokeOpacity: 1,
      titleOpacity: 1,
      titleStrokeOpacity: 1,
      titleFillOpacity: 1,
      titleFontSize: 11,
      titleFontWeight: "bold"
    },
    axisLeft: {
      gridFilter: (_2, i) => i !== 0
    },
    axisRight: {
      gridFilter: (_2, i) => i !== 0
    },
    legendCategory: {
      itemLabelFillOpacity: 1,
      itemLabelFontSize: 10,
      itemValueFillOpacity: 1,
      itemValueFontSize: 10,
      titleFillOpacity: 1,
      titleFontSize: 11,
      titleFontWeight: "bold"
    },
    legendContinuous: {
      handleLabelFontSize: 10,
      labelFillOpacity: 0.45,
      labelFontSize: 10
    },
    label: {
      fontSize: 10
    },
    innerLabel: {
      fontSize: 10
    },
    htmlLabel: {
      fontSize: 10
    },
    slider: {
      handleLabelFontSize: 10,
      trackFillOpacity: 0.05
    }
  }, options);
};
Academy.props = {};

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x3) {
  return Math.abs(x3 = Math.round(x3)) >= 1e21 ? x3.toLocaleString("en").replace(/,/g, "") : x3.toString(10);
}
function formatDecimalParts(x3, p2) {
  if ((i = (x3 = p2 ? x3.toExponential(p2 - 1) : x3.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x3.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x3.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x3) {
  return x3 = formatDecimalParts(Math.abs(x3)), x3 ? x3[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value2, width) {
    var i = value2.length, t = [], j = 0, g = grouping[0], length5 = 0;
    while (i > 0 && g > 0) {
      if (length5 + g + 1 > width)
        g = Math.max(1, width - length5);
      t.push(value2.substring(i -= g, i + g));
      if ((length5 += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value2) {
    return value2.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s3) {
  out:
    for (var n = s3.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s3[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s3[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s3.slice(0, i0) + s3.slice(i1 + 1) : s3;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x3, p2) {
  var d3 = formatDecimalParts(x3, p2);
  if (!d3)
    return x3 + "";
  var coefficient = d3[0], exponent = d3[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x3, Math.max(0, p2 + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x3, p2) {
  var d3 = formatDecimalParts(x3, p2);
  if (!d3)
    return x3 + "";
  var coefficient = d3[0], exponent = d3[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x3, p2) => (x3 * 100).toFixed(p2),
  "b": (x3) => Math.round(x3).toString(2),
  "c": (x3) => x3 + "",
  "d": formatDecimal_default,
  "e": (x3, p2) => x3.toExponential(p2),
  "f": (x3, p2) => x3.toFixed(p2),
  "g": (x3, p2) => x3.toPrecision(p2),
  "o": (x3) => Math.round(x3).toString(8),
  "p": (x3, p2) => formatRounded_default(x3 * 100, p2),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x3) => Math.round(x3).toString(16).toUpperCase(),
  "x": (x3) => Math.round(x3).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default3(x3) {
  return x3;
}

// node_modules/d3-format/src/locale.js
var map3 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale2) {
  var group3 = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default3 : formatGroup_default(map3.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default3 : formatNumerals_default(map3.call(locale2.numerals, String)), percent2 = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "−" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol = specifier.symbol, zero5 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n")
      comma = true, type = "g";
    else if (!formatTypes_default[type])
      precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero5 || fill === "0" && align === "=")
      zero5 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent2 : "";
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format3(value2) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c5;
      if (type === "c") {
        valueSuffix = formatType(value2) + valueSuffix;
        value2 = "";
      } else {
        value2 = +value2;
        var valueNegative = value2 < 0 || 1 / value2 < 0;
        value2 = isNaN(value2) ? nan : formatType(Math.abs(value2), precision);
        if (trim)
          value2 = formatTrim_default(value2);
        if (valueNegative && +value2 === 0 && sign3 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value2.length;
          while (++i < n) {
            if (c5 = value2.charCodeAt(i), 48 > c5 || c5 > 57) {
              valueSuffix = (c5 === 46 ? decimal + value2.slice(i + 1) : value2.slice(i)) + valueSuffix;
              value2 = value2.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero5)
        value2 = group3(value2, Infinity);
      var length5 = valuePrefix.length + value2.length + valueSuffix.length, padding = length5 < width ? new Array(width - length5 + 1).join(fill) : "";
      if (comma && zero5)
        value2 = group3(padding + value2, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value2 = valuePrefix + value2 + valueSuffix + padding;
          break;
        case "=":
          value2 = valuePrefix + padding + value2 + valueSuffix;
          break;
        case "^":
          value2 = padding.slice(0, length5 = padding.length >> 1) + valuePrefix + value2 + valueSuffix + padding.slice(length5);
          break;
        default:
          value2 = padding + valuePrefix + value2 + valueSuffix;
          break;
      }
      return numerals(value2);
    }
    format3.toString = function() {
      return specifier + "";
    };
    return format3;
  }
  function formatPrefix2(specifier, value2) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value2) / 3))) * 3, k2 = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value3) {
      return f(k2 * value3) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format2;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format2 = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/@antv/g2/esm/component/utils.js
var __rest53 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function createComponent(descriptor) {
  return class extends CustomElement {
    constructor(config) {
      super(config);
      this.descriptor = descriptor;
    }
    connectedCallback() {
      var _a2, _b;
      (_b = (_a2 = this.descriptor).render) === null || _b === void 0 ? void 0 : _b.call(_a2, this.attributes, this);
    }
    update(cfg = {}) {
      var _a2, _b;
      this.attr(deep_mix_default({}, this.attributes, cfg));
      (_b = (_a2 = this.descriptor).render) === null || _b === void 0 ? void 0 : _b.call(_a2, this.attributes, this);
    }
  };
}
function maybeAppend2(parent, selector, node) {
  if (!parent.querySelector(selector)) {
    return select(parent).append(node);
  }
  return select(parent).select(selector);
}
function titleContent(field3) {
  return Array.isArray(field3) ? field3.join(", ") : `${field3 || ""}`;
}
function inferComponentLayout(position, userDefinitions) {
  const preset = {
    display: "flex",
    flexDirection: "row",
    justifyContent: "flex-start",
    alignItems: "center"
  };
  let { flexDirection, justifyContent, alignItems } = preset;
  const layout = {
    top: ["row", "flex-start", "center"],
    bottom: ["row", "flex-start", "center"],
    left: ["column", "flex-start", "center"],
    right: ["column", "flex-start", "center"],
    center: ["column", "center", "center"]
  };
  if (position in layout) {
    [flexDirection, justifyContent, alignItems] = layout[position];
  }
  return Object.assign({
    display: "flex",
    flexDirection,
    justifyContent,
    alignItems
  }, userDefinitions);
}
var G2Layout = class extends Layout {
  get child() {
    var _a2;
    return (_a2 = this.children) === null || _a2 === void 0 ? void 0 : _a2[0];
  }
  update(options) {
    var _a2;
    this.attr(options);
    const { subOptions } = options;
    (_a2 = this.child) === null || _a2 === void 0 ? void 0 : _a2.update(subOptions);
  }
};
var LegendCategoryLayout = class extends G2Layout {
  update(options) {
    var _a2;
    const { subOptions } = options;
    this.attr(options);
    (_a2 = this.child) === null || _a2 === void 0 ? void 0 : _a2.update(subOptions);
  }
};
function scaleOf(scales, type) {
  var _a2;
  return (_a2 = scales.filter((s3) => s3.getOptions().name === type)) === null || _a2 === void 0 ? void 0 : _a2[0];
}
function isHorizontal2(orientation) {
  return orientation === "horizontal" || orientation === 0;
}
function isVertical(orientation) {
  return orientation === "vertical" || orientation === -Math.PI / 2;
}
function inferComponentShape(value2, options, component) {
  const { bbox } = value2;
  const { position = "top", size: userDefinedSize, length: userDefinedLength } = options;
  const isHorizontal3 = ["top", "bottom", "center"].includes(position);
  const [bboxSize, bboxLength] = isHorizontal3 ? [bbox.height, bbox.width] : [bbox.width, bbox.height];
  const { defaultSize, defaultLength } = component.props;
  const size3 = userDefinedSize || defaultSize || bboxSize;
  const length5 = userDefinedLength || defaultLength || bboxLength;
  const orientation = isHorizontal3 ? "horizontal" : "vertical";
  const [width, height] = isHorizontal3 ? [length5, size3] : [size3, length5];
  return {
    orientation,
    width,
    height,
    size: size3,
    length: length5
  };
}
function domainOf2(scales) {
  return scales.find((scale11) => scale11.getOptions().domain.length > 0).getOptions().domain;
}
function adaptor(style) {
  const reservedKeys = [
    "arrow",
    "crosshairs",
    "grid",
    "handle",
    "handleLabel",
    "indicator",
    "label",
    "line",
    "tick",
    "tip",
    "title",
    "trunc"
  ];
  const { style: styles } = style, rest = __rest53(style, ["style"]);
  const finalStyle = {};
  Object.entries(rest).forEach(([key, value2]) => {
    if (reservedKeys.includes(key)) {
      finalStyle[`show${upper_first_default(key)}`] = value2;
    } else
      finalStyle[key] = value2;
  });
  return Object.assign(Object.assign({}, finalStyle), styles);
}

// node_modules/@antv/g2/esm/component/axis.js
var __rest54 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function rotateAxis(axis, options) {
  const { eulerAngles, origin } = options;
  if (origin) {
    axis.setOrigin(origin);
  }
  if (eulerAngles) {
    axis.rotate(eulerAngles[0], eulerAngles[1], eulerAngles[2]);
  }
}
function sizeOf(coordinate) {
  const { innerWidth, innerHeight, depth } = coordinate.getOptions();
  return [innerWidth, innerHeight, depth];
}
function createFisheye(position, coordinate) {
  const { width, height } = coordinate.getOptions();
  return (tick3) => {
    if (!isFisheye(coordinate))
      return tick3;
    const tickPoint = position === "bottom" ? [tick3, 1] : [0, tick3];
    const vector = coordinate.map(tickPoint);
    if (position === "bottom") {
      const v = vector[0];
      const x3 = new Linear({
        domain: [0, width],
        range: [0, 1]
      });
      return x3.map(v);
    } else if (position === "left") {
      const v = vector[1];
      const x3 = new Linear({
        domain: [0, height],
        range: [0, 1]
      });
      return x3.map(v);
    }
    return tick3;
  };
}
function ticksOf(scale11, domain, tickMethod) {
  if (scale11.getTicks)
    return scale11.getTicks();
  if (!tickMethod)
    return domain;
  const [min10, max11] = extent(domain, (d3) => +d3);
  const { tickCount } = scale11.getOptions();
  return tickMethod(min10, max11, tickCount);
}
function createInset(position, coordinate) {
  if (isPolar(coordinate))
    return (d3) => d3;
  const options = coordinate.getOptions();
  const { innerWidth, innerHeight, insetTop, insetBottom, insetLeft, insetRight } = options;
  const [start, end, size3] = position === "left" || position === "right" ? [insetTop, insetBottom, innerHeight] : [insetLeft, insetRight, innerWidth];
  const x3 = new Linear({
    domain: [0, 1],
    range: [start / size3, 1 - end / size3]
  });
  return (i) => x3.map(i);
}
function getData2(scale11, domain, tickCount, defaultTickFormatter, tickFilter, tickMethod, position, coordinate) {
  var _a2;
  if (tickCount !== void 0 || tickMethod !== void 0) {
    scale11.update(Object.assign(Object.assign({}, tickCount && { tickCount }), tickMethod && { tickMethod }));
  }
  const ticks2 = ticksOf(scale11, domain, tickMethod);
  const filteredTicks = tickFilter ? ticks2.filter(tickFilter) : ticks2;
  const toString5 = (d3) => d3 instanceof Date ? String(d3) : typeof d3 === "object" && !!d3 ? d3 : String(d3);
  const labelFormatter2 = defaultTickFormatter || ((_a2 = scale11.getFormatter) === null || _a2 === void 0 ? void 0 : _a2.call(scale11)) || toString5;
  const applyInset = createInset(position, coordinate);
  const applyFisheye = createFisheye(position, coordinate);
  const isHorizontal3 = (position2) => ["top", "bottom", "center", "outer"].includes(position2);
  const isVertical2 = (position2) => ["left", "right"].includes(position2);
  if (isPolar(coordinate) || isTranspose(coordinate)) {
    return filteredTicks.map((d3, i, array2) => {
      var _a3, _b;
      const offset2 = ((_a3 = scale11.getBandWidth) === null || _a3 === void 0 ? void 0 : _a3.call(scale11, d3)) / 2 || 0;
      const tick3 = applyInset(scale11.map(d3) + offset2);
      const shouldReverse = isRadial(coordinate) && position === "center" || isTranspose(coordinate) && ((_b = scale11.getTicks) === null || _b === void 0 ? void 0 : _b.call(scale11)) && isHorizontal3(position) || isTranspose(coordinate) && isVertical2(position);
      return {
        value: shouldReverse ? 1 - tick3 : tick3,
        label: toString5(labelFormatter2(prettyNumber2(d3), i, array2)),
        id: String(i)
      };
    });
  }
  return filteredTicks.map((d3, i, array2) => {
    var _a3;
    const offset2 = ((_a3 = scale11.getBandWidth) === null || _a3 === void 0 ? void 0 : _a3.call(scale11, d3)) / 2 || 0;
    const tick3 = applyFisheye(applyInset(scale11.map(d3) + offset2));
    const shouldReverse = isVertical2(position);
    return {
      value: shouldReverse ? 1 - tick3 : tick3,
      label: toString5(labelFormatter2(prettyNumber2(d3), i, array2)),
      id: String(i)
    };
  });
}
function inferGridLength(position, coordinate, plane = "xy") {
  const [width, height, depth] = sizeOf(coordinate);
  if (plane === "xy") {
    if (position.includes("bottom") || position.includes("top"))
      return height;
    return width;
  } else if (plane === "xz") {
    if (position.includes("bottom") || position.includes("top"))
      return depth;
    return width;
  } else {
    if (position.includes("bottom") || position.includes("top"))
      return height;
    return depth;
  }
}
function inferLabelOverlap(transform2 = [], style) {
  if (transform2.length > 0)
    return transform2;
  const { labelAutoRotate, labelAutoHide, labelAutoEllipsis, labelAutoWrap } = style;
  const finalTransforms = [];
  const addToTransforms = (overlap, state) => {
    if (state) {
      finalTransforms.push(Object.assign(Object.assign({}, overlap), state));
    }
  };
  addToTransforms({
    type: "rotate",
    optionalAngles: [0, 15, 30, 45, 60, 90]
  }, labelAutoRotate);
  addToTransforms({ type: "ellipsis", minLength: 20 }, labelAutoEllipsis);
  addToTransforms({ type: "hide" }, labelAutoHide);
  addToTransforms({ type: "wrap", wordWrapWidth: 100, maxLines: 3, recoveryWhenFail: true }, labelAutoWrap);
  return finalTransforms;
}
function inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate) {
  const { x: x3, y: y3, width, height } = bbox;
  const center2 = [x3 + width / 2, y3 + height / 2];
  const radius = Math.min(width, height) / 2;
  const [startAngle, endAngle] = angleOf(coordinate);
  const [w, h] = sizeOf(coordinate);
  const r = Math.min(w, h) / 2;
  const common = {
    center: center2,
    radius,
    startAngle,
    endAngle,
    gridLength: (outerRadius - innerRadius) * r
  };
  if (position === "inner") {
    const { insetLeft, insetTop } = coordinate.getOptions();
    return Object.assign(Object.assign({}, common), { center: [center2[0] - insetLeft, center2[1] - insetTop], labelAlign: "perpendicular", labelDirection: "positive", tickDirection: "positive", gridDirection: "negative" });
  }
  return Object.assign(Object.assign({}, common), { labelAlign: "parallel", labelDirection: "negative", tickDirection: "negative", gridDirection: "positive" });
}
function inferGrid(value2, coordinate, scale11) {
  if (isTheta(coordinate) || isParallel(coordinate))
    return false;
  return value2 === void 0 ? !!scale11.getTicks : value2;
}
function infer3DAxisLinearOverrideStyle(coordinate) {
  const { depth } = coordinate.getOptions();
  return depth ? {
    tickIsBillboard: true,
    lineIsBillboard: true,
    labelIsBillboard: true,
    titleIsBillboard: true,
    gridIsBillboard: true
  } : {};
}
function inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate, xScale) {
  const { x: x3, y: y3, width, height } = bbox;
  if (position === "bottom") {
    return { startPos: [x3, y3], endPos: [x3 + width, y3] };
  }
  if (position === "left") {
    return { startPos: [x3 + width, y3 + height], endPos: [x3 + width, y3] };
  }
  if (position === "right") {
    return { startPos: [x3, y3 + height], endPos: [x3, y3] };
  }
  if (position === "top") {
    return { startPos: [x3, y3 + height], endPos: [x3 + width, y3 + height] };
  }
  if (position === "center") {
    if (orientation === "vertical") {
      return {
        startPos: [x3, y3],
        endPos: [x3, y3 + height]
      };
    } else if (orientation === "horizontal") {
      return {
        startPos: [x3, y3],
        endPos: [x3 + width, y3]
      };
    } else if (typeof orientation === "number") {
      const [cx, cy] = coordinate.getCenter();
      const [innerRadius, outerRadius] = radiusOf(coordinate);
      const [startAngle, endAngle] = angleOf(coordinate);
      const r = Math.min(width, height) / 2;
      const { insetLeft, insetTop } = coordinate.getOptions();
      const innerR = innerRadius * r;
      const outerR = outerRadius * r;
      const [actualCx, actualCy] = [cx + x3 - insetLeft, cy + y3 - insetTop];
      const [cos3, sin3] = [Math.cos(orientation), Math.sin(orientation)];
      const startPos = [
        actualCx + outerR * cos3,
        actualCy + outerR * sin3
      ];
      const endPos = [
        actualCx + innerR * cos3,
        actualCy + innerR * sin3
      ];
      const getAxisXDomainLength = () => {
        const { domain } = xScale.getOptions();
        return domain.length;
      };
      const controllAngleCount = isPolar(coordinate) && xScale ? getAxisXDomainLength() : 3;
      return {
        startPos,
        endPos,
        gridClosed: Math.abs(endAngle - startAngle - 360) < 1e-6,
        gridCenter: [actualCx, actualCy],
        gridControlAngles: new Array(controllAngleCount).fill(0).map((d3, i, arr) => (endAngle - startAngle) / controllAngleCount * i)
      };
    }
  }
  return {};
}
var ArcAxisComponent = (options) => {
  const { order, size: size3, position, orientation, labelFormatter: labelFormatter2, tickFilter, tickCount, tickMethod, important = {}, style = {}, indexBBox, title, grid: grid2 = false } = options, rest = __rest54(options, ["order", "size", "position", "orientation", "labelFormatter", "tickFilter", "tickCount", "tickMethod", "important", "style", "indexBBox", "title", "grid"]);
  return ({ scales: [scale11], value: value2, coordinate, theme }) => {
    const { bbox } = value2;
    const { domain } = scale11.getOptions();
    const data2 = getData2(scale11, domain, tickCount, labelFormatter2, tickFilter, tickMethod, position, coordinate);
    const labels = indexBBox ? data2.map((d3, i) => {
      const bbox2 = indexBBox.get(i);
      if (!bbox2)
        return d3;
      if (bbox2[0] !== d3.label)
        return d3;
      return Object.assign(Object.assign({}, d3), { bbox: bbox2[1] });
    }) : data2;
    const [innerRadius, outerRadius] = radiusOf(coordinate);
    const defaultStyle2 = inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate);
    const { axis: axisTheme, axisArc = {} } = theme;
    const finalStyle = adaptor(deep_mix_default({}, axisTheme, axisArc, defaultStyle2, Object.assign(Object.assign({ type: "arc", data: labels, titleText: titleContent(title), grid: grid2 }, rest), important)));
    return new Axis({
      // @fixme transform is not valid for arcAxis.
      // @ts-ignore
      style: omit_default(finalStyle, ["transform"])
    });
  };
};
function inferThemeStyle(scale11, coordinate, theme, direction3, position, orientation) {
  const baseStyle = theme.axis;
  const positionStyle = ["top", "right", "bottom", "left"].includes(position) ? theme[`axis${capitalizeFirst(position)}`] : theme.axisLinear;
  const channel = scale11.getOptions().name;
  const channelStyle = theme[`axis${upper_first_default(channel)}`] || {};
  return Object.assign({}, baseStyle, positionStyle, channelStyle);
}
function inferDefaultStyle(scale11, coordinate, theme, direction3, position, orientation) {
  const themeStyle = inferThemeStyle(scale11, coordinate, theme, direction3, position, orientation);
  if (position === "center") {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, themeStyle), { labelDirection: direction3 === "right" ? "negative" : "positive" }), direction3 === "center" ? { labelTransform: "translate(50%,0)" } : null), { tickDirection: direction3 === "right" ? "negative" : "positive", labelSpacing: direction3 === "center" ? 0 : 4, titleSpacing: isVertical(orientation) ? 10 : 0, tick: direction3 === "center" ? false : void 0 });
  }
  return themeStyle;
}
var LinearAxisComponent = (options) => {
  const { direction: direction3 = "left", important = {}, labelFormatter: labelFormatter2, order, orientation, actualPosition, position, size: size3, style = {}, title, tickCount, tickFilter, tickMethod, transform: transform2, indexBBox } = options, userDefinitions = __rest54(options, ["direction", "important", "labelFormatter", "order", "orientation", "actualPosition", "position", "size", "style", "title", "tickCount", "tickFilter", "tickMethod", "transform", "indexBBox"]);
  return ({ scales, value: value2, coordinate, theme }) => {
    const { bbox } = value2;
    const [scale11] = scales;
    const { domain, xScale } = scale11.getOptions();
    const defaultStyle2 = inferDefaultStyle(scale11, coordinate, theme, direction3, position, orientation);
    const internalAxisStyle = Object.assign(Object.assign(Object.assign({}, defaultStyle2), style), userDefinitions);
    const gridLength = inferGridLength(actualPosition || position, coordinate, options.plane);
    const overrideStyle = inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate, xScale);
    const threeDOverrideStyle = infer3DAxisLinearOverrideStyle(coordinate);
    const data2 = getData2(scale11, domain, tickCount, labelFormatter2, tickFilter, tickMethod, position, coordinate);
    const labels = indexBBox ? data2.map((d3, i) => {
      const bbox2 = indexBBox.get(i);
      if (!bbox2)
        return d3;
      if (bbox2[0] !== d3.label)
        return d3;
      return Object.assign(Object.assign({}, d3), { bbox: bbox2[1] });
    }) : data2;
    const finalAxisStyle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, internalAxisStyle), {
      type: "linear",
      data: labels,
      crossSize: size3,
      titleText: titleContent(title),
      labelOverlap: inferLabelOverlap(transform2, internalAxisStyle),
      grid: inferGrid(internalAxisStyle.grid, coordinate, scale11),
      gridLength,
      // Always showLine, make title could align the end of axis.
      line: true,
      indexBBox
    }), !internalAxisStyle.line ? { lineOpacity: 0 } : null), overrideStyle), threeDOverrideStyle), important);
    const hasHide = finalAxisStyle.labelOverlap.find((d3) => d3.type === "hide");
    if (hasHide)
      finalAxisStyle.crossSize = false;
    return new Axis({
      className: "axis",
      style: adaptor(finalAxisStyle)
    });
  };
};
var axisFactor = (axis) => {
  return (options) => {
    const { labelFormatter: useDefinedLabelFormatter, labelFilter: userDefinedLabelFilter = () => true } = options;
    return (context) => {
      var _a2;
      const { scales: [scale11] } = context;
      const ticks2 = ((_a2 = scale11.getTicks) === null || _a2 === void 0 ? void 0 : _a2.call(scale11)) || scale11.getOptions().domain;
      const labelFormatter2 = typeof useDefinedLabelFormatter === "string" ? format2(useDefinedLabelFormatter) : useDefinedLabelFormatter;
      const labelFilter = (datum, index3, array2) => userDefinedLabelFilter(ticks2[index3], index3, ticks2);
      const normalizedOptions = Object.assign(Object.assign({}, options), {
        labelFormatter: labelFormatter2,
        labelFilter,
        scale: scale11
      });
      return axis(normalizedOptions)(context);
    };
  };
};
var LinearAxis = axisFactor(LinearAxisComponent);
var ArcAxis = axisFactor(ArcAxisComponent);
LinearAxis.props = {
  defaultPosition: "center",
  defaultSize: 45,
  defaultOrder: 0,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};
ArcAxis.props = {
  defaultPosition: "outer",
  defaultOrientation: "vertical",
  defaultSize: 45,
  defaultOrder: 0,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/axisX.js
var AxisX = (options) => {
  return (...args) => {
    const axisX = LinearAxis(Object.assign({}, { crossPadding: 50 }, options))(...args);
    rotateAxis(axisX, options);
    return axisX;
  };
};
AxisX.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "bottom" });

// node_modules/@antv/g2/esm/component/axisY.js
var AxisY = (options) => {
  return (...args) => {
    const axisY = LinearAxis(Object.assign({}, { crossPadding: 10 }, options))(...args);
    rotateAxis(axisY, options);
    return axisY;
  };
};
AxisY.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "left" });

// node_modules/@antv/g2/esm/component/axisRadar.js
var __rest55 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function inferTitleTransform(orientation) {
  const internalOrientation = orientation % (Math.PI * 2);
  if (internalOrientation === Math.PI / 2) {
    return { titleTransform: "translate(0, 50%)" };
  }
  if (internalOrientation > -Math.PI / 2 && internalOrientation < Math.PI / 2) {
    return { titleTransform: "translate(50%, 0)" };
  }
  if (internalOrientation > Math.PI / 2 && internalOrientation < Math.PI * 3 / 2) {
    return { titleTransform: "translate(-50%, 0)" };
  }
  return {};
}
function inferAxisStyle(options, theme, coordinate, scales) {
  const { radar } = options;
  const [scale11] = scales;
  const name2 = scale11.getOptions().name;
  const [startAngle, endAngle] = angleOf(coordinate);
  const { axisRadar: radarTheme = {} } = theme;
  return Object.assign(Object.assign({}, radarTheme), { grid: name2 === "position", gridConnect: "line", gridControlAngles: new Array(radar.count).fill(0).map((_2, i) => {
    const angle4 = (endAngle - startAngle) / radar.count;
    return angle4 * i;
  }) });
}
var AxisRadar = (options) => {
  const { important = {} } = options, restOptions = __rest55(options, ["important"]);
  return (context) => {
    const { theme, coordinate, scales } = context;
    return LinearAxis(Object.assign(Object.assign(Object.assign({}, restOptions), inferTitleTransform(options.orientation)), { important: Object.assign(Object.assign({}, inferAxisStyle(options, theme, coordinate, scales)), important) }))(context);
  };
};
AxisRadar.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "center" });

// node_modules/@antv/g2/esm/component/legendCategory.js
var __rest56 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function inferShape(scales, markState) {
  const shapeScale = scaleOf(scales, "shape");
  const colorScale = scaleOf(scales, "color");
  const shapeScale1 = shapeScale ? shapeScale.clone() : null;
  const shapes = [];
  for (const [mark2, state] of markState) {
    const namespace = mark2.type;
    const domain = (colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain.length) > 0 ? colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain : state.data;
    const shape23 = domain.map((d3, i) => {
      var _a2;
      if (shapeScale1)
        return shapeScale1.map(d3 || "point");
      return ((_a2 = mark2 === null || mark2 === void 0 ? void 0 : mark2.style) === null || _a2 === void 0 ? void 0 : _a2.shape) || state.defaultShape || "point";
    });
    if (typeof namespace === "string")
      shapes.push([namespace, shape23]);
  }
  if (shapes.length === 0)
    return ["point", ["point"]];
  if (shapes.length === 1)
    return shapes[0];
  if (!shapeScale)
    return shapes[0];
  const { range: range3 } = shapeScale.getOptions();
  return shapes.map(([namespace, shape23]) => {
    let sum4 = 0;
    for (let i = 0; i < shapes.length; i++) {
      const targetShape = range3[i % range3.length];
      if (shape23[i] === targetShape)
        sum4++;
    }
    return [sum4 / shape23.length, [namespace, shape23]];
  }).sort((a4, b) => b[0] - a4[0])[0][1];
}
function inferItemMarker(options, context) {
  const { scales, library: library3, markState } = context;
  const [mark2, shapes] = inferShape(scales, markState);
  const { itemMarker, itemMarkerSize: size3 } = options;
  const create8 = (name2, d3) => {
    var _a2, _b, _c;
    const marker = ((_c = (_b = (_a2 = library3[`mark.${mark2}`]) === null || _a2 === void 0 ? void 0 : _a2.props) === null || _b === void 0 ? void 0 : _b.shape[name2]) === null || _c === void 0 ? void 0 : _c.props.defaultMarker) || last(name2.split("."));
    const radius = typeof size3 === "function" ? size3(d3) : size3;
    return () => useMarker(marker, { color: d3.color })(0, 0, radius);
  };
  const shapeOf = (i) => `${shapes[i]}`;
  const shapeScale = scaleOf(scales, "shape");
  if (shapeScale && !itemMarker)
    return (d3, i) => create8(shapeOf(i), d3);
  if (typeof itemMarker === "function") {
    return (d3, i) => {
      const node = itemMarker(d3.id, i);
      if (typeof node === "string")
        return create8(node, d3);
      return node;
    };
  }
  return (d3, i) => create8(itemMarker || shapeOf(i), d3);
}
function inferItemMarkerOpacity(scales) {
  const scale11 = scaleOf(scales, "opacity");
  if (scale11) {
    const { range: range3 } = scale11.getOptions();
    return (d3, i) => range3[i];
  }
  return void 0;
}
function inferItemMarkerSize(scales, defaults4) {
  const scale11 = scaleOf(scales, "size");
  if (scale11 instanceof Identity)
    return scale11.map(NaN) * 2;
  return defaults4;
}
function inferCategoryStyle(options, context) {
  const { labelFormatter: labelFormatter2 = (d3) => `${d3}` } = options;
  const { scales, theme } = context;
  const defaultSize = theme.legendCategory.itemMarkerSize;
  const itemMarkerSize = inferItemMarkerSize(scales, defaultSize);
  const baseStyle = {
    itemMarker: inferItemMarker(Object.assign(Object.assign({}, options), { itemMarkerSize }), context),
    itemMarkerSize,
    itemMarkerOpacity: inferItemMarkerOpacity(scales)
  };
  const finalLabelFormatter = typeof labelFormatter2 === "string" ? format2(labelFormatter2) : labelFormatter2;
  const colorScale = scaleOf(scales, "color");
  const domain = domainOf2(scales);
  const colorOf = colorScale ? (d3) => colorScale.map(d3) : () => context.theme.color;
  return Object.assign(Object.assign({}, baseStyle), { data: domain.map((d3) => ({
    id: d3,
    label: finalLabelFormatter(d3),
    color: colorOf(d3)
  })) });
}
function inferLegendShape(value2, options, component) {
  const { position } = options;
  if (position === "center") {
    const { bbox } = value2;
    const { width: width2, height: height2 } = bbox;
    return { width: width2, height: height2 };
  }
  const { width, height } = inferComponentShape(value2, options, component);
  return { width, height };
}
var LegendCategory = (options) => {
  const { labelFormatter: labelFormatter2, layout, order, orientation, position, size: size3, title, cols, itemMarker } = options, style = __rest56(options, ["labelFormatter", "layout", "order", "orientation", "position", "size", "title", "cols", "itemMarker"]);
  const { gridRow } = style;
  return (context) => {
    const { value: value2, theme } = context;
    const { bbox } = value2;
    const { width, height } = inferLegendShape(value2, options, LegendCategory);
    const finalLayout = inferComponentLayout(position, layout);
    const legendStyle = Object.assign(Object.assign(Object.assign(Object.assign({
      orientation: ["right", "left", "center"].includes(position) ? "vertical" : "horizontal",
      width,
      height,
      layout: cols !== void 0 ? "grid" : "flex"
    }, cols !== void 0 && { gridCol: cols }), gridRow !== void 0 && { gridRow }), { titleText: titleContent(title) }), inferCategoryStyle(options, context));
    const { legendCategory: legendTheme = {} } = theme;
    const categoryStyle = adaptor(Object.assign({}, legendTheme, legendStyle, style));
    const layoutWrapper = new LegendCategoryLayout({
      style: Object.assign(Object.assign({ x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height }, finalLayout), {
        // @ts-ignore
        subOptions: categoryStyle
      })
    });
    layoutWrapper.appendChild(new Category({
      className: "legend-category",
      style: categoryStyle
    }));
    return layoutWrapper;
  };
};
LegendCategory.props = {
  defaultPosition: "top",
  defaultOrder: 1,
  defaultSize: 40,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/legendContinuous.js
var __rest57 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function updateShapeDimensions(shape23, finalSize, orientation) {
  shape23.size = finalSize;
  if (isHorizontal2(orientation)) {
    shape23.height = finalSize;
  } else {
    shape23.width = finalSize;
  }
  return shape23;
}
function inferContinuousShape(value2, options, component) {
  const { size: size3 } = options;
  const shape23 = inferComponentShape(value2, options, component);
  return updateShapeDimensions(shape23, size3, shape23.orientation);
}
function getFormatter(max11) {
  return (value2) => ({
    value: value2 / max11,
    label: String(value2)
  });
}
function getQuantizeOrQuantileConfig(shape23, colorScale, min10, max11, range3) {
  const thresholds = colorScale.thresholds;
  const formatter2 = getFormatter(max11);
  return Object.assign(Object.assign({}, shape23), { color: range3, data: [min10, ...thresholds, max11].map(formatter2) });
}
function getThresholdConfig(shape23, colorScale, range3) {
  const thresholds = colorScale.thresholds;
  const data2 = [-Infinity, ...thresholds, Infinity].map((value2, index3) => ({
    value: index3,
    label: value2
  }));
  return Object.assign(Object.assign({}, shape23), { data: data2, color: range3, labelFilter: (datum, index3) => {
    return index3 > 0 && index3 < data2.length - 1;
  } });
}
function rangeOf4(scale11) {
  const { domain } = scale11.getOptions();
  const [min10, max11] = [domain[0], lastOf(domain)];
  return [min10, max11];
}
function createColorScale(scale11, defaultColor) {
  const options = scale11.getOptions();
  const newScale = scale11.clone();
  newScale.update(Object.assign(Object.assign({}, options), { range: [parseColor(defaultColor).toString()] }));
  return newScale;
}
function getLinearConfig(shape23, colorScale, sizeScale, opacityScale, scales, theme) {
  const { length: length5 } = shape23;
  const definedScale = sizeScale || opacityScale;
  const defaultColor = scales.color ? theme.legendContinuous.ribbonFill || "black" : theme.color;
  const scale11 = colorScale || createColorScale(definedScale, defaultColor);
  const [min10, max11] = rangeOf4(scale11);
  const [domainMin, domainMax] = rangeOf4([colorScale, sizeScale, opacityScale].filter((d3) => d3 !== void 0).find((d3) => !(d3 instanceof Constant2)));
  return Object.assign(Object.assign({}, shape23), { domain: [domainMin, domainMax], data: scale11.getTicks().map((value2) => ({ value: value2 })), color: new Array(Math.floor(length5)).fill(0).map((d3, i) => {
    const value2 = (max11 - min10) / (length5 - 1) * i + min10;
    const color3 = scale11.map(value2) || defaultColor;
    const opacity = opacityScale ? opacityScale.map(value2) : 1;
    return color3.replace(/rgb[a]*\(([\d]{1,3}) *, *([\d]{1,3}) *, *([\d]{1,3})[\S\s]*\)/, (match, p1, p2, p3) => `rgba(${p1}, ${p2}, ${p3}, ${opacity})`);
  }) });
}
function inferContinuousConfig(scales, scale11, value2, options, component, theme) {
  const colorScale = scaleOf(scales, "color");
  const shape23 = inferContinuousShape(value2, options, component);
  if (colorScale instanceof Threshold) {
    const { range: range3 } = colorScale.getOptions();
    const [min10, max11] = rangeOf4(colorScale);
    if (colorScale instanceof Quantize || colorScale instanceof Quantile) {
      return getQuantizeOrQuantileConfig(shape23, colorScale, min10, max11, range3);
    }
    return getThresholdConfig(shape23, colorScale, range3);
  }
  const sizeScale = scaleOf(scales, "size");
  const opacityScale = scaleOf(scales, "opacity");
  return getLinearConfig(shape23, colorScale, sizeScale, opacityScale, scale11, theme);
}
var LegendContinuous = (options) => {
  const { labelFormatter: labelFormatter2, layout, order, orientation, position, size: size3, title, style, crossPadding, padding } = options, rest = __rest57(options, ["labelFormatter", "layout", "order", "orientation", "position", "size", "title", "style", "crossPadding", "padding"]);
  return ({ scales, value: value2, theme, scale: scale11 }) => {
    const { bbox } = value2;
    const { x: x3, y: y3, width, height } = bbox;
    const finalLayout = inferComponentLayout(position, layout);
    const { legendContinuous: legendTheme = {} } = theme;
    const finalStyle = adaptor(Object.assign({}, legendTheme, Object.assign(Object.assign({ titleText: titleContent(title), labelAlign: "value", labelFormatter: typeof labelFormatter2 === "string" ? (d3) => format2(labelFormatter2)(d3.label) : labelFormatter2 }, inferContinuousConfig(scales, scale11, value2, options, LegendContinuous, theme)), style), rest));
    const layoutWrapper = new G2Layout({
      style: Object.assign(Object.assign({
        x: x3,
        y: y3,
        width,
        height
      }, finalLayout), {
        // @ts-ignore
        subOptions: finalStyle
      })
    });
    layoutWrapper.appendChild(new Continuous2({
      className: "legend-continuous",
      style: finalStyle
    }));
    return layoutWrapper;
  };
};
LegendContinuous.props = {
  defaultPosition: "top",
  defaultOrientation: "vertical",
  defaultOrder: 1,
  defaultSize: 60,
  defaultLength: 200,
  defaultLegendSize: 60,
  defaultPadding: [20, 10],
  defaultCrossPadding: [12, 12]
  // [horizontal, vertical]
};

// node_modules/@antv/g2/esm/component/legendContinuousBlock.js
var LegendContinuousBlock = (options) => {
  return (...args) => LegendContinuous(Object.assign({}, { block: true }, options))(...args);
};
LegendContinuousBlock.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

// node_modules/@antv/g2/esm/component/legendContinuousSize.js
var LegendContinuousSize = (options) => {
  return (context) => {
    const { scales } = context;
    const sizeScale = scaleOf(scales, "size");
    return LegendContinuous(Object.assign({}, {
      type: "size",
      data: sizeScale.getTicks().map((value2, index3) => ({
        value: value2,
        label: String(value2)
      }))
    }, options))(context);
  };
};
LegendContinuousSize.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

// node_modules/@antv/g2/esm/component/legendContinuousBlockSize.js
var LegendContinuousBlockSize = (options) => {
  return LegendContinuousSize(Object.assign({}, { block: true }, options));
};
LegendContinuousBlockSize.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

// node_modules/@antv/g2/esm/component/title.js
var __rest58 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function inferStyleByAlign(x3, y3, width, align) {
  switch (align) {
    case "center":
      return {
        x: x3 + width / 2,
        y: y3,
        textAlign: "middle"
      };
    case "right":
      return {
        x: x3 + width,
        y: y3,
        textAlign: "right"
      };
    default:
      return {
        x: x3,
        y: y3,
        textAlign: "left"
      };
  }
}
var Title2 = createComponent({
  render(attributes, container) {
    const { width, title, subtitle, spacing = 2, align = "left", x: x3, y: y3 } = attributes, style = __rest58(attributes, ["width", "title", "subtitle", "spacing", "align", "x", "y"]);
    container.style.transform = `translate(${x3}, ${y3})`;
    const titleStyle = subObject(style, "title");
    const subtitleStyle = subObject(style, "subtitle");
    const mainTitle = maybeAppend2(container, ".title", "text").attr("className", "title").call(applyStyle, Object.assign(Object.assign(Object.assign({}, inferStyleByAlign(0, 0, width, align)), { fontSize: 14, textBaseline: "top", text: title }), titleStyle)).node();
    const bounds = mainTitle.getLocalBounds();
    maybeAppend2(container, ".sub-title", "text").attr("className", "sub-title").call((selection) => {
      if (!subtitle)
        return selection.node().remove();
      selection.node().attr(Object.assign(Object.assign(Object.assign({}, inferStyleByAlign(0, bounds.max[1] + spacing, width, align)), { fontSize: 12, textBaseline: "top", text: subtitle }), subtitleStyle));
    });
  }
});
var TitleComponent = (options) => {
  return ({ value: value2, theme }) => {
    const { x: x3, y: y3, width, height } = value2.bbox;
    return new Title2({
      style: deep_mix_default({}, theme.title, Object.assign({
        x: x3,
        y: y3,
        width,
        height
      }, options))
    });
  };
};
TitleComponent.props = {
  defaultPosition: "top",
  defaultOrder: 2,
  defaultSize: 36,
  defaultCrossPadding: [20, 20],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/utils/scale.js
function constrain(x3, lo, hi) {
  return Math.min(hi, Math.max(lo, x3));
}
function isOrdinalScale(scale11) {
  return !!scale11.getBandWidth;
}
function invert4(scale11, x3, start) {
  if (!isOrdinalScale(scale11))
    return scale11.invert(x3);
  const { adjustedRange } = scale11;
  const { domain } = scale11.getOptions();
  const offset2 = start ? -1 : 0;
  const step2 = scale11.getStep();
  const range3 = start ? adjustedRange : adjustedRange.map((d3) => d3 + step2);
  const i0 = bisectLeft(range3, x3);
  const i1 = constrain(i0 + offset2, 0, domain.length - 1);
  return domain[i1];
}
function domainOf3(scale11, values4, ratioX) {
  if (!values4)
    return scale11.getOptions().domain;
  if (!isOrdinalScale(scale11)) {
    const sortedDomain = sort(values4);
    if (!ratioX)
      return sortedDomain;
    const [d3] = sortedDomain;
    const { range: range3 } = scale11.getOptions();
    const [r0, r1] = range3;
    const v = r0 > r1 ? -1 : 1;
    const d1 = scale11.invert(scale11.map(d3) + v * ratioX);
    return [d3, d1];
  }
  const { domain } = scale11.getOptions();
  const v1 = values4[0];
  const start = domain.indexOf(v1);
  if (ratioX) {
    const end2 = start + Math.round(domain.length * ratioX);
    return domain.slice(start, end2);
  }
  const v2 = values4[values4.length - 1];
  const end = domain.indexOf(v2);
  return domain.slice(start, end + 1);
}
function selectionOf(x3, y3, x12, y12, scale11, coordinate) {
  const { x: scaleX2, y: scaleY2 } = scale11;
  const abstractDomain = (point7, start) => {
    const [x4, y4] = coordinate.invert(point7);
    return [invert4(scaleX2, x4, start), invert4(scaleY2, y4, start)];
  };
  const p0 = abstractDomain([x3, y3], true);
  const p1 = abstractDomain([x12, y12], false);
  const domainX = domainOf3(scaleX2, [p0[0], p1[0]]);
  const domainY = domainOf3(scaleY2, [p0[1], p1[1]]);
  return [domainX, domainY];
}
function abstractOf(domain, scale11) {
  const [d0, d1] = domain;
  const maybeStep = (scale12) => scale12.getStep ? scale12.getStep() : 0;
  return [scale11.map(d0), scale11.map(d1) + maybeStep(scale11)];
}
function pixelsOf(selection, scale11, coordinate) {
  const { x: scaleX2, y: scaleY2 } = scale11;
  const [X, Y] = selection;
  const AX = abstractOf(X, scaleX2);
  const AY = abstractOf(Y, scaleY2);
  const p0 = [AX[0], AY[0]];
  const p1 = [AX[1], AY[1]];
  const [x3, y3] = coordinate.map(p0);
  const [x12, y12] = coordinate.map(p1);
  return [x3, y3, x12, y12];
}

// node_modules/@antv/g2/esm/component/slider.js
var __rest59 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function inferPosition2(bbox, position, trackSize) {
  const { x: x3, y: y3, width, height } = bbox;
  if (position === "left")
    return [x3 + width - trackSize, y3];
  if (position === "right")
    return [x3, y3];
  if (position === "bottom")
    return [x3, y3];
  if (position === "top")
    return [x3, y3 + height - trackSize];
}
var Slider2 = (options) => {
  const { orientation, labelFormatter: labelFormatter2, size: size3, style = {}, position } = options, rest = __rest59(options, ["orientation", "labelFormatter", "size", "style", "position"]);
  return (context) => {
    var _a2;
    const { scales: [scale11], value: value2, theme, coordinate } = context;
    const { bbox } = value2;
    const { width, height } = bbox;
    const { slider: sliderTheme = {} } = theme;
    const defaultFormatter = ((_a2 = scale11.getFormatter) === null || _a2 === void 0 ? void 0 : _a2.call(scale11)) || ((v) => v + "");
    const formatter2 = typeof labelFormatter2 === "string" ? format2(labelFormatter2) : labelFormatter2;
    const isHorizontal3 = orientation === "horizontal";
    const reverse2 = isTranspose(coordinate) && isHorizontal3;
    const { trackSize = sliderTheme.trackSize } = style;
    const [x05, y05] = inferPosition2(bbox, position, trackSize);
    return new Slider({
      className: "slider",
      style: Object.assign({}, sliderTheme, Object.assign(Object.assign({ x: x05, y: y05, trackLength: isHorizontal3 ? width : height, orientation, formatter: (v) => {
        const f = formatter2 || defaultFormatter;
        const v1 = reverse2 ? 1 - v : v;
        const tick3 = invert4(scale11, v1, true);
        return f(tick3);
      }, sparklineData: inferSparklineData(options, context) }, style), rest))
    });
  };
};
function markValue(markState, channels) {
  const [value2] = Array.from(markState.entries()).filter(([mark2]) => mark2.type === "line" || mark2.type === "area").filter(([mark2]) => mark2.slider).map(([mark2]) => {
    const { encode, slider } = mark2;
    if (slider === null || slider === void 0 ? void 0 : slider.x) {
      const channel = (name2) => {
        const channel2 = encode[name2];
        return [name2, channel2 ? channel2.value : void 0];
      };
      return Object.fromEntries(channels.map(channel));
    }
  });
  if (!(value2 === null || value2 === void 0 ? void 0 : value2.series))
    return value2 === null || value2 === void 0 ? void 0 : value2.y;
  const result = value2.series.reduce((acc, curr, index3) => {
    acc[curr] = acc[curr] || [];
    acc[curr].push(value2.y[index3]);
    return acc;
  }, {});
  return Object.values(result);
}
function inferSparklineData(options, context) {
  const { markState } = context;
  if (isArray(options.sparklineData))
    return options.sparklineData;
  return markValue(markState, ["y", "series"]);
}
Slider2.props = {
  defaultPosition: "bottom",
  defaultSize: 24,
  defaultOrder: 1,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/sliderX.js
var SliderX = (options) => {
  return Slider2(Object.assign(Object.assign({}, options), { orientation: "horizontal" }));
};
SliderX.props = Object.assign(Object.assign({}, Slider2.props), { defaultPosition: "bottom" });

// node_modules/@antv/g2/esm/component/sliderY.js
var SliderY = (options) => {
  return Slider2(Object.assign(Object.assign({}, options), { orientation: "vertical" }));
};
SliderY.props = Object.assign(Object.assign({}, Slider2.props), { defaultPosition: "left" });

// node_modules/@antv/g2/esm/component/scrollbar.js
var __rest60 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var Scrollbar2 = (options) => {
  const { orientation, labelFormatter: labelFormatter2, style } = options, rest = __rest60(options, ["orientation", "labelFormatter", "style"]);
  return ({ scales: [scale11], value: value2, theme }) => {
    const { bbox } = value2;
    const { x: x3, y: y3, width, height } = bbox;
    const { scrollbar: scrollbarTheme = {} } = theme;
    const { ratio, range: range3 } = scale11.getOptions();
    const mainSize = orientation === "horizontal" ? width : height;
    const actualSize = mainSize / ratio;
    const [r0, r1] = range3;
    const value1 = r1 > r0 ? 0 : 1;
    return new Scrollbar({
      className: "g2-scrollbar",
      style: Object.assign({}, scrollbarTheme, Object.assign(Object.assign(Object.assign(Object.assign({}, style), {
        x: x3,
        y: y3,
        trackLength: mainSize,
        value: value1
      }), rest), { orientation, contentLength: actualSize, viewportLength: mainSize }))
    });
  };
};
Scrollbar2.props = {
  defaultPosition: "bottom",
  defaultSize: 24,
  defaultOrder: 1,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/scrollbarX.js
var ScrollbarX = (options) => {
  return Scrollbar2(Object.assign(Object.assign({}, options), { orientation: "horizontal" }));
};
ScrollbarX.props = Object.assign(Object.assign({}, Scrollbar2.props), { defaultPosition: "bottom" });

// node_modules/@antv/g2/esm/component/scrollbarY.js
var ScrollbarY = (options) => {
  return Scrollbar2(Object.assign(Object.assign({}, options), { orientation: "vertical" }));
};
ScrollbarY.props = Object.assign(Object.assign({}, Scrollbar2.props), { defaultPosition: "left" });

// node_modules/@antv/g2/esm/component/legends.js
var Legends = (options) => {
  return () => {
    return new Group2();
  };
};
Legends.props = {};

// node_modules/@antv/g2/esm/animation/scaleInX.js
var ScaleInX = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate } = context;
  return (from, _2, defaults4) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const [transformOrigin, transform2] = isTranspose(coordinate) ? [`left bottom`, `scale(1, ${ZERO})`] : [`left top`, `scale(${ZERO}, 1)`];
    const keyframes = [
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      },
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.01
      },
      {
        transform: `${prefix} scale(1, 1)`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/scaleOutX.js
var ScaleOutX = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate } = context;
  return (from, _2, defaults4) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const [transformOrigin, transform2] = isTranspose(coordinate) ? [`left bottom`, `scale(1, ${ZERO})`] : [`left top`, `scale(${ZERO}, 1)`];
    const keyframes = [
      {
        transform: `${prefix} scale(1, 1)`.trimStart(),
        transformOrigin
      },
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.99
      },
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/scaleInY.js
var ScaleInY = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate } = context;
  CSS.registerProperty({
    name: "scaleInYRadius",
    inherits: false,
    initialValue: "",
    interpolable: true,
    syntax: PropertySyntax.NUMBER
  });
  return (from, _2, defaults4) => {
    const [shape23] = from;
    const PolarScaleInY = (shape24) => {
      const { __data__, style } = shape24;
      const { radius = 0, inset = 0, fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
      const { points, y: y3, y1: y12 } = __data__;
      const arcObject = getArcObject(coordinate, points, [y3, y12]);
      const { innerRadius, outerRadius } = arcObject;
      const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
      const pathForConversion = new Path2({});
      const createArcPath = (arcParams) => {
        pathForConversion.attr({
          d: path2(arcParams)
        });
        const convertedPathDefinition = convertToPath(pathForConversion);
        return convertedPathDefinition;
      };
      const keyframes = [
        {
          scaleInYRadius: innerRadius + ZERO,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        },
        {
          scaleInYRadius: innerRadius + ZERO,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.01
        },
        {
          scaleInYRadius: outerRadius,
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
      animation.onframe = function() {
        shape24.style.d = createArcPath(Object.assign(Object.assign({}, arcObject), { outerRadius: Number(shape24.style.scaleInYRadius) }));
      };
      animation.onfinish = function() {
        shape24.style.d = createArcPath(Object.assign(Object.assign({}, arcObject), { outerRadius }));
      };
      return animation;
    };
    const RectangularScaleInY = (shape24) => {
      const { style } = shape24;
      const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
      const [transformOrigin, transform2] = isTranspose(coordinate) ? [`left top`, `scale(${ZERO}, 1)`] : [`left bottom`, `scale(1, ${ZERO})`];
      const keyframes = [
        {
          transform: `${prefix} ${transform2}`.trimStart(),
          transformOrigin,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        },
        {
          transform: `${prefix} ${transform2}`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.01
        },
        {
          transform: `${prefix} scale(1, 1)`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
      return animation;
    };
    if (isPolar(coordinate)) {
      return PolarScaleInY(shape23);
    } else {
      return RectangularScaleInY(shape23);
    }
  };
};

// node_modules/@antv/g2/esm/animation/scaleOutY.js
var ScaleOutY = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate } = context;
  return (from, _2, defaults4) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const [transformOrigin, transform2] = isTranspose(coordinate) ? [`left top`, `scale(${ZERO}, 1)`] : [`left bottom`, `scale(1, ${ZERO})`];
    const keyframes = [
      {
        transform: `${prefix} scale(1, 1)`.trimStart(),
        transformOrigin
      },
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.99
      },
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/fadeIn.js
var FadeIn = (options) => {
  return (from, _2, defaults4) => {
    const [shape23] = from;
    const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const keyframes = [
      { fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
      {
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
  };
};
FadeIn.props = {};

// node_modules/@antv/g2/esm/animation/fadeOut.js
var FadeOut = (options) => {
  return (from, _2, defaults4) => {
    const [shape23] = from;
    const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const keyframes = [
      {
        fillOpacity,
        strokeOpacity,
        opacity
      },
      { fillOpacity: 0, strokeOpacity: 0, opacity: 0 }
    ];
    return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
  };
};
FadeOut.props = {};

// node_modules/@antv/g2/esm/animation/utils.js
var DEFAULT_ATTRIBUTE_VALUE = {
  opacity: 1,
  strokeOpacity: 1,
  fillOpacity: 1,
  lineWidth: 0,
  x: 0,
  y: 0,
  cx: 0,
  cy: 0,
  r: 0,
  rx: 0,
  ry: 0,
  width: 0,
  height: 0
};
var GEOMETRY_ATTRIBUTES = {
  [Shape.CIRCLE]: ["cx", "cy", "r"],
  [Shape.ELLIPSE]: ["cx", "cy", "rx", "ry"],
  [Shape.RECT]: ["x", "y", "width", "height"],
  [Shape.IMAGE]: ["x", "y", "width", "height"],
  [Shape.LINE]: ["x1", "y1", "x2", "y2"],
  [Shape.POLYLINE]: ["points"],
  [Shape.POLYGON]: ["points"]
};
function attributeOf(shape23, keys2, useDefaultValue = false) {
  const attribute = {};
  for (const key of keys2) {
    const value2 = shape23.style[key];
    if (value2) {
      attribute[key] = value2;
    } else if (useDefaultValue) {
      attribute[key] = DEFAULT_ATTRIBUTE_VALUE[key];
    }
  }
  return attribute;
}
var attributeKeys = [
  "fill",
  "stroke",
  "fillOpacity",
  "strokeOpacity",
  "opacity",
  "lineWidth"
];

// node_modules/@antv/g2/esm/animation/morphing.js
function localBBoxOf(shape23) {
  const { min: min10, max: max11 } = shape23.getLocalBounds();
  const [x05, y05] = min10;
  const [x12, y12] = max11;
  const height = y12 - y05;
  const width = x12 - x05;
  return [x05, y05, width, height];
}
function d2(bbox) {
  const [x3, y3, width, height] = bbox;
  return `
    M ${x3} ${y3}
    L ${x3 + width} ${y3}
    L ${x3 + width} ${y3 + height}
    L ${x3} ${y3 + height}
    Z
  `;
}
function pack2(shape23, count4) {
  const [x05, y05, width, height] = localBBoxOf(shape23);
  const aspect = height / width;
  const col = Math.ceil(Math.sqrt(count4 / aspect));
  const row2 = Math.ceil(count4 / col);
  const B4 = [];
  const h = height / row2;
  let j = 0;
  let n = count4;
  while (n > 0) {
    const c5 = Math.min(n, col);
    const w = width / c5;
    for (let i = 0; i < c5; i++) {
      const x3 = x05 + i * w;
      const y3 = y05 + j * h;
      B4.push(d2([x3, y3, w, h]));
    }
    n -= c5;
    j += 1;
  }
  return B4;
}
function normalizeSplit(split = "pack") {
  if (typeof split == "function")
    return split;
  return pack2;
}
function shapeToShape(from, to, timeEffect) {
  let { transform: fromTransform } = from.style;
  const { transform: toTransform } = to.style;
  replaceChild(to, from);
  let keys2 = attributeKeys;
  if (from.nodeName === Shape.GROUP) {
    const [x05, y05, w0, h0] = localBBoxOf(from);
    const [x12, y12, w1, h1] = localBBoxOf(to);
    const dx = x05 - x12;
    const dy = y05 - y12;
    const sx = w0 / w1;
    const sy = h0 / h1;
    fromTransform = `translate(${dx}, ${dy}) scale(${sx}, ${sy})`;
  } else {
    keys2 = keys2.concat(GEOMETRY_ATTRIBUTES[from.nodeName] || []);
  }
  const keyframes = [
    Object.assign({ transform: fromTransform !== null && fromTransform !== void 0 ? fromTransform : "none" }, attributeOf(from, keys2, true)),
    Object.assign({ transform: toTransform !== null && toTransform !== void 0 ? toTransform : "none" }, attributeOf(to, keys2, true))
  ];
  const animation = to.animate(keyframes, timeEffect);
  return animation;
}
function replaceChild(newChild, oldChild) {
  newChild["__data__"] = oldChild["__data__"];
  newChild.className = oldChild.className;
  newChild.markType = oldChild.markType;
  oldChild.parentNode.replaceChild(newChild, oldChild);
}
function maybePath(node, d3) {
  const { nodeName } = node;
  if (nodeName === "path")
    return node;
  const path2 = new Path2({
    style: Object.assign(Object.assign({}, attributeOf(node, attributeKeys)), { d: d3 })
  });
  replaceChild(path2, node);
  return path2;
}
function hasUniqueString(search2, pattern) {
  const first3 = search2.indexOf(pattern);
  const last5 = search2.lastIndexOf(pattern);
  return first3 === last5;
}
function hasSubPath(path2) {
  return !hasUniqueString(path2, "m") || !hasUniqueString(path2, "M");
}
function shape2path(shape23) {
  const path2 = convertToPath(shape23);
  if (!path2)
    return;
  if (hasSubPath(path2))
    return;
  return path2;
}
function hasMarker(shape23) {
  const { nodeName } = shape23;
  if (nodeName === "path") {
    const attributes = get_default(shape23, "attributes");
    return attributes.markerEnd || attributes.markerStart;
  }
  return false;
}
function oneToOne(shape23, from, to, timeEffect) {
  const { nodeName: fromName } = from;
  const { nodeName: toName } = to;
  const fromPath = shape2path(from);
  const toPath = shape2path(to);
  const isSameNodes = fromName === toName && fromName !== "path";
  const hasNonPathNode = fromPath === void 0 || toPath === void 0;
  const isPathWithMarker = hasMarker(from) || hasMarker(to);
  if (isSameNodes || hasNonPathNode || isPathWithMarker)
    return shapeToShape(from, to, timeEffect);
  const pathShape = maybePath(shape23, fromPath);
  const keyframes = [
    Object.assign({}, attributeOf(from, attributeKeys)),
    Object.assign({}, attributeOf(to, attributeKeys))
  ];
  if (fromPath !== toPath) {
    keyframes[0].d = fromPath;
    keyframes[1].d = toPath;
    const animation = pathShape.animate(keyframes, timeEffect);
    animation.onfinish = () => {
      const d3 = pathShape.style.d;
      copyAttributes(pathShape, to);
      pathShape.style.d = d3;
      pathShape.style.transform = "none";
    };
    pathShape.style.transform = "none";
    return animation;
  }
  return null;
}
function oneToMultiple(from, to, timeEffect, split) {
  from.style.visibility = "hidden";
  const D2 = split(from, to.length);
  return to.map((shape23, i) => {
    const path2 = new Path2({
      style: Object.assign({ d: D2[i] }, attributeOf(from, attributeKeys))
    });
    return oneToOne(shape23, path2, shape23, timeEffect);
  });
}
function multipleToOne(from, to, timeEffect, split) {
  const D2 = split(to, from.length);
  const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = to.style;
  const keyframes = [
    { fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
    { fillOpacity: 0, strokeOpacity: 0, opacity: 0, offset: 0.99 },
    {
      fillOpacity,
      strokeOpacity,
      opacity
    }
  ];
  const animation = to.animate(keyframes, timeEffect);
  const animations = from.map((shape23, i) => {
    const path2 = new Path2({
      style: {
        d: D2[i],
        fill: to.style.fill
      }
    });
    return oneToOne(shape23, shape23, path2, timeEffect);
  });
  return [...animations, animation];
}
var Morphing = (options) => {
  return (from, to, defaults4) => {
    const split = normalizeSplit(options.split);
    const timeEffect = Object.assign(Object.assign({}, defaults4), options);
    const { length: fl } = from;
    const { length: tl } = to;
    if (fl === 1 && tl === 1 || fl > 1 && tl > 1) {
      const [f] = from;
      const [t] = to;
      return oneToOne(f, f, t, timeEffect);
    }
    if (fl === 1 && tl > 1) {
      const [f] = from;
      return oneToMultiple(f, to, timeEffect, split);
    }
    if (fl > 1 && tl === 1) {
      const [t] = to;
      return multipleToOne(from, t, timeEffect, split);
    }
    return null;
  };
};
Morphing.props = {};

// node_modules/@antv/g2/esm/animation/waveIn.js
var WaveIn = (options, context) => {
  const ZERO = 1e-4;
  CSS.registerProperty({
    name: "waveInArcAngle",
    inherits: false,
    initialValue: "",
    interpolable: true,
    syntax: PropertySyntax.NUMBER
  });
  const { coordinate } = context;
  return (from, to, defaults4) => {
    const [shape23] = from;
    if (!isPolar(coordinate)) {
      return ScaleInX(options, context)(from, to, defaults4);
    }
    const { __data__, style } = shape23;
    const { radius = 0, inset = 0, fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
    const { points, y: y3, y1: y12 } = __data__;
    const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
    const arcObject = getArcObject(coordinate, points, [y3, y12]);
    const { startAngle, endAngle } = arcObject;
    const keyframes = [
      // Use custom interpolable CSS property.
      {
        waveInArcAngle: startAngle + ZERO,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      },
      {
        waveInArcAngle: startAngle + ZERO,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.01
      },
      {
        waveInArcAngle: endAngle,
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    animation.onframe = function() {
      shape23.style.d = path2(Object.assign(Object.assign({}, arcObject), { endAngle: Number(shape23.style.waveInArcAngle) }));
    };
    animation.onfinish = function() {
      shape23.style.d = path2(Object.assign(Object.assign({}, arcObject), { endAngle }));
    };
    return animation;
  };
};
WaveIn.props = {};

// node_modules/@antv/g2/esm/animation/zoomIn.js
var ZoomIn = (options) => {
  const ZERO = 1e-4;
  return (from, _2, defaults4) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const transformOrigin = "center center";
    const keyframes = [
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      },
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.01
      },
      {
        transform: `${prefix} scale(1)`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/zoomOut.js
var ZoomOut = (options) => {
  const ZERO = 1e-4;
  return (from, _2, defaults4) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const transformOrigin = "center center";
    const keyframes = [
      { transform: `${prefix} scale(1)`.trimStart(), transformOrigin },
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.99
      },
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/pathIn.js
var PathIn = (options) => {
  return (from, _2, defaults4) => {
    var _a2, _b;
    const [shape23] = from;
    const length5 = ((_b = (_a2 = shape23).getTotalLength) === null || _b === void 0 ? void 0 : _b.call(_a2)) || 0;
    const keyframes = [
      { lineDash: [0, length5] },
      { lineDash: [length5, 0] }
    ];
    return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
  };
};
PathIn.props = {};

// node_modules/@antv/g2/esm/animation/growInX.js
var GrowInX = (options, context) => {
  return (from, to, defaults4) => {
    const [shape23] = from;
    const { min: [x3, y3], halfExtents } = shape23.getLocalBounds();
    const width = halfExtents[0] * 2;
    const height = halfExtents[1] * 2;
    const clipPath = new Path2({
      style: {
        d: `M${x3},${y3}L${x3 + width},${y3}L${x3 + width},${y3 + height}L${x3},${y3 + height}Z`
      }
    });
    shape23.appendChild(clipPath);
    shape23.style.clipPath = clipPath;
    const animation = ScaleInX(options, context)([clipPath], to, defaults4);
    return animation;
  };
};
GrowInX.props = {};

// node_modules/@antv/g2/esm/animation/growInY.js
var GrowInY = (options, context) => {
  return (from, to, defaults4) => {
    const [shape23] = from;
    const { min: [x3, y3], halfExtents } = shape23.getLocalBounds();
    const width = halfExtents[0] * 2;
    const height = halfExtents[1] * 2;
    const clipPath = new Path2({
      style: {
        d: `M${x3},${y3}L${x3 + width},${y3}L${x3 + width},${y3 + height}L${x3},${y3 + height}Z`
      }
    });
    shape23.appendChild(clipPath);
    shape23.style.clipPath = clipPath;
    const animation = ScaleInY(options, context)([clipPath], to, defaults4);
    return animation;
  };
};
GrowInY.props = {};

// node_modules/@antv/g2/esm/runtime/constant.js
var MAIN_LAYER_CLASS_NAME = "main-layer";
var LABEL_LAYER_CLASS_NAME = "label-layer";
var ELEMENT_CLASS_NAME = "element";
var VIEW_CLASS_NAME = "view";
var PLOT_CLASS_NAME = "plot";
var COMPONENT_CLASS_NAME = "component";
var LABEL_CLASS_NAME = "label";
var AREA_CLASS_NAME = "area";
var MASK_CLASS_NAME = "mask";

// node_modules/@antv/g-plugin-canvas-path-generator/dist/index.esm.js
function generatePath$6(context, parsedStyle) {
  var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, r = parsedStyle.r;
  context.arc(cx, cy, r, 0, Math.PI * 2, false);
}
function generatePath$5(context, parsedStyle) {
  var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, rx = parsedStyle.rx, ry = parsedStyle.ry;
  if (context.ellipse) {
    context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
  } else {
    var r = rx > ry ? rx : ry;
    var scaleX2 = rx > ry ? 1 : rx / ry;
    var scaleY2 = rx > ry ? ry / rx : 1;
    context.save();
    context.scale(scaleX2, scaleY2);
    context.arc(cx, cy, r, 0, Math.PI * 2);
  }
}
function generatePath$4(context, parsedStyle) {
  var x12 = parsedStyle.x1, y12 = parsedStyle.y1, x22 = parsedStyle.x2, y22 = parsedStyle.y2, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x3;
  var y3;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x3 = x22 - x12;
    y3 = y22 - y12;
    rad2 = Math.atan2(y3, x3);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x3 = x12 - x22;
    y3 = y12 - y22;
    rad2 = Math.atan2(y3, x3);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  context.moveTo(x12 + startOffsetX, y12 + startOffsetY);
  context.lineTo(x22 + endOffsetX, y22 + endOffsetY);
}
function generatePath$3(context, parsedStyle) {
  var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var _parsedStyle$d = parsedStyle.d, absolutePath = _parsedStyle$d.absolutePath, segments = _parsedStyle$d.segments;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x3;
  var y3;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    var _getStartTangent = markerStart.parentNode.getStartTangent(), _getStartTangent2 = _slicedToArray(_getStartTangent, 2), p1 = _getStartTangent2[0], p2 = _getStartTangent2[1];
    x3 = p1[0] - p2[0];
    y3 = p1[1] - p2[1];
    rad2 = Math.atan2(y3, x3);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    var _getEndTangent = markerEnd.parentNode.getEndTangent(), _getEndTangent2 = _slicedToArray(_getEndTangent, 2), _p = _getEndTangent2[0], _p2 = _getEndTangent2[1];
    x3 = _p[0] - _p2[0];
    y3 = _p[1] - _p2[1];
    rad2 = Math.atan2(y3, x3);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  for (var i = 0; i < absolutePath.length; i++) {
    var params = absolutePath[i];
    var command = params[0];
    var nextSegment = absolutePath[i + 1];
    var useStartOffset = i === 0 && (startOffsetX !== 0 || startOffsetY !== 0);
    var useEndOffset = (i === absolutePath.length - 1 || nextSegment && (nextSegment[0] === "M" || nextSegment[0] === "Z")) && endOffsetX !== 0 && endOffsetY !== 0;
    var _ref = useStartOffset ? [startOffsetX, startOffsetY] : [0, 0], _ref2 = _slicedToArray(_ref, 2), startOffsetXTemp = _ref2[0], startOffsetYTemp = _ref2[1];
    var _ref3 = useEndOffset ? [endOffsetX, endOffsetY] : [0, 0], _ref4 = _slicedToArray(_ref3, 2), endOffsetXTemp = _ref4[0], endOffsetYTemp = _ref4[1];
    switch (command) {
      case "M":
        context.moveTo(params[1] + startOffsetXTemp, params[2] + startOffsetYTemp);
        break;
      case "L":
        context.lineTo(params[1] + endOffsetXTemp, params[2] + endOffsetYTemp);
        break;
      case "Q":
        context.quadraticCurveTo(params[1], params[2], params[3] + endOffsetXTemp, params[4] + endOffsetYTemp);
        break;
      case "C":
        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] + endOffsetXTemp, params[6] + endOffsetYTemp);
        break;
      case "A": {
        var arcParams = segments[i].arcParams;
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
        if (context.ellipse) {
          context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, !!(1 - sweepFlag));
        } else {
          var r = rx > ry ? rx : ry;
          var scaleX2 = rx > ry ? 1 : rx / ry;
          var scaleY2 = rx > ry ? ry / rx : 1;
          context.translate(cx, cy);
          context.rotate(xRotation);
          context.scale(scaleX2, scaleY2);
          context.arc(0, 0, r, startAngle, endAngle, !!(1 - sweepFlag));
          context.scale(1 / scaleX2, 1 / scaleY2);
          context.rotate(-xRotation);
          context.translate(-cx, -cy);
        }
        if (useEndOffset) {
          context.lineTo(params[6] + endOffsetX, params[7] + endOffsetY);
        }
        break;
      }
      case "Z":
        context.closePath();
        break;
    }
  }
}
function generatePath$2(context, parsedStyle) {
  var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var points = parsedStyle.points.points;
  var length5 = points.length;
  var x12 = points[0][0];
  var y12 = points[0][1];
  var x22 = points[length5 - 1][0];
  var y22 = points[length5 - 1][1];
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x3;
  var y3;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x3 = points[1][0] - points[0][0];
    y3 = points[1][1] - points[0][1];
    rad2 = Math.atan2(y3, x3);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x3 = points[length5 - 1][0] - points[0][0];
    y3 = points[length5 - 1][1] - points[0][1];
    rad2 = Math.atan2(y3, x3);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  context.moveTo(x12 + (startOffsetX || endOffsetX), y12 + (startOffsetY || endOffsetY));
  for (var i = 1; i < length5 - 1; i++) {
    var point7 = points[i];
    context.lineTo(point7[0], point7[1]);
  }
  context.lineTo(x22, y22);
}
function generatePath$1(context, parsedStyle) {
  var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var points = parsedStyle.points.points;
  var length5 = points.length;
  var x12 = points[0][0];
  var y12 = points[0][1];
  var x22 = points[length5 - 1][0];
  var y22 = points[length5 - 1][1];
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x3;
  var y3;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x3 = points[1][0] - points[0][0];
    y3 = points[1][1] - points[0][1];
    rad2 = Math.atan2(y3, x3);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x3 = points[length5 - 2][0] - points[length5 - 1][0];
    y3 = points[length5 - 2][1] - points[length5 - 1][1];
    rad2 = Math.atan2(y3, x3);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  context.moveTo(x12 + startOffsetX, y12 + startOffsetY);
  for (var i = 1; i < length5 - 1; i++) {
    var point7 = points[i];
    context.lineTo(point7[0], point7[1]);
  }
  context.lineTo(x22 + endOffsetX, y22 + endOffsetY);
}
function generatePath(context, parsedStyle) {
  var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, radius = parsedStyle.radius, width = parsedStyle.width, height = parsedStyle.height;
  var w = width;
  var h = height;
  var hasRadius = radius && radius.some(function(r) {
    return r !== 0;
  });
  if (!hasRadius) {
    context.rect(x3, y3, w, h);
  } else {
    var signX = width > 0 ? 1 : -1;
    var signY = height > 0 ? 1 : -1;
    var sweepFlag = signX + signY === 0;
    var _radius$map = radius.map(function(r) {
      return clamp_default(r, 0, Math.min(Math.abs(w) / 2, Math.abs(h) / 2));
    }), _radius$map2 = _slicedToArray(_radius$map, 4), tlr = _radius$map2[0], trr = _radius$map2[1], brr = _radius$map2[2], blr = _radius$map2[3];
    context.moveTo(signX * tlr + x3, y3);
    context.lineTo(w - signX * trr + x3, y3);
    if (trr !== 0) {
      context.arc(w - signX * trr + x3, signY * trr + y3, trr, -signY * Math.PI / 2, signX > 0 ? 0 : Math.PI, sweepFlag);
    }
    context.lineTo(w + x3, h - signY * brr + y3);
    if (brr !== 0) {
      context.arc(w - signX * brr + x3, h - signY * brr + y3, brr, signX > 0 ? 0 : Math.PI, signY > 0 ? Math.PI / 2 : 1.5 * Math.PI, sweepFlag);
    }
    context.lineTo(signX * blr + x3, h + y3);
    if (blr !== 0) {
      context.arc(signX * blr + x3, h - signY * blr + y3, blr, signY > 0 ? Math.PI / 2 : -Math.PI / 2, signX > 0 ? Math.PI : 0, sweepFlag);
    }
    context.lineTo(x3, signY * tlr + y3);
    if (tlr !== 0) {
      context.arc(signX * tlr + x3, signY * tlr + y3, tlr, signX > 0 ? Math.PI : 0, signY > 0 ? Math.PI * 1.5 : Math.PI / 2, sweepFlag);
    }
  }
}
var Plugin = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    _classCallCheck(this, Plugin8);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin8, [].concat(args));
    _this2.name = "canvas-path-generator";
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      var _pathGeneratorFactory;
      var pathGeneratorFactory = (_pathGeneratorFactory = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_pathGeneratorFactory, Shape.CIRCLE, generatePath$6), Shape.ELLIPSE, generatePath$5), Shape.RECT, generatePath), Shape.LINE, generatePath$4), Shape.POLYLINE, generatePath$1), Shape.POLYGON, generatePath$2), Shape.PATH, generatePath$3), Shape.TEXT, void 0), Shape.GROUP, void 0), Shape.IMAGE, void 0), _defineProperty(_defineProperty(_defineProperty(_pathGeneratorFactory, Shape.HTML, void 0), Shape.MESH, void 0), Shape.FRAGMENT, void 0));
      this.context.pathGeneratorFactory = pathGeneratorFactory;
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      delete this.context.pathGeneratorFactory;
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/g-plugin-canvas-picker/dist/index.esm.js
var tmpVec3a = vec3_exports.create();
var tmpVec3b = vec3_exports.create();
var tmpVec3c = vec3_exports.create();
var tmpMat4 = mat4_exports.create();
var CanvasPickerPlugin = function() {
  function CanvasPickerPlugin2() {
    var _this2 = this;
    _classCallCheck(this, CanvasPickerPlugin2);
    this.isHit = function(displayObject, position, worldTransform, isClipPath) {
      var pick3 = _this2.context.pointInPathPickerFactory[displayObject.nodeName];
      if (pick3) {
        var invertWorldMat = mat4_exports.invert(tmpMat4, worldTransform);
        var localPosition = vec3_exports.transformMat4(tmpVec3b, vec3_exports.set(tmpVec3c, position[0], position[1], 0), invertWorldMat);
        if (pick3(displayObject, new Point2(localPosition[0], localPosition[1]), isClipPath, _this2.isPointInPath, _this2.context, _this2.runtime)) {
          return true;
        }
      }
      return false;
    };
    this.isPointInPath = function(displayObject, position) {
      var context = _this2.runtime.offscreenCanvasCreator.getOrCreateContext(_this2.context.config.offscreenCanvas);
      var generatePath2 = _this2.context.pathGeneratorFactory[displayObject.nodeName];
      if (generatePath2) {
        context.beginPath();
        generatePath2(context, displayObject.parsedStyle);
        context.closePath();
      }
      return context.isPointInPath(position.x, position.y);
    };
  }
  return _createClass(CanvasPickerPlugin2, [{
    key: "apply",
    value: function apply(context, runtime2) {
      var _renderingContext$roo, _this2 = this;
      var renderingService = context.renderingService, renderingContext = context.renderingContext;
      this.context = context;
      this.runtime = runtime2;
      var document2 = (_renderingContext$roo = renderingContext.root) === null || _renderingContext$roo === void 0 ? void 0 : _renderingContext$roo.ownerDocument;
      renderingService.hooks.pick.tapPromise(CanvasPickerPlugin2.tag, function() {
        var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(result) {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1)
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", _this2.pick(document2, result));
                case 1:
                case "end":
                  return _context.stop();
              }
          }, _callee);
        }));
        return function(_x) {
          return _ref.apply(this, arguments);
        };
      }());
      renderingService.hooks.pickSync.tap(CanvasPickerPlugin2.tag, function(result) {
        return _this2.pick(document2, result);
      });
    }
  }, {
    key: "pick",
    value: function pick3(document2, result) {
      var topmost = result.topmost, _result$position = result.position, x3 = _result$position.x, y3 = _result$position.y;
      var position = vec3_exports.set(tmpVec3a, x3, y3, 0);
      var hitTestList = document2.elementsFromBBox(position[0], position[1], position[0], position[1]);
      var pickedDisplayObjects = [];
      var _iterator = _createForOfIteratorHelper(hitTestList), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _displayObject = _step.value;
          var worldTransform = _displayObject.getWorldTransform();
          var isHitOriginShape = this.isHit(_displayObject, position, worldTransform, false);
          if (isHitOriginShape) {
            var clipped = findClosestClipPathTarget(_displayObject);
            if (clipped) {
              var clipPath = clipped.parsedStyle.clipPath;
              var isHitClipPath = this.isHit(clipPath, position, clipPath.getWorldTransform(), true);
              if (isHitClipPath) {
                if (topmost) {
                  result.picked = [_displayObject];
                  return result;
                }
                pickedDisplayObjects.push(_displayObject);
              }
            } else {
              if (topmost) {
                result.picked = [_displayObject];
                return result;
              }
              pickedDisplayObjects.push(_displayObject);
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      result.picked = pickedDisplayObjects;
      return result;
    }
  }]);
}();
CanvasPickerPlugin.tag = "CanvasPicker";
function isPointInPath$8(displayObject, position, isClipPath) {
  var _ref = displayObject.parsedStyle, _ref$cx = _ref.cx, cx = _ref$cx === void 0 ? 0 : _ref$cx, _ref$cy = _ref.cy, cy = _ref$cy === void 0 ? 0 : _ref$cy, r = _ref.r, fill = _ref.fill, stroke2 = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var halfLineWidth = (lineWidth + increasedLineWidthForHitTesting) / 2;
  var absDistance = distance4(cx, cy, position.x, position.y);
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  if (hasFill && hasStroke || isClipPath) {
    return absDistance <= r + halfLineWidth;
  }
  if (hasFill) {
    return absDistance <= r;
  }
  if (hasStroke) {
    return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
  }
  return false;
}
function ellipseDistance(squareX, squareY, rx, ry) {
  return squareX / (rx * rx) + squareY / (ry * ry);
}
function isPointInPath$7(displayObject, position, isClipPath) {
  var _ref = displayObject.parsedStyle, _ref$cx = _ref.cx, cx = _ref$cx === void 0 ? 0 : _ref$cx, _ref$cy = _ref.cy, cy = _ref$cy === void 0 ? 0 : _ref$cy, rx = _ref.rx, ry = _ref.ry, fill = _ref.fill, stroke2 = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var x3 = position.x, y3 = position.y;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  var halfLineWith = (lineWidth + increasedLineWidthForHitTesting) / 2;
  var squareX = (x3 - cx) * (x3 - cx);
  var squareY = (y3 - cy) * (y3 - cy);
  if (hasFill && hasStroke || isClipPath) {
    return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
  }
  if (hasFill) {
    return ellipseDistance(squareX, squareY, rx, ry) <= 1;
  }
  if (hasStroke) {
    return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
  }
  return false;
}
function inBox(minX, minY, width, height, x3, y3) {
  return x3 >= minX && x3 <= minX + width && y3 >= minY && y3 <= minY + height;
}
function inRect(minX, minY, width, height, lineWidth, x3, y3) {
  var halfWidth = lineWidth / 2;
  return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x3, y3) || // 上边
  inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x3, y3) || // 右边
  inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x3, y3) || // 下边
  inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x3, y3);
}
function inArc(cx, cy, r, startAngle, endAngle, lineWidth, x3, y3) {
  var angle4 = (Math.atan2(y3 - cy, x3 - cx) + Math.PI * 2) % (Math.PI * 2);
  var point7 = {
    x: cx + r * Math.cos(angle4),
    y: cy + r * Math.sin(angle4)
  };
  return distance4(point7.x, point7.y, x3, y3) <= lineWidth / 2;
}
function inLine(x12, y12, x22, y22, lineWidth, x3, y3) {
  var minX = Math.min(x12, x22);
  var maxX = Math.max(x12, x22);
  var minY = Math.min(y12, y22);
  var maxY2 = Math.max(y12, y22);
  var halfWidth = lineWidth / 2;
  if (!(x3 >= minX - halfWidth && x3 <= maxX + halfWidth && y3 >= minY - halfWidth && y3 <= maxY2 + halfWidth)) {
    return false;
  }
  return pointToLine(x12, y12, x22, y22, x3, y3) <= lineWidth / 2;
}
function inPolyline(points, lineWidth, x3, y3, isClose) {
  var count4 = points.length;
  if (count4 < 2) {
    return false;
  }
  for (var i = 0; i < count4 - 1; i++) {
    var x12 = points[i][0];
    var y12 = points[i][1];
    var x22 = points[i + 1][0];
    var y22 = points[i + 1][1];
    if (inLine(x12, y12, x22, y22, lineWidth, x3, y3)) {
      return true;
    }
  }
  if (isClose) {
    var first3 = points[0];
    var last5 = points[count4 - 1];
    if (inLine(first3[0], first3[1], last5[0], last5[1], lineWidth, x3, y3)) {
      return true;
    }
  }
  return false;
}
var tolerance = 1e-6;
function dcmp(x3) {
  if (Math.abs(x3) < tolerance) {
    return 0;
  }
  return x3 < 0 ? -1 : 1;
}
function onSegment(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function inPolygon(points, x3, y3) {
  var isHit = false;
  var n = points.length;
  if (n <= 2) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points[i];
    var p2 = points[(i + 1) % n];
    if (onSegment(p1, p2, [x3, y3])) {
      return true;
    }
    if (dcmp(p1[1] - y3) > 0 !== dcmp(p2[1] - y3) > 0 && dcmp(x3 - (y3 - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}
function inPolygons(polygons, x3, y3) {
  var isHit = false;
  for (var i = 0; i < polygons.length; i++) {
    var points = polygons[i];
    isHit = inPolygon(points, x3, y3);
    if (isHit) {
      break;
    }
  }
  return isHit;
}
function isPointInPath$6(displayObject, position, isClipPath) {
  var _ref = displayObject.parsedStyle, x12 = _ref.x1, y12 = _ref.y1, x22 = _ref.x2, y22 = _ref.y2, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, fill = _ref.fill, stroke2 = _ref.stroke;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasStroke = _isFillOrStrokeAffect2[1];
  if (!hasStroke && !isClipPath || !lineWidth) {
    return false;
  }
  return inLine(x12, y12, x22, y22, lineWidth + increasedLineWidthForHitTesting, position.x, position.y);
}
function isPointInStroke2(segments, lineWidth, px2, py, length5) {
  var isHit = false;
  var halfWidth = lineWidth / 2;
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
    if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, px2, py)) {
      continue;
    }
    switch (segment.command) {
      case "L":
      case "Z":
        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, px2, py);
        if (isHit) {
          return true;
        }
        break;
      case "Q":
        var qDistance = pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], px2, py);
        isHit = qDistance <= lineWidth / 2;
        if (isHit) {
          return true;
        }
        break;
      case "C":
        var cDistance = pointDistance$3(
          prePoint[0],
          // 上一段结束位置, 即 C 的起始点
          prePoint[1],
          params[1],
          // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点
          params[2],
          params[3],
          params[4],
          params[5],
          params[6],
          px2,
          py,
          length5
        );
        isHit = cDistance <= lineWidth / 2;
        if (isHit) {
          return true;
        }
        break;
      case "A":
        if (!segment.cubicParams) {
          segment.cubicParams = arcToCubic(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], params[7], void 0);
        }
        var args = segment.cubicParams;
        var prePointInCubic = prePoint;
        for (var _i = 0; _i < args.length; _i += 6) {
          var _cDistance = pointDistance$3(
            prePointInCubic[0],
            // 上一段结束位置, 即 C 的起始点
            prePointInCubic[1],
            args[_i],
            args[_i + 1],
            args[_i + 2],
            args[_i + 3],
            args[_i + 4],
            args[_i + 5],
            px2,
            py,
            length5
          );
          prePointInCubic = [args[_i + 4], args[_i + 5]];
          isHit = _cDistance <= lineWidth / 2;
          if (isHit) {
            return true;
          }
        }
        break;
    }
  }
  return isHit;
}
function isPointInPath$5(displayObject, position, isClipPath, isPointInPath2, renderingPluginContext, runtime2) {
  var _ref = displayObject.parsedStyle, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, stroke2 = _ref.stroke, fill = _ref.fill, d3 = _ref.d, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var segments = d3.segments, hasArc = d3.hasArc, polylines = d3.polylines, polygons = d3.polygons;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(
    pointerEvents,
    // Only a closed path can be filled.
    (polygons === null || polygons === void 0 ? void 0 : polygons.length) && fill,
    stroke2
  ), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  var totalLength = getOrCalculatePathTotalLength(displayObject);
  var isHit = false;
  if (hasFill || isClipPath) {
    if (hasArc) {
      isHit = isPointInPath2(displayObject, position);
    } else {
      isHit = inPolygons(polygons, position.x, position.y) || inPolygons(polylines, position.x, position.y);
    }
    return isHit;
  }
  if (hasStroke || isClipPath) {
    isHit = isPointInStroke2(segments, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, totalLength);
  }
  return isHit;
}
function isPointInPath$4(displayObject, position, isClipPath) {
  var _ref = displayObject.parsedStyle, stroke2 = _ref.stroke, fill = _ref.fill, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, points = _ref.points, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  var isHit = false;
  if (hasStroke || isClipPath) {
    isHit = inPolyline(points.points, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, true);
  }
  if (!isHit && (hasFill || isClipPath)) {
    isHit = inPolygon(points.points, position.x, position.y);
  }
  return isHit;
}
function isPointInPath$3(displayObject, position, isClipPath) {
  var _ref = displayObject.parsedStyle, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, points = _ref.points, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, fill = _ref.fill, stroke2 = _ref.stroke;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasStroke = _isFillOrStrokeAffect2[1];
  if (!hasStroke && !isClipPath || !lineWidth) {
    return false;
  }
  return inPolyline(points.points, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, false);
}
function isPointInPath$2(displayObject, position, isClipPath, isPointInPath2, runtime2) {
  var _ref = displayObject.parsedStyle, radius = _ref.radius, fill = _ref.fill, stroke2 = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$x = _ref.x, x3 = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y3 = _ref$y === void 0 ? 0 : _ref$y, width = _ref.width, height = _ref.height, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  var hasRadius = radius && radius.some(function(r) {
    return r !== 0;
  });
  var lineWidthForHitTesting = lineWidth + increasedLineWidthForHitTesting;
  if (!hasRadius) {
    var halfWidth = lineWidthForHitTesting / 2;
    if (hasFill && hasStroke || isClipPath) {
      return inBox(x3 - halfWidth, y3 - halfWidth, width + halfWidth, height + halfWidth, position.x, position.y);
    }
    if (hasFill) {
      return inBox(x3, y3, width, height, position.x, position.y);
    }
    if (hasStroke) {
      return inRect(x3, y3, width, height, lineWidthForHitTesting, position.x, position.y);
    }
  } else {
    var isHit = false;
    if (hasStroke || isClipPath) {
      isHit = inRectWithRadius(x3, y3, width, height, radius.map(function(r) {
        return clamp_default(r, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
      }), lineWidthForHitTesting, position.x, position.y);
    }
    if (!isHit && (hasFill || isClipPath)) {
      isHit = isPointInPath2(displayObject, position);
    }
    return isHit;
  }
  return false;
}
function inRectWithRadius(minX, minY, width, height, radiusArray, lineWidth, x3, y3) {
  var _radiusArray = _slicedToArray(radiusArray, 4), tlr = _radiusArray[0], trr = _radiusArray[1], brr = _radiusArray[2], blr = _radiusArray[3];
  return inLine(minX + tlr, minY, minX + width - trr, minY, lineWidth, x3, y3) || inLine(minX + width, minY + trr, minX + width, minY + height - brr, lineWidth, x3, y3) || inLine(minX + width - brr, minY + height, minX + blr, minY + height, lineWidth, x3, y3) || inLine(minX, minY + height - blr, minX, minY + tlr, lineWidth, x3, y3) || inArc(minX + width - trr, minY + trr, trr, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x3, y3) || inArc(minX + width - brr, minY + height - brr, brr, 0, 0.5 * Math.PI, lineWidth, x3, y3) || inArc(minX + blr, minY + height - blr, blr, 0.5 * Math.PI, Math.PI, lineWidth, x3, y3) || inArc(minX + tlr, minY + tlr, tlr, Math.PI, 1.5 * Math.PI, lineWidth, x3, y3);
}
function isPointInPath$1(displayObject, position, isClipPath, isPointInPath2, renderingPluginContext, runtime2) {
  var _ref = displayObject.parsedStyle, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, _ref$x = _ref.x, x3 = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y3 = _ref$y === void 0 ? 0 : _ref$y, width = _ref.width, height = _ref.height;
  if (pointerEvents === "non-transparent-pixel") {
    var offscreenCanvas = renderingPluginContext.config.offscreenCanvas;
    var canvas = runtime2.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
    var context = runtime2.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {
      willReadFrequently: true
    });
    canvas.width = width;
    canvas.height = height;
    renderingPluginContext.defaultStyleRendererFactory[Shape.IMAGE].render(context, _objectSpread2(_objectSpread2({}, displayObject.parsedStyle), {}, {
      x: 0,
      y: 0
    }), displayObject, void 0, void 0, void 0);
    var imagedata = context.getImageData(position.x - x3, position.y - y3, 1, 1).data;
    return imagedata.every(function(component) {
      return component !== 0;
    });
  }
  return true;
}
function isPointInPath(displayObject, position, isClipPath, isPointInPath2) {
  var bounds = displayObject.getGeometryBounds();
  return position.x >= bounds.min[0] && position.y >= bounds.min[1] && position.x <= bounds.max[0] && position.y <= bounds.max[1];
}
var Plugin2 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    _classCallCheck(this, Plugin8);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin8, [].concat(args));
    _this2.name = "canvas-picker";
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      var _pointInPathPickerFac;
      var pointInPathPickerFactory = (_pointInPathPickerFac = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_pointInPathPickerFac, Shape.CIRCLE, isPointInPath$8), Shape.ELLIPSE, isPointInPath$7), Shape.RECT, isPointInPath$2), Shape.LINE, isPointInPath$6), Shape.POLYLINE, isPointInPath$3), Shape.POLYGON, isPointInPath$4), Shape.PATH, isPointInPath$5), Shape.TEXT, isPointInPath), Shape.GROUP, null), Shape.IMAGE, isPointInPath$1), _defineProperty(_defineProperty(_pointInPathPickerFac, Shape.HTML, null), Shape.MESH, null));
      this.context.pointInPathPickerFactory = pointInPathPickerFactory;
      this.addRenderingPlugin(new CanvasPickerPlugin());
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      delete this.context.pointInPathPickerFactory;
      this.removeAllRenderingPlugins();
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js
function _classPrivateFieldBase(e, t) {
  if (!{}.hasOwnProperty.call(e, t))
    throw new TypeError("attempted to use private field on non-instance");
  return e;
}

// node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js
var id3 = 0;
function _classPrivateFieldKey(e) {
  return "__private_" + id3++ + "_" + e;
}

// node_modules/@antv/g-plugin-image-loader/dist/index.esm.js
var RefCountCache = function() {
  function RefCountCache2() {
    _classCallCheck(this, RefCountCache2);
    this.cacheStore = /* @__PURE__ */ new Map();
  }
  return _createClass(RefCountCache2, [{
    key: "onRefAdded",
    value: function onRefAdded2(ref) {
    }
  }, {
    key: "has",
    value: function has(key) {
      return this.cacheStore.has(key);
    }
  }, {
    key: "put",
    value: function put(key, item, ref) {
      if (this.cacheStore.has(key)) {
        return false;
      }
      this.cacheStore.set(key, {
        value: item,
        counter: /* @__PURE__ */ new Set([ref])
      });
      this.onRefAdded(ref);
      return true;
    }
  }, {
    key: "get",
    value: function get4(key, ref) {
      var cacheItem = this.cacheStore.get(key);
      if (!cacheItem) {
        return null;
      }
      if (!cacheItem.counter.has(ref)) {
        cacheItem.counter.add(ref);
        this.onRefAdded(ref);
      }
      return cacheItem.value;
    }
  }, {
    key: "update",
    value: function update2(key, value2, ref) {
      var cacheItem = this.cacheStore.get(key);
      if (!cacheItem) {
        return false;
      }
      cacheItem.value = _objectSpread2(_objectSpread2({}, cacheItem.value), value2);
      if (!cacheItem.counter.has(ref)) {
        cacheItem.counter.add(ref);
        this.onRefAdded(ref);
      }
      return true;
    }
  }, {
    key: "release",
    value: function release(key, ref) {
      var cacheItem = this.cacheStore.get(key);
      if (!cacheItem) {
        return false;
      }
      cacheItem.counter["delete"](ref);
      if (cacheItem.counter.size <= 0) {
        this.cacheStore["delete"](key);
      }
      return true;
    }
  }, {
    key: "releaseRef",
    value: function releaseRef(ref) {
      var _this2 = this;
      Array.from(this.cacheStore.keys()).forEach(function(key) {
        _this2.release(key, ref);
      });
    }
  }, {
    key: "getSize",
    value: function getSize() {
      return this.cacheStore.size;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.cacheStore.clear();
    }
  }]);
}();
var tasks = [];
var nextFrameTasks = [];
var ImageSlicer = function() {
  function ImageSlicer2() {
    _classCallCheck(this, ImageSlicer2);
  }
  return _createClass(ImageSlicer2, null, [{
    key: "stop",
    value: function stop() {
      var api = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ImageSlicer2.api;
      if (ImageSlicer2.rafId) {
        api.cancelAnimationFrame(ImageSlicer2.rafId);
        ImageSlicer2.rafId = null;
      }
    }
  }, {
    key: "executeTask",
    value: function executeTask() {
      var api = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ImageSlicer2.api;
      if (tasks.length <= 0 && nextFrameTasks.length <= 0) {
        return;
      }
      nextFrameTasks.forEach(function(task) {
        return task();
      });
      nextFrameTasks = tasks.splice(0, ImageSlicer2.TASK_NUM_PER_FRAME);
      ImageSlicer2.rafId = api.requestAnimationFrame(function() {
        ImageSlicer2.executeTask(api);
      });
    }
  }, {
    key: "sliceImage",
    value: function sliceImage(image, sliceWidth, sliceHeight, rerender) {
      var overlap = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
      var api = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : ImageSlicer2.api;
      var imageWidth = image.naturalWidth || image.width;
      var imageHeight = image.naturalHeight || image.height;
      var strideW = sliceWidth - overlap;
      var strideH = sliceHeight - overlap;
      var gridCols = Math.ceil(imageWidth / strideW);
      var gridRows = Math.ceil(imageHeight / strideH);
      var result = {
        tileSize: [sliceWidth, sliceHeight],
        gridSize: [gridRows, gridCols],
        tiles: Array(gridRows).fill(null).map(function() {
          return Array(gridCols).fill(null);
        })
      };
      var _loop = function _loop2(row3) {
        var _loop22 = function _loop23(col2) {
          tasks.push(function() {
            var startX = col2 * strideW;
            var startY = row3 * strideH;
            var _ref = [Math.min(sliceWidth, imageWidth - startX), Math.min(sliceHeight, imageHeight - startY)], tempSliceWidth = _ref[0], tempSliceHeight = _ref[1];
            var sliceCanvas = api.createCanvas();
            sliceCanvas.width = sliceWidth;
            sliceCanvas.height = sliceHeight;
            var sliceCtx = sliceCanvas.getContext("2d");
            sliceCtx.drawImage(image, startX, startY, tempSliceWidth, tempSliceHeight, 0, 0, tempSliceWidth, tempSliceHeight);
            result.tiles[row3][col2] = {
              x: startX,
              y: startY,
              tileX: col2,
              tileY: row3,
              data: sliceCanvas
            };
            rerender();
          });
        };
        for (var col = 0; col < gridCols; col++) {
          _loop22(col);
        }
      };
      for (var row2 = 0; row2 < gridRows; row2++) {
        _loop(row2);
      }
      ImageSlicer2.stop();
      ImageSlicer2.executeTask();
      return result;
    }
  }]);
}();
ImageSlicer.TASK_NUM_PER_FRAME = 10;
var IMAGE_CACHE = new RefCountCache();
IMAGE_CACHE.onRefAdded = function onRefAdded(ref) {
  var _this2 = this;
  ref.addEventListener(ElementEvent.DESTROY, function() {
    _this2.releaseRef(ref);
  }, {
    once: true
  });
};
var ImagePool = function() {
  function ImagePool2(context, runtime2) {
    _classCallCheck(this, ImagePool2);
    this.gradientCache = {};
    this.patternCache = {};
    this.context = context;
    this.runtime = runtime2;
  }
  return _createClass(ImagePool2, [{
    key: "getImageSync",
    value: function getImageSync(src, ref, callback) {
      var imageSource = isString(src) ? src : src.src;
      if (IMAGE_CACHE.has(imageSource)) {
        var imageCache = IMAGE_CACHE.get(imageSource, ref);
        if (imageCache.img.complete) {
          callback === null || callback === void 0 || callback(imageCache);
          return imageCache;
        }
      }
      this.getOrCreateImage(src, ref).then(function(cache2) {
        callback === null || callback === void 0 || callback(cache2);
      })["catch"](function(reason) {
        console.error(reason);
      });
      return null;
    }
  }, {
    key: "getOrCreateImage",
    value: function getOrCreateImage(src, ref) {
      var _this2 = this;
      var imageSource = isString(src) ? src : src.src;
      if (!isString(src) && !IMAGE_CACHE.has(imageSource)) {
        var imageCache = {
          img: src,
          size: [src.naturalWidth || src.width, src.naturalHeight || src.height],
          tileSize: calculateImageTileSize(src)
        };
        IMAGE_CACHE.put(imageSource, imageCache, ref);
      }
      if (IMAGE_CACHE.has(imageSource)) {
        var _imageCache = IMAGE_CACHE.get(imageSource, ref);
        if (_imageCache.img.complete) {
          return Promise.resolve(_imageCache);
        }
        return new Promise(function(resolve, reject) {
          _imageCache.img.addEventListener("load", function() {
            _imageCache.size = [_imageCache.img.naturalWidth || _imageCache.img.width, _imageCache.img.naturalHeight || _imageCache.img.height];
            _imageCache.tileSize = calculateImageTileSize(_imageCache.img);
            resolve(_imageCache);
          });
          _imageCache.img.addEventListener("error", function(ev) {
            reject(ev);
          });
        });
      }
      return new Promise(function(resolve, reject) {
        var image = _this2.context.config.createImage();
        if (image) {
          var _imageCache2 = {
            img: image,
            size: [0, 0],
            tileSize: calculateImageTileSize(image)
          };
          IMAGE_CACHE.put(imageSource, _imageCache2, ref);
          image.onload = function() {
            _imageCache2.size = [image.naturalWidth || image.width, image.naturalHeight || image.height];
            _imageCache2.tileSize = calculateImageTileSize(_imageCache2.img);
            resolve(_imageCache2);
          };
          image.onerror = function(ev) {
            reject(ev);
          };
          image.crossOrigin = "Anonymous";
          image.src = imageSource;
        }
      });
    }
  }, {
    key: "createDownSampledImage",
    value: function() {
      var _createDownSampledImage = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(src, ref) {
        var imageCache, enableLargeImageOptimization, _ref, _ref$maxDownSampledIm, maxDownSampledImageSize, _ref$downSamplingRate, downSamplingRateThreshold, createImageBitmapFunc, _imageCache$size, originWidth, originHeight, resizedImage, downSamplingRate, updateCache;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getOrCreateImage(src, ref);
              case 2:
                imageCache = _context.sent;
                if (!(typeof imageCache.downSamplingRate !== "undefined")) {
                  _context.next = 5;
                  break;
                }
                return _context.abrupt("return", imageCache);
              case 5:
                enableLargeImageOptimization = this.context.config.enableLargeImageOptimization;
                _ref = typeof enableLargeImageOptimization === "boolean" ? {} : enableLargeImageOptimization, _ref$maxDownSampledIm = _ref.maxDownSampledImageSize, maxDownSampledImageSize = _ref$maxDownSampledIm === void 0 ? 2048 : _ref$maxDownSampledIm, _ref$downSamplingRate = _ref.downSamplingRateThreshold, downSamplingRateThreshold = _ref$downSamplingRate === void 0 ? 0.5 : _ref$downSamplingRate;
                createImageBitmapFunc = this.runtime.globalThis.createImageBitmap;
                _imageCache$size = _slicedToArray(imageCache.size, 2), originWidth = _imageCache$size[0], originHeight = _imageCache$size[1];
                resizedImage = imageCache.img;
                downSamplingRate = Math.min((maxDownSampledImageSize + maxDownSampledImageSize) / (originWidth + originHeight), Math.max(0.01, Math.min(downSamplingRateThreshold, 0.5)));
                updateCache = _objectSpread2(_objectSpread2({}, imageCache), {}, {
                  downSamplingRate
                });
                IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
                if (!createImageBitmapFunc) {
                  _context.next = 25;
                  break;
                }
                _context.prev = 14;
                _context.next = 17;
                return createImageBitmapFunc(imageCache.img, {
                  resizeWidth: originWidth * downSamplingRate,
                  resizeHeight: originHeight * downSamplingRate
                });
              case 17:
                resizedImage = _context.sent;
                _context.next = 23;
                break;
              case 20:
                _context.prev = 20;
                _context.t0 = _context["catch"](14);
                downSamplingRate = 1;
              case 23:
                _context.next = 26;
                break;
              case 25:
                downSamplingRate = 1;
              case 26:
                updateCache = _objectSpread2(_objectSpread2({}, this.getImageSync(src, ref)), {}, {
                  downSampled: resizedImage,
                  downSamplingRate
                });
                IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
                return _context.abrupt("return", updateCache);
              case 29:
              case "end":
                return _context.stop();
            }
        }, _callee, this, [[14, 20]]);
      }));
      function createDownSampledImage(_x, _x2) {
        return _createDownSampledImage.apply(this, arguments);
      }
      return createDownSampledImage;
    }()
  }, {
    key: "createImageTiles",
    value: function() {
      var _createImageTiles = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(src, tiles, rerender, ref) {
        var imageCache, _ref$ownerDocument$de, requestAnimationFrame3, cancelAnimationFrame3, updateCache;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getOrCreateImage(src, ref);
              case 2:
                imageCache = _context2.sent;
                _ref$ownerDocument$de = ref.ownerDocument.defaultView, requestAnimationFrame3 = _ref$ownerDocument$de.requestAnimationFrame, cancelAnimationFrame3 = _ref$ownerDocument$de.cancelAnimationFrame;
                ImageSlicer.api = {
                  requestAnimationFrame: requestAnimationFrame3,
                  cancelAnimationFrame: cancelAnimationFrame3,
                  createCanvas: function createCanvas() {
                    return OffscreenCanvasCreator.createCanvas();
                  }
                };
                updateCache = _objectSpread2(_objectSpread2({}, imageCache), ImageSlicer.sliceImage(imageCache.img, imageCache.tileSize[0], imageCache.tileSize[0], rerender));
                IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
                return _context2.abrupt("return", updateCache);
              case 8:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function createImageTiles(_x3, _x4, _x5, _x6) {
        return _createImageTiles.apply(this, arguments);
      }
      return createImageTiles;
    }()
  }, {
    key: "releaseImage",
    value: function releaseImage(src, ref) {
      IMAGE_CACHE.release(isString(src) ? src : src.src, ref);
    }
  }, {
    key: "releaseImageRef",
    value: function releaseImageRef(ref) {
      IMAGE_CACHE.releaseRef(ref);
    }
  }, {
    key: "getOrCreatePatternSync",
    value: function getOrCreatePatternSync(object, pattern, context, $offscreenCanvas, dpr, min10, callback) {
      var patternKey = this.generatePatternKey(pattern);
      if (patternKey && this.patternCache[patternKey]) {
        return this.patternCache[patternKey];
      }
      var image = pattern.image, repetition = pattern.repetition, transform2 = pattern.transform;
      var src;
      var needScaleWithDPR = false;
      if (isString(image)) {
        var imageCache = this.getImageSync(image, object, callback);
        src = imageCache === null || imageCache === void 0 ? void 0 : imageCache.img;
      } else if ($offscreenCanvas) {
        src = $offscreenCanvas;
        needScaleWithDPR = true;
      } else {
        src = image;
      }
      var canvasPattern = src && context.createPattern(src, repetition);
      if (canvasPattern) {
        var mat;
        if (transform2) {
          mat = parsedTransformToMat4(parseTransform(transform2), new DisplayObject({}));
        } else {
          mat = mat4_exports.identity(mat4_exports.create());
        }
        if (needScaleWithDPR) {
          mat4_exports.scale(mat, mat, [1 / dpr, 1 / dpr, 1]);
        }
        canvasPattern.setTransform({
          a: mat[0],
          b: mat[1],
          c: mat[4],
          d: mat[5],
          e: mat[12] + min10[0],
          f: mat[13] + min10[1]
        });
      }
      if (patternKey && canvasPattern) {
        this.patternCache[patternKey] = canvasPattern;
      }
      return canvasPattern;
    }
  }, {
    key: "getOrCreateGradient",
    value: function getOrCreateGradient(params, context) {
      var key = this.generateGradientKey(params);
      var type = params.type, steps = params.steps, min10 = params.min, width = params.width, height = params.height, angle4 = params.angle, cx = params.cx, cy = params.cy, size3 = params.size;
      if (this.gradientCache[key]) {
        return this.gradientCache[key];
      }
      var gradient2 = null;
      if (type === GradientType.LinearGradient) {
        var _computeLinearGradien = computeLinearGradient(min10, width, height, angle4), x12 = _computeLinearGradien.x1, y12 = _computeLinearGradien.y1, x22 = _computeLinearGradien.x2, y22 = _computeLinearGradien.y2;
        gradient2 = context.createLinearGradient(x12, y12, x22, y22);
      } else if (type === GradientType.RadialGradient) {
        var _computeRadialGradien = computeRadialGradient(min10, width, height, cx, cy, size3), x3 = _computeRadialGradien.x, y3 = _computeRadialGradien.y, r = _computeRadialGradien.r;
        gradient2 = context.createRadialGradient(x3, y3, 0, x3, y3, r);
      }
      if (gradient2) {
        steps.forEach(function(_ref2) {
          var offset2 = _ref2.offset, color3 = _ref2.color;
          if (offset2.unit === UnitType.kPercentage) {
            var _gradient;
            (_gradient = gradient2) === null || _gradient === void 0 || _gradient.addColorStop(offset2.value / 100, color3.toString());
          }
        });
        this.gradientCache[key] = gradient2;
      }
      return this.gradientCache[key];
    }
  }, {
    key: "generateGradientKey",
    value: function generateGradientKey(params) {
      var type = params.type, min10 = params.min, width = params.width, height = params.height, steps = params.steps, angle4 = params.angle, cx = params.cx, cy = params.cy, size3 = params.size;
      return "gradient-".concat(type, "-").concat((angle4 === null || angle4 === void 0 ? void 0 : angle4.toString()) || 0, "-").concat((cx === null || cx === void 0 ? void 0 : cx.toString()) || 0, "-").concat((cy === null || cy === void 0 ? void 0 : cy.toString()) || 0, "-").concat((size3 === null || size3 === void 0 ? void 0 : size3.toString()) || 0, "-").concat(min10[0], "-").concat(min10[1], "-").concat(width, "-").concat(height, "-").concat(steps.map(function(_ref3) {
        var offset2 = _ref3.offset, color3 = _ref3.color;
        return "".concat(offset2).concat(color3);
      }).join("-"));
    }
  }, {
    key: "generatePatternKey",
    value: function generatePatternKey(pattern) {
      var image = pattern.image, repetition = pattern.repetition;
      if (isString(image)) {
        return "pattern-".concat(image, "-").concat(repetition);
      }
      if (image.nodeName === "rect") {
        return "pattern-".concat(image.entity, "-").concat(repetition);
      }
    }
  }]);
}();
ImagePool.isSupportTile = !!OffscreenCanvasCreator.createCanvas();
function calculateImageTileSize(img) {
  if (!img.complete) {
    return [0, 0];
  }
  var width = img.naturalWidth || img.width, height = img.naturalHeight || img.height;
  var tileSize = 256;
  [256, 512].forEach(function(size3) {
    var rows = Math.ceil(height / size3);
    var cols = Math.ceil(width / size3);
    if (rows * cols < 1e3) {
      tileSize = size3;
    }
  });
  return [tileSize, tileSize];
}
var LoadImagePlugin = function() {
  function LoadImagePlugin2() {
    _classCallCheck(this, LoadImagePlugin2);
  }
  return _createClass(LoadImagePlugin2, [{
    key: "apply",
    value: function apply(context) {
      var renderingService = context.renderingService, renderingContext = context.renderingContext, imagePool = context.imagePool;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var calculateWithAspectRatio = function calculateWithAspectRatio2(object, imageWidth, imageHeight) {
        var _object$parsedStyle = object.parsedStyle, width = _object$parsedStyle.width, height = _object$parsedStyle.height;
        if (width && !height) {
          object.setAttribute("height", imageHeight / imageWidth * width);
        } else if (!width && height) {
          object.setAttribute("width", imageWidth / imageHeight * height);
        }
      };
      var handleMounted = function handleMounted2(e) {
        var object = e.target;
        var nodeName = object.nodeName, attributes = object.attributes;
        if (nodeName === Shape.IMAGE) {
          var src = attributes.src, keepAspectRatio = attributes.keepAspectRatio;
          imagePool.getImageSync(src, object, function(_ref) {
            var _ref$img = _ref.img, width = _ref$img.width, height = _ref$img.height;
            if (keepAspectRatio) {
              calculateWithAspectRatio(object, width, height);
            }
            object.renderable.dirty = true;
            renderingService.dirtify();
          });
        }
      };
      var handleAttributeChanged = function handleAttributeChanged2(e) {
        var object = e.target;
        var attrName = e.attrName, prevValue = e.prevValue, newValue = e.newValue;
        if (object.nodeName !== Shape.IMAGE || attrName !== "src") {
          return;
        }
        if (prevValue !== newValue) {
          imagePool.releaseImage(prevValue, object);
        }
        if (isString(newValue)) {
          imagePool.getOrCreateImage(newValue, object).then(function(_ref2) {
            var _ref2$img = _ref2.img, width = _ref2$img.width, height = _ref2$img.height;
            if (object.attributes.keepAspectRatio) {
              calculateWithAspectRatio(object, width, height);
            }
            object.renderable.dirty = true;
            renderingService.dirtify();
          })["catch"](function() {
          });
        }
      };
      renderingService.hooks.init.tap(LoadImagePlugin2.tag, function() {
        canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
      });
      renderingService.hooks.destroy.tap(LoadImagePlugin2.tag, function() {
        canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
      });
    }
  }]);
}();
LoadImagePlugin.tag = "LoadImage";
var Plugin3 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    _classCallCheck(this, Plugin8);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin8, [].concat(args));
    _this2.name = "image-loader";
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init(runtime2) {
      this.context.imagePool = new ImagePool(this.context, runtime2);
      this.addRenderingPlugin(new LoadImagePlugin());
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      this.removeAllRenderingPlugins();
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/g-plugin-canvas-renderer/dist/index.esm.js
var _renderState = _classPrivateFieldKey("renderState");
var CanvasRendererPlugin = function() {
  function CanvasRendererPlugin2(canvasRendererPluginOptions) {
    _classCallCheck(this, CanvasRendererPlugin2);
    this.removedRBushNodeAABBs = [];
    this.renderQueue = [];
    Object.defineProperty(this, _renderState, {
      writable: true,
      value: {
        restoreStack: [],
        prevObject: null,
        currentContext: /* @__PURE__ */ new Map()
      }
    });
    this.clearFullScreenLastFrame = false;
    this.clearFullScreen = false;
    this.vpMatrix = mat4_exports.create();
    this.dprMatrix = mat4_exports.create();
    this.tmpMat4 = mat4_exports.create();
    this.vec3a = vec3_exports.create();
    this.vec3b = vec3_exports.create();
    this.vec3c = vec3_exports.create();
    this.vec3d = vec3_exports.create();
    this.canvasRendererPluginOptions = canvasRendererPluginOptions;
  }
  return _createClass(CanvasRendererPlugin2, [{
    key: "apply",
    value: function apply(context, runtime2) {
      var _this2 = this;
      this.context = context;
      var _this$context = this.context, config = _this$context.config, camera = _this$context.camera, renderingService = _this$context.renderingService, renderingContext = _this$context.renderingContext, rBushRoot = _this$context.rBushRoot, pathGeneratorFactory = _this$context.pathGeneratorFactory;
      var enableRenderingOptimization = config.renderer.getConfig().enableRenderingOptimization;
      config.renderer.getConfig().enableDirtyCheck = false;
      config.renderer.getConfig().enableDirtyRectangleRendering = false;
      this.rBush = rBushRoot;
      this.pathGeneratorFactory = pathGeneratorFactory;
      var contextService = context.contextService;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var handleUnmounted = function handleUnmounted2(e) {
        var object = e.target;
        var rBushNode = object.rBushNode;
        if (rBushNode.aabb) {
          _this2.removedRBushNodeAABBs.push(rBushNode.aabb);
        }
      };
      var handleCulled = function handleCulled2(e) {
        var object = e.target;
        var rBushNode = object.rBushNode;
        if (rBushNode.aabb) {
          _this2.removedRBushNodeAABBs.push(rBushNode.aabb);
        }
      };
      renderingService.hooks.init.tap(CanvasRendererPlugin2.tag, function() {
        canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.addEventListener(ElementEvent.CULLED, handleCulled);
        var dpr = contextService.getDPR();
        var width = config.width, height = config.height;
        var context2 = contextService.getContext();
        _this2.clearRect(context2, 0, 0, width * dpr, height * dpr, config.background);
      });
      renderingService.hooks.destroy.tap(CanvasRendererPlugin2.tag, function() {
        canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.removeEventListener(ElementEvent.CULLED, handleCulled);
        _this2.renderQueue = [];
        _this2.removedRBushNodeAABBs = [];
        _classPrivateFieldBase(_this2, _renderState)[_renderState] = {
          restoreStack: [],
          prevObject: null,
          currentContext: null
        };
      });
      renderingService.hooks.beginFrame.tap(CanvasRendererPlugin2.tag, function() {
        var _canvas$context$rende;
        var context2 = contextService.getContext();
        var dpr = contextService.getDPR();
        var width = config.width, height = config.height;
        var _this$canvasRendererP = _this2.canvasRendererPluginOptions, dirtyObjectNumThreshold = _this$canvasRendererP.dirtyObjectNumThreshold, dirtyObjectRatioThreshold = _this$canvasRendererP.dirtyObjectRatioThreshold;
        var _renderingService$get = renderingService.getStats(), total = _renderingService$get.total, rendered = _renderingService$get.rendered;
        var ratio = rendered / total;
        _this2.clearFullScreen = _this2.clearFullScreenLastFrame || // @ts-ignore
        !((_canvas$context$rende = canvas.context.renderingPlugins[1]) !== null && _canvas$context$rende !== void 0 && _canvas$context$rende.isFirstTimeRenderingFinished) || renderingService.disableDirtyRectangleRendering() || rendered > dirtyObjectNumThreshold && ratio > dirtyObjectRatioThreshold;
        if (context2) {
          if (typeof context2.resetTransform === "function") {
            context2.resetTransform();
          } else {
            context2.setTransform(1, 0, 0, 1, 0, 0);
          }
          if (_this2.clearFullScreen) {
            _this2.clearRect(context2, 0, 0, width * dpr, height * dpr, config.background);
          }
        }
      });
      var renderByZIndex = function renderByZIndex2(object, context2) {
        var stack = [object];
        while (stack.length > 0) {
          var currentObject = stack.pop();
          if (currentObject.isVisible() && !currentObject.isCulled()) {
            if (enableRenderingOptimization) {
              _this2.renderDisplayObjectOptimized(currentObject, context2, _this2.context, _classPrivateFieldBase(_this2, _renderState)[_renderState], runtime2);
            } else {
              _this2.renderDisplayObject(currentObject, context2, _this2.context, _classPrivateFieldBase(_this2, _renderState)[_renderState], runtime2);
            }
          }
          var objects = currentObject.sortable.sorted || currentObject.childNodes;
          for (var i = objects.length - 1; i >= 0; i--) {
            stack.push(objects[i]);
          }
        }
      };
      renderingService.hooks.endFrame.tap(CanvasRendererPlugin2.tag, function() {
        if (renderingContext.root.childNodes.length === 0) {
          _this2.clearFullScreenLastFrame = true;
          return;
        }
        enableRenderingOptimization = config.renderer.getConfig().enableRenderingOptimization;
        _classPrivateFieldBase(_this2, _renderState)[_renderState] = {
          restoreStack: [],
          prevObject: null,
          currentContext: _classPrivateFieldBase(_this2, _renderState)[_renderState].currentContext
        };
        _classPrivateFieldBase(_this2, _renderState)[_renderState].currentContext.clear();
        _this2.clearFullScreenLastFrame = false;
        var context2 = contextService.getContext();
        var dpr = contextService.getDPR();
        mat4_exports.fromScaling(_this2.dprMatrix, [dpr, dpr, 1]);
        mat4_exports.multiply(_this2.vpMatrix, _this2.dprMatrix, camera.getOrthoMatrix());
        if (_this2.clearFullScreen) {
          if (enableRenderingOptimization) {
            context2.save();
            renderByZIndex(renderingContext.root, context2);
            context2.restore();
          } else {
            renderByZIndex(renderingContext.root, context2);
          }
          _this2.removedRBushNodeAABBs = [];
        } else {
          var dirtyRenderBounds = _this2.safeMergeAABB.apply(_this2, [_this2.mergeDirtyAABBs(_this2.renderQueue)].concat(_toConsumableArray(_this2.removedRBushNodeAABBs.map(function(_ref) {
            var minX = _ref.minX, minY = _ref.minY, maxX = _ref.maxX, maxY2 = _ref.maxY;
            var aabb = new AABB();
            aabb.setMinMax(
              // vec3.fromValues(minX, minY, 0),
              // vec3.fromValues(maxX, maxY, 0),
              [minX, minY, 0],
              [maxX, maxY2, 0]
            );
            return aabb;
          }))));
          _this2.removedRBushNodeAABBs = [];
          if (AABB.isEmpty(dirtyRenderBounds)) {
            _this2.renderQueue = [];
            return;
          }
          var dirtyRect = _this2.convertAABB2Rect(dirtyRenderBounds);
          var x3 = dirtyRect.x, y3 = dirtyRect.y, width = dirtyRect.width, height = dirtyRect.height;
          var tl = vec3_exports.transformMat4(_this2.vec3a, [x3, y3, 0], _this2.vpMatrix);
          var tr = vec3_exports.transformMat4(_this2.vec3b, [x3 + width, y3, 0], _this2.vpMatrix);
          var bl = vec3_exports.transformMat4(_this2.vec3c, [x3, y3 + height, 0], _this2.vpMatrix);
          var br = vec3_exports.transformMat4(_this2.vec3d, [x3 + width, y3 + height, 0], _this2.vpMatrix);
          var minx = Math.min(tl[0], tr[0], br[0], bl[0]);
          var miny = Math.min(tl[1], tr[1], br[1], bl[1]);
          var maxx = Math.max(tl[0], tr[0], br[0], bl[0]);
          var maxy = Math.max(tl[1], tr[1], br[1], bl[1]);
          var ix = Math.floor(minx);
          var iy = Math.floor(miny);
          var iwidth = Math.ceil(maxx - minx);
          var iheight = Math.ceil(maxy - miny);
          context2.save();
          _this2.clearRect(context2, ix, iy, iwidth, iheight, config.background);
          context2.beginPath();
          context2.rect(ix, iy, iwidth, iheight);
          context2.clip();
          context2.setTransform(_this2.vpMatrix[0], _this2.vpMatrix[1], _this2.vpMatrix[4], _this2.vpMatrix[5], _this2.vpMatrix[12], _this2.vpMatrix[13]);
          var _config$renderer$getC = config.renderer.getConfig(), enableDirtyRectangleRenderingDebug = _config$renderer$getC.enableDirtyRectangleRenderingDebug;
          if (enableDirtyRectangleRenderingDebug) {
            canvas.dispatchEvent(new CustomEvent(CanvasEvent.DIRTY_RECTANGLE, {
              dirtyRect: {
                x: ix,
                y: iy,
                width: iwidth,
                height: iheight
              }
            }));
          }
          var dirtyObjects = _this2.searchDirtyObjects(dirtyRenderBounds);
          dirtyObjects.sort(function(a4, b) {
            return a4.sortable.renderOrder - b.sortable.renderOrder;
          }).forEach(function(object) {
            if (object && object.isVisible() && !object.isCulled()) {
              _this2.renderDisplayObject(object, context2, _this2.context, _classPrivateFieldBase(_this2, _renderState)[_renderState], runtime2);
            }
          });
          context2.restore();
          _this2.renderQueue.forEach(function(object) {
            _this2.saveDirtyAABB(object);
          });
          _this2.renderQueue = [];
        }
        _classPrivateFieldBase(_this2, _renderState)[_renderState].restoreStack.forEach(function() {
          context2.restore();
        });
        _classPrivateFieldBase(_this2, _renderState)[_renderState].restoreStack = [];
      });
      renderingService.hooks.render.tap(CanvasRendererPlugin2.tag, function(object) {
        if (!_this2.clearFullScreen) {
          _this2.renderQueue.push(object);
        }
      });
    }
  }, {
    key: "clearRect",
    value: function clearRect(context, x3, y3, width, height, background) {
      context.clearRect(x3, y3, width, height);
      if (background) {
        context.fillStyle = background;
        context.fillRect(x3, y3, width, height);
      }
    }
  }, {
    key: "renderDisplayObjectOptimized",
    value: function renderDisplayObjectOptimized(object, context, canvasContext, renderState, runtime2) {
      var nodeName = object.nodeName;
      var updateTransform = false;
      var clipDraw = false;
      var styleRenderer = this.context.styleRendererFactory[nodeName];
      var generatePath2 = this.pathGeneratorFactory[nodeName];
      var clipPath = object.parsedStyle.clipPath;
      if (clipPath) {
        updateTransform = !renderState.prevObject || !mat4_exports.exactEquals(clipPath.getWorldTransform(), renderState.prevObject.getWorldTransform());
        if (updateTransform) {
          this.applyWorldTransform(context, clipPath);
          renderState.prevObject = null;
        }
        var _generatePath = this.pathGeneratorFactory[clipPath.nodeName];
        if (_generatePath) {
          context.save();
          clipDraw = true;
          context.beginPath();
          _generatePath(context, clipPath.parsedStyle);
          context.closePath();
          context.clip();
        }
      }
      if (styleRenderer) {
        updateTransform = !renderState.prevObject || !mat4_exports.exactEquals(object.getWorldTransform(), renderState.prevObject.getWorldTransform());
        if (updateTransform) {
          this.applyWorldTransform(context, object);
        }
        var forceUpdateStyle = !renderState.prevObject;
        if (!forceUpdateStyle) {
          var prevNodeName = renderState.prevObject.nodeName;
          if (nodeName === Shape.TEXT) {
            forceUpdateStyle = prevNodeName !== Shape.TEXT;
          } else if (nodeName === Shape.IMAGE) {
            forceUpdateStyle = prevNodeName !== Shape.IMAGE;
          } else {
            forceUpdateStyle = prevNodeName === Shape.TEXT || prevNodeName === Shape.IMAGE;
          }
        }
        styleRenderer.applyStyleToContext(context, object, forceUpdateStyle, renderState);
        renderState.prevObject = object;
      }
      if (generatePath2) {
        context.beginPath();
        generatePath2(context, object.parsedStyle);
        if (nodeName !== Shape.LINE && nodeName !== Shape.PATH && nodeName !== Shape.POLYLINE) {
          context.closePath();
        }
      }
      if (styleRenderer) {
        styleRenderer.drawToContext(context, object, _classPrivateFieldBase(this, _renderState)[_renderState], this, runtime2);
      }
      if (clipDraw) {
        context.restore();
      }
      object.renderable.dirty = false;
    }
  }, {
    key: "renderDisplayObject",
    value: function renderDisplayObject(object, context, canvasContext, renderState, runtime2) {
      var nodeName = object.nodeName;
      var parent = renderState.restoreStack[renderState.restoreStack.length - 1];
      if (parent && !(object.compareDocumentPosition(parent) & Node.DOCUMENT_POSITION_CONTAINS)) {
        context.restore();
        renderState.restoreStack.pop();
      }
      var styleRenderer = this.context.styleRendererFactory[nodeName];
      var generatePath2 = this.pathGeneratorFactory[nodeName];
      var clipPath = object.parsedStyle.clipPath;
      if (clipPath) {
        this.applyWorldTransform(context, clipPath);
        var _generatePath2 = this.pathGeneratorFactory[clipPath.nodeName];
        if (_generatePath2) {
          context.save();
          renderState.restoreStack.push(object);
          context.beginPath();
          _generatePath2(context, clipPath.parsedStyle);
          context.closePath();
          context.clip();
        }
      }
      if (styleRenderer) {
        this.applyWorldTransform(context, object);
        context.save();
        this.applyAttributesToContext(context, object);
      }
      if (generatePath2) {
        context.beginPath();
        generatePath2(context, object.parsedStyle);
        if (nodeName !== Shape.LINE && nodeName !== Shape.PATH && nodeName !== Shape.POLYLINE) {
          context.closePath();
        }
      }
      if (styleRenderer) {
        styleRenderer.render(context, object.parsedStyle, object, canvasContext, this, runtime2);
        context.restore();
      }
      object.renderable.dirty = false;
    }
  }, {
    key: "applyAttributesToContext",
    value: function applyAttributesToContext(context, object) {
      var _ref2 = object.parsedStyle, stroke2 = _ref2.stroke, fill = _ref2.fill, opacity = _ref2.opacity, lineDash = _ref2.lineDash, lineDashOffset = _ref2.lineDashOffset;
      if (lineDash) {
        context.setLineDash(lineDash);
      }
      if (!isNil(lineDashOffset)) {
        context.lineDashOffset = lineDashOffset;
      }
      if (!isNil(opacity)) {
        context.globalAlpha *= opacity;
      }
      if (!isNil(stroke2) && !Array.isArray(stroke2) && !stroke2.isNone) {
        context.strokeStyle = object.attributes.stroke;
      }
      if (!isNil(fill) && !Array.isArray(fill) && !fill.isNone) {
        context.fillStyle = object.attributes.fill;
      }
    }
  }, {
    key: "convertAABB2Rect",
    value: function convertAABB2Rect(aabb) {
      var min10 = aabb.getMin();
      var max11 = aabb.getMax();
      var minX = Math.floor(min10[0]);
      var minY = Math.floor(min10[1]);
      var maxX = Math.ceil(max11[0]);
      var maxY2 = Math.ceil(max11[1]);
      var width = maxX - minX;
      var height = maxY2 - minY;
      return {
        x: minX,
        y: minY,
        width,
        height
      };
    }
    /**
     * TODO: merge dirty rectangles with some strategies.
     * For now, we just simply merge all the rectangles into one.
     * @see https://idom.me/articles/841.html
     */
  }, {
    key: "mergeDirtyAABBs",
    value: function mergeDirtyAABBs(dirtyObjects) {
      var aabb = new AABB();
      dirtyObjects.forEach(function(object) {
        var renderBounds = object.getRenderBounds();
        aabb.add(renderBounds);
        var dirtyRenderBounds = object.renderable.dirtyRenderBounds;
        if (dirtyRenderBounds) {
          aabb.add(dirtyRenderBounds);
        }
      });
      return aabb;
    }
  }, {
    key: "searchDirtyObjects",
    value: function searchDirtyObjects(dirtyRectangle) {
      var _dirtyRectangle$getMi = dirtyRectangle.getMin(), _dirtyRectangle$getMi2 = _slicedToArray(_dirtyRectangle$getMi, 2), minX = _dirtyRectangle$getMi2[0], minY = _dirtyRectangle$getMi2[1];
      var _dirtyRectangle$getMa = dirtyRectangle.getMax(), _dirtyRectangle$getMa2 = _slicedToArray(_dirtyRectangle$getMa, 2), maxX = _dirtyRectangle$getMa2[0], maxY2 = _dirtyRectangle$getMa2[1];
      var rBushNodes = this.rBush.search({
        minX,
        minY,
        maxX,
        maxY: maxY2
      });
      return rBushNodes.map(function(_ref3) {
        var displayObject = _ref3.displayObject;
        return displayObject;
      });
    }
  }, {
    key: "saveDirtyAABB",
    value: function saveDirtyAABB(object) {
      var renderable = object.renderable;
      if (!renderable.dirtyRenderBounds) {
        renderable.dirtyRenderBounds = new AABB();
      }
      var renderBounds = object.getRenderBounds();
      if (renderBounds) {
        renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
      }
    }
  }, {
    key: "applyWorldTransform",
    value: function applyWorldTransform(context, object, matrix3) {
      if (matrix3) {
        mat4_exports.copy(this.tmpMat4, object.getLocalTransform());
        mat4_exports.multiply(this.tmpMat4, matrix3, this.tmpMat4);
        mat4_exports.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
      } else {
        mat4_exports.copy(this.tmpMat4, object.getWorldTransform());
        mat4_exports.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
      }
      context.setTransform(this.tmpMat4[0], this.tmpMat4[1], this.tmpMat4[4], this.tmpMat4[5], this.tmpMat4[12], this.tmpMat4[13]);
    }
  }, {
    key: "safeMergeAABB",
    value: function safeMergeAABB() {
      var merged = new AABB();
      for (var _len = arguments.length, aabbs = new Array(_len), _key = 0; _key < _len; _key++) {
        aabbs[_key] = arguments[_key];
      }
      aabbs.forEach(function(aabb) {
        merged.add(aabb);
      });
      return merged;
    }
  }]);
}();
CanvasRendererPlugin.tag = "CanvasRenderer";
function getPattern(pattern, object, context, canvasContext, plugin, runtime2, imagePool) {
  var $offscreenCanvas;
  var dpr;
  if (pattern.image.nodeName === "rect") {
    var _parsedStyle = pattern.image.parsedStyle, width = _parsedStyle.width, height = _parsedStyle.height;
    dpr = canvasContext.contextService.getDPR();
    var offscreenCanvas = canvasContext.config.offscreenCanvas;
    $offscreenCanvas = runtime2.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
    $offscreenCanvas.width = width * dpr;
    $offscreenCanvas.height = height * dpr;
    var offscreenCanvasContext = runtime2.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
    var renderState = {
      restoreStack: [],
      prevObject: null,
      currentContext: /* @__PURE__ */ new Map()
    };
    pattern.image.forEach(function(object2) {
      plugin.renderDisplayObject(object2, offscreenCanvasContext, canvasContext, renderState, runtime2);
    });
    renderState.restoreStack.forEach(function() {
      offscreenCanvasContext.restore();
    });
  }
  var canvasPattern = imagePool.getOrCreatePatternSync(object, pattern, context, $offscreenCanvas, dpr, object.getGeometryBounds().min, function() {
    object.renderable.dirty = true;
    canvasContext.renderingService.dirtify();
  });
  return canvasPattern;
}
function getColor2(parsedColor, object, context, imagePool) {
  var color3;
  if (parsedColor.type === GradientType.LinearGradient || parsedColor.type === GradientType.RadialGradient) {
    var bounds = object.getGeometryBounds();
    var width = bounds && bounds.halfExtents[0] * 2 || 1;
    var height = bounds && bounds.halfExtents[1] * 2 || 1;
    var min10 = bounds && bounds.min || [0, 0];
    color3 = imagePool.getOrCreateGradient(_objectSpread2(_objectSpread2({
      type: parsedColor.type
    }, parsedColor.value), {}, {
      min: min10,
      width,
      height
    }), context);
  }
  return color3;
}
var SHADOW_NUMBER_STYLE = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"];
var STROKE_STYLE = ["lineCap", "lineJoin", "miterLimit"];
var DEFAULT_STYLE = {
  // common
  globalAlpha: 1,
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  filter: "none",
  globalCompositeOperation: "source-over",
  // stroke/fill
  strokeStyle: "#000",
  strokeOpacity: 1,
  lineWidth: 1,
  lineDash: [],
  lineDashOffset: 0,
  lineCap: "butt",
  lineJoin: "miter",
  miterLimit: 10,
  fillStyle: "#000",
  fillOpacity: 1
  // image
};
var defaultParsedStyle = {};
function updateContextIfNotHitCache(context, key, value2, cache2) {
  var prevValue = cache2.has(key) ? cache2.get(key) : DEFAULT_STYLE[key];
  if (prevValue !== value2) {
    if (key === "lineDash") {
      context.setLineDash(value2);
    } else {
      context[key] = value2;
    }
    cache2.set(key, value2);
  }
  return prevValue;
}
var OptimizedDefaultRenderer = function() {
  function OptimizedDefaultRenderer2(imagePool) {
    _classCallCheck(this, OptimizedDefaultRenderer2);
    this.imagePool = imagePool;
  }
  return _createClass(OptimizedDefaultRenderer2, [{
    key: "applyAttributesToContext",
    value: function applyAttributesToContext(context, object) {
    }
  }, {
    key: "render",
    value: function render3(context, parsedStyle, object, canvasContext, plugin, runtime2) {
    }
    // #region common style
  }, {
    key: "applyCommonStyleToContext",
    value: function applyCommonStyleToContext(context, object, forceUpdate, renderState) {
      var prevStyle = forceUpdate ? defaultParsedStyle : renderState.prevObject.parsedStyle;
      var style = object.parsedStyle;
      if (forceUpdate || style.opacity !== prevStyle.opacity) {
        updateContextIfNotHitCache(context, "globalAlpha", !isNil(style.opacity) ? style.opacity : DEFAULT_STYLE.globalAlpha, renderState.currentContext);
      }
      if (forceUpdate || style.blend !== prevStyle.blend) {
        updateContextIfNotHitCache(
          context,
          "globalCompositeOperation",
          // @ts-ignore
          !isNil(style.blend) ? (
            // @ts-ignore
            style.blend
          ) : DEFAULT_STYLE.globalCompositeOperation,
          renderState.currentContext
        );
      }
    }
    // #endregion common style
    // #region stroke/fill style
  }, {
    key: "applyStrokeFillStyleToContext",
    value: function applyStrokeFillStyleToContext(context, object, forceUpdate, renderState) {
      var prevStyle = forceUpdate ? defaultParsedStyle : renderState.prevObject.parsedStyle;
      var style = object.parsedStyle;
      var _style$lineWidth = style.lineWidth, lineWidth = _style$lineWidth === void 0 ? DEFAULT_STYLE.lineWidth : _style$lineWidth;
      var hasFill = style.fill && !style.fill.isNone;
      var hasStroke = style.stroke && !style.stroke.isNone && lineWidth > 0;
      if (hasStroke) {
        if (forceUpdate || object.attributes.stroke !== renderState.prevObject.attributes.stroke) {
          var value2 = !isNil(style.stroke) && !Array.isArray(style.stroke) && !style.stroke.isNone ? object.attributes.stroke : DEFAULT_STYLE.strokeStyle;
          updateContextIfNotHitCache(context, "strokeStyle", value2, renderState.currentContext);
        }
        if (forceUpdate || style.lineWidth !== prevStyle.lineWidth) {
          updateContextIfNotHitCache(context, "lineWidth", !isNil(style.lineWidth) ? style.lineWidth : DEFAULT_STYLE.lineWidth, renderState.currentContext);
        }
        if (forceUpdate || style.lineDash !== prevStyle.lineDash) {
          updateContextIfNotHitCache(context, "lineDash", style.lineDash || DEFAULT_STYLE.lineDash, renderState.currentContext);
        }
        if (forceUpdate || style.lineDashOffset !== prevStyle.lineDashOffset) {
          updateContextIfNotHitCache(context, "lineDashOffset", !isNil(style.lineDashOffset) ? style.lineDashOffset : DEFAULT_STYLE.lineDashOffset, renderState.currentContext);
        }
        for (var i = 0; i < STROKE_STYLE.length; i++) {
          var styleName = STROKE_STYLE[i];
          if (forceUpdate || style[styleName] !== prevStyle[styleName]) {
            updateContextIfNotHitCache(context, styleName, !isNil(style[styleName]) ? style[styleName] : DEFAULT_STYLE[styleName], renderState.currentContext);
          }
        }
      }
      if (hasFill && (forceUpdate || object.attributes.fill !== renderState.prevObject.attributes.fill)) {
        var _value = !isNil(style.fill) && !Array.isArray(style.fill) && !style.fill.isNone ? object.attributes.fill : DEFAULT_STYLE.fillStyle;
        updateContextIfNotHitCache(context, "fillStyle", _value, renderState.currentContext);
      }
    }
    // #endregion stroke/fill style
  }, {
    key: "applyStyleToContext",
    value: function applyStyleToContext(context, object, forceUpdate, renderState) {
      var nodeName = object.nodeName;
      this.applyCommonStyleToContext(context, object, forceUpdate, renderState);
      if (nodeName === Shape.IMAGE)
        ;
      else {
        this.applyStrokeFillStyleToContext(context, object, forceUpdate, renderState);
      }
    }
  }, {
    key: "applyShadowAndFilterStyleToContext",
    value: function applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState) {
      var style = object.parsedStyle;
      if (hasShadow) {
        updateContextIfNotHitCache(context, "shadowColor", style.shadowColor.toString(), renderState.currentContext);
        for (var i = 0; i < SHADOW_NUMBER_STYLE.length; i++) {
          var styleName = SHADOW_NUMBER_STYLE[i];
          updateContextIfNotHitCache(context, styleName, style[styleName] || DEFAULT_STYLE[styleName], renderState.currentContext);
        }
      }
      if (style.filter && style.filter.length) {
        updateContextIfNotHitCache(
          context,
          "filter",
          // use raw filter string
          object.attributes.filter,
          renderState.currentContext
        );
      }
    }
  }, {
    key: "clearShadowAndFilterStyleForContext",
    value: function clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState) {
      var onlyClearShadowFilter = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      if (hasShadow) {
        updateContextIfNotHitCache(context, "shadowColor", DEFAULT_STYLE.shadowColor, renderState.currentContext);
        for (var i = 0; i < SHADOW_NUMBER_STYLE.length; i++) {
          var styleName = SHADOW_NUMBER_STYLE[i];
          updateContextIfNotHitCache(context, styleName, DEFAULT_STYLE[styleName], renderState.currentContext);
        }
      }
      if (hasFilter) {
        if (hasShadow && onlyClearShadowFilter) {
          var oldFilter = context.filter;
          if (!isNil(oldFilter) && oldFilter.indexOf("drop-shadow") > -1) {
            updateContextIfNotHitCache(context, "filter", oldFilter.replace(/drop-shadow\([^)]*\)/, "").trim() || DEFAULT_STYLE.filter, renderState.currentContext);
          }
        } else {
          updateContextIfNotHitCache(context, "filter", DEFAULT_STYLE.filter, renderState.currentContext);
        }
      }
    }
  }, {
    key: "fillToContext",
    value: function fillToContext(context, object, renderState, plugin, runtime2) {
      var _this2 = this;
      var _object$parsedStyle = object.parsedStyle, fill = _object$parsedStyle.fill, fillRule = _object$parsedStyle.fillRule;
      var resetStyle = null;
      if (Array.isArray(fill) && fill.length > 0) {
        fill.forEach(function(gradient2) {
          var prevStyle = updateContextIfNotHitCache(context, "fillStyle", getColor2(gradient2, object, context, _this2.imagePool), renderState.currentContext);
          resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle;
          if (fillRule) {
            context.fill(fillRule);
          } else {
            context.fill();
          }
        });
      } else {
        if (isPattern(fill)) {
          var pattern = getPattern(fill, object, context, object.ownerDocument.defaultView.context, plugin, runtime2, this.imagePool);
          if (pattern) {
            context.fillStyle = pattern;
            resetStyle = true;
          }
        }
        if (fillRule) {
          context.fill(fillRule);
        } else {
          context.fill();
        }
      }
      if (resetStyle !== null) {
        updateContextIfNotHitCache(context, "fillStyle", resetStyle, renderState.currentContext);
      }
    }
  }, {
    key: "strokeToContext",
    value: function strokeToContext(context, object, renderState, plugin, runtime2) {
      var _this2 = this;
      var stroke2 = object.parsedStyle.stroke;
      var resetStyle = null;
      if (Array.isArray(stroke2) && stroke2.length > 0) {
        stroke2.forEach(function(gradient2) {
          var prevStyle2 = updateContextIfNotHitCache(context, "strokeStyle", getColor2(gradient2, object, context, _this2.imagePool), renderState.currentContext);
          resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle2;
          context.stroke();
        });
      } else {
        if (isPattern(stroke2)) {
          var pattern = getPattern(stroke2, object, context, object.ownerDocument.defaultView.context, plugin, runtime2, this.imagePool);
          if (pattern) {
            var prevStyle = updateContextIfNotHitCache(context, "strokeStyle", pattern, renderState.currentContext);
            resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle;
          }
        }
        context.stroke();
      }
      if (resetStyle !== null) {
        updateContextIfNotHitCache(context, "strokeStyle", resetStyle, renderState.currentContext);
      }
    }
  }, {
    key: "drawToContext",
    value: function drawToContext(context, object, renderState, plugin, runtime2) {
      var _style$fill;
      var nodeName = object.nodeName;
      var style = object.parsedStyle;
      var _style$opacity = style.opacity, opacity = _style$opacity === void 0 ? DEFAULT_STYLE.globalAlpha : _style$opacity, _style$fillOpacity = style.fillOpacity, fillOpacity = _style$fillOpacity === void 0 ? DEFAULT_STYLE.fillOpacity : _style$fillOpacity, _style$strokeOpacity = style.strokeOpacity, strokeOpacity = _style$strokeOpacity === void 0 ? DEFAULT_STYLE.strokeOpacity : _style$strokeOpacity, _style$lineWidth2 = style.lineWidth, lineWidth = _style$lineWidth2 === void 0 ? DEFAULT_STYLE.lineWidth : _style$lineWidth2;
      var hasFill = style.fill && !style.fill.isNone;
      var hasStroke = style.stroke && !style.stroke.isNone && lineWidth > 0;
      if (!hasFill && !hasStroke) {
        return;
      }
      var hasShadow = !isNil(style.shadowColor) && style.shadowBlur > 0;
      var isInnerShadow = style.shadowType === "inner";
      var isFillTransparent = ((_style$fill = style.fill) === null || _style$fill === void 0 ? void 0 : _style$fill.alpha) === 0;
      var hasFilter = !!(style.filter && style.filter.length);
      var shouldDrawShadowWithStroke = hasShadow && hasStroke && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);
      var originGlobalAlpha = null;
      if (hasFill) {
        if (!shouldDrawShadowWithStroke) {
          this.applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState);
        }
        var updateOpacity = opacity * fillOpacity;
        originGlobalAlpha = updateContextIfNotHitCache(context, "globalAlpha", updateOpacity, renderState.currentContext);
        this.fillToContext(context, object, renderState, plugin, runtime2);
        if (!shouldDrawShadowWithStroke) {
          this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState);
        }
      }
      if (hasStroke) {
        var clearShadowAndFilter = false;
        var _updateOpacity = opacity * strokeOpacity;
        var prevOpacity = updateContextIfNotHitCache(context, "globalAlpha", _updateOpacity, renderState.currentContext);
        originGlobalAlpha = hasFill ? originGlobalAlpha : prevOpacity;
        if (shouldDrawShadowWithStroke) {
          this.applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState);
          clearShadowAndFilter = true;
          if (isInnerShadow) {
            var originBlend = context.globalCompositeOperation;
            context.globalCompositeOperation = "source-atop";
            this.strokeToContext(context, object, renderState, plugin, runtime2);
            context.globalCompositeOperation = originBlend;
            this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState, true);
          }
        }
        this.strokeToContext(context, object, renderState, plugin, runtime2);
        if (clearShadowAndFilter) {
          this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState);
        }
      }
      if (originGlobalAlpha !== null) {
        updateContextIfNotHitCache(context, "globalAlpha", originGlobalAlpha, renderState.currentContext);
      }
    }
  }]);
}();
var DefaultRenderer = function(_OptimizedDefaultRend) {
  function DefaultRenderer2() {
    _classCallCheck(this, DefaultRenderer2);
    return _callSuper(this, DefaultRenderer2, arguments);
  }
  _inherits(DefaultRenderer2, _OptimizedDefaultRend);
  return _createClass(DefaultRenderer2, [{
    key: "render",
    value: function render3(context, parsedStyle, object, canvasContext, plugin, runtime2) {
      var fill = parsedStyle.fill, fillRule = parsedStyle.fillRule, _parsedStyle$opacity = parsedStyle.opacity, opacity = _parsedStyle$opacity === void 0 ? 1 : _parsedStyle$opacity, _parsedStyle$fillOpac = parsedStyle.fillOpacity, fillOpacity = _parsedStyle$fillOpac === void 0 ? 1 : _parsedStyle$fillOpac, stroke2 = parsedStyle.stroke, _parsedStyle$strokeOp = parsedStyle.strokeOpacity, strokeOpacity = _parsedStyle$strokeOp === void 0 ? 1 : _parsedStyle$strokeOp, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, lineCap = parsedStyle.lineCap, lineJoin = parsedStyle.lineJoin, shadowType = parsedStyle.shadowType, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur, filter3 = parsedStyle.filter, miterLimit = parsedStyle.miterLimit;
      var hasFill = fill && !fill.isNone;
      var hasStroke = stroke2 && !stroke2.isNone && lineWidth > 0;
      var isFillTransparent = (fill === null || fill === void 0 ? void 0 : fill.alpha) === 0;
      var hasFilter = !!(filter3 && filter3.length);
      var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
      var nodeName = object.nodeName;
      var isInnerShadow = shadowType === "inner";
      var shouldDrawShadowWithStroke = hasStroke && hasShadow && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);
      if (hasFill) {
        context.globalAlpha = opacity * fillOpacity;
        if (!shouldDrawShadowWithStroke) {
          setShadowAndFilter(object, context, hasShadow);
        }
        applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, this.imagePool);
        if (!shouldDrawShadowWithStroke) {
          this.clearShadowAndFilter(context, hasFilter, hasShadow);
        }
      }
      if (hasStroke) {
        context.globalAlpha = opacity * strokeOpacity;
        context.lineWidth = lineWidth;
        if (!isNil(miterLimit)) {
          context.miterLimit = miterLimit;
        }
        if (!isNil(lineCap)) {
          context.lineCap = lineCap;
        }
        if (!isNil(lineJoin)) {
          context.lineJoin = lineJoin;
        }
        if (shouldDrawShadowWithStroke) {
          if (isInnerShadow) {
            context.globalCompositeOperation = "source-atop";
          }
          setShadowAndFilter(object, context, true);
          if (isInnerShadow) {
            applyStroke(context, object, stroke2, canvasContext, plugin, runtime2, this.imagePool);
            context.globalCompositeOperation = DEFAULT_STYLE.globalCompositeOperation;
            this.clearShadowAndFilter(context, hasFilter, true);
          }
        }
        applyStroke(context, object, stroke2, canvasContext, plugin, runtime2, this.imagePool);
      }
    }
  }, {
    key: "clearShadowAndFilter",
    value: function clearShadowAndFilter(context, hasFilter, hasShadow) {
      if (hasShadow) {
        context.shadowColor = "transparent";
        context.shadowBlur = 0;
      }
      if (hasFilter) {
        var oldFilter = context.filter;
        if (!isNil(oldFilter) && oldFilter.indexOf("drop-shadow") > -1) {
          context.filter = oldFilter.replace(/drop-shadow\([^)]*\)/, "").trim() || "none";
        }
      }
    }
  }]);
}(OptimizedDefaultRenderer);
function setShadowAndFilter(object, context, hasShadow) {
  var _object$parsedStyle = object.parsedStyle, filter3 = _object$parsedStyle.filter, shadowColor = _object$parsedStyle.shadowColor, shadowBlur = _object$parsedStyle.shadowBlur, shadowOffsetX = _object$parsedStyle.shadowOffsetX, shadowOffsetY = _object$parsedStyle.shadowOffsetY;
  if (filter3 && filter3.length) {
    context.filter = object.style.filter;
  }
  if (hasShadow) {
    context.shadowColor = shadowColor.toString();
    context.shadowBlur = shadowBlur || 0;
    context.shadowOffsetX = shadowOffsetX || 0;
    context.shadowOffsetY = shadowOffsetY || 0;
  }
}
function applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, imagePool) {
  var skipFill = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false;
  if (Array.isArray(fill)) {
    fill.forEach(function(gradient2) {
      context.fillStyle = getColor2(gradient2, object, context, imagePool);
      if (!skipFill) {
        fillRule ? context.fill(fillRule) : context.fill();
      }
    });
  } else {
    if (isPattern(fill)) {
      context.fillStyle = getPattern(fill, object, context, canvasContext, plugin, runtime2, imagePool);
    }
    if (!skipFill) {
      fillRule ? context.fill(fillRule) : context.fill();
    }
  }
}
function applyStroke(context, object, stroke2, canvasContext, plugin, runtime2, imagePool) {
  var skipStroke = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
  if (Array.isArray(stroke2)) {
    stroke2.forEach(function(gradient2) {
      context.strokeStyle = getColor2(gradient2, object, context, imagePool);
      if (!skipStroke) {
        context.stroke();
      }
    });
  } else {
    if (isPattern(stroke2)) {
      context.strokeStyle = getPattern(stroke2, object, context, canvasContext, plugin, runtime2, imagePool);
    }
    if (!skipStroke) {
      context.stroke();
    }
  }
}
function calculateOverlapRect(rect1, rect22) {
  var _rect = _slicedToArray(rect1, 4), x12 = _rect[0], y12 = _rect[1], w1 = _rect[2], h1 = _rect[3];
  var _rect2 = _slicedToArray(rect22, 4), x22 = _rect2[0], y22 = _rect2[1], w2 = _rect2[2], h2 = _rect2[3];
  var overlapLeft = Math.max(x12, x22);
  var overlapTop = Math.max(y12, y22);
  var overlapRight = Math.min(x12 + w1, x22 + w2);
  var overlapBottom = Math.min(y12 + h1, y22 + h2);
  if (overlapRight <= overlapLeft || overlapBottom <= overlapTop) {
    return null;
  }
  return [overlapLeft, overlapTop, overlapRight - overlapLeft, overlapBottom - overlapTop];
}
function transformRect(rect4, matrix3) {
  var tl = vec3_exports.transformMat4(vec3_exports.create(), [rect4[0], rect4[1], 0], matrix3);
  var tr = vec3_exports.transformMat4(vec3_exports.create(), [rect4[0] + rect4[2], rect4[1], 0], matrix3);
  var bl = vec3_exports.transformMat4(vec3_exports.create(), [rect4[0], rect4[1] + rect4[3], 0], matrix3);
  var br = vec3_exports.transformMat4(vec3_exports.create(), [rect4[0] + rect4[2], rect4[1] + rect4[3], 0], matrix3);
  return [Math.min(tl[0], tr[0], bl[0], br[0]), Math.min(tl[1], tr[1], bl[1], br[1]), Math.max(tl[0], tr[0], bl[0], br[0]) - Math.min(tl[0], tr[0], bl[0], br[0]), Math.max(tl[1], tr[1], bl[1], br[1]) - Math.min(tl[1], tr[1], bl[1], br[1])];
}
var ImageRenderer = function(_DefaultRenderer) {
  function ImageRenderer2() {
    _classCallCheck(this, ImageRenderer2);
    return _callSuper(this, ImageRenderer2, arguments);
  }
  _inherits(ImageRenderer2, _DefaultRenderer);
  return _createClass(ImageRenderer2, [{
    key: "renderDownSampled",
    value: function renderDownSampled(context, parsedStyle, object, data2) {
      var src = data2.src, imageCache = data2.imageCache;
      if (!imageCache.downSampled) {
        this.imagePool.createDownSampledImage(src, object).then(function() {
          if (!object.ownerDocument) {
            return;
          }
          object.renderable.dirty = true;
          object.ownerDocument.defaultView.context.renderingService.dirtify();
        })["catch"](function(reason) {
          console.error(reason);
        });
        return;
      }
      context.drawImage(imageCache.downSampled, Math.floor(data2.drawRect[0]), Math.floor(data2.drawRect[1]), Math.ceil(data2.drawRect[2]), Math.ceil(data2.drawRect[3]));
    }
  }, {
    key: "renderTile",
    value: function renderTile(context, parsedStyle, object, data2) {
      var src = data2.src, imageCache = data2.imageCache, imageRect = data2.imageRect, drawRect = data2.drawRect;
      var originalSize = imageCache.size;
      var _context$getTransform = context.getTransform(), a4 = _context$getTransform.a, b = _context$getTransform.b, c5 = _context$getTransform.c, d3 = _context$getTransform.d, e = _context$getTransform.e, f = _context$getTransform.f;
      context.resetTransform();
      if (!(imageCache !== null && imageCache !== void 0 && imageCache.gridSize)) {
        this.imagePool.createImageTiles(src, [], function() {
          if (!object.ownerDocument) {
            return;
          }
          object.renderable.dirty = true;
          object.ownerDocument.defaultView.context.renderingService.dirtify();
        }, object)["catch"](function(reason) {
          console.error(reason);
        });
        return;
      }
      var scaleToOrigin = [originalSize[0] / imageRect[2], originalSize[1] / imageRect[3]];
      var scaledTileSize = [imageCache.tileSize[0] / scaleToOrigin[0], imageCache.tileSize[1] / scaleToOrigin[1]];
      var _ref = [Math.floor((drawRect[0] - imageRect[0]) / scaledTileSize[0]), Math.ceil((drawRect[0] + drawRect[2] - imageRect[0]) / scaledTileSize[0])], startTileX = _ref[0], endTileX = _ref[1];
      var _ref2 = [Math.floor((drawRect[1] - imageRect[1]) / scaledTileSize[1]), Math.ceil((drawRect[1] + drawRect[3] - imageRect[1]) / scaledTileSize[1])], startTileY = _ref2[0], endTileY = _ref2[1];
      for (var tileY = startTileY; tileY <= endTileY; tileY++) {
        for (var tileX = startTileX; tileX <= endTileX; tileX++) {
          var item = imageCache.tiles[tileY][tileX];
          if (item) {
            var tileRect = [Math.floor(imageRect[0] + item.tileX * scaledTileSize[0]), Math.floor(imageRect[1] + item.tileY * scaledTileSize[1]), Math.ceil(scaledTileSize[0]), Math.ceil(scaledTileSize[1])];
            context.drawImage(item.data, tileRect[0], tileRect[1], tileRect[2], tileRect[3]);
          }
        }
      }
      context.setTransform(a4, b, c5, d3, e, f);
    }
  }, {
    key: "render",
    value: function render3(context, parsedStyle, object) {
      var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, width = parsedStyle.width, height = parsedStyle.height, src = parsedStyle.src, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
      var imageCache = this.imagePool.getImageSync(src, object);
      var image = imageCache === null || imageCache === void 0 ? void 0 : imageCache.img;
      var iw = width;
      var ih = height;
      if (!image) {
        return;
      }
      iw || (iw = image.width);
      ih || (ih = image.height);
      var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
      setShadowAndFilter(object, context, hasShadow);
      try {
        var _object$ownerDocument = object.ownerDocument.defaultView.getContextService().getDomElement(), viewWidth = _object$ownerDocument.width, viewHeight = _object$ownerDocument.height;
        var currentTransform = context.getTransform();
        var a4 = currentTransform.a, b = currentTransform.b, c5 = currentTransform.c, d3 = currentTransform.d, e = currentTransform.e, f = currentTransform.f;
        var transformMatrix = mat4_exports.fromValues(a4, c5, 0, 0, b, d3, 0, 0, 0, 0, 1, 0, e, f, 0, 1);
        var imageRect = transformRect([x3, y3, iw, ih], transformMatrix);
        var drawRect = calculateOverlapRect([0, 0, viewWidth, viewHeight], imageRect);
        if (!drawRect) {
          return;
        }
        if (!object.ownerDocument.defaultView.getConfig().enableLargeImageOptimization) {
          ImageRenderer2.renderFull(context, parsedStyle, object, {
            image,
            drawRect: [x3, y3, iw, ih]
          });
          return;
        }
        var sizeOfOrigin = imageRect[2] / imageCache.size[0];
        if (sizeOfOrigin < (imageCache.downSamplingRate || 0.5)) {
          this.renderDownSampled(context, parsedStyle, object, {
            src,
            imageCache,
            drawRect: [x3, y3, iw, ih]
          });
          return;
        }
        if (!ImagePool.isSupportTile) {
          ImageRenderer2.renderFull(context, parsedStyle, object, {
            image,
            drawRect: [x3, y3, iw, ih]
          });
          return;
        }
        this.renderTile(context, parsedStyle, object, {
          src,
          imageCache,
          imageRect,
          drawRect
        });
      } catch (_unused) {
      }
    }
    // ---
  }, {
    key: "drawToContext",
    value: function drawToContext(context, object, renderState, plugin, runtime2) {
      this.render(context, object.parsedStyle, object);
    }
  }], [{
    key: "renderFull",
    value: function renderFull(context, parsedStyle, object, data2) {
      context.drawImage(data2.image, Math.floor(data2.drawRect[0]), Math.floor(data2.drawRect[1]), Math.ceil(data2.drawRect[2]), Math.ceil(data2.drawRect[3]));
    }
  }]);
}(DefaultRenderer);
var TextRenderer = function(_DefaultRenderer) {
  function TextRenderer2() {
    _classCallCheck(this, TextRenderer2);
    return _callSuper(this, TextRenderer2, arguments);
  }
  _inherits(TextRenderer2, _DefaultRenderer);
  return _createClass(TextRenderer2, [{
    key: "render",
    value: function render3(context, parsedStyle, object, canvasContext, plugin, runtime2) {
      object.getBounds();
      var _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$lineJoin = parsedStyle.lineJoin, lineJoin = _parsedStyle$lineJoin === void 0 ? "miter" : _parsedStyle$lineJoin, _parsedStyle$miterLim = parsedStyle.miterLimit, miterLimit = _parsedStyle$miterLim === void 0 ? 10 : _parsedStyle$miterLim, _parsedStyle$letterSp = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp === void 0 ? 0 : _parsedStyle$letterSp, stroke2 = parsedStyle.stroke, fill = parsedStyle.fill, fillRule = parsedStyle.fillRule, _parsedStyle$fillOpac = parsedStyle.fillOpacity, fillOpacity = _parsedStyle$fillOpac === void 0 ? 1 : _parsedStyle$fillOpac, _parsedStyle$strokeOp = parsedStyle.strokeOpacity, strokeOpacity = _parsedStyle$strokeOp === void 0 ? 1 : _parsedStyle$strokeOp, _parsedStyle$opacity = parsedStyle.opacity, opacity = _parsedStyle$opacity === void 0 ? 1 : _parsedStyle$opacity, metrics = parsedStyle.metrics, _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, dx = parsedStyle.dx, dy = parsedStyle.dy, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
      var font = metrics.font, lines = metrics.lines, height = metrics.height, lineHeight = metrics.lineHeight, lineMetrics = metrics.lineMetrics;
      context.font = font;
      context.lineWidth = lineWidth;
      context.textAlign = textAlign === "middle" ? "center" : textAlign;
      var formattedTextBaseline = textBaseline;
      if (formattedTextBaseline === "alphabetic") {
        formattedTextBaseline = "bottom";
      }
      context.lineJoin = lineJoin;
      if (!isNil(miterLimit)) {
        context.miterLimit = miterLimit;
      }
      var linePositionY = y3;
      if (textBaseline === "middle") {
        linePositionY += -height / 2 - lineHeight / 2;
      } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
        linePositionY += -height;
      } else if (textBaseline === "top" || textBaseline === "hanging") {
        linePositionY += -lineHeight;
      }
      var offsetX = x3 + (dx || 0);
      linePositionY += dy || 0;
      if (lines.length === 1) {
        if (formattedTextBaseline === "bottom") {
          formattedTextBaseline = "middle";
          linePositionY -= 0.5 * height;
        } else if (formattedTextBaseline === "top") {
          formattedTextBaseline = "middle";
          linePositionY += 0.5 * height;
        }
      }
      context.textBaseline = formattedTextBaseline;
      var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
      setShadowAndFilter(object, context, hasShadow);
      for (var i = 0; i < lines.length; i++) {
        var linePositionX = lineWidth / 2 + offsetX;
        linePositionY += lineHeight;
        if (!isNil(stroke2) && !stroke2.isNone && lineWidth) {
          this.drawLetterSpacing(context, object, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fill, fillRule, fillOpacity, stroke2, strokeOpacity, opacity, true, canvasContext, plugin, runtime2);
        }
        if (!isNil(fill)) {
          this.drawLetterSpacing(context, object, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fill, fillRule, fillOpacity, stroke2, strokeOpacity, opacity, false, canvasContext, plugin, runtime2);
        }
      }
    }
  }, {
    key: "drawLetterSpacing",
    value: function drawLetterSpacing(context, object, text, lineMetrics, textAlign, x3, y3, letterSpacing, fill, fillRule, fillOpacity, stroke2, strokeOpacity, opacity, isStroke, canvasContext, plugin, runtime2) {
      if (letterSpacing === 0) {
        if (isStroke) {
          this.strokeText(context, object, text, x3, y3, stroke2, strokeOpacity, canvasContext, plugin, runtime2);
        } else {
          this.fillText(context, object, text, x3, y3, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2);
        }
        return;
      }
      var currentTextAlign = context.textAlign;
      context.textAlign = "left";
      var currentPosition = x3;
      if (textAlign === "center" || textAlign === "middle") {
        currentPosition = x3 - lineMetrics.width / 2;
      } else if (textAlign === "right" || textAlign === "end") {
        currentPosition = x3 - lineMetrics.width;
      }
      var stringArray = Array.from(text);
      var previousWidth = context.measureText(text).width;
      var currentWidth = 0;
      for (var i = 0; i < stringArray.length; ++i) {
        var currentChar = stringArray[i];
        if (isStroke) {
          this.strokeText(context, object, currentChar, currentPosition, y3, stroke2, strokeOpacity, canvasContext, plugin, runtime2);
        } else {
          this.fillText(context, object, currentChar, currentPosition, y3, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2);
        }
        currentWidth = context.measureText(text.substring(i + 1)).width;
        currentPosition += previousWidth - currentWidth + letterSpacing;
        previousWidth = currentWidth;
      }
      context.textAlign = currentTextAlign;
    }
  }, {
    key: "fillText",
    value: function fillText(context, object, text, x3, y3, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2) {
      applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, this.imagePool, true);
      var currentGlobalAlpha;
      var applyOpacity = !isNil(fillOpacity) && fillOpacity !== 1;
      if (applyOpacity) {
        currentGlobalAlpha = context.globalAlpha;
        context.globalAlpha = fillOpacity * opacity;
      }
      context.fillText(text, x3, y3);
      if (applyOpacity) {
        context.globalAlpha = currentGlobalAlpha;
      }
    }
  }, {
    key: "strokeText",
    value: function strokeText(context, object, text, x3, y3, stroke2, strokeOpacity, canvasContext, plugin, runtime2) {
      applyStroke(context, object, stroke2, canvasContext, plugin, runtime2, this.imagePool, true);
      var currentGlobalAlpha;
      var applyOpacity = !isNil(strokeOpacity) && strokeOpacity !== 1;
      if (applyOpacity) {
        currentGlobalAlpha = context.globalAlpha;
        context.globalAlpha = strokeOpacity;
      }
      context.strokeText(text, x3, y3);
      if (applyOpacity) {
        context.globalAlpha = currentGlobalAlpha;
      }
    }
    // ---
  }, {
    key: "drawToContext",
    value: function drawToContext(context, object, renderState, plugin, runtime2) {
      this.render(context, object.parsedStyle, object, object.ownerDocument.defaultView.context, plugin, runtime2);
    }
  }]);
}(DefaultRenderer);
var Plugin4 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Plugin8);
    _this2 = _callSuper(this, Plugin8);
    _this2.name = "canvas-renderer";
    _this2.options = options;
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      var _defaultStyleRenderer;
      var canvasRendererPluginOptions = _objectSpread2({
        dirtyObjectNumThreshold: 500,
        dirtyObjectRatioThreshold: 0.8
      }, this.options);
      var imagePool = this.context.imagePool;
      var defaultRenderer = new DefaultRenderer(imagePool);
      var defaultStyleRendererFactory = (_defaultStyleRenderer = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defaultStyleRenderer, Shape.CIRCLE, defaultRenderer), Shape.ELLIPSE, defaultRenderer), Shape.RECT, defaultRenderer), Shape.IMAGE, new ImageRenderer(imagePool)), Shape.TEXT, new TextRenderer(imagePool)), Shape.LINE, defaultRenderer), Shape.POLYLINE, defaultRenderer), Shape.POLYGON, defaultRenderer), Shape.PATH, defaultRenderer), Shape.GROUP, void 0), _defineProperty(_defineProperty(_defineProperty(_defaultStyleRenderer, Shape.HTML, void 0), Shape.MESH, void 0), Shape.FRAGMENT, void 0));
      this.context.defaultStyleRendererFactory = defaultStyleRendererFactory;
      this.context.styleRendererFactory = defaultStyleRendererFactory;
      this.addRenderingPlugin(new CanvasRendererPlugin(canvasRendererPluginOptions));
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      this.removeAllRenderingPlugins();
      delete this.context.defaultStyleRendererFactory;
      delete this.context.styleRendererFactory;
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/g-plugin-dom-interaction/dist/index.esm.js
var DOMInteractionPlugin = function() {
  function DOMInteractionPlugin2() {
    _classCallCheck(this, DOMInteractionPlugin2);
  }
  return _createClass(DOMInteractionPlugin2, [{
    key: "apply",
    value: function apply(context, runtime2) {
      var _this2 = this;
      var renderingService = context.renderingService, renderingContext = context.renderingContext, config = context.config;
      this.context = context;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var onPointerMove = function onPointerMove2(ev) {
        renderingService.hooks.pointerMove.call(ev);
      };
      var onPointerUp = function onPointerUp2(ev) {
        renderingService.hooks.pointerUp.call(ev);
      };
      var onPointerDown = function onPointerDown2(ev) {
        renderingService.hooks.pointerDown.call(ev);
      };
      var onPointerOver = function onPointerOver2(ev) {
        renderingService.hooks.pointerOver.call(ev);
      };
      var onPointerOut = function onPointerOut2(ev) {
        renderingService.hooks.pointerOut.call(ev);
      };
      var onPointerCancel = function onPointerCancel2(ev) {
        renderingService.hooks.pointerCancel.call(ev);
      };
      var onPointerWheel = function onPointerWheel2(ev) {
        renderingService.hooks.pointerWheel.call(ev);
      };
      var onClick = function onClick2(ev) {
        renderingService.hooks.click.call(ev);
      };
      var addPointerEventListener = function addPointerEventListener2($el) {
        runtime2.globalThis.document.addEventListener("pointermove", onPointerMove, true);
        $el.addEventListener("pointerdown", onPointerDown, true);
        $el.addEventListener("pointerleave", onPointerOut, true);
        $el.addEventListener("pointerover", onPointerOver, true);
        runtime2.globalThis.addEventListener("pointerup", onPointerUp, true);
        runtime2.globalThis.addEventListener("pointercancel", onPointerCancel, true);
      };
      var addTouchEventListener = function addTouchEventListener2($el) {
        $el.addEventListener("touchstart", onPointerDown, true);
        $el.addEventListener("touchend", onPointerUp, true);
        $el.addEventListener("touchmove", onPointerMove, true);
        $el.addEventListener("touchcancel", onPointerCancel, true);
      };
      var addMouseEventListener = function addMouseEventListener2($el) {
        runtime2.globalThis.document.addEventListener("mousemove", onPointerMove, true);
        $el.addEventListener("mousedown", onPointerDown, true);
        $el.addEventListener("mouseout", onPointerOut, true);
        $el.addEventListener("mouseover", onPointerOver, true);
        runtime2.globalThis.addEventListener("mouseup", onPointerUp, true);
      };
      var removePointerEventListener = function removePointerEventListener2($el) {
        runtime2.globalThis.document.removeEventListener("pointermove", onPointerMove, true);
        $el.removeEventListener("pointerdown", onPointerDown, true);
        $el.removeEventListener("pointerleave", onPointerOut, true);
        $el.removeEventListener("pointerover", onPointerOver, true);
        runtime2.globalThis.removeEventListener("pointerup", onPointerUp, true);
        runtime2.globalThis.removeEventListener("pointercancel", onPointerCancel, true);
      };
      var removeTouchEventListener = function removeTouchEventListener2($el) {
        $el.removeEventListener("touchstart", onPointerDown, true);
        $el.removeEventListener("touchend", onPointerUp, true);
        $el.removeEventListener("touchmove", onPointerMove, true);
        $el.removeEventListener("touchcancel", onPointerCancel, true);
      };
      var removeMouseEventListener = function removeMouseEventListener2($el) {
        runtime2.globalThis.document.removeEventListener("mousemove", onPointerMove, true);
        $el.removeEventListener("mousedown", onPointerDown, true);
        $el.removeEventListener("mouseout", onPointerOut, true);
        $el.removeEventListener("mouseover", onPointerOver, true);
        runtime2.globalThis.removeEventListener("mouseup", onPointerUp, true);
      };
      renderingService.hooks.init.tap(DOMInteractionPlugin2.tag, function() {
        var $el = _this2.context.contextService.getDomElement();
        if (runtime2.globalThis.navigator.msPointerEnabled) {
          $el.style.msContentZooming = "none";
          $el.style.msTouchAction = "none";
        } else if (canvas.supportsPointerEvents) {
          $el.style.touchAction = "none";
        }
        if (canvas.supportsPointerEvents) {
          addPointerEventListener($el);
        } else {
          addMouseEventListener($el);
        }
        if (canvas.supportsTouchEvents) {
          addTouchEventListener($el);
        }
        if (config.useNativeClickEvent) {
          $el.addEventListener("click", onClick, true);
        }
        $el.addEventListener("wheel", onPointerWheel, {
          passive: true,
          capture: true
        });
      });
      renderingService.hooks.destroy.tap(DOMInteractionPlugin2.tag, function() {
        var $el = _this2.context.contextService.getDomElement();
        if (runtime2.globalThis.navigator.msPointerEnabled) {
          $el.style.msContentZooming = "";
          $el.style.msTouchAction = "";
        } else if (canvas.supportsPointerEvents) {
          $el.style.touchAction = "";
        }
        if (canvas.supportsPointerEvents) {
          removePointerEventListener($el);
        } else {
          removeMouseEventListener($el);
        }
        if (canvas.supportsTouchEvents) {
          removeTouchEventListener($el);
        }
        if (config.useNativeClickEvent) {
          $el.removeEventListener("click", onClick, true);
        }
        $el.removeEventListener("wheel", onPointerWheel, true);
      });
    }
  }]);
}();
DOMInteractionPlugin.tag = "DOMInteraction";
var Plugin5 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    _classCallCheck(this, Plugin8);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin8, [].concat(args));
    _this2.name = "dom-interaction";
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      this.addRenderingPlugin(new DOMInteractionPlugin());
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      this.removeAllRenderingPlugins();
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/g-plugin-html-renderer/dist/index.esm.js
var CANVAS_CAMERA_ID = "g-canvas-camera";
var HTMLRenderingPlugin = function() {
  function HTMLRenderingPlugin2() {
    _classCallCheck(this, HTMLRenderingPlugin2);
    this.displayObjectHTMLElementMap = /* @__PURE__ */ new WeakMap();
  }
  return _createClass(HTMLRenderingPlugin2, [{
    key: "joinTransformMatrix",
    value: (
      /**
       * ! The reason for adding `offset` is that the `transform-origin` coordinate system of DOM is the local coordinate system of the element, while the `transform-origin` coordinate system of canvas drawing is the local coordinate system of the element's parent element. At the same time, the `transform` attribute value of the DOM element does not include `transform-origin`.
       */
      function joinTransformMatrix(matrix3) {
        var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
        return "matrix(".concat([matrix3[0], matrix3[1], matrix3[4], matrix3[5], matrix3[12] + offset2[0], matrix3[13] + offset2[1]].join(","), ")");
      }
    )
  }, {
    key: "apply",
    value: function apply(context, runtime2) {
      var _this2 = this;
      var camera = context.camera, renderingContext = context.renderingContext, renderingService = context.renderingService;
      this.context = context;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var nativeHTMLMap = canvas.context.eventService.nativeHTMLMap;
      var setTransform = function setTransform2(object, $el) {
        $el.style.transform = _this2.joinTransformMatrix(object.getWorldTransform(), object.getOrigin());
      };
      var handleMounted = function handleMounted2(e) {
        var object = e.target;
        if (object.nodeName === Shape.HTML) {
          if (!_this2.$camera) {
            _this2.$camera = _this2.createCamera(camera);
          }
          var $el = _this2.getOrCreateEl(object);
          _this2.$camera.appendChild($el);
          Object.keys(object.attributes).forEach(function(name2) {
            _this2.updateAttribute(name2, object);
          });
          setTransform(object, $el);
          nativeHTMLMap.set($el, object);
        }
      };
      var handleUnmounted = function handleUnmounted2(e) {
        var object = e.target;
        if (object.nodeName === Shape.HTML && _this2.$camera) {
          var $el = _this2.getOrCreateEl(object);
          if ($el) {
            $el.remove();
            nativeHTMLMap["delete"]($el);
          }
        }
      };
      var handleAttributeChanged = function handleAttributeChanged2(e) {
        var object = e.target;
        if (object.nodeName === Shape.HTML) {
          var attrName = e.attrName;
          _this2.updateAttribute(attrName, object);
        }
      };
      var handleBoundsChanged = function handleBoundsChanged2(e) {
        var object = e.target;
        var nodes = object.nodeName === Shape.FRAGMENT ? object.childNodes : [object];
        nodes.forEach(function(node) {
          if (node.nodeName === Shape.HTML) {
            var $el = _this2.getOrCreateEl(node);
            setTransform(node, $el);
          }
        });
      };
      var handleCanvasResize = function handleCanvasResize2() {
        if (_this2.$camera) {
          var _this$context$config = _this2.context.config, width = _this$context$config.width, height = _this$context$config.height;
          _this2.$camera.parentElement.style.width = "".concat(width || 0, "px");
          _this2.$camera.parentElement.style.height = "".concat(height || 0, "px");
        }
      };
      renderingService.hooks.init.tap(HTMLRenderingPlugin2.tag, function() {
        canvas.addEventListener(CanvasEvent.RESIZE, handleCanvasResize);
        canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      });
      renderingService.hooks.endFrame.tap(HTMLRenderingPlugin2.tag, function() {
        if (_this2.$camera && renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED)) {
          _this2.$camera.style.transform = _this2.joinTransformMatrix(camera.getOrthoMatrix());
        }
      });
      renderingService.hooks.destroy.tap(HTMLRenderingPlugin2.tag, function() {
        if (_this2.$camera) {
          _this2.$camera.remove();
        }
        canvas.removeEventListener(CanvasEvent.RESIZE, handleCanvasResize);
        canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      });
    }
  }, {
    key: "createCamera",
    value: function createCamera(camera) {
      var _this$context$config2 = this.context.config, doc = _this$context$config2.document, width = _this$context$config2.width, height = _this$context$config2.height;
      var $canvas = this.context.contextService.getDomElement();
      var $container = $canvas.parentNode;
      if ($container) {
        var cameraId = CANVAS_CAMERA_ID;
        var $existedCamera = $container.querySelector("#".concat(cameraId));
        if (!$existedCamera) {
          var $cameraContainer = (doc || document).createElement("div");
          $cameraContainer.style.overflow = "hidden";
          $cameraContainer.style.pointerEvents = "none";
          $cameraContainer.style.position = "absolute";
          $cameraContainer.style.left = "0px";
          $cameraContainer.style.top = "0px";
          $cameraContainer.style.width = "".concat(width || 0, "px");
          $cameraContainer.style.height = "".concat(height || 0, "px");
          var $camera = (doc || document).createElement("div");
          $existedCamera = $camera;
          $camera.id = cameraId;
          $camera.style.position = "absolute";
          $camera.style.left = "".concat($canvas.offsetLeft || 0, "px");
          $camera.style.top = "".concat($canvas.offsetTop || 0, "px");
          $camera.style.transformOrigin = "left top";
          $camera.style.transform = this.joinTransformMatrix(camera.getOrthoMatrix());
          $camera.style.pointerEvents = "none";
          $camera.style.width = "100%";
          $camera.style.height = "100%";
          $cameraContainer.appendChild($camera);
          $container.appendChild($cameraContainer);
        }
        return $existedCamera;
      }
      return null;
    }
  }, {
    key: "getOrCreateEl",
    value: function getOrCreateEl(object) {
      var doc = this.context.config.document;
      var $existedElement = this.displayObjectHTMLElementMap.get(object);
      if (!$existedElement) {
        $existedElement = (doc || document).createElement("div");
        object.parsedStyle.$el = $existedElement;
        this.displayObjectHTMLElementMap.set(object, $existedElement);
        if (object.id) {
          $existedElement.id = object.id;
        }
        if (object.name) {
          $existedElement.setAttribute("name", object.name);
        }
        if (object.className) {
          $existedElement.className = object.className;
        }
        $existedElement.style.position = "absolute";
        $existedElement.style["will-change"] = "transform";
        $existedElement.style.transform = this.joinTransformMatrix(object.getWorldTransform(), object.getOrigin());
      }
      return $existedElement;
    }
  }, {
    key: "updateAttribute",
    value: function updateAttribute(name2, object) {
      var $el = this.getOrCreateEl(object);
      switch (name2) {
        case "innerHTML":
          var innerHTML = object.parsedStyle.innerHTML;
          if (isString(innerHTML)) {
            $el.innerHTML = innerHTML;
          } else {
            $el.innerHTML = "";
            $el.appendChild(innerHTML);
          }
          break;
        case "x":
          $el.style.left = "".concat(object.parsedStyle.x, "px");
          break;
        case "y":
          $el.style.top = "".concat(object.parsedStyle.y, "px");
          break;
        case "transformOrigin":
          var transformOrigin = object.parsedStyle.transformOrigin;
          $el.style["transform-origin"] = "".concat(transformOrigin[0].buildCSSText(null, null, ""), " ").concat(transformOrigin[1].buildCSSText(null, null, ""));
          break;
        case "width":
          var width = object.parsedStyle.width;
          $el.style.width = isNumber(width) ? "".concat(width, "px") : width.toString();
          break;
        case "height":
          var height = object.parsedStyle.height;
          $el.style.height = isNumber(height) ? "".concat(height, "px") : height.toString();
          break;
        case "zIndex":
          var zIndex = object.parsedStyle.zIndex;
          $el.style["z-index"] = "".concat(zIndex);
          break;
        case "visibility":
          var visibility2 = object.parsedStyle.visibility;
          $el.style.visibility = visibility2;
          break;
        case "pointerEvents":
          var _object$parsedStyle$p = object.parsedStyle.pointerEvents, pointerEvents = _object$parsedStyle$p === void 0 ? "auto" : _object$parsedStyle$p;
          $el.style.pointerEvents = pointerEvents;
          break;
        case "opacity":
          var opacity = object.parsedStyle.opacity;
          $el.style.opacity = "".concat(opacity);
          break;
        case "fill":
          var fill = object.parsedStyle.fill;
          var color3 = "";
          if (isCSSRGB(fill)) {
            if (fill.isNone) {
              color3 = "transparent";
            } else {
              color3 = object.getAttribute("fill");
            }
          } else if (Array.isArray(fill)) {
            color3 = object.getAttribute("fill");
          } else if (isPattern(fill))
            ;
          $el.style.background = color3;
          break;
        case "stroke":
          var stroke2 = object.parsedStyle.stroke;
          var borderColor = "";
          if (isCSSRGB(stroke2)) {
            if (stroke2.isNone) {
              borderColor = "transparent";
            } else {
              borderColor = object.getAttribute("stroke");
            }
          } else if (Array.isArray(stroke2)) {
            borderColor = object.getAttribute("stroke");
          } else if (isPattern(stroke2))
            ;
          $el.style["border-color"] = borderColor;
          $el.style["border-style"] = "solid";
          break;
        case "lineWidth":
          var lineWidth = object.parsedStyle.lineWidth;
          $el.style["border-width"] = "".concat(lineWidth || 0, "px");
          break;
        case "lineDash":
          $el.style["border-style"] = "dashed";
          break;
        case "filter":
          var filter3 = object.style.filter;
          $el.style.filter = filter3;
          break;
        default:
          if (!isNil(object.style[name2]) && object.style[name2] !== "") {
            $el.style[name2] = object.style[name2];
          }
      }
    }
  }]);
}();
HTMLRenderingPlugin.tag = "HTMLRendering";
var Plugin6 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    _classCallCheck(this, Plugin8);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin8, [].concat(args));
    _this2.name = "html-renderer";
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      this.addRenderingPlugin(new HTMLRenderingPlugin());
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      this.removeAllRenderingPlugins();
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/g-canvas/dist/index.esm.js
var Canvas2DContextService = function() {
  function Canvas2DContextService2(context) {
    _classCallCheck(this, Canvas2DContextService2);
    this.renderingContext = context.renderingContext;
    this.canvasConfig = context.config;
  }
  return _createClass(Canvas2DContextService2, [{
    key: "init",
    value: function init() {
      var _this$canvasConfig = this.canvasConfig, container = _this$canvasConfig.container, canvas = _this$canvasConfig.canvas;
      if (canvas) {
        this.$canvas = canvas;
        if (container && canvas.parentElement !== container) {
          container.appendChild(canvas);
        }
        this.$container = canvas.parentElement;
        this.canvasConfig.container = this.$container;
      } else if (container) {
        this.$container = isString(container) ? document.getElementById(container) : container;
        if (this.$container) {
          var $canvas = document.createElement("canvas");
          this.$container.appendChild($canvas);
          if (!this.$container.style.position) {
            this.$container.style.position = "relative";
          }
          this.$canvas = $canvas;
        }
      }
      this.context = this.$canvas.getContext("2d");
      this.resize(this.canvasConfig.width, this.canvasConfig.height);
    }
  }, {
    key: "getContext",
    value: function getContext() {
      return this.context;
    }
  }, {
    key: "getDomElement",
    value: function getDomElement() {
      return this.$canvas;
    }
  }, {
    key: "getDPR",
    value: function getDPR() {
      return this.dpr;
    }
  }, {
    key: "getBoundingClientRect",
    value: function getBoundingClientRect() {
      if (this.$canvas.getBoundingClientRect) {
        return this.$canvas.getBoundingClientRect();
      }
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      if (this.$container && this.$canvas && this.$canvas.parentNode) {
        this.$container.removeChild(this.$canvas);
      }
    }
  }, {
    key: "resize",
    value: function resize(width, height) {
      var dpr = this.canvasConfig.devicePixelRatio;
      this.dpr = dpr;
      if (this.$canvas) {
        this.$canvas.width = this.dpr * width;
        this.$canvas.height = this.dpr * height;
        setDOMSize(this.$canvas, width, height);
      }
      this.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
    }
  }, {
    key: "applyCursorStyle",
    value: function applyCursorStyle(cursor) {
      if (this.$container && this.$container.style) {
        this.$container.style.cursor = cursor;
      }
    }
  }, {
    key: "toDataURL",
    value: function() {
      var _toDataURL = _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
        var options, type, encoderOptions, _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {};
                type = options.type, encoderOptions = options.encoderOptions;
                return _context.abrupt("return", this.context.canvas.toDataURL(type, encoderOptions));
              case 3:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function toDataURL() {
        return _toDataURL.apply(this, arguments);
      }
      return toDataURL;
    }()
  }]);
}();
var ContextRegisterPlugin = function(_AbstractRendererPlug) {
  function ContextRegisterPlugin2() {
    var _this2;
    _classCallCheck(this, ContextRegisterPlugin2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, ContextRegisterPlugin2, [].concat(args));
    _this2.name = "canvas-context-register";
    return _this2;
  }
  _inherits(ContextRegisterPlugin2, _AbstractRendererPlug);
  return _createClass(ContextRegisterPlugin2, [{
    key: "init",
    value: function init() {
      this.context.ContextService = Canvas2DContextService;
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      delete this.context.ContextService;
    }
  }]);
}(AbstractRendererPlugin);
var Renderer = function(_AbstractRenderer) {
  function Renderer2(config) {
    var _this2;
    _classCallCheck(this, Renderer2);
    _this2 = _callSuper(this, Renderer2, [config]);
    _this2.registerPlugin(new ContextRegisterPlugin());
    _this2.registerPlugin(new Plugin3());
    _this2.registerPlugin(new Plugin());
    _this2.registerPlugin(new Plugin4());
    _this2.registerPlugin(new Plugin5());
    _this2.registerPlugin(new Plugin2());
    _this2.registerPlugin(new Plugin6());
    return _this2;
  }
  _inherits(Renderer2, _AbstractRenderer);
  return _createClass(Renderer2);
}(AbstractRenderer);

// node_modules/@antv/g-plugin-dragndrop/dist/index.esm.js
var DragndropPlugin = function() {
  function DragndropPlugin2(dragndropPluginOptions) {
    _classCallCheck(this, DragndropPlugin2);
    this.dragndropPluginOptions = dragndropPluginOptions;
  }
  return _createClass(DragndropPlugin2, [{
    key: "apply",
    value: function apply(context) {
      var _this2 = this;
      var renderingService = context.renderingService, renderingContext = context.renderingContext;
      var document2 = renderingContext.root.ownerDocument;
      var canvas = document2.defaultView;
      var handlePointerdown = function handlePointerdown2(event) {
        var target = event.target;
        var isDocument = target === document2;
        var draggableEventTarget = isDocument && _this2.dragndropPluginOptions.isDocumentDraggable ? document2 : target.closest && target.closest("[draggable=true]");
        if (draggableEventTarget) {
          var dragstartTriggered = false;
          var dragstartTimeStamp = event.timeStamp;
          var dragstartClientCoordinates = [event.clientX, event.clientY];
          var currentDroppable = null;
          var lastDragClientCoordinates = [event.clientX, event.clientY];
          var handlePointermove = function() {
            var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(event2) {
              var timeElapsed, distanceMoved, point7, elementsBelow, elementBelow, droppableBelow;
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1)
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (dragstartTriggered) {
                        _context.next = 8;
                        break;
                      }
                      timeElapsed = event2.timeStamp - dragstartTimeStamp;
                      distanceMoved = distanceSquareRoot([event2.clientX, event2.clientY], dragstartClientCoordinates);
                      if (!(timeElapsed <= _this2.dragndropPluginOptions.dragstartTimeThreshold || distanceMoved <= _this2.dragndropPluginOptions.dragstartDistanceThreshold)) {
                        _context.next = 5;
                        break;
                      }
                      return _context.abrupt("return");
                    case 5:
                      event2.type = "dragstart";
                      draggableEventTarget.dispatchEvent(event2);
                      dragstartTriggered = true;
                    case 8:
                      event2.type = "drag";
                      event2.dx = event2.clientX - lastDragClientCoordinates[0];
                      event2.dy = event2.clientY - lastDragClientCoordinates[1];
                      draggableEventTarget.dispatchEvent(event2);
                      lastDragClientCoordinates = [event2.clientX, event2.clientY];
                      if (isDocument) {
                        _context.next = 21;
                        break;
                      }
                      point7 = _this2.dragndropPluginOptions.overlap === "pointer" ? [event2.canvasX, event2.canvasY] : target.getBounds().center;
                      _context.next = 17;
                      return document2.elementsFromPoint(point7[0], point7[1]);
                    case 17:
                      elementsBelow = _context.sent;
                      elementBelow = elementsBelow[elementsBelow.indexOf(target) + 1];
                      droppableBelow = (elementBelow === null || elementBelow === void 0 ? void 0 : elementBelow.closest("[droppable=true]")) || (_this2.dragndropPluginOptions.isDocumentDroppable ? document2 : null);
                      if (currentDroppable !== droppableBelow) {
                        if (currentDroppable) {
                          event2.type = "dragleave";
                          event2.target = currentDroppable;
                          currentDroppable.dispatchEvent(event2);
                        }
                        if (droppableBelow) {
                          event2.type = "dragenter";
                          event2.target = droppableBelow;
                          droppableBelow.dispatchEvent(event2);
                        }
                        currentDroppable = droppableBelow;
                        if (currentDroppable) {
                          event2.type = "dragover";
                          event2.target = currentDroppable;
                          currentDroppable.dispatchEvent(event2);
                        }
                      }
                    case 21:
                    case "end":
                      return _context.stop();
                  }
              }, _callee);
            }));
            return function handlePointermove2(_x) {
              return _ref.apply(this, arguments);
            };
          }();
          canvas.addEventListener("pointermove", handlePointermove);
          var stopDragging = function stopDragging2(originalPointerUpEvent) {
            if (dragstartTriggered) {
              originalPointerUpEvent.detail = {
                preventClick: true
              };
              var _event = originalPointerUpEvent.clone();
              if (currentDroppable) {
                _event.type = "drop";
                _event.target = currentDroppable;
                currentDroppable.dispatchEvent(_event);
              }
              _event.type = "dragend";
              draggableEventTarget.dispatchEvent(_event);
              dragstartTriggered = false;
            }
            canvas.removeEventListener("pointermove", handlePointermove);
          };
          target.addEventListener("pointerup", stopDragging, {
            once: true
          });
          target.addEventListener("pointerupoutside", stopDragging, {
            once: true
          });
        }
      };
      renderingService.hooks.init.tap(DragndropPlugin2.tag, function() {
        canvas.addEventListener("pointerdown", handlePointerdown);
      });
      renderingService.hooks.destroy.tap(DragndropPlugin2.tag, function() {
        canvas.removeEventListener("pointerdown", handlePointerdown);
      });
    }
  }]);
}();
DragndropPlugin.tag = "Dragndrop";
var Plugin7 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Plugin8);
    _this2 = _callSuper(this, Plugin8);
    _this2.name = "dragndrop";
    _this2.options = options;
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      this.addRenderingPlugin(new DragndropPlugin(_objectSpread2({
        overlap: "pointer",
        isDocumentDraggable: false,
        isDocumentDroppable: false,
        dragstartDistanceThreshold: 0,
        dragstartTimeThreshold: 0
      }, this.options)));
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      this.removeAllRenderingPlugins();
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      Object.assign(this.plugins[0].dragndropPluginOptions, options);
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/event-emitter/esm/index.js
var WILDCARD = "*";
var EventEmitter2 = (
  /** @class */
  function() {
    function EventEmitter3() {
      this._events = {};
    }
    EventEmitter3.prototype.on = function(evt, callback, once) {
      if (!this._events[evt]) {
        this._events[evt] = [];
      }
      this._events[evt].push({
        callback,
        once: !!once
      });
      return this;
    };
    EventEmitter3.prototype.once = function(evt, callback) {
      return this.on(evt, callback, true);
    };
    EventEmitter3.prototype.emit = function(evt) {
      var _this2 = this;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var events = this._events[evt] || [];
      var wildcardEvents = this._events[WILDCARD] || [];
      var doEmit = function(es) {
        var length5 = es.length;
        for (var i = 0; i < length5; i++) {
          if (!es[i]) {
            continue;
          }
          var _a2 = es[i], callback = _a2.callback, once = _a2.once;
          if (once) {
            es.splice(i, 1);
            if (es.length === 0) {
              delete _this2._events[evt];
            }
            length5--;
            i--;
          }
          callback.apply(_this2, args);
        }
      };
      doEmit(events);
      doEmit(wildcardEvents);
    };
    EventEmitter3.prototype.off = function(evt, callback) {
      if (!evt) {
        this._events = {};
      } else {
        if (!callback) {
          delete this._events[evt];
        } else {
          var events = this._events[evt] || [];
          var length_1 = events.length;
          for (var i = 0; i < length_1; i++) {
            if (events[i].callback === callback) {
              events.splice(i, 1);
              length_1--;
              i--;
            }
          }
          if (events.length === 0) {
            delete this._events[evt];
          }
        }
      }
      return this;
    };
    EventEmitter3.prototype.getEvents = function() {
      return this._events;
    };
    return EventEmitter3;
  }()
);
var esm_default = EventEmitter2;

// node_modules/@antv/g2/esm/utils/event.js
var ChartEvent = {
  BEFORE_RENDER: "beforerender",
  AFTER_RENDER: "afterrender",
  BEFORE_PAINT: "beforepaint",
  AFTER_PAINT: "afterpaint",
  BEFORE_CHANGE_DATA: "beforechangedata",
  AFTER_CHANGE_DATA: "afterchangedata",
  BEFORE_CLEAR: "beforeclear",
  AFTER_CLEAR: "afterclear",
  BEFORE_DESTROY: "beforedestroy",
  AFTER_DESTROY: "afterdestroy",
  BEFORE_CHANGE_SIZE: "beforechangesize",
  AFTER_CHANGE_SIZE: "afterchangesize",
  POINTER_TAP: "pointertap",
  POINTER_DOWN: "pointerdown",
  POINTER_UP: "pointerup",
  POINTER_OVER: "pointerover",
  POINTER_OUT: "pointerout",
  POINTER_MOVE: "pointermove",
  POINTER_ENTER: "pointerenter",
  POINTER_LEAVE: "pointerleave",
  POINTER_UPOUTSIDE: "pointerupoutside",
  DRAG_START: "dragstart",
  DRAG: "drag",
  DRAG_END: "dragend",
  DRAG_ENTER: "dragenter",
  DRAG_LEAVE: "dragleave",
  DRAG_OVER: "dragover",
  DROP: "DROP",
  CLICK: "click",
  DBLCLICK: "dblclick"
};

// node_modules/@antv/g2/esm/component/constant.js
var LEGEND_INFER_STRATEGIES = [
  [
    "legendCategory",
    [
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "constant"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "constant"]
      ],
      [
        ["color", "constant"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "discrete"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "constant"],
        ["shape", "discrete"]
      ],
      // [
      //   ['color', 'constant'],
      //   ['opacity', 'constant'],
      //   ['size', 'constant'],
      // ],
      // [
      //   ['color', 'constant'],
      //   ['shape', 'constant'],
      //   ['size', 'constant'],
      // ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "constant"]
      ],
      [
        ["color", "constant"],
        ["shape", "discrete"]
      ],
      [
        ["color", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"]
      ],
      // [
      //   ['color', 'constant'],
      //   ['opacity', 'constant'],
      // ],
      // [
      //   ['color', 'constant'],
      //   ['shape', 'constant'],
      // ],
      [["color", "discrete"]]
      // [['color', 'constant']],
    ]
  ],
  [
    "legendContinuousSize",
    [
      [
        ["color", "continuous"],
        ["opacity", "continuous"],
        ["size", "continuous"]
      ],
      [
        ["color", "constant"],
        ["opacity", "continuous"],
        ["size", "continuous"]
      ],
      [
        ["color", "continuous"],
        ["size", "continuous"]
      ],
      [
        ["color", "constant"],
        ["size", "continuous"]
      ],
      [
        ["size", "continuous"],
        ["opacity", "continuous"]
      ],
      [["size", "continuous"]]
    ]
  ],
  [
    "legendContinuousBlockSize",
    [
      [
        ["color", "distribution"],
        ["opacity", "distribution"],
        ["size", "distribution"]
      ],
      [
        ["color", "distribution"],
        ["size", "distribution"]
      ]
    ]
  ],
  [
    "legendContinuousBlock",
    [
      [
        ["color", "distribution"],
        ["opacity", "continuous"]
      ],
      [["color", "distribution"]]
    ]
  ],
  [
    "legendContinuous",
    [
      [
        ["color", "continuous"],
        ["opacity", "continuous"]
      ],
      [["color", "continuous"]],
      [["opacity", "continuous"]]
    ]
  ]
];

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-type.js
var toString3 = {}.toString;
var isType2 = function(value2, type) {
  return toString3.call(value2) === "[object " + type + "]";
};
var is_type_default2 = isType2;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-function.js
var is_function_default = function(value2) {
  return is_type_default2(value2, "Function");
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-array.js
var is_array_default = function(value2) {
  return Array.isArray ? Array.isArray(value2) : is_type_default2(value2, "Array");
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-object.js
var is_object_default2 = function(value2) {
  var type = typeof value2;
  return value2 !== null && type === "object" || type === "function";
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/each.js
function each2(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (is_array_default(elements)) {
    for (var i = 0, len5 = elements.length; i < len5; i++) {
      rst = func(elements[i], i);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default2(elements)) {
    for (var k2 in elements) {
      if (elements.hasOwnProperty(k2)) {
        rst = func(elements[k2], k2);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default3 = each2;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-object-like.js
var isObjectLike2 = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var is_object_like_default2 = isObjectLike2;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-plain-object.js
var isPlainObject2 = function(value2) {
  if (!is_object_like_default2(value2) || !is_type_default2(value2, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value2) === null) {
    return true;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
var is_plain_object_default2 = isPlainObject2;

// node_modules/@antv/coord/node_modules/@antv/util/esm/pull.js
var arrPrototype2 = Array.prototype;
var splice4 = arrPrototype2.splice;
var indexOf4 = arrPrototype2.indexOf;

// node_modules/@antv/coord/node_modules/@antv/util/esm/pull-at.js
var splice5 = Array.prototype.splice;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-string.js
var is_string_default = function(str7) {
  return is_type_default2(str7, "String");
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-number.js
var isNumber2 = function(value2) {
  return is_type_default2(value2, "Number");
};
var is_number_default = isNumber2;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-integer.js
var isInteger2 = Number.isInteger ? Number.isInteger : function(num) {
  return is_number_default(num) && num % 1 === 0;
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/to-degree.js
var DEGREE2 = 180 / Math.PI;

// node_modules/@antv/coord/node_modules/@antv/util/esm/to-radian.js
var RADIAN2 = Math.PI / 180;

// node_modules/@antv/coord/node_modules/@antv/util/esm/values.js
var values = Object.values ? function(obj) {
  return Object.values(obj);
} : function(obj) {
  var result = [];
  each_default3(obj, function(value2, key) {
    if (!(is_function_default(obj) && key === "prototype")) {
      result.push(value2);
    }
  });
  return result;
};
var values_default2 = values;

// node_modules/@antv/coord/node_modules/@antv/util/esm/get-type.js
var toString4 = {}.toString;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-prototype.js
var objectProto2 = Object.prototype;

// node_modules/@antv/coord/node_modules/@antv/util/esm/memoize.js
var memoize_default = function(f, resolver) {
  if (!is_function_default(f)) {
    throw new TypeError("Expected a function");
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = f.apply(this, args);
    cache2.set(key, result);
    return result;
  };
  memoized.cache = /* @__PURE__ */ new Map();
  return memoized;
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/deep-mix.js
var MAX_MIX_LEVEL3 = 5;
function _deepMix2(dist5, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL3;
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      var value2 = src[key];
      if (value2 !== null && is_plain_object_default2(value2)) {
        if (!is_plain_object_default2(dist5[key])) {
          dist5[key] = {};
        }
        if (level < maxLevel) {
          _deepMix2(dist5[key], value2, level + 1, maxLevel);
        } else {
          dist5[key] = src[key];
        }
      } else if (is_array_default(value2)) {
        dist5[key] = [];
        dist5[key] = dist5[key].concat(value2);
      } else if (value2 !== void 0) {
        dist5[key] = value2;
      }
    }
  }
}
var deepMix2 = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    _deepMix2(rst, args[i]);
  }
  return rst;
};
var deep_mix_default2 = deepMix2;

// node_modules/@antv/coord/node_modules/@antv/util/esm/identity.js
var identity_default4 = function(v) {
  return v;
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/measure-text-width.js
var ctx2;
var measure_text_width_default = memoize_default(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  if (!ctx2) {
    ctx2 = document.createElement("canvas").getContext("2d");
  }
  ctx2.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
  return ctx2.measureText(is_string_default(text) ? text : "").width;
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArrays([text], values_default2(font)).join("");
});

// node_modules/@antv/coord/node_modules/@antv/util/esm/cache.js
var default_12 = (
  /** @class */
  function() {
    function default_13() {
      this.map = {};
    }
    default_13.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_13.prototype.get = function(key, def) {
      var v = this.map[key];
      return v === void 0 ? def : v;
    };
    default_13.prototype.set = function(key, value2) {
      this.map[key] = value2;
    };
    default_13.prototype.clear = function() {
      this.map = {};
    };
    default_13.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_13.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_13;
  }()
);

// node_modules/@antv/coord/esm/utils/compose.js
function compose3(fn) {
  var rest = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    rest[_i - 1] = arguments[_i];
  }
  return fn ? rest.reduce(function(total, current) {
    return function(x3) {
      return current(total(x3));
    };
  }, fn) : identity_default4;
}

// node_modules/@antv/coord/esm/utils/isMatrix.js
function isMatrix(transformer2) {
  return transformer2 instanceof Float32Array || transformer2 instanceof Array;
}

// node_modules/@antv/coord/esm/utils/extend.js
var __read2 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function extend3(transform2) {
  return function(vector) {
    var v = [];
    for (var i = 0; i < vector.length - 1; i += 2) {
      var from = [vector[i], vector[i + 1]];
      var to = transform2(from);
      v.push.apply(v, __spreadArray2([], __read2(to), false));
    }
    return v;
  };
}
function extend3D(transform2) {
  return function(vector) {
    var v = [];
    for (var i = 0; i < vector.length - 1; i += 3) {
      var from = [vector[i], vector[i + 1], vector[i + 2]];
      var to = transform2(from);
      v.push.apply(v, __spreadArray2([], __read2(to), false));
    }
    return v;
  };
}

// node_modules/@antv/coord/esm/utils/adjustAngle.js
function adjustAngle(theta, min10, max11) {
  while (theta < min10)
    theta += Math.PI * 2;
  while (theta > max11)
    theta -= Math.PI * 2;
  return theta;
}

// node_modules/@antv/coord/esm/transforms/translate.js
var __read3 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var translate5 = function(params, x3, y3, width, height) {
  var _a2 = __read3(params, 2), tx = _a2[0], ty = _a2[1];
  var matrix3 = mat3_exports.create();
  return mat3_exports.fromTranslation(matrix3, [tx, ty]);
};

// node_modules/@antv/coord/esm/transforms/cartesian.js
var __read4 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var cartesian = function(params, x3, y3, width, height) {
  var sx = new Linear({
    range: [x3, x3 + width]
  });
  var sy = new Linear({
    range: [y3, y3 + height]
  });
  return {
    transform: function(vector) {
      var _a2 = __read4(vector, 2), v1 = _a2[0], v2 = _a2[1];
      return [sx.map(v1), sy.map(v2)];
    },
    untransform: function(vector) {
      var _a2 = __read4(vector, 2), v1 = _a2[0], v2 = _a2[1];
      return [sx.invert(v1), sy.invert(v2)];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/custom.js
var __read5 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var custom10 = function(params, x3, y3, width, height) {
  var _a2 = __read5(params, 1), callback = _a2[0];
  return callback(x3, y3, width, height);
};

// node_modules/@antv/coord/esm/transforms/matrix.js
var __read6 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var matrix2 = function(params, x3, y3, width, height) {
  var _a2 = __read6(params, 1), matrix3 = _a2[0];
  return matrix3;
};

// node_modules/@antv/coord/esm/transforms/polar.js
var __read7 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var polar = function(params, x3, y3, width, height) {
  var _a2 = __read7(params, 4), startAngle = _a2[0], endAngle = _a2[1], innerRadius = _a2[2], outerRadius = _a2[3];
  var radius = new Linear({
    range: [innerRadius, outerRadius]
  });
  var angle4 = new Linear({
    range: [startAngle, endAngle]
  });
  var aspect = height / width;
  var sx = aspect > 1 ? 1 : aspect;
  var sy = aspect > 1 ? 1 / aspect : 1;
  return {
    transform: function(vector) {
      var _a3 = __read7(vector, 2), v1 = _a3[0], v2 = _a3[1];
      var theta = angle4.map(v1);
      var r = radius.map(v2);
      var x4 = r * Math.cos(theta) * sx;
      var y4 = r * Math.sin(theta) * sy;
      var dx = x4 * 0.5 + 0.5;
      var dy = y4 * 0.5 + 0.5;
      return [dx, dy];
    },
    untransform: function(vector) {
      var _a3 = __read7(vector, 2), dx = _a3[0], dy = _a3[1];
      var x4 = (dx - 0.5) * 2 / sx;
      var y4 = (dy - 0.5) * 2 / sy;
      var r = Math.sqrt(Math.pow(x4, 2) + Math.pow(y4, 2));
      var t = Math.atan2(y4, x4);
      var theta = adjustAngle(t, startAngle, endAngle);
      var v1 = angle4.invert(theta);
      var v2 = radius.invert(r);
      return [v1, v2];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/transpose.js
var __read8 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var transpose5 = function(params, x3, y3, width, height) {
  return {
    transform: function(_a2) {
      var _b = __read8(_a2, 2), x4 = _b[0], y4 = _b[1];
      return [y4, x4];
    },
    untransform: function(_a2) {
      var _b = __read8(_a2, 2), x4 = _b[0], y4 = _b[1];
      return [y4, x4];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/scale.js
var __read9 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var scale9 = function(params, x3, y3, width, height) {
  var _a2 = __read9(params, 2), sx = _a2[0], sy = _a2[1];
  var matrix3 = mat3_exports.create();
  return mat3_exports.fromScaling(matrix3, [sx, sy]);
};

// node_modules/@antv/coord/esm/transforms/reflect.js
var __read10 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray3 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var reflect2 = function(params) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return scale9.apply(void 0, __spreadArray3([[-1, -1]], __read10(args), false));
};
var reflectX = function(params) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return scale9.apply(void 0, __spreadArray3([[-1, 1]], __read10(args), false));
};
var reflectY = function(params) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return scale9.apply(void 0, __spreadArray3([[1, -1]], __read10(args), false));
};

// node_modules/@antv/coord/esm/transforms/rotate.js
var __read11 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var rotate6 = function(params, x3, y3, width, height) {
  var _a2 = __read11(params, 1), theta = _a2[0];
  var matrix3 = mat3_exports.create();
  return mat3_exports.fromRotation(matrix3, theta);
};

// node_modules/@antv/coord/esm/transforms/helix.js
var __read12 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var helix = function(params, x3, y3, width, height) {
  var _a2 = __read12(params, 4), startAngle = _a2[0], endAngle = _a2[1], innerRadius = _a2[2], outerRadius = _a2[3];
  var count4 = (endAngle - 0) / (2 * Math.PI) + 1;
  var d3 = (outerRadius - innerRadius) / count4;
  var b = d3 / (Math.PI * 2);
  var step2 = new Linear({
    range: [innerRadius, innerRadius + d3 * 0.99]
    // 防止和下一个螺线重合
  });
  var angle4 = new Linear({
    range: [startAngle, endAngle]
  });
  var aspect = height / width;
  var sx = aspect > 1 ? 1 : aspect;
  var sy = aspect > 1 ? 1 / aspect : 1;
  return {
    transform: function(vector) {
      var _a3 = __read12(vector, 2), v1 = _a3[0], v2 = _a3[1];
      var theta = angle4.map(v1);
      var a4 = step2.map(v2);
      var x4 = Math.cos(theta) * (b * theta + a4) * sx;
      var y4 = Math.sin(theta) * (b * theta + a4) * sy;
      var dx = x4 * 0.5 + 0.5;
      var dy = y4 * 0.5 + 0.5;
      return [dx, dy];
    },
    untransform: function(vector) {
      var _a3 = __read12(vector, 2), dx = _a3[0], dy = _a3[1];
      var x4 = (dx - 0.5) * 2 / sx;
      var y4 = (dy - 0.5) * 2 / sy;
      var r = Math.sqrt(Math.pow(x4, 2) + Math.pow(y4, 2));
      var t = Math.atan2(y4, x4) + Math.floor(r / d3) * Math.PI * 2;
      var theta = adjustAngle(t, startAngle, endAngle);
      var a4 = r - b * theta;
      var v1 = angle4.invert(theta);
      var v2 = step2.invert(a4);
      return [v1, v2];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/parallel.js
var __read13 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var parallel2 = function(params, x3, y3, width, height) {
  var _a2 = __read13(params, 4), x05 = _a2[0], x12 = _a2[1], y05 = _a2[2], y12 = _a2[3];
  var sy = new Linear({
    range: [y05, y12]
  });
  return {
    transform: function(vector) {
      var v = [];
      var len5 = vector.length;
      var sx = new Point({
        domain: new Array(len5).fill(0).map(function(_2, i2) {
          return i2;
        }),
        range: [x05, x12]
      });
      for (var i = 0; i < len5; i++) {
        var e = vector[i];
        var x_1 = sx.map(i);
        var y_1 = sy.map(e);
        v.push(x_1, y_1);
      }
      return v;
    },
    untransform: function(vector) {
      var v = [];
      for (var i = 0; i < vector.length; i += 2) {
        var y_2 = vector[i + 1];
        v.push(sy.invert(y_2));
      }
      return v;
    }
  };
};

// node_modules/@antv/coord/esm/transforms/shear.js
var __read14 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function cot(theta) {
  return 1 / Math.tan(theta);
}
var shearX = function(params, x3, y3, width, height) {
  var _a2 = __read14(params, 1), theta = _a2[0];
  var sx = cot(theta);
  return {
    transform: function(vector) {
      var _a3 = __read14(vector, 2), x4 = _a3[0], y4 = _a3[1];
      var xx = x4 + y4 * sx;
      return [xx, y4];
    },
    untransform: function(vector) {
      var _a3 = __read14(vector, 2), xx = _a3[0], y4 = _a3[1];
      var x4 = xx - y4 * sx;
      return [x4, y4];
    }
  };
};
var shearY = function(params, x3, y3, width, height) {
  var _a2 = __read14(params, 1), theta = _a2[0];
  var sy = cot(theta);
  return {
    transform: function(vector) {
      var _a3 = __read14(vector, 2), x4 = _a3[0], y4 = _a3[1];
      var yy = y4 + x4 * sy;
      return [x4, yy];
    },
    untransform: function(vector) {
      var _a3 = __read14(vector, 2), x4 = _a3[0], yy = _a3[1];
      var y4 = yy - x4 * sy;
      return [x4, y4];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/fisheye.js
var __read15 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function fisheyeTransform(x3, focus, distortion, min10, max11) {
  var left2 = x3 < focus;
  var m3 = (left2 ? focus - min10 : max11 - focus) || max11 - min10;
  var f = left2 ? -1 : 1;
  return f * m3 * (distortion + 1) / (distortion + m3 / ((x3 - focus) * f)) + focus;
}
function fisheyeUntransform(tx, focus, distortion, min10, max11) {
  var left2 = tx < focus;
  var m3 = (left2 ? focus - min10 : max11 - focus) || max11 - min10;
  var f = left2 ? -1 : 1;
  return m3 / (m3 * (distortion + 1) / (tx - focus) - distortion * f) + focus;
}
function normalize9(focus, length5, isVisual) {
  if (!isVisual)
    return focus;
  var s3 = new Linear({
    range: [0, 1],
    domain: [0, length5]
  });
  return s3.map(focus);
}
var fisheyeX = function(params, x3, y3, width, height) {
  var _a2 = __read15(params, 3), focus = _a2[0], distortion = _a2[1], _b = _a2[2], isVisual = _b === void 0 ? false : _b;
  var normalizedFocusX = normalize9(focus, width, isVisual);
  return {
    transform: function(vector) {
      var _a3 = __read15(vector, 2), vx = _a3[0], vy = _a3[1];
      var fx = fisheyeTransform(vx, normalizedFocusX, distortion, 0, 1);
      return [fx, vy];
    },
    untransform: function(vector) {
      var _a3 = __read15(vector, 2), fx = _a3[0], vy = _a3[1];
      var vx = fisheyeUntransform(fx, normalizedFocusX, distortion, 0, 1);
      return [vx, vy];
    }
  };
};
var fisheyeY = function(params, x3, y3, width, height) {
  var _a2 = __read15(params, 3), focus = _a2[0], distortion = _a2[1], _b = _a2[2], isVisual = _b === void 0 ? false : _b;
  var normalizedFocusY = normalize9(focus, height, isVisual);
  return {
    transform: function(vector) {
      var _a3 = __read15(vector, 2), vx = _a3[0], vy = _a3[1];
      var fy = fisheyeTransform(vy, normalizedFocusY, distortion, 0, 1);
      return [vx, fy];
    },
    untransform: function(vector) {
      var _a3 = __read15(vector, 2), vx = _a3[0], fy = _a3[1];
      var vy = fisheyeUntransform(fy, normalizedFocusY, distortion, 0, 1);
      return [vx, vy];
    }
  };
};
var fisheye = function(params, x3, y3, width, height) {
  var _a2 = __read15(params, 5), focusX = _a2[0], focusY = _a2[1], distortionX = _a2[2], distortionY = _a2[3], _b = _a2[4], isVisual = _b === void 0 ? false : _b;
  var normalizedFocusX = normalize9(focusX, width, isVisual);
  var normalizedFocusY = normalize9(focusY, height, isVisual);
  return {
    transform: function(vector) {
      var _a3 = __read15(vector, 2), vx = _a3[0], vy = _a3[1];
      var fx = fisheyeTransform(vx, normalizedFocusX, distortionX, 0, 1);
      var fy = fisheyeTransform(vy, normalizedFocusY, distortionY, 0, 1);
      return [fx, fy];
    },
    untransform: function(vector) {
      var _a3 = __read15(vector, 2), fx = _a3[0], fy = _a3[1];
      var vx = fisheyeUntransform(fx, normalizedFocusX, distortionX, 0, 1);
      var vy = fisheyeUntransform(fy, normalizedFocusY, distortionY, 0, 1);
      return [vx, vy];
    }
  };
};
var fisheyeCircular = function(params, x3, y3, width, height) {
  var _a2 = __read15(params, 5), focusX = _a2[0], focusY = _a2[1], radius = _a2[2], distortion = _a2[3], _b = _a2[4], isVisual = _b === void 0 ? false : _b;
  var scaleX2 = new Linear({
    range: [0, width]
  });
  var scaleY2 = new Linear({
    range: [0, height]
  });
  var nx = isVisual ? focusX : scaleX2.map(focusX);
  var ny = isVisual ? focusY : scaleY2.map(focusY);
  return {
    transform: function(vector) {
      var _a3 = __read15(vector, 2), x4 = _a3[0], y4 = _a3[1];
      var dx = scaleX2.map(x4) - nx;
      var dy = scaleY2.map(y4) - ny;
      var dd = Math.sqrt(dx * dx + dy * dy);
      if (dd > radius)
        return [x4, y4];
      var r = fisheyeTransform(dd, 0, distortion, 0, radius);
      var theta = Math.atan2(dy, dx);
      var fx = nx + r * Math.cos(theta);
      var fy = ny + r * Math.sin(theta);
      return [scaleX2.invert(fx), scaleY2.invert(fy)];
    },
    untransform: function(vector) {
      var _a3 = __read15(vector, 2), tx = _a3[0], ty = _a3[1];
      var dx = scaleX2.map(tx) - nx;
      var dy = scaleY2.map(ty) - ny;
      var dd = Math.sqrt(dx * dx + dy * dy);
      if (dd > radius)
        return [tx, ty];
      var x4 = fisheyeUntransform(dd, 0, distortion, 0, radius);
      var theta = Math.atan2(dy, dx);
      var fx = nx + x4 * Math.cos(theta);
      var fy = ny + x4 * Math.sin(theta);
      return [scaleX2.invert(fx), scaleY2.invert(fy)];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/cartesian3D.js
var __read16 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var cartesian3D = function(params, x3, y3, z, width, height, depth) {
  var sx = new Linear({
    range: [x3, x3 + width]
  });
  var sy = new Linear({
    range: [y3, y3 + height]
  });
  var sz = new Linear({
    range: [z, z + depth]
  });
  return {
    transform: function(vector) {
      var _a2 = __read16(vector, 3), v1 = _a2[0], v2 = _a2[1], v3 = _a2[2];
      return [sx.map(v1), sy.map(v2), sz.map(v3)];
    },
    untransform: function(vector) {
      var _a2 = __read16(vector, 3), v1 = _a2[0], v2 = _a2[1], v3 = _a2[2];
      return [sx.invert(v1), sy.invert(v2), sz.invert(v3)];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/translate3D.js
var __read17 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var translate3D = function(params, x3, y3, z, width, height, depth) {
  var _a2 = __read17(params, 3), tx = _a2[0], ty = _a2[1], tz = _a2[2];
  return mat4_exports.fromTranslation(mat4_exports.create(), [tx, ty, tz]);
};

// node_modules/@antv/coord/esm/transforms/transpose3D.js
var __read18 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var transpose3D = function(params, x3, y3, z, width, height, depth) {
  return {
    transform: function(_a2) {
      var _b = __read18(_a2, 3), x4 = _b[0], y4 = _b[1], z2 = _b[2];
      return [y4, x4, z2];
    },
    untransform: function(_a2) {
      var _b = __read18(_a2, 3), x4 = _b[0], y4 = _b[1], z2 = _b[2];
      return [y4, x4, z2];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/scale3D.js
var __read19 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var scale3D = function(params, x3, y3, z, width, height, depth) {
  var _a2 = __read19(params, 3), sx = _a2[0], sy = _a2[1], sz = _a2[2];
  return mat4_exports.fromScaling(mat4_exports.create(), [sx, sy, sz]);
};

// node_modules/@antv/coord/esm/coordinate.js
var __read20 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray4 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var __values2 = function(o) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o[s3], i = 0;
  if (m3)
    return m3.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Coordinate = (
  /** @class */
  function() {
    function Coordinate2(options) {
      this.options = {
        x: 0,
        y: 0,
        width: 300,
        height: 150,
        transformations: []
      };
      this.transformers = {
        cartesian,
        translate: translate5,
        custom: custom10,
        matrix: matrix2,
        polar,
        transpose: transpose5,
        scale: scale9,
        "shear.x": shearX,
        "shear.y": shearY,
        reflect: reflect2,
        "reflect.x": reflectX,
        "reflect.y": reflectY,
        rotate: rotate6,
        helix,
        parallel: parallel2,
        fisheye,
        "fisheye.x": fisheyeX,
        "fisheye.y": fisheyeY,
        "fisheye.circular": fisheyeCircular
      };
      this.update(options);
    }
    Coordinate2.prototype.update = function(options) {
      this.options = deep_mix_default2({}, this.options, options);
      this.recoordinate();
    };
    Coordinate2.prototype.clone = function() {
      return new Coordinate2(this.options);
    };
    Coordinate2.prototype.getOptions = function() {
      return this.options;
    };
    Coordinate2.prototype.clear = function() {
      this.update({
        transformations: []
      });
    };
    Coordinate2.prototype.getSize = function() {
      var _a2 = this.options, width = _a2.width, height = _a2.height;
      return [width, height];
    };
    Coordinate2.prototype.getCenter = function() {
      var _a2 = this.options, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
      return [(x3 * 2 + width) / 2, (y3 * 2 + height) / 2];
    };
    Coordinate2.prototype.transform = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var transformations = this.options.transformations;
      this.update({
        transformations: __spreadArray4(__spreadArray4([], __read20(transformations), false), [__spreadArray4([], __read20(args), false)], false)
      });
      return this;
    };
    Coordinate2.prototype.map = function(vector) {
      return this.output(vector);
    };
    Coordinate2.prototype.invert = function(vector) {
      return this.input(vector);
    };
    Coordinate2.prototype.recoordinate = function() {
      this.output = this.compose();
      this.input = this.compose(true);
    };
    Coordinate2.prototype.compose = function(invert5) {
      var e_1, _a2;
      if (invert5 === void 0) {
        invert5 = false;
      }
      var transformations = invert5 ? __spreadArray4([], __read20(this.options.transformations), false).reverse() : this.options.transformations;
      var getter = invert5 ? function(d3) {
        return d3.untransform;
      } : function(d3) {
        return d3.transform;
      };
      var matrixes = [];
      var transforms = [];
      var add10 = function(transform3, extended) {
        if (extended === void 0) {
          extended = true;
        }
        return transforms.push(extended ? extend3(transform3) : transform3);
      };
      try {
        for (var transformations_1 = __values2(transformations), transformations_1_1 = transformations_1.next(); !transformations_1_1.done; transformations_1_1 = transformations_1.next()) {
          var _b = __read20(transformations_1_1.value), name_1 = _b[0], args = _b.slice(1);
          var createTransformer = this.transformers[name_1];
          if (createTransformer) {
            var _c = this.options, x3 = _c.x, y3 = _c.y, width = _c.width, height = _c.height;
            var transformer2 = createTransformer(__spreadArray4([], __read20(args), false), x3, y3, width, height);
            if (isMatrix(transformer2)) {
              matrixes.push(transformer2);
            } else {
              if (matrixes.length) {
                var transform_1 = this.createMatrixTransform(matrixes, invert5);
                add10(transform_1);
                matrixes.splice(0, matrixes.length);
              }
              var transform2 = getter(transformer2) || identity_default4;
              add10(transform2, name_1 !== "parallel");
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (transformations_1_1 && !transformations_1_1.done && (_a2 = transformations_1.return))
            _a2.call(transformations_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (matrixes.length) {
        var transform2 = this.createMatrixTransform(matrixes, invert5);
        add10(transform2);
      }
      return compose3.apply(void 0, __spreadArray4([], __read20(transforms), false));
    };
    Coordinate2.prototype.createMatrixTransform = function(matrixes, invert5) {
      var matrix3 = mat3_exports.create();
      if (invert5)
        matrixes.reverse();
      matrixes.forEach(function(m3) {
        return mat3_exports.mul(matrix3, matrix3, m3);
      });
      if (invert5) {
        mat3_exports.invert(matrix3, mat3_exports.clone(matrix3));
      }
      return function(vector) {
        var vector3 = [vector[0], vector[1], 1];
        vec3_exports.transformMat3(vector3, vector3, matrix3);
        return [vector3[0], vector3[1]];
      };
    };
    return Coordinate2;
  }()
);

// node_modules/@antv/coord/esm/coordinate3D.js
var __read21 = function(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i = m3.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error3) {
    e = { error: error3 };
  } finally {
    try {
      if (r && !r.done && (m3 = i["return"]))
        m3.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray5 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var __values3 = function(o) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o[s3], i = 0;
  if (m3)
    return m3.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Coordinate3D = (
  /** @class */
  function() {
    function Coordinate3D2(options) {
      this.options = {
        x: 0,
        y: 0,
        z: 0,
        width: 300,
        height: 150,
        depth: 150,
        transformations: []
      };
      this.transformers = {
        cartesian3D,
        translate3D,
        scale3D,
        transpose3D
      };
      this.update(options);
    }
    Coordinate3D2.prototype.update = function(options) {
      this.options = deep_mix_default2({}, this.options, options);
      this.recoordinate();
    };
    Coordinate3D2.prototype.clone = function() {
      return new Coordinate3D2(this.options);
    };
    Coordinate3D2.prototype.getOptions = function() {
      return this.options;
    };
    Coordinate3D2.prototype.clear = function() {
      this.update({
        transformations: []
      });
    };
    Coordinate3D2.prototype.getSize = function() {
      var _a2 = this.options, width = _a2.width, height = _a2.height, depth = _a2.depth;
      return [width, height, depth];
    };
    Coordinate3D2.prototype.getCenter = function() {
      var _a2 = this.options, x3 = _a2.x, y3 = _a2.y, z = _a2.z, width = _a2.width, height = _a2.height, depth = _a2.depth;
      return [(x3 * 2 + width) / 2, (y3 * 2 + height) / 2, (z * 2 + depth) / 2];
    };
    Coordinate3D2.prototype.transform = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var transformations = this.options.transformations;
      this.update({
        transformations: __spreadArray5(__spreadArray5([], __read21(transformations), false), [__spreadArray5([], __read21(args), false)], false)
      });
      return this;
    };
    Coordinate3D2.prototype.map = function(vector) {
      return this.output(vector);
    };
    Coordinate3D2.prototype.invert = function(vector) {
      return this.input(vector);
    };
    Coordinate3D2.prototype.recoordinate = function() {
      this.output = this.compose();
      this.input = this.compose(true);
    };
    Coordinate3D2.prototype.compose = function(invert5) {
      var e_1, _a2;
      if (invert5 === void 0) {
        invert5 = false;
      }
      var transformations = invert5 ? __spreadArray5([], __read21(this.options.transformations), false).reverse() : this.options.transformations;
      var getter = invert5 ? function(d3) {
        return d3.untransform;
      } : function(d3) {
        return d3.transform;
      };
      var matrixes = [];
      var transforms = [];
      var add10 = function(transform3, extended) {
        if (extended === void 0) {
          extended = true;
        }
        return transforms.push(extended ? extend3D(transform3) : transform3);
      };
      try {
        for (var transformations_1 = __values3(transformations), transformations_1_1 = transformations_1.next(); !transformations_1_1.done; transformations_1_1 = transformations_1.next()) {
          var _b = __read21(transformations_1_1.value), name_1 = _b[0], args = _b.slice(1);
          var createTransformer = this.transformers[name_1];
          if (createTransformer) {
            var _c = this.options, x3 = _c.x, y3 = _c.y, z = _c.z, width = _c.width, height = _c.height, depth = _c.depth;
            var transformer2 = createTransformer(__spreadArray5([], __read21(args), false), x3, y3, z, width, height, depth);
            if (isMatrix(transformer2)) {
              matrixes.push(transformer2);
            } else {
              if (matrixes.length) {
                var transform_1 = this.createMatrixTransform(matrixes, invert5);
                add10(transform_1);
                matrixes.splice(0, matrixes.length);
              }
              var transform2 = getter(transformer2) || identity_default4;
              add10(transform2, true);
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (transformations_1_1 && !transformations_1_1.done && (_a2 = transformations_1.return))
            _a2.call(transformations_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (matrixes.length) {
        var transform2 = this.createMatrixTransform(matrixes, invert5);
        add10(transform2);
      }
      return compose3.apply(void 0, __spreadArray5([], __read21(transforms), false));
    };
    Coordinate3D2.prototype.createMatrixTransform = function(matrixes, invert5) {
      var matrix3 = mat4_exports.create();
      if (invert5)
        matrixes.reverse();
      matrixes.forEach(function(m3) {
        return mat4_exports.mul(matrix3, matrix3, m3);
      });
      if (invert5) {
        mat4_exports.invert(matrix3, mat4_exports.clone(matrix3));
      }
      return function(vector) {
        var vector4 = [vector[0], vector[1], vector[2], 1];
        vec4_exports.transformMat4(vector4, vector4, matrix3);
        return [vector4[0], vector4[1], vector4[2]];
      };
    };
    return Coordinate3D2;
  }()
);

// node_modules/@antv/g2/esm/composition/utils.js
var __rest61 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function useDefaultAdaptor(adaptor33) {
  return (options, ...rest) => deep_mix_default({}, adaptor33(options, ...rest), options);
}
function useOverrideAdaptor(adaptor33) {
  return (options, ...rest) => deep_mix_default({}, options, adaptor33(options, ...rest));
}
function isObject2(d3) {
  if (d3 instanceof Date)
    return false;
  return typeof d3 === "object";
}
function mergeData(dataDescriptor, dataValue) {
  if (!dataDescriptor)
    return dataValue;
  if (Array.isArray(dataDescriptor))
    return dataDescriptor;
  if (isObject2(dataDescriptor)) {
    const { value: value2 = dataValue } = dataDescriptor, rest = __rest61(dataDescriptor, ["value"]);
    return Object.assign(Object.assign({}, rest), { value: value2 });
  }
  return dataDescriptor;
}

// node_modules/@antv/g2/esm/composition/spaceLayer.js
var __rest62 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var SpaceLayer = () => {
  return (options) => {
    const { children } = options;
    if (!Array.isArray(children))
      return [];
    const { x: viewX = 0, y: viewY = 0, width: viewWidth, height: viewHeight, data: layerData } = options;
    return children.map((_a2) => {
      var { data: data2, x: x3, y: y3, width, height } = _a2, rest = __rest62(_a2, ["data", "x", "y", "width", "height"]);
      return Object.assign(Object.assign({}, rest), { data: mergeData(data2, layerData), x: x3 !== null && x3 !== void 0 ? x3 : viewX, y: y3 !== null && y3 !== void 0 ? y3 : viewY, width: width !== null && width !== void 0 ? width : viewWidth, height: height !== null && height !== void 0 ? height : viewHeight });
    });
  };
};
SpaceLayer.props = {};

// node_modules/@antv/g2/esm/composition/spaceFlex.js
var __rest63 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var SpaceFlex = () => {
  return (options) => {
    const { children } = options;
    if (!Array.isArray(children))
      return [];
    const { direction: direction3 = "row", ratio = children.map(() => 1), padding = 0, data: flexData } = options;
    const [mainStart, mainSize, crossSize, crossStart] = direction3 === "col" ? ["y", "height", "width", "x"] : ["x", "width", "height", "y"];
    const sum4 = ratio.reduce((total, value2) => total + value2);
    const totalSize = options[mainSize] - padding * (children.length - 1);
    const sizes = ratio.map((value2) => totalSize * (value2 / sum4));
    const newChildren = [];
    let next = options[mainStart] || 0;
    for (let i = 0; i < sizes.length; i += 1) {
      const _a2 = children[i], { data: data2 } = _a2, rest = __rest63(_a2, ["data"]);
      const newData = mergeData(data2, flexData);
      newChildren.push(Object.assign({ [mainStart]: next, [mainSize]: sizes[i], [crossStart]: options[crossStart] || 0, [crossSize]: options[crossSize], data: newData }, rest));
      next += sizes[i] + padding;
    }
    return newChildren;
  };
};
SpaceFlex.props = {};

// node_modules/@antv/g2/esm/composition/view.js
var __rest64 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var View = () => {
  return (options) => {
    const { children } = options, restOptions = __rest64(options, ["children"]);
    if (!Array.isArray(children))
      return [];
    const { data: viewData, scale: viewScale = {}, axis: viewAxis = {}, legend: viewLegend = {}, encode: viewEncode = {}, transform: viewTransform = [] } = restOptions, rest = __rest64(restOptions, ["data", "scale", "axis", "legend", "encode", "transform"]);
    const marks = children.map((_a2) => {
      var { data: data2, scale: scale11 = {}, axis = {}, legend = {}, encode = {}, transform: transform2 = [] } = _a2, rest2 = __rest64(_a2, ["data", "scale", "axis", "legend", "encode", "transform"]);
      return Object.assign({ data: mergeData(data2, viewData), scale: deep_mix_default({}, viewScale, scale11), encode: deep_mix_default({}, viewEncode, encode), transform: [...viewTransform, ...transform2], axis: axis && viewAxis ? deep_mix_default({}, viewAxis, axis) : false, legend: legend && viewLegend ? deep_mix_default({}, viewLegend, legend) : false }, rest2);
    });
    return [Object.assign(Object.assign({}, rest), { marks, type: "standardView" })];
  };
};
View.props = {};

// node_modules/@antv/g2/esm/composition/mark.js
var __rest65 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var Mark = ({ static: isStatic = false } = {}) => {
  return (options) => {
    const { width, height, depth, paddingLeft, paddingRight, paddingTop, paddingBottom, padding, inset, insetLeft, insetTop, insetRight, insetBottom, margin, marginLeft, marginBottom, marginTop, marginRight, data: data2, coordinate, theme, component, interaction, x: x3, y: y3, z, key, frame: frame2, labelTransform, parentKey, clip, viewStyle, title } = options, mark2 = __rest65(options, ["width", "height", "depth", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "padding", "inset", "insetLeft", "insetTop", "insetRight", "insetBottom", "margin", "marginLeft", "marginBottom", "marginTop", "marginRight", "data", "coordinate", "theme", "component", "interaction", "x", "y", "z", "key", "frame", "labelTransform", "parentKey", "clip", "viewStyle", "title"]);
    return [
      Object.assign(Object.assign({
        type: "standardView",
        x: x3,
        y: y3,
        z,
        key,
        width,
        height,
        depth,
        padding,
        paddingLeft,
        paddingRight,
        paddingTop,
        inset,
        insetLeft,
        insetTop,
        insetRight,
        insetBottom,
        paddingBottom,
        theme,
        coordinate,
        component,
        interaction,
        frame: frame2,
        labelTransform,
        margin,
        marginLeft,
        marginBottom,
        marginTop,
        marginRight,
        parentKey,
        clip,
        style: viewStyle
      }, !isStatic && { title }), { marks: [Object.assign(Object.assign(Object.assign({}, mark2), { key: `${key}-0`, data: data2 }), isStatic && { title })] })
    ];
  };
};
Mark.props = {};

// node_modules/@antv/g2/esm/utils/container.js
var Container = class _Container {
  constructor(x3) {
    this.$value = x3;
  }
  static of(x3) {
    return new _Container(x3);
  }
  call(f, ...rest) {
    return this.$value = f(this.$value, ...rest), this;
  }
  value() {
    return this.$value;
  }
};

// node_modules/@antv/g2/esm/composition/facetRect.js
var __rest66 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var setScale = useDefaultAdaptor((options) => {
  const { encode, data: data2, scale: scale11, shareSize = false } = options;
  const { x: x3, y: y3 } = encode;
  const flexDomain = (encode2, channel) => {
    var _a2;
    if (encode2 === void 0 || !shareSize)
      return {};
    const groups2 = group(data2, (d3) => d3[encode2]);
    const domain = ((_a2 = scale11 === null || scale11 === void 0 ? void 0 : scale11[channel]) === null || _a2 === void 0 ? void 0 : _a2.domain) || Array.from(groups2.keys());
    const flex2 = domain.map((key) => {
      if (!groups2.has(key))
        return 1;
      return groups2.get(key).length;
    });
    return { domain, flex: flex2 };
  };
  return {
    scale: {
      x: Object.assign(Object.assign({ paddingOuter: 0, paddingInner: 0.1, guide: x3 === void 0 ? null : { position: "top" } }, x3 === void 0 && { paddingInner: 0 }), flexDomain(x3, "x")),
      y: Object.assign(Object.assign({ range: [0, 1], paddingOuter: 0, paddingInner: 0.1, guide: y3 === void 0 ? null : { position: "right" } }, y3 === void 0 && { paddingInner: 0 }), flexDomain(y3, "y"))
    }
  };
});
var inferColor = useOverrideAdaptor((options) => {
  const { data: data2, scale: scale11, legend } = options;
  const discovered = [options];
  let encodeColor;
  let scaleColor;
  let legendColor;
  while (discovered.length) {
    const node = discovered.shift();
    const { children, encode = {}, scale: scale12 = {}, legend: legend2 = {} } = node;
    const { color: c5 } = encode;
    const { color: cs } = scale12;
    const { color: cl } = legend2;
    if (c5 !== void 0)
      encodeColor = c5;
    if (cs !== void 0)
      scaleColor = cs;
    if (cl !== void 0)
      legendColor = cl;
    if (Array.isArray(children)) {
      discovered.push(...children);
    }
  }
  const domainColor = () => {
    var _a2;
    const domain2 = (_a2 = scale11 === null || scale11 === void 0 ? void 0 : scale11.color) === null || _a2 === void 0 ? void 0 : _a2.domain;
    if (domain2 !== void 0)
      return [domain2];
    if (encodeColor === void 0)
      return [void 0];
    const color3 = typeof encodeColor === "function" ? encodeColor : (d3) => d3[encodeColor];
    const values4 = data2.map(color3);
    if (values4.some((d3) => typeof d3 === "number"))
      return [extent(values4)];
    return [Array.from(new Set(values4)), "ordinal"];
  };
  const title = typeof encodeColor === "string" ? encodeColor : "";
  const [domain, type] = domainColor();
  return Object.assign({ encode: { color: { type: "column", value: domain !== null && domain !== void 0 ? domain : [] } }, scale: { color: deep_mix_default({}, scaleColor, { domain, type }) } }, legend === void 0 && {
    legend: { color: deep_mix_default({ title }, legendColor) }
  });
});
var setAnimation = useDefaultAdaptor(() => ({
  animate: {
    enterType: "fadeIn"
  }
}));
var setStyle = useOverrideAdaptor(() => ({
  frame: false,
  encode: {
    shape: "hollow"
  },
  style: {
    lineWidth: 0
  }
}));
var toCell = useOverrideAdaptor(() => ({
  type: "cell"
}));
var setData = useOverrideAdaptor((options) => {
  const { data: data2 } = options;
  const connector = {
    type: "custom",
    callback: () => {
      const { data: data3, encode } = options;
      const { x: x3, y: y3 } = encode;
      const X = x3 ? Array.from(new Set(data3.map((d3) => d3[x3]))) : [];
      const Y = y3 ? Array.from(new Set(data3.map((d3) => d3[y3]))) : [];
      const cellData = () => {
        if (X.length && Y.length) {
          const cellData2 = [];
          for (const vx of X) {
            for (const vy of Y) {
              cellData2.push({ [x3]: vx, [y3]: vy });
            }
          }
          return cellData2;
        }
        if (X.length)
          return X.map((d3) => ({ [x3]: d3 }));
        if (Y.length)
          return Y.map((d3) => ({ [y3]: d3 }));
      };
      return cellData();
    }
  };
  return {
    data: { type: "inline", value: data2, transform: [connector] }
  };
});
var setChildren = useOverrideAdaptor((options, subLayout = subLayoutRect, createGuideX2 = createGuideXRect, createGuideY2 = createGuideYRect, childOptions = {}) => {
  const { data: dataValue, encode, children, scale: facetScale, x: originX = 0, y: originY = 0, shareData = false, key: viewKey } = options;
  const { value: data2 } = dataValue;
  const { x: encodeX, y: encodeY } = encode;
  const { color: facetScaleColor } = facetScale;
  const { domain: facetDomainColor } = facetScaleColor;
  const createChildren = (visualData, scale11, layout) => {
    const { x: scaleX2, y: scaleY2 } = scale11;
    const { paddingLeft, paddingTop, marginLeft, marginTop } = layout;
    const { domain: domainX } = scaleX2.getOptions();
    const { domain: domainY } = scaleY2.getOptions();
    const index3 = indexOf3(visualData);
    const bboxs = visualData.map(subLayout);
    const values4 = visualData.map(({ x: x3, y: y3 }) => [
      scaleX2.invert(x3),
      scaleY2.invert(y3)
    ]);
    const filters = values4.map(([fx, fy]) => (d3) => {
      const { [encodeX]: x3, [encodeY]: y3 } = d3;
      const inX = encodeX !== void 0 ? x3 === fx : true;
      const inY = encodeY !== void 0 ? y3 === fy : true;
      return inX && inY;
    });
    const facetData2d = filters.map((f) => data2.filter(f));
    const maxDataDomain = shareData ? max5(facetData2d, (data3) => data3.length) : void 0;
    const facets = values4.map(([fx, fy]) => ({
      columnField: encodeX,
      columnIndex: domainX.indexOf(fx),
      columnValue: fx,
      columnValuesLength: domainX.length,
      rowField: encodeY,
      rowIndex: domainY.indexOf(fy),
      rowValue: fy,
      rowValuesLength: domainY.length
    }));
    const normalizedChildren = facets.map((facet) => {
      if (Array.isArray(children))
        return children;
      return [children(facet)].flat(1);
    });
    return index3.flatMap((i) => {
      const [left2, top, width, height] = bboxs[i];
      const facet = facets[i];
      const facetData = facetData2d[i];
      const children2 = normalizedChildren[i];
      return children2.map((_a2) => {
        var _b, _c;
        var { scale: scale12, key, facet: isFacet = true, axis = {}, legend = {} } = _a2, rest = __rest66(_a2, ["scale", "key", "facet", "axis", "legend"]);
        const guideY = ((_b = scale12 === null || scale12 === void 0 ? void 0 : scale12.y) === null || _b === void 0 ? void 0 : _b.guide) || axis.y;
        const guideX = ((_c = scale12 === null || scale12 === void 0 ? void 0 : scale12.x) === null || _c === void 0 ? void 0 : _c.guide) || axis.x;
        const defaultScale = {
          x: { tickCount: encodeX ? 5 : void 0 },
          y: { tickCount: encodeY ? 5 : void 0 }
        };
        const newData = isFacet ? facetData : facetData.length === 0 ? [] : data2;
        const newScale = {
          color: { domain: facetDomainColor }
        };
        const newAxis = {
          x: createGuide(guideX, createGuideX2)(facet, newData),
          y: createGuide(guideY, createGuideY2)(facet, newData)
        };
        return Object.assign(Object.assign({
          key: `${key}-${i}`,
          data: newData,
          margin: 0,
          x: left2 + paddingLeft + originX + marginLeft,
          y: top + paddingTop + originY + marginTop,
          parentKey: viewKey,
          width,
          height,
          paddingLeft: 0,
          paddingRight: 0,
          paddingTop: 0,
          paddingBottom: 0,
          frame: newData.length ? true : false,
          dataDomain: maxDataDomain,
          scale: deep_mix_default(defaultScale, scale12, newScale),
          axis: deep_mix_default({}, axis, newAxis),
          // Hide all legends for child mark by default,
          // they are displayed in the top-level.
          legend: false
        }, rest), childOptions);
      });
    });
  };
  return {
    children: createChildren
  };
});
function subLayoutRect(data2) {
  const { points } = data2;
  return calcBBox(points);
}
function createInnerGuide(guide, data2) {
  return data2.length ? deep_mix_default({
    title: false,
    tick: null,
    label: null
  }, guide) : deep_mix_default({
    title: false,
    tick: null,
    label: null,
    grid: null
  }, guide);
}
function createGuideXRect(guide) {
  return (facet, data2) => {
    const { rowIndex, rowValuesLength, columnIndex, columnValuesLength } = facet;
    if (rowIndex !== rowValuesLength - 1)
      return createInnerGuide(guide, data2);
    const title = columnIndex !== columnValuesLength - 1 ? false : void 0;
    const grid2 = data2.length ? void 0 : null;
    return deep_mix_default({ title, grid: grid2 }, guide);
  };
}
function createGuideYRect(guide) {
  return (facet, data2) => {
    const { rowIndex, columnIndex } = facet;
    if (columnIndex !== 0)
      return createInnerGuide(guide, data2);
    const title = rowIndex !== 0 ? false : void 0;
    const grid2 = data2.length ? void 0 : null;
    return deep_mix_default({ title, grid: grid2 }, guide);
  };
}
function createGuide(guide, factory) {
  if (typeof guide === "function")
    return guide;
  if (guide === null || guide === false)
    return () => null;
  return factory(guide);
}
var FacetRect = () => {
  return (options) => {
    const newOptions = Container.of(options).call(toCell).call(inferColor).call(setAnimation).call(setScale).call(setStyle).call(setData).call(setChildren).value();
    return [newOptions];
  };
};
FacetRect.props = {};

// node_modules/@antv/g2/esm/composition/repeatMatrix.js
var __rest67 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var setScale2 = useDefaultAdaptor((options) => {
  return {
    scale: {
      x: { guide: null, paddingOuter: 0, paddingInner: 0.1 },
      y: { guide: null, range: [0, 1], paddingOuter: 0, paddingInner: 0.1 }
    }
  };
});
var setChildren2 = useOverrideAdaptor((options) => {
  const { data: data2, children, x: originX = 0, y: originY = 0, key: viewKey } = options;
  const createChildren = (visualData, scale11, layout) => {
    const { x: scaleX2, y: scaleY2 } = scale11;
    const { paddingLeft, paddingTop, marginLeft, marginTop } = layout;
    const { domain: domainX } = scaleX2.getOptions();
    const { domain: domainY } = scaleY2.getOptions();
    const index3 = indexOf3(visualData);
    const bboxs = visualData.map(({ points }) => calcBBox(points));
    const values4 = visualData.map(({ x: x3, y: y3 }) => [
      scaleX2.invert(x3),
      scaleY2.invert(y3)
    ]);
    const facets = values4.map(([fx, fy]) => ({
      columnField: fx,
      columnIndex: domainX.indexOf(fx),
      columnValue: fx,
      columnValuesLength: domainX.length,
      rowField: fy,
      rowIndex: domainY.indexOf(fy),
      rowValue: fy,
      rowValuesLength: domainY.length
    }));
    const normalizedChildren = facets.map((facet) => {
      if (Array.isArray(children))
        return children;
      return [children(facet)].flat(1);
    });
    return index3.flatMap((i) => {
      const [left2, top, width, height] = bboxs[i];
      const [fx, fy] = values4[i];
      const facet = facets[i];
      const children2 = normalizedChildren[i];
      return children2.map((d3) => {
        var _a2, _b;
        const { scale: scale12, key, encode, axis, interaction } = d3, rest = __rest67(d3, ["scale", "key", "encode", "axis", "interaction"]);
        const guideY = (_a2 = scale12 === null || scale12 === void 0 ? void 0 : scale12.y) === null || _a2 === void 0 ? void 0 : _a2.guide;
        const guideX = (_b = scale12 === null || scale12 === void 0 ? void 0 : scale12.x) === null || _b === void 0 ? void 0 : _b.guide;
        const defaultScale = {
          // Do not sync position scales among facets by default.
          x: { facet: false },
          // Do not sync position scales among facets by default.
          y: { facet: false }
        };
        const newAxis = {
          x: createGuideX(guideX)(facet, data2),
          y: createGuideY(guideY)(facet, data2)
        };
        const defaultAxis = {
          x: { tickCount: 5 },
          y: { tickCount: 5 }
        };
        return Object.assign({
          data: data2,
          parentKey: viewKey,
          key: `${key}-${i}`,
          x: left2 + paddingLeft + originX + marginLeft,
          y: top + paddingTop + originY + marginTop,
          width,
          height,
          margin: 0,
          paddingLeft: 0,
          paddingRight: 0,
          paddingTop: 0,
          paddingBottom: 0,
          frame: true,
          scale: deep_mix_default(defaultScale, scale12),
          axis: deep_mix_default(defaultAxis, axis, newAxis),
          // Hide all legends for child mark by default,
          // they are displayed in the top-level.
          legend: false,
          encode: deep_mix_default({}, encode, {
            x: fx,
            y: fy
          }),
          interaction: deep_mix_default({}, interaction, {
            // Register this interaction in parent node.
            legendFilter: false
          })
        }, rest);
      });
    });
  };
  return {
    children: createChildren
  };
});
var setData2 = useOverrideAdaptor((options) => {
  const { encode } = options, rest = __rest67(options, ["encode"]);
  const { position: P = [], x: X = P, y: Y = [...P].reverse() } = encode, restEncode = __rest67(encode, ["position", "x", "y"]);
  const data2 = [];
  for (const $x of [X].flat(1)) {
    for (const $y of [Y].flat(1)) {
      data2.push({ $x, $y });
    }
  }
  return Object.assign(Object.assign({}, rest), { data: data2, encode: Object.assign(Object.assign({}, restEncode), { x: "$x", y: "$y" }), scale: Object.assign(Object.assign({}, [X].flat(1).length === 1 && { x: { paddingInner: 0 } }), [Y].flat(1).length === 1 && { y: { paddingInner: 0 } }) });
});
function createGuideX(guideX) {
  if (typeof guideX === "function")
    return guideX;
  if (guideX === null)
    return () => null;
  return (facet, data2) => {
    const { rowIndex, rowValuesLength } = facet;
    if (rowIndex !== rowValuesLength - 1)
      return createInnerGuide(guideX, data2);
  };
}
function createGuideY(guideY) {
  if (typeof guideY === "function")
    return guideY;
  if (guideY === null)
    return () => null;
  return (facet, data2) => {
    const { columnIndex } = facet;
    if (columnIndex !== 0)
      return createInnerGuide(guideY, data2);
  };
}
var RepeatMatrix = () => {
  return (options) => {
    const newOptions = Container.of(options).call(toCell).call(inferColor).call(setChildren2).call(setData2).call(setAnimation).call(setStyle).call(setScale2).value();
    return [newOptions];
  };
};

// node_modules/@antv/g2/esm/composition/facetCircle.js
var __rest68 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var setScale3 = useDefaultAdaptor((options) => {
  return {
    scale: {
      x: { guide: { type: "axisArc" }, paddingOuter: 0, paddingInner: 0.1 },
      y: { guide: null, range: [0, 1], paddingOuter: 0, paddingInner: 0.1 }
    }
  };
});
var setCoordinate = useDefaultAdaptor((options) => {
  return {
    coordinate: { type: "polar" }
  };
});
var setEncode = (options) => {
  const { encode } = options, rest = __rest68(options, ["encode"]);
  const { position } = encode;
  return Object.assign(Object.assign({}, rest), { encode: { x: position } });
};
function createGuideFacetCircle(guide) {
  return (facet) => null;
}
function subLayoutFacetCircle(data2) {
  const { points } = data2;
  const [p0, p1, p2, p3] = points;
  const sr = dist4(p0, p3);
  const v0 = sub6(p0, p3);
  const v1 = sub6(p1, p2);
  const a01 = angleBetween2(v0, v1);
  const t = 1 / Math.sin(a01 / 2);
  const ir = sr / (1 + t);
  const s3 = ir * Math.sqrt(2);
  const [x05, y05] = p2;
  const a0 = angleWithQuadrant(v0);
  const a32 = a0 + a01 / 2;
  const d3 = ir * t;
  const cx = x05 + d3 * Math.sin(a32);
  const cy = y05 - d3 * Math.cos(a32);
  return [cx - s3 / 2, cy - s3 / 2, s3, s3];
}
var FacetCircle = () => {
  return (options) => {
    const newOptions = Container.of(options).call(toCell).call(setEncode).call(inferColor).call(setCoordinate).call(setData).call(setChildren, subLayoutFacetCircle, createGuideFacetCircle, createGuideFacetCircle, { frame: false }).call(setAnimation).call(setStyle).call(setScale3).value();
    return [newOptions];
  };
};

// node_modules/@antv/g2/esm/composition/timingKeyframe.js
function range2(direction3, iterationCount, keyframeCount) {
  const start = 0;
  const end = keyframeCount;
  const normal = [start, end];
  const reverse2 = [-end + 1, -start + 1];
  if (direction3 === "normal")
    return normal;
  if (direction3 === "reverse")
    return reverse2;
  if (direction3 === "alternate") {
    return iterationCount % 2 === 0 ? normal : reverse2;
  }
  if (direction3 === "reverse-alternate") {
    return iterationCount % 2 === 0 ? reverse2 : normal;
  }
}
function setAnimation2(node, duration, easing) {
  const discovered = [node];
  while (discovered.length) {
    const n = discovered.pop();
    n.animate = deep_mix_default({
      enter: {
        duration
      },
      update: {
        duration,
        easing,
        type: "morphing",
        fill: "both"
      },
      exit: {
        type: "fadeOut",
        duration
      }
    }, n.animate || {});
    const { children } = n;
    if (Array.isArray(children))
      discovered.push(...children);
  }
  return node;
}
var TimingKeyframe = () => {
  return (options) => {
    const { children = [], duration = 1e3, iterationCount = 1, direction: direction3 = "normal", easing = "ease-in-out-sine" } = options;
    const n = children.length;
    if (!Array.isArray(children) || n === 0)
      return [];
    const { key } = children[0];
    const newChildren = children.map((d3) => Object.assign(Object.assign({}, d3), { key })).map((d3) => setAnimation2(d3, duration, easing));
    return function* () {
      let count4 = 0;
      let prevIndex;
      while (iterationCount === "infinite" || count4 < iterationCount) {
        const [start, end] = range2(direction3, count4, n);
        for (let i = start; i < end; i += 1) {
          const index3 = Math.abs(i);
          if (prevIndex !== index3)
            yield newChildren[index3];
          prevIndex = index3;
        }
        count4++;
      }
    };
  };
};
TimingKeyframe.props = {};

// node_modules/@antv/g2/esm/composition/geoPath.js
var __rest69 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var GeoPath = () => {
  return (options) => {
    const { type, data: data2, scale: scale11, encode, style, animate: animate2, key, state } = options, rest = __rest69(options, ["type", "data", "scale", "encode", "style", "animate", "key", "state"]);
    return [
      Object.assign(Object.assign({ type: "geoView" }, rest), { children: [
        {
          type: "geoPath",
          key: `${key}-0`,
          data: {
            value: data2
          },
          scale: scale11,
          encode,
          style,
          animate: animate2,
          state
        }
      ] })
    ];
  };
};
GeoPath.props = {};

// node_modules/d3-geo/src/math.js
var epsilon3 = 1e-6;
var epsilon22 = 1e-12;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var quarterPi = pi3 / 4;
var tau3 = pi3 * 2;
var degrees = 180 / pi3;
var radians = pi3 / 180;
var abs2 = Math.abs;
var atan = Math.atan;
var atan22 = Math.atan2;
var cos2 = Math.cos;
var ceil4 = Math.ceil;
var exp2 = Math.exp;
var log = Math.log;
var pow2 = Math.pow;
var sin2 = Math.sin;
var sign2 = Math.sign || function(x3) {
  return x3 > 0 ? 1 : x3 < 0 ? -1 : 0;
};
var sqrt2 = Math.sqrt;
var tan = Math.tan;
function acos2(x3) {
  return x3 > 1 ? 0 : x3 < -1 ? pi3 : Math.acos(x3);
}
function asin2(x3) {
  return x3 > 1 ? halfPi2 : x3 < -1 ? -halfPi2 : Math.asin(x3);
}

// node_modules/d3-geo/src/noop.js
function noop2() {
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n)
      streamGeometry(features[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n)
      streamGeometry(geometries[i], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n)
    coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n)
    streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}
function stream_default(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

// node_modules/d3-geo/src/area.js
var areaRingSum = new Adder();
var areaSum = new Adder();

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian3) {
  return [atan22(cartesian3[1], cartesian3[0]), asin2(cartesian3[2])];
}
function cartesian2(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
}
function cartesianDot(a4, b) {
  return a4[0] * b[0] + a4[1] * b[1] + a4[2] * b[2];
}
function cartesianCross(a4, b) {
  return [a4[1] * b[2] - a4[2] * b[1], a4[2] * b[0] - a4[0] * b[2], a4[0] * b[1] - a4[1] * b[0]];
}
function cartesianAddInPlace(a4, b) {
  a4[0] += b[0], a4[1] += b[1], a4[2] += b[2];
}
function cartesianScale(vector, k2) {
  return [vector[0] * k2, vector[1] * k2, vector[2] * k2];
}
function cartesianNormalizeInPlace(d3) {
  var l = sqrt2(d3[0] * d3[0] + d3[1] * d3[1] + d3[2] * d3[2]);
  d3[0] /= l, d3[1] /= l, d3[2] /= l;
}

// node_modules/d3-geo/src/compose.js
function compose_default(a4, b) {
  function compose4(x3, y3) {
    return x3 = a4(x3, y3), b(x3[0], x3[1]);
  }
  if (a4.invert && b.invert)
    compose4.invert = function(x3, y3) {
      return x3 = b.invert(x3, y3), x3 && a4.invert(x3[0], x3[1]);
    };
  return compose4;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  if (abs2(lambda) > pi3)
    lambda -= Math.round(lambda / tau3) * tau3;
  return [lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau3) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    lambda += deltaLambda;
    if (abs2(lambda) > pi3)
      lambda -= Math.round(lambda / tau3) * tau3;
    return [lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation(lambda, phi2) {
    var cosPhi = cos2(phi2), x3 = cos2(lambda) * cosPhi, y3 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaPhi + x3 * sinDeltaPhi;
    return [
      atan22(y3 * cosDeltaGamma - k2 * sinDeltaGamma, x3 * cosDeltaPhi - z * sinDeltaPhi),
      asin2(k2 * cosDeltaGamma + y3 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi2) {
    var cosPhi = cos2(phi2), x3 = cos2(lambda) * cosPhi, y3 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaGamma - y3 * sinDeltaGamma;
    return [
      atan22(y3 * cosDeltaGamma + z * sinDeltaGamma, x3 * cosDeltaPhi + k2 * sinDeltaPhi),
      asin2(k2 * cosDeltaPhi - x3 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate7) {
  rotate7 = rotateRadians(rotate7[0] * radians, rotate7[1] * radians, rotate7.length > 2 ? rotate7[2] * radians : 0);
  function forward(coordinates) {
    coordinates = rotate7(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate7.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  };
  return forward;
}

// node_modules/d3-geo/src/circle.js
function circleStream(stream, radius, delta, direction3, t02, t12) {
  if (!delta)
    return;
  var cosRadius = cos2(radius), sinRadius = sin2(radius), step2 = direction3 * delta;
  if (t02 == null) {
    t02 = radius + direction3 * tau3;
    t12 = radius - step2 / 2;
  } else {
    t02 = circleRadius(cosRadius, t02);
    t12 = circleRadius(cosRadius, t12);
    if (direction3 > 0 ? t02 < t12 : t02 > t12)
      t02 += direction3 * tau3;
  }
  for (var point7, t = t02; direction3 > 0 ? t > t12 : t < t12; t -= step2) {
    point7 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);
    stream.point(point7[0], point7[1]);
  }
}
function circleRadius(cosRadius, point7) {
  point7 = cartesian2(point7), point7[0] -= cosRadius;
  cartesianNormalizeInPlace(point7);
  var radius = acos2(-point7[1]);
  return ((-point7[2] < 0 ? -radius : radius) + tau3 - epsilon3) % tau3;
}

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line4;
  return {
    point: function(x3, y3, m3) {
      line4.push([x3, y3, m3]);
    },
    lineStart: function() {
      lines.push(line4 = []);
    },
    lineEnd: noop2,
    rejoin: function() {
      if (lines.length > 1)
        lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line4 = null;
      return result;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a4, b) {
  return abs2(a4[0] - b[0]) < epsilon3 && abs2(a4[1] - b[1]) < epsilon3;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point7, points, other, entry) {
  this.x = point7;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate4, stream) {
  var subject = [], clip = [], i, n;
  segments.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0)
      return;
    var n2, p0 = segment[0], p1 = segment[n2], x3;
    if (pointEqual_default(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n2; ++i)
          stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon3;
    }
    subject.push(x3 = new Intersection(p0, segment, null, true));
    clip.push(x3.o = new Intersection(p0, null, x3, false));
    subject.push(x3 = new Intersection(p1, segment, null, false));
    clip.push(x3.o = new Intersection(p1, null, x3, true));
  });
  if (!subject.length)
    return;
  clip.sort(compareIntersection2);
  link2(subject);
  link2(clip);
  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }
  var start = subject[0], points, point7;
  while (1) {
    var current = start, isSubject = true;
    while (current.v)
      if ((current = current.n) === start)
        return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i)
            stream.point((point7 = points[i])[0], point7[1]);
        } else {
          interpolate4(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i)
            stream.point((point7 = points[i])[0], point7[1]);
        } else {
          interpolate4(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link2(array2) {
  if (!(n = array2.length))
    return;
  var n, i = 0, a4 = array2[0], b;
  while (++i < n) {
    a4.n = b = array2[i];
    b.p = a4;
    a4 = b;
  }
  a4.n = b = array2[0];
  b.p = a4;
}

// node_modules/d3-geo/src/polygonContains.js
function longitude(point7) {
  return abs2(point7[0]) <= pi3 ? point7[0] : sign2(point7[0]) * ((abs2(point7[0]) + pi3) % tau3 - pi3);
}
function polygonContains_default(polygon, point7) {
  var lambda = longitude(point7), phi2 = point7[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle4 = 0, winding = 0;
  var sum4 = new Adder();
  if (sinPhi === 1)
    phi2 = halfPi2 + epsilon3;
  else if (sinPhi === -1)
    phi2 = -halfPi2 - epsilon3;
  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m3 = (ring = polygon[i]).length))
      continue;
    var ring, m3, point0 = ring[m3 - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin2(phi0), cosPhi0 = cos2(phi0);
    for (var j = 0; j < m3; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi1), cosPhi1 = cos2(phi1), delta = lambda1 - lambda0, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi3, k2 = sinPhi0 * sinPhi1;
      sum4.add(atan22(k2 * sign3 * sin2(absDelta), cosPhi0 * cosPhi1 + k2 * cos2(absDelta)));
      angle4 += antimeridian ? delta + sign3 * tau3 : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian2(point0), cartesian2(point1));
        cartesianNormalizeInPlace(arc);
        var intersection3 = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection3);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection3[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle4 < -epsilon3 || angle4 < epsilon3 && sum4 < -epsilon22) ^ winding & 1;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate4, start) {
  return function(sink) {
    var line4 = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point7,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point7;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains_default(polygon, start);
        if (segments.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate4, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate4(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate4(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point7(lambda, phi2) {
      if (pointVisible(lambda, phi2))
        sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line4.point(lambda, phi2);
    }
    function lineStart() {
      clip.point = pointLine;
      line4.lineStart();
    }
    function lineEnd() {
      clip.point = point7;
      line4.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m3, segment, point8;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m3 = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m3; ++i)
            sink.point((point8 = segment[i])[0], point8[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a4, b) {
  return ((a4 = a4.x)[0] < 0 ? a4[1] - halfPi2 - epsilon3 : halfPi2 - a4[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi2 - epsilon3 : halfPi2 - b[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi3, -halfPi2]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi3 : -pi3, delta = abs2(lambda1 - lambda0);
      if (abs2(delta - pi3) < epsilon3) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi2 : -halfPi2);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi3) {
        if (abs2(lambda0 - sign0) < epsilon3)
          lambda0 -= sign0 * epsilon3;
        if (abs2(lambda1 - sign1) < epsilon3)
          lambda1 -= sign1 * epsilon3;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin2(lambda0 - lambda1);
  return abs2(sinLambda0Lambda1) > epsilon3 ? atan((sin2(phi0) * (cosPhi1 = cos2(phi1)) * sin2(lambda1) - sin2(phi1) * (cosPhi0 = cos2(phi0)) * sin2(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction3, stream) {
  var phi2;
  if (from == null) {
    phi2 = direction3 * halfPi2;
    stream.point(-pi3, phi2);
    stream.point(0, phi2);
    stream.point(pi3, phi2);
    stream.point(pi3, 0);
    stream.point(pi3, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi3, -phi2);
    stream.point(-pi3, 0);
    stream.point(-pi3, phi2);
  } else if (abs2(from[0] - to[0]) > epsilon3) {
    var lambda = from[0] < to[0] ? pi3 : -pi3;
    phi2 = direction3 * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to[0], to[1]);
  }
}

// node_modules/d3-geo/src/clip/circle.js
function circle_default2(radius) {
  var cr = cos2(radius), delta = 2 * radians, smallRadius = cr > 0, notHemisphere = abs2(cr) > epsilon3;
  function interpolate4(from, to, direction3, stream) {
    circleStream(stream, radius, delta, direction3, from, to);
  }
  function visible(lambda, phi2) {
    return cos2(lambda) * cos2(phi2) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point22, v = visible(lambda, phi2), c5 = smallRadius ? v ? 0 : code(lambda, phi2) : v ? code(lambda + (lambda < 0 ? pi3 : -pi3), phi2) : 0;
        if (!point0 && (v00 = v0 = v))
          stream.lineStart();
        if (v !== v0) {
          point22 = intersect4(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            stream.lineStart();
            point22 = intersect4(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect4(point0, point1);
            stream.point(point22[0], point22[1], 2);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          if (!(c5 & c0) && (t = intersect4(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c5;
      },
      lineEnd: function() {
        if (v0)
          stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect4(a4, b, two) {
    var pa = cartesian2(a4), pb = cartesian2(b);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant3 = n2n2 - n1n2 * n1n2;
    if (!determinant3)
      return !two && a4;
    var c1 = cr * n2n2 / determinant3, c22 = -cr * n1n2 / determinant3, n1xn2 = cartesianCross(n1, n2), A6 = cartesianScale(n1, c1), B4 = cartesianScale(n2, c22);
    cartesianAddInPlace(A6, B4);
    var u = n1xn2, w = cartesianDot(A6, u), uu = cartesianDot(u, u), t22 = w * w - uu * (cartesianDot(A6, A6) - 1);
    if (t22 < 0)
      return;
    var t = sqrt2(t22), q = cartesianScale(u, (-w - t) / uu);
    cartesianAddInPlace(q, A6);
    q = spherical(q);
    if (!two)
      return q;
    var lambda0 = a4[0], lambda1 = b[0], phi0 = a4[1], phi1 = b[1], z;
    if (lambda1 < lambda0)
      z = lambda0, lambda0 = lambda1, lambda1 = z;
    var delta2 = lambda1 - lambda0, polar2 = abs2(delta2 - pi3) < epsilon3, meridian = polar2 || delta2 < epsilon3;
    if (!polar2 && phi1 < phi0)
      z = phi0, phi0 = phi1, phi1 = z;
    if (meridian ? polar2 ? phi0 + phi1 > 0 ^ q[1] < (abs2(q[0] - lambda0) < epsilon3 ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta2 > pi3 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q12 = cartesianScale(u, (-w + t) / uu);
      cartesianAddInPlace(q12, A6);
      return [q, spherical(q12)];
    }
  }
  function code(lambda, phi2) {
    var r = smallRadius ? radius : pi3 - radius, code2 = 0;
    if (lambda < -r)
      code2 |= 1;
    else if (lambda > r)
      code2 |= 2;
    if (phi2 < -r)
      code2 |= 4;
    else if (phi2 > r)
      code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate4, smallRadius ? [0, -radius] : [-pi3, radius - pi3]);
}

// node_modules/d3-geo/src/clip/line.js
function line_default2(a4, b, x05, y05, x12, y12) {
  var ax = a4[0], ay = a4[1], bx = b[0], by = b[1], t02 = 0, t12 = 1, dx = bx - ax, dy = by - ay, r;
  r = x05 - ax;
  if (!dx && r > 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  } else if (dx > 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  } else if (dx > 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  }
  r = y05 - ay;
  if (!dy && r > 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  } else if (dy > 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  } else if (dy > 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  }
  if (t02 > 0)
    a4[0] = ax + t02 * dx, a4[1] = ay + t02 * dy;
  if (t12 < 1)
    b[0] = ax + t12 * dx, b[1] = ay + t12 * dy;
  return true;
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x05, y05, x12, y12) {
  function visible(x3, y3) {
    return x05 <= x3 && x3 <= x12 && y05 <= y3 && y3 <= y12;
  }
  function interpolate4(from, to, direction3, stream) {
    var a4 = 0, a1 = 0;
    if (from == null || (a4 = corner(from, direction3)) !== (a1 = corner(to, direction3)) || comparePoint(from, to) < 0 ^ direction3 > 0) {
      do
        stream.point(a4 === 0 || a4 === 3 ? x05 : x12, a4 > 1 ? y12 : y05);
      while ((a4 = (a4 + direction3 + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p2, direction3) {
    return abs2(p2[0] - x05) < epsilon3 ? direction3 > 0 ? 0 : 3 : abs2(p2[0] - x12) < epsilon3 ? direction3 > 0 ? 2 : 1 : abs2(p2[1] - y05) < epsilon3 ? direction3 > 0 ? 1 : 0 : direction3 > 0 ? 3 : 2;
  }
  function compareIntersection2(a4, b) {
    return comparePoint(a4.x, b.x);
  }
  function comparePoint(a4, b) {
    var ca = corner(a4, 1), cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a4[1] : ca === 1 ? a4[0] - b[0] : ca === 2 ? a4[1] - b[1] : b[0] - a4[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first3, clean;
    var clipStream = {
      point: point7,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point7(x3, y3) {
      if (visible(x3, y3))
        activeStream.point(x3, y3);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring2 = polygon[i], j = 1, m3 = ring2.length, point8 = ring2[0], a0, a1, b0 = point8[0], b1 = point8[1]; j < m3; ++j) {
          a0 = b0, a1 = b1, point8 = ring2[j], b0 = point8[0], b1 = point8[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x05 - a0))
              ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x05 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate4(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments, compareIntersection2, startInside, interpolate4, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon)
        polygon.push(ring = []);
      first3 = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point7;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint(x3, y3) {
      var v = visible(x3, y3);
      if (polygon)
        ring.push([x3, y3]);
      if (first3) {
        x__ = x3, y__ = y3, v__ = v;
        first3 = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x3, y3);
        }
      } else {
        if (v && v_)
          activeStream.point(x3, y3);
        else {
          var a4 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x3 = Math.max(clipMin, Math.min(clipMax, x3)), y3 = Math.max(clipMin, Math.min(clipMax, y3))];
          if (line_default2(a4, b, x05, y05, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a4[0], a4[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v)
              activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x3, y3);
            clean = false;
          }
        }
      }
      x_ = x3, y_ = y3, v_ = v;
    }
    return clipStream;
  };
}

// node_modules/d3-geo/src/graticule.js
function graticuleX(y05, y12, dy) {
  var y3 = range(y05, y12 - epsilon3, dy).concat(y12);
  return function(x3) {
    return y3.map(function(y4) {
      return [x3, y4];
    });
  };
}
function graticuleY(x05, x12, dx) {
  var x3 = range(x05, x12 - epsilon3, dx).concat(x12);
  return function(y3) {
    return x3.map(function(x4) {
      return [x4, y3];
    });
  };
}
function graticule() {
  var x12, x05, X12, X02, y12, y05, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x3, y3, X, Y, precision = 2.5;
  function graticule2() {
    return { type: "MultiLineString", coordinates: lines() };
  }
  function lines() {
    return range(ceil4(X02 / DX) * DX, X12, DX).map(X).concat(range(ceil4(Y02 / DY) * DY, Y12, DY).map(Y)).concat(range(ceil4(x05 / dx) * dx, x12, dx).filter(function(x4) {
      return abs2(x4 % DX) > epsilon3;
    }).map(x3)).concat(range(ceil4(y05 / dy) * dy, y12, dy).filter(function(y4) {
      return abs2(y4 % DY) > epsilon3;
    }).map(y3));
  }
  graticule2.lines = function() {
    return lines().map(function(coordinates) {
      return { type: "LineString", coordinates };
    });
  };
  graticule2.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X02).concat(
          Y(Y12).slice(1),
          X(X12).reverse().slice(1),
          Y(Y02).reverse().slice(1)
        )
      ]
    };
  };
  graticule2.extent = function(_2) {
    if (!arguments.length)
      return graticule2.extentMinor();
    return graticule2.extentMajor(_2).extentMinor(_2);
  };
  graticule2.extentMajor = function(_2) {
    if (!arguments.length)
      return [[X02, Y02], [X12, Y12]];
    X02 = +_2[0][0], X12 = +_2[1][0];
    Y02 = +_2[0][1], Y12 = +_2[1][1];
    if (X02 > X12)
      _2 = X02, X02 = X12, X12 = _2;
    if (Y02 > Y12)
      _2 = Y02, Y02 = Y12, Y12 = _2;
    return graticule2.precision(precision);
  };
  graticule2.extentMinor = function(_2) {
    if (!arguments.length)
      return [[x05, y05], [x12, y12]];
    x05 = +_2[0][0], x12 = +_2[1][0];
    y05 = +_2[0][1], y12 = +_2[1][1];
    if (x05 > x12)
      _2 = x05, x05 = x12, x12 = _2;
    if (y05 > y12)
      _2 = y05, y05 = y12, y12 = _2;
    return graticule2.precision(precision);
  };
  graticule2.step = function(_2) {
    if (!arguments.length)
      return graticule2.stepMinor();
    return graticule2.stepMajor(_2).stepMinor(_2);
  };
  graticule2.stepMajor = function(_2) {
    if (!arguments.length)
      return [DX, DY];
    DX = +_2[0], DY = +_2[1];
    return graticule2;
  };
  graticule2.stepMinor = function(_2) {
    if (!arguments.length)
      return [dx, dy];
    dx = +_2[0], dy = +_2[1];
    return graticule2;
  };
  graticule2.precision = function(_2) {
    if (!arguments.length)
      return precision;
    precision = +_2;
    x3 = graticuleX(y05, y12, 90);
    y3 = graticuleY(x05, x12, precision);
    X = graticuleX(Y02, Y12, 90);
    Y = graticuleY(X02, X12, precision);
    return graticule2;
  };
  return graticule2.extentMajor([[-180, -90 + epsilon3], [180, 90 - epsilon3]]).extentMinor([[-180, -80 - epsilon3], [180, 80 + epsilon3]]);
}
function graticule10() {
  return graticule()();
}

// node_modules/d3-geo/src/identity.js
var identity_default5 = (x3) => x3;

// node_modules/d3-geo/src/path/area.js
var areaSum2 = new Adder();
var areaRingSum2 = new Adder();
var x00;
var y00;
var x0;
var y0;
var areaStream2 = {
  point: noop2,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: function() {
    areaStream2.lineStart = areaRingStart;
    areaStream2.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop2;
    areaSum2.add(abs2(areaRingSum2));
    areaRingSum2 = new Adder();
  },
  result: function() {
    var area2 = areaSum2 / 2;
    areaSum2 = new Adder();
    return area2;
  }
};
function areaRingStart() {
  areaStream2.point = areaPointFirst;
}
function areaPointFirst(x3, y3) {
  areaStream2.point = areaPoint;
  x00 = x0 = x3, y00 = y0 = y3;
}
function areaPoint(x3, y3) {
  areaRingSum2.add(y0 * x3 - x0 * y3);
  x0 = x3, y0 = y3;
}
function areaRingEnd() {
  areaPoint(x00, y00);
}
var area_default2 = areaStream2;

// node_modules/d3-geo/src/path/bounds.js
var x02 = Infinity;
var y02 = x02;
var x1 = -x02;
var y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: noop2,
  polygonEnd: noop2,
  result: function() {
    var bounds = [[x02, y02], [x1, y1]];
    x1 = y1 = -(y02 = x02 = Infinity);
    return bounds;
  }
};
function boundsPoint(x3, y3) {
  if (x3 < x02)
    x02 = x3;
  if (x3 > x1)
    x1 = x3;
  if (y3 < y02)
    y02 = y3;
  if (y3 > y1)
    y1 = y3;
}
var bounds_default = boundsStream;

// node_modules/d3-geo/src/path/centroid.js
var X0 = 0;
var Y0 = 0;
var Z0 = 0;
var X1 = 0;
var Y1 = 0;
var Z1 = 0;
var X2 = 0;
var Y2 = 0;
var Z2 = 0;
var x002;
var y002;
var x03;
var y03;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid;
  }
};
function centroidPoint(x3, y3) {
  X0 += x3;
  Y0 += y3;
  ++Z0;
}
function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x3, y3) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x03 = x3, y03 = y3);
}
function centroidPointLine(x3, y3) {
  var dx = x3 - x03, dy = y3 - y03, z = sqrt2(dx * dx + dy * dy);
  X1 += z * (x03 + x3) / 2;
  Y1 += z * (y03 + y3) / 2;
  Z1 += z;
  centroidPoint(x03 = x3, y03 = y3);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x3, y3) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x002 = x03 = x3, y002 = y03 = y3);
}
function centroidPointRing(x3, y3) {
  var dx = x3 - x03, dy = y3 - y03, z = sqrt2(dx * dx + dy * dy);
  X1 += z * (x03 + x3) / 2;
  Y1 += z * (y03 + y3) / 2;
  Z1 += z;
  z = y03 * x3 - x03 * y3;
  X2 += z * (x03 + x3);
  Y2 += z * (y03 + y3);
  Z2 += z * 3;
  centroidPoint(x03 = x3, y03 = y3);
}
var centroid_default = centroidStream;

// node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_2) {
    return this._radius = _2, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._context.closePath();
    this._point = NaN;
  },
  point: function(x3, y3) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x3, y3);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x3, y3);
        break;
      }
      default: {
        this._context.moveTo(x3 + this._radius, y3);
        this._context.arc(x3, y3, this._radius, 0, tau3);
        break;
      }
    }
  },
  result: noop2
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum = new Adder();
var lengthRing;
var x003;
var y003;
var x04;
var y04;
var lengthStream = {
  point: noop2,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing)
      lengthPoint(x003, y003);
    lengthStream.point = noop2;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length5 = +lengthSum;
    lengthSum = new Adder();
    return length5;
  }
};
function lengthPointFirst(x3, y3) {
  lengthStream.point = lengthPoint;
  x003 = x04 = x3, y003 = y04 = y3;
}
function lengthPoint(x3, y3) {
  x04 -= x3, y04 -= y3;
  lengthSum.add(sqrt2(x04 * x04 + y04 * y04));
  x04 = x3, y04 = y3;
}
var measure_default = lengthStream;

// node_modules/d3-geo/src/path/string.js
var cacheDigits;
var cacheAppend;
var cacheRadius;
var cacheCircle;
var PathString = class {
  constructor(digits) {
    this._append = digits == null ? append2 : appendRound2(digits);
    this._radius = 4.5;
    this._ = "";
  }
  pointRadius(_2) {
    this._radius = +_2;
    return this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0)
      this._ += "Z";
    this._point = NaN;
  }
  point(x3, y3) {
    switch (this._point) {
      case 0: {
        this._append`M${x3},${y3}`;
        this._point = 1;
        break;
      }
      case 1: {
        this._append`L${x3},${y3}`;
        break;
      }
      default: {
        this._append`M${x3},${y3}`;
        if (this._radius !== cacheRadius || this._append !== cacheAppend) {
          const r = this._radius;
          const s3 = this._;
          this._ = "";
          this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
          cacheRadius = r;
          cacheAppend = this._append;
          cacheCircle = this._;
          this._ = s3;
        }
        this._ += cacheCircle;
        break;
      }
    }
  }
  result() {
    const result = this._;
    this._ = "";
    return result.length ? result : null;
  }
};
function append2(strings) {
  let i = 1;
  this._ += strings[0];
  for (const j = strings.length; i < j; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound2(digits) {
  const d3 = Math.floor(digits);
  if (!(d3 >= 0))
    throw new RangeError(`invalid digits: ${digits}`);
  if (d3 > 15)
    return append2;
  if (d3 !== cacheDigits) {
    const k2 = 10 ** d3;
    cacheDigits = d3;
    cacheAppend = function append3(strings) {
      let i = 1;
      this._ += strings[0];
      for (const j = strings.length; i < j; ++i) {
        this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
      }
    };
  }
  return cacheAppend;
}

// node_modules/d3-geo/src/path/index.js
function path_default2(projection3, context) {
  let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
  function path2(object) {
    if (object) {
      if (typeof pointRadius === "function")
        contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path2.area = function(object) {
    stream_default(object, projectionStream(area_default2));
    return area_default2.result();
  };
  path2.measure = function(object) {
    stream_default(object, projectionStream(measure_default));
    return measure_default.result();
  };
  path2.bounds = function(object) {
    stream_default(object, projectionStream(bounds_default));
    return bounds_default.result();
  };
  path2.centroid = function(object) {
    stream_default(object, projectionStream(centroid_default));
    return centroid_default.result();
  };
  path2.projection = function(_2) {
    if (!arguments.length)
      return projection3;
    projectionStream = _2 == null ? (projection3 = null, identity_default5) : (projection3 = _2).stream;
    return path2;
  };
  path2.context = function(_2) {
    if (!arguments.length)
      return context;
    contextStream = _2 == null ? (context = null, new PathString(digits)) : new PathContext(context = _2);
    if (typeof pointRadius !== "function")
      contextStream.pointRadius(pointRadius);
    return path2;
  };
  path2.pointRadius = function(_2) {
    if (!arguments.length)
      return pointRadius;
    pointRadius = typeof _2 === "function" ? _2 : (contextStream.pointRadius(+_2), +_2);
    return path2;
  };
  path2.digits = function(_2) {
    if (!arguments.length)
      return digits;
    if (_2 == null)
      digits = null;
    else {
      const d3 = Math.floor(_2);
      if (!(d3 >= 0))
        throw new RangeError(`invalid digits: ${_2}`);
      digits = d3;
    }
    if (context === null)
      contextStream = new PathString(digits);
    return path2;
  };
  return path2.projection(projection3).digits(digits).context(context);
}

// node_modules/d3-geo/src/transform.js
function transformer(methods2) {
  return function(stream) {
    var s3 = new TransformStream();
    for (var key in methods2)
      s3[key] = methods2[key];
    s3.stream = stream;
    return s3;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x3, y3) {
    this.stream.point(x3, y3);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/fit.js
function fit(projection3, fitBounds, object) {
  var clip = projection3.clipExtent && projection3.clipExtent();
  projection3.scale(150).translate([0, 0]);
  if (clip != null)
    projection3.clipExtent(null);
  stream_default(object, projection3.stream(bounds_default));
  fitBounds(bounds_default.result());
  if (clip != null)
    projection3.clipExtent(clip);
  return projection3;
}
function fitExtent(projection3, extent2, object) {
  return fit(projection3, function(b) {
    var w = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], k2 = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x3 = +extent2[0][0] + (w - k2 * (b[1][0] + b[0][0])) / 2, y3 = +extent2[0][1] + (h - k2 * (b[1][1] + b[0][1])) / 2;
    projection3.scale(150 * k2).translate([x3, y3]);
  }, object);
}
function fitSize(projection3, size3, object) {
  return fitExtent(projection3, [[0, 0], size3], object);
}
function fitWidth(projection3, width, object) {
  return fit(projection3, function(b) {
    var w = +width, k2 = w / (b[1][0] - b[0][0]), x3 = (w - k2 * (b[1][0] + b[0][0])) / 2, y3 = -k2 * b[0][1];
    projection3.scale(150 * k2).translate([x3, y3]);
  }, object);
}
function fitHeight(projection3, height, object) {
  return fit(projection3, function(b) {
    var h = +height, k2 = h / (b[1][1] - b[0][1]), x3 = -k2 * b[0][0], y3 = (h - k2 * (b[1][1] + b[0][1])) / 2;
    projection3.scale(150 * k2).translate([x3, y3]);
  }, object);
}

// node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos2(30 * radians);
function resample_default(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer({
    point: function(x3, y3) {
      x3 = project(x3, y3);
      this.stream.point(x3[0], x3[1]);
    }
  });
}
function resample(project, delta2) {
  function resampleLineTo(x05, y05, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth, stream) {
    var dx = x12 - x05, dy = y12 - y05, d22 = dx * dx + dy * dy;
    if (d22 > 4 * delta2 && depth--) {
      var a4 = a0 + a1, b = b0 + b1, c5 = c0 + c1, m3 = sqrt2(a4 * a4 + b * b + c5 * c5), phi2 = asin2(c5 /= m3), lambda2 = abs2(abs2(c5) - 1) < epsilon3 || abs2(lambda0 - lambda1) < epsilon3 ? (lambda0 + lambda1) / 2 : atan22(b, a4), p2 = project(lambda2, phi2), x22 = p2[0], y22 = p2[1], dx2 = x22 - x05, dy2 = y22 - y05, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d22 > delta2 || abs2((dx * dx2 + dy * dy2) / d22 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x05, y05, lambda0, a0, b0, c0, x22, y22, lambda2, a4 /= m3, b /= m3, c5, depth, stream);
        stream.point(x22, y22);
        resampleLineTo(x22, y22, lambda2, a4, b, c5, x12, y12, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x004, y004, a00, b00, c00, lambda0, x05, y05, a0, b0, c0;
    var resampleStream = {
      point: point7,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point7(x3, y3) {
      x3 = project(x3, y3);
      stream.point(x3[0], x3[1]);
    }
    function lineStart() {
      x05 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi2) {
      var c5 = cartesian2([lambda, phi2]), p2 = project(lambda, phi2);
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x05 = p2[0], y05 = p2[1], lambda0 = lambda, a0 = c5[0], b0 = c5[1], c0 = c5[2], maxDepth, stream);
      stream.point(x05, y05);
    }
    function lineEnd() {
      resampleStream.point = point7;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint(lambda00 = lambda, phi2), x004 = x05, y004 = y05, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x004, y004, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer({
  point: function(x3, y3) {
    this.stream.point(x3 * radians, y3 * radians);
  }
});
function transformRotate(rotate7) {
  return transformer({
    point: function(x3, y3) {
      var r = rotate7(x3, y3);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function scaleTranslate(k2, dx, dy, sx, sy) {
  function transform2(x3, y3) {
    x3 *= sx;
    y3 *= sy;
    return [dx + k2 * x3, dy - k2 * y3];
  }
  transform2.invert = function(x3, y3) {
    return [(x3 - dx) / k2 * sx, (dy - y3) / k2 * sy];
  };
  return transform2;
}
function scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {
  if (!alpha)
    return scaleTranslate(k2, dx, dy, sx, sy);
  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a4 = cosAlpha * k2, b = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;
  function transform2(x3, y3) {
    x3 *= sx;
    y3 *= sy;
    return [a4 * x3 - b * y3 + dx, dy - b * x3 - a4 * y3];
  }
  transform2.invert = function(x3, y3) {
    return [sx * (ai * x3 - bi * y3 + ci), sy * (fi - bi * x3 - ai * y3)];
  };
  return transform2;
}
function projection2(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k2 = 150, x3 = 480, y3 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate7, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x05 = null, y05, x12, y12, postclip = identity_default5, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache2, cacheStream;
  function projection3(point7) {
    return projectRotateTransform(point7[0] * radians, point7[1] * radians);
  }
  function invert5(point7) {
    point7 = projectRotateTransform.invert(point7[0], point7[1]);
    return point7 && [point7[0] * degrees, point7[1] * degrees];
  }
  projection3.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = transformRadians(transformRotate(rotate7)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection3.preclip = function(_2) {
    return arguments.length ? (preclip = _2, theta = void 0, reset()) : preclip;
  };
  projection3.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x05 = y05 = x12 = y12 = null, reset()) : postclip;
  };
  projection3.clipAngle = function(_2) {
    return arguments.length ? (preclip = +_2 ? circle_default2(theta = _2 * radians) : (theta = null, antimeridian_default), reset()) : theta * degrees;
  };
  projection3.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x05 = y05 = x12 = y12 = null, identity_default5) : clipRectangle(x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  projection3.scale = function(_2) {
    return arguments.length ? (k2 = +_2, recenter()) : k2;
  };
  projection3.translate = function(_2) {
    return arguments.length ? (x3 = +_2[0], y3 = +_2[1], recenter()) : [x3, y3];
  };
  projection3.center = function(_2) {
    return arguments.length ? (lambda = _2[0] % 360 * radians, phi2 = _2[1] % 360 * radians, recenter()) : [lambda * degrees, phi2 * degrees];
  };
  projection3.rotate = function(_2) {
    return arguments.length ? (deltaLambda = _2[0] % 360 * radians, deltaPhi = _2[1] % 360 * radians, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };
  projection3.angle = function(_2) {
    return arguments.length ? (alpha = _2 % 360 * radians, recenter()) : alpha * degrees;
  };
  projection3.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, recenter()) : sx < 0;
  };
  projection3.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, recenter()) : sy < 0;
  };
  projection3.precision = function(_2) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _2 * _2), reset()) : sqrt2(delta2);
  };
  projection3.fitExtent = function(extent2, object) {
    return fitExtent(projection3, extent2, object);
  };
  projection3.fitSize = function(size3, object) {
    return fitSize(projection3, size3, object);
  };
  projection3.fitWidth = function(width, object) {
    return fitWidth(projection3, width, object);
  };
  projection3.fitHeight = function(height, object) {
    return fitHeight(projection3, height, object);
  };
  function recenter() {
    var center2 = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi2)), transform2 = scaleTranslateRotate(k2, x3 - center2[0], y3 - center2[1], sx, sy, alpha);
    rotate7 = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project, transform2);
    projectRotateTransform = compose_default(rotate7, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset();
  }
  function reset() {
    cache2 = cacheStream = null;
    return projection3;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection3.invert = project.invert && invert5;
    return recenter();
  };
}

// node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi0 = 0, phi1 = pi3 / 3, m3 = projectionMutator(projectAt), p2 = m3(phi0, phi1);
  p2.parallels = function(_2) {
    return arguments.length ? m3(phi0 = _2[0] * radians, phi1 = _2[1] * radians) : [phi0 * degrees, phi1 * degrees];
  };
  return p2;
}

// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos2(phi0);
  function forward(lambda, phi2) {
    return [lambda * cosPhi0, sin2(phi2) / cosPhi0];
  }
  forward.invert = function(x3, y3) {
    return [x3 / cosPhi0, asin2(y3 * cosPhi0)];
  };
  return forward;
}

// node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y05, y12) {
  var sy0 = sin2(y05), n = (sy0 + sin2(y12)) / 2;
  if (abs2(n) < epsilon3)
    return cylindricalEqualAreaRaw(y05);
  var c5 = 1 + sy0 * (2 * n - sy0), r0 = sqrt2(c5) / n;
  function project(x3, y3) {
    var r = sqrt2(c5 - 2 * n * sin2(y3)) / n;
    return [r * sin2(x3 *= n), r0 - r * cos2(x3)];
  }
  project.invert = function(x3, y3) {
    var r0y = r0 - y3, l = atan22(x3, abs2(r0y)) * sign2(r0y);
    if (r0y * n < 0)
      l -= pi3 * sign2(x3) * sign2(r0y);
    return [l / n, asin2((c5 - (x3 * x3 + r0y * r0y) * n * n) / (2 * n))];
  };
  return project;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x3, y3) {
      var i = -1;
      while (++i < n)
        streams[i].point(x3, y3);
    },
    sphere: function() {
      var i = -1;
      while (++i < n)
        streams[i].sphere();
    },
    lineStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineStart();
    },
    lineEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineEnd();
    },
    polygonStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonStart();
    },
    polygonEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache2, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point7, pointStream = { point: function(x3, y3) {
    point7 = [x3, y3];
  } };
  function albersUsa(coordinates) {
    var x3 = coordinates[0], y3 = coordinates[1];
    return point7 = null, (lower48Point.point(x3, y3), point7) || (alaskaPoint.point(x3, y3), point7) || (hawaiiPoint.point(x3, y3), point7);
  }
  albersUsa.invert = function(coordinates) {
    var k2 = lower48.scale(), t = lower48.translate(), x3 = (coordinates[0] - t[0]) / k2, y3 = (coordinates[1] - t[1]) / k2;
    return (y3 >= 0.12 && y3 < 0.234 && x3 >= -0.425 && x3 < -0.214 ? alaska : y3 >= 0.166 && y3 < 0.234 && x3 >= -0.214 && x3 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_2) {
    if (!arguments.length)
      return lower48.precision();
    lower48.precision(_2), alaska.precision(_2), hawaii.precision(_2);
    return reset();
  };
  albersUsa.scale = function(_2) {
    if (!arguments.length)
      return lower48.scale();
    lower48.scale(_2), alaska.scale(_2 * 0.35), hawaii.scale(_2);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_2) {
    if (!arguments.length)
      return lower48.translate();
    var k2 = lower48.scale(), x3 = +_2[0], y3 = +_2[1];
    lower48Point = lower48.translate(_2).clipExtent([[x3 - 0.455 * k2, y3 - 0.238 * k2], [x3 + 0.455 * k2, y3 + 0.238 * k2]]).stream(pointStream);
    alaskaPoint = alaska.translate([x3 - 0.307 * k2, y3 + 0.201 * k2]).clipExtent([[x3 - 0.425 * k2 + epsilon3, y3 + 0.12 * k2 + epsilon3], [x3 - 0.214 * k2 - epsilon3, y3 + 0.234 * k2 - epsilon3]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x3 - 0.205 * k2, y3 + 0.212 * k2]).clipExtent([[x3 - 0.214 * k2 + epsilon3, y3 + 0.166 * k2 + epsilon3], [x3 - 0.115 * k2 - epsilon3, y3 + 0.234 * k2 - epsilon3]]).stream(pointStream);
    return reset();
  };
  albersUsa.fitExtent = function(extent2, object) {
    return fitExtent(albersUsa, extent2, object);
  };
  albersUsa.fitSize = function(size3, object) {
    return fitSize(albersUsa, size3, object);
  };
  albersUsa.fitWidth = function(width, object) {
    return fitWidth(albersUsa, width, object);
  };
  albersUsa.fitHeight = function(height, object) {
    return fitHeight(albersUsa, height, object);
  };
  function reset() {
    cache2 = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale11) {
  return function(x3, y3) {
    var cx = cos2(x3), cy = cos2(y3), k2 = scale11(cx * cy);
    if (k2 === Infinity)
      return [2, 0];
    return [
      k2 * cy * sin2(x3),
      k2 * sin2(y3)
    ];
  };
}
function azimuthalInvert(angle4) {
  return function(x3, y3) {
    var z = sqrt2(x3 * x3 + y3 * y3), c5 = angle4(z), sc = sin2(c5), cc = cos2(c5);
    return [
      atan22(x3 * sc, z * cc),
      asin2(z && y3 * sc / z)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt2(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin2(z / 2);
});
function azimuthalEqualArea_default() {
  return projection2(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c5) {
  return (c5 = acos2(c5)) && c5 / sin2(c5);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});
function azimuthalEquidistant_default() {
  return projection2(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log(tan((halfPi2 + phi2) / 2))];
}
mercatorRaw.invert = function(x3, y3) {
  return [x3, 2 * atan(exp2(y3)) - halfPi2];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau3);
}
function mercatorProjection(project) {
  var m3 = projection2(project), center2 = m3.center, scale11 = m3.scale, translate6 = m3.translate, clipExtent = m3.clipExtent, x05 = null, y05, x12, y12;
  m3.scale = function(_2) {
    return arguments.length ? (scale11(_2), reclip()) : scale11();
  };
  m3.translate = function(_2) {
    return arguments.length ? (translate6(_2), reclip()) : translate6();
  };
  m3.center = function(_2) {
    return arguments.length ? (center2(_2), reclip()) : center2();
  };
  m3.clipExtent = function(_2) {
    return arguments.length ? (_2 == null ? x05 = y05 = x12 = y12 = null : (x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reclip()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  function reclip() {
    var k2 = pi3 * scale11(), t = m3(rotation_default(m3.rotate()).invert([0, 0]));
    return clipExtent(x05 == null ? [[t[0] - k2, t[1] - k2], [t[0] + k2, t[1] + k2]] : project === mercatorRaw ? [[Math.max(t[0] - k2, x05), y05], [Math.min(t[0] + k2, x12), y12]] : [[x05, Math.max(t[1] - k2, y05)], [x12, Math.min(t[1] + k2, y12)]]);
  }
  return reclip();
}

// node_modules/d3-geo/src/projection/conicConformal.js
function tany(y3) {
  return tan((halfPi2 + y3) / 2);
}
function conicConformalRaw(y05, y12) {
  var cy0 = cos2(y05), n = y05 === y12 ? sin2(y05) : log(cy0 / cos2(y12)) / log(tany(y12) / tany(y05)), f = cy0 * pow2(tany(y05), n) / n;
  if (!n)
    return mercatorRaw;
  function project(x3, y3) {
    if (f > 0) {
      if (y3 < -halfPi2 + epsilon3)
        y3 = -halfPi2 + epsilon3;
    } else {
      if (y3 > halfPi2 - epsilon3)
        y3 = halfPi2 - epsilon3;
    }
    var r = f / pow2(tany(y3), n);
    return [r * sin2(n * x3), f - r * cos2(n * x3)];
  }
  project.invert = function(x3, y3) {
    var fy = f - y3, r = sign2(n) * sqrt2(x3 * x3 + fy * fy), l = atan22(x3, abs2(fy)) * sign2(fy);
    if (fy * n < 0)
      l -= pi3 * sign2(x3) * sign2(fy);
    return [l / n, 2 * atan(pow2(f / r, 1 / n)) - halfPi2];
  };
  return project;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection2(equirectangularRaw).scale(152.63);
}

// node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y05, y12) {
  var cy0 = cos2(y05), n = y05 === y12 ? sin2(y05) : (cy0 - cos2(y12)) / (y12 - y05), g = cy0 / n + y05;
  if (abs2(n) < epsilon3)
    return equirectangularRaw;
  function project(x3, y3) {
    var gy = g - y3, nx = n * x3;
    return [gy * sin2(nx), g - gy * cos2(nx)];
  }
  project.invert = function(x3, y3) {
    var gy = g - y3, l = atan22(x3, abs2(gy)) * sign2(gy);
    if (gy * n < 0)
      l -= pi3 * sign2(x3) * sign2(gy);
    return [l / n, g - sign2(n) * sqrt2(x3 * x3 + gy * gy)];
  };
  return project;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A22 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = sqrt2(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l = asin2(M * sin2(phi2)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos2(l) / (M * (A1 + 3 * A22 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A22 * l2 + l6 * (A3 + A4 * l2))
  ];
}
equalEarthRaw.invert = function(x3, y3) {
  var l = y3, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A22 * l2 + l6 * (A3 + A4 * l2)) - y3;
    fpy = A1 + 3 * A22 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs2(delta) < epsilon22)
      break;
  }
  return [
    M * x3 * (A1 + 3 * A22 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),
    asin2(sin2(l) / M)
  ];
};
function equalEarth_default() {
  return projection2(equalEarthRaw).scale(177.158);
}

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x3, y3) {
  var cy = cos2(y3), k2 = cos2(x3) * cy;
  return [cy * sin2(x3) / k2, sin2(y3) / k2];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection2(gnomonicRaw).scale(144.049).clipAngle(60);
}

// node_modules/d3-geo/src/projection/identity.js
function identity_default6() {
  var k2 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x05 = null, y05, x12, y12, kx2 = 1, ky2 = 1, transform2 = transformer({
    point: function(x3, y3) {
      var p2 = projection3([x3, y3]);
      this.stream.point(p2[0], p2[1]);
    }
  }), postclip = identity_default5, cache2, cacheStream;
  function reset() {
    kx2 = k2 * sx;
    ky2 = k2 * sy;
    cache2 = cacheStream = null;
    return projection3;
  }
  function projection3(p2) {
    var x3 = p2[0] * kx2, y3 = p2[1] * ky2;
    if (alpha) {
      var t = y3 * ca - x3 * sa;
      x3 = x3 * ca + y3 * sa;
      y3 = t;
    }
    return [x3 + tx, y3 + ty];
  }
  projection3.invert = function(p2) {
    var x3 = p2[0] - tx, y3 = p2[1] - ty;
    if (alpha) {
      var t = y3 * ca + x3 * sa;
      x3 = x3 * ca - y3 * sa;
      y3 = t;
    }
    return [x3 / kx2, y3 / ky2];
  };
  projection3.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = transform2(postclip(cacheStream = stream));
  };
  projection3.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x05 = y05 = x12 = y12 = null, reset()) : postclip;
  };
  projection3.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x05 = y05 = x12 = y12 = null, identity_default5) : clipRectangle(x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  projection3.scale = function(_2) {
    return arguments.length ? (k2 = +_2, reset()) : k2;
  };
  projection3.translate = function(_2) {
    return arguments.length ? (tx = +_2[0], ty = +_2[1], reset()) : [tx, ty];
  };
  projection3.angle = function(_2) {
    return arguments.length ? (alpha = _2 % 360 * radians, sa = sin2(alpha), ca = cos2(alpha), reset()) : alpha * degrees;
  };
  projection3.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, reset()) : sx < 0;
  };
  projection3.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, reset()) : sy < 0;
  };
  projection3.fitExtent = function(extent2, object) {
    return fitExtent(projection3, extent2, object);
  };
  projection3.fitSize = function(size3, object) {
    return fitSize(projection3, size3, object);
  };
  projection3.fitWidth = function(width, object) {
    return fitWidth(projection3, width, object);
  };
  projection3.fitHeight = function(height, object) {
    return fitHeight(projection3, height, object);
  };
  return projection3;
}

// node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x3, y3) {
  var phi2 = y3, i = 25, delta;
  do {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y3) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
  } while (abs2(delta) > epsilon3 && --i > 0);
  return [
    x3 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
    phi2
  ];
};
function naturalEarth1_default() {
  return projection2(naturalEarth1Raw).scale(175.295);
}

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x3, y3) {
  return [cos2(y3) * sin2(x3), sin2(y3)];
}
orthographicRaw.invert = azimuthalInvert(asin2);
function orthographic_default() {
  return projection2(orthographicRaw).scale(249.5).clipAngle(90 + epsilon3);
}

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x3, y3) {
  var cy = cos2(y3), k2 = 1 + cos2(x3) * cy;
  return [cy * sin2(x3) / k2, sin2(y3) / k2];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});
function stereographic_default() {
  return projection2(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log(tan((halfPi2 + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x3, y3) {
  return [-y3, 2 * atan(exp2(x3)) - halfPi2];
};
function transverseMercator_default() {
  var m3 = mercatorProjection(transverseMercatorRaw), center2 = m3.center, rotate7 = m3.rotate;
  m3.center = function(_2) {
    return arguments.length ? center2([-_2[1], _2[0]]) : (_2 = center2(), [_2[1], -_2[0]]);
  };
  m3.rotate = function(_2) {
    return arguments.length ? rotate7([_2[0], _2[1], _2.length > 2 ? _2[2] + 90 : 90]) : (_2 = rotate7(), [_2[0], _2[1], _2[2] - 90]);
  };
  return rotate7([0, 0, 90]).scale(159.155);
}

// node_modules/@antv/g2/esm/composition/d3Projection.js
var d3Projection_exports = {};
__export(d3Projection_exports, {
  geoAlbers: () => albers_default,
  geoAlbersUsa: () => albersUsa_default,
  geoAzimuthalEqualArea: () => azimuthalEqualArea_default,
  geoAzimuthalEqualAreaRaw: () => azimuthalEqualAreaRaw,
  geoAzimuthalEquidistant: () => azimuthalEquidistant_default,
  geoAzimuthalEquidistantRaw: () => azimuthalEquidistantRaw,
  geoConicConformal: () => conicConformal_default,
  geoConicConformalRaw: () => conicConformalRaw,
  geoConicEqualArea: () => conicEqualArea_default,
  geoConicEqualAreaRaw: () => conicEqualAreaRaw,
  geoConicEquidistant: () => conicEquidistant_default,
  geoConicEquidistantRaw: () => conicEquidistantRaw,
  geoEqualEarth: () => equalEarth_default,
  geoEqualEarthRaw: () => equalEarthRaw,
  geoEquirectangular: () => equirectangular_default,
  geoEquirectangularRaw: () => equirectangularRaw,
  geoGnomonic: () => gnomonic_default,
  geoGnomonicRaw: () => gnomonicRaw,
  geoIdentity: () => identity_default6,
  geoMercator: () => mercator_default,
  geoMercatorRaw: () => mercatorRaw,
  geoNaturalEarth1: () => naturalEarth1_default,
  geoNaturalEarth1Raw: () => naturalEarth1Raw,
  geoOrthographic: () => orthographic_default,
  geoOrthographicRaw: () => orthographicRaw,
  geoProjection: () => projection2,
  geoProjectionMutator: () => projectionMutator,
  geoStereographic: () => stereographic_default,
  geoStereographicRaw: () => stereographicRaw,
  geoTransverseMercator: () => transverseMercator_default,
  geoTransverseMercatorRaw: () => transverseMercatorRaw
});

// node_modules/@antv/g2/esm/composition/geoView.js
var __rest70 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function normalizeProjection(type) {
  if (typeof type === "function")
    return type;
  const name2 = `geo${upper_first_default(type)}`;
  const projection3 = d3Projection_exports[name2];
  if (!projection3)
    throw new Error(`Unknown coordinate: ${type}`);
  return projection3;
}
function mergeGeoJSON(gjs) {
  return {
    type: "FeatureCollection",
    features: gjs.flatMap((gj) => normalizeGeoJSON(gj).features)
  };
}
function normalizeGeoJSON(gj) {
  const types = {
    Point: "geometry",
    MultiPoint: "geometry",
    LineString: "geometry",
    MultiLineString: "geometry",
    Polygon: "geometry",
    MultiPolygon: "geometry",
    GeometryCollection: "geometry",
    Feature: "feature",
    FeatureCollection: "featureCollection"
  };
  if (!gj || !gj.type)
    return null;
  const type = types[gj.type];
  if (!type)
    return null;
  if (type === "geometry") {
    return {
      type: "FeatureCollection",
      features: [
        {
          type: "Feature",
          properties: {},
          geometry: gj
        }
      ]
    };
  } else if (type === "feature") {
    return {
      type: "FeatureCollection",
      features: [gj]
    };
  } else if (type === "featureCollection") {
    return gj;
  }
}
function setProjectionOptions(projection3, options) {
  var _a2;
  for (const [key, value2] of Object.entries(options)) {
    (_a2 = projection3[key]) === null || _a2 === void 0 ? void 0 : _a2.call(projection3, value2);
  }
}
function setProjectionSize(projection3, nodes, layout, options) {
  const defaultOutline = () => {
    const geoNodes = nodes.filter(isGeoPath);
    const sphere = geoNodes.find((d3) => d3.sphere);
    if (sphere)
      return { type: "Sphere" };
    return mergeGeoJSON(geoNodes.filter((d3) => !d3.sphere).flatMap((d3) => d3.data.value));
  };
  const { outline = defaultOutline() } = options;
  const { size: size3 = "fitExtent" } = options;
  if (size3 === "fitExtent") {
    return setFitExtent(projection3, outline, layout);
  } else if (size3 === "fitWidth") {
    return setFitWidth(projection3, outline, layout);
  }
}
function setFitExtent(projection3, object, layout) {
  const { x: x3, y: y3, width, height } = layout;
  projection3.fitExtent([
    [x3, y3],
    [width, height]
  ], object);
}
function setFitWidth(projection3, object, layout) {
  const { width, height } = layout;
  const [[x05, y05], [x12, y12]] = path_default2(projection3.fitWidth(width, object)).bounds(object);
  const dy = Math.ceil(y12 - y05);
  const l = Math.min(Math.ceil(x12 - x05), dy);
  const s3 = projection3.scale() * (l - 1) / l;
  const [tx, ty] = projection3.translate();
  const t = ty + (height - dy) / 2;
  projection3.scale(s3).translate([tx, t]).precision(0.2);
}
function normalizeDataSource(node) {
  const { data: data2 } = node;
  if (Array.isArray(data2))
    return Object.assign(Object.assign({}, node), { data: { value: data2 } });
  const { type } = data2;
  if (type === "graticule10") {
    return Object.assign(Object.assign({}, node), { data: { value: [graticule10()] } });
  } else if (type === "sphere") {
    return Object.assign(Object.assign({}, node), { sphere: true, data: { value: [{ type: "Sphere" }] } });
  }
  return node;
}
function isGeoPath(d3) {
  return d3.type === "geoPath";
}
var GeoView = () => {
  return (options) => {
    const { children, coordinate: projection3 = {} } = options;
    if (!Array.isArray(children))
      return [];
    const { type = "equalEarth" } = projection3, projectionOptions = __rest70(projection3, ["type"]);
    const createProjection = normalizeProjection(type);
    const nodes = children.map(normalizeDataSource);
    let path2;
    function Geo() {
      return [
        [
          "custom",
          (x3, y3, width, height) => {
            const visual = createProjection();
            const layout = { x: x3, y: y3, width, height };
            setProjectionSize(visual, nodes, layout, projectionOptions);
            setProjectionOptions(visual, projectionOptions);
            path2 = path_default2(visual);
            const scaleX2 = new Linear({
              domain: [x3, x3 + width]
            });
            const scaleY2 = new Linear({
              domain: [y3, y3 + height]
            });
            const normalize10 = (point7) => {
              const visualPoint = visual(point7);
              if (!visualPoint)
                return [null, null];
              const [vx, vy] = visualPoint;
              return [scaleX2.map(vx), scaleY2.map(vy)];
            };
            const normalizeInvert = (point7) => {
              if (!point7)
                return null;
              const [px2, py] = point7;
              const visualPoint = [scaleX2.invert(px2), scaleY2.invert(py)];
              return visual.invert(visualPoint);
            };
            return {
              transform: (point7) => normalize10(point7),
              untransform: (point7) => normalizeInvert(point7)
            };
          }
        ]
      ];
    }
    function GeoPath2(options2) {
      const { style, tooltip: tooltip2 = {} } = options2;
      return Object.assign(Object.assign({}, options2), { type: "path", tooltip: maybeTooltip(tooltip2, {
        title: "id",
        items: [{ channel: "color" }]
      }), style: Object.assign(Object.assign({}, style), { d: (d3) => path2(d3) || [] }) });
    }
    const t = (d3) => isGeoPath(d3) ? GeoPath2(d3) : d3;
    return [
      Object.assign(Object.assign({}, options), { type: "view", scale: {
        x: { type: "identity" },
        y: { type: "identity" }
      }, axis: false, coordinate: { type: Geo }, children: nodes.flatMap(t) })
    ];
  };
};
GeoView.props = {};

// node_modules/@antv/g2/esm/interaction/event.js
function dataOf(element, view) {
  const { __data__: datum } = element;
  const { markKey, index: index3, seriesIndex } = datum;
  const { markState } = view;
  const selectedMark = Array.from(markState.keys()).find((mark2) => mark2.key === markKey);
  if (!selectedMark)
    return;
  if (seriesIndex) {
    return seriesIndex.map((i) => selectedMark.data[i]);
  }
  return selectedMark.data[index3];
}
function maybeComponentRoot(node) {
  return maybeRoot(node, (node2) => node2.className === "component");
}
function maybeElementRoot(node) {
  return maybeRoot(node, (node2) => node2.className === "element");
}
function maybeLabelRoot(node) {
  return maybeRoot(node, (node2) => node2.className === "label");
}
function bubblesEvent(eventType, view, emitter, predicate = (event) => true) {
  return (e) => {
    if (!predicate(e))
      return;
    emitter.emit(`plot:${eventType}`, e);
    const { target } = e;
    if (!target)
      return;
    const { className: className2 } = target;
    if (className2 === "plot")
      return;
    const elementRoot = maybeElementRoot(target);
    const componentRoot = maybeComponentRoot(target);
    const babelRoot = maybeLabelRoot(target);
    const root2 = elementRoot || componentRoot || babelRoot;
    if (!root2)
      return;
    const { className: elementType, markType } = root2;
    const e1 = Object.assign(Object.assign({}, e), { nativeEvent: true });
    if (elementType === "element") {
      e1["data"] = { data: dataOf(root2, view) };
      emitter.emit(`element:${eventType}`, e1);
      emitter.emit(`${markType}:${eventType}`, e1);
    } else if (elementType === "label") {
      e1["data"] = { data: root2.attributes.datum };
      emitter.emit(`label:${eventType}`, e1);
      emitter.emit(`${className2}:${eventType}`, e1);
    } else {
      emitter.emit(`component:${eventType}`, e1);
      emitter.emit(`${className2}:${eventType}`, e1);
    }
  };
}
function Event2() {
  return (context, _2, emitter) => {
    const { container, view } = context;
    const click = bubblesEvent(ChartEvent.CLICK, view, emitter, (e) => e.detail === 1);
    const dblclick2 = bubblesEvent(ChartEvent.DBLCLICK, view, emitter, (e) => e.detail === 2);
    const pointertap = bubblesEvent(ChartEvent.POINTER_TAP, view, emitter);
    const pointerdown = bubblesEvent(ChartEvent.POINTER_DOWN, view, emitter);
    const pointerup = bubblesEvent(ChartEvent.POINTER_UP, view, emitter);
    const pointerover = bubblesEvent(ChartEvent.POINTER_OVER, view, emitter);
    const pointerout = bubblesEvent(ChartEvent.POINTER_OUT, view, emitter);
    const pointermove = bubblesEvent(ChartEvent.POINTER_MOVE, view, emitter);
    const pointerenter = bubblesEvent(ChartEvent.POINTER_ENTER, view, emitter);
    const pointerleave = bubblesEvent(ChartEvent.POINTER_LEAVE, view, emitter);
    const pointerupoutside = bubblesEvent(ChartEvent.POINTER_UPOUTSIDE, view, emitter);
    const dragstart = bubblesEvent(ChartEvent.DRAG_START, view, emitter);
    const drag = bubblesEvent(ChartEvent.DRAG, view, emitter);
    const dragend = bubblesEvent(ChartEvent.DRAG_END, view, emitter);
    const dragenter = bubblesEvent(ChartEvent.DRAG_ENTER, view, emitter);
    const dragleave = bubblesEvent(ChartEvent.DRAG_LEAVE, view, emitter);
    const dragover = bubblesEvent(ChartEvent.DRAG_OVER, view, emitter);
    const drop = bubblesEvent(ChartEvent.DROP, view, emitter);
    container.addEventListener("click", click);
    container.addEventListener("click", dblclick2);
    container.addEventListener("pointertap", pointertap);
    container.addEventListener("pointerdown", pointerdown);
    container.addEventListener("pointerup", pointerup);
    container.addEventListener("pointerover", pointerover);
    container.addEventListener("pointerout", pointerout);
    container.addEventListener("pointermove", pointermove);
    container.addEventListener("pointerenter", pointerenter);
    container.addEventListener("pointerleave", pointerleave);
    container.addEventListener("pointerupoutside", pointerupoutside);
    container.addEventListener("dragstart", dragstart);
    container.addEventListener("drag", drag);
    container.addEventListener("dragend", dragend);
    container.addEventListener("dragenter", dragenter);
    container.addEventListener("dragleave", dragleave);
    container.addEventListener("dragover", dragover);
    container.addEventListener("drop", drop);
    return () => {
      container.removeEventListener("click", click);
      container.removeEventListener("click", dblclick2);
      container.removeEventListener("pointertap", pointertap);
      container.removeEventListener("pointerdown", pointerdown);
      container.removeEventListener("pointerup", pointerup);
      container.removeEventListener("pointerover", pointerover);
      container.removeEventListener("pointerout", pointerout);
      container.removeEventListener("pointermove", pointermove);
      container.removeEventListener("pointerenter", pointerenter);
      container.removeEventListener("pointerleave", pointerleave);
      container.removeEventListener("pointerupoutside", pointerupoutside);
      container.removeEventListener("dragstart", dragstart);
      container.removeEventListener("drag", drag);
      container.removeEventListener("dragend", dragend);
      container.removeEventListener("dragenter", dragenter);
      container.removeEventListener("dragleave", dragleave);
      container.removeEventListener("dragover", dragover);
      container.removeEventListener("drop", drop);
    };
  };
}
Event2.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/lib/builtinlib.js
function builtinlib() {
  return {
    "component.axisRadar": AxisRadar,
    "component.axisLinear": LinearAxis,
    "component.axisArc": ArcAxis,
    "component.legendContinuousBlock": LegendContinuousBlock,
    "component.legendContinuousBlockSize": LegendContinuousBlockSize,
    "component.legendContinuousSize": LegendContinuousSize,
    "interaction.event": Event2,
    "composition.mark": Mark,
    "composition.view": View,
    "shape.label.label": Label
  };
}

// node_modules/@antv/g2/esm/runtime/library.js
var __rest71 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function useLibrary(namespace, publicLibrary) {
  const library3 = Object.assign(Object.assign({}, builtinlib()), publicLibrary);
  const create8 = (type) => {
    if (typeof type !== "string")
      return type;
    const key = `${namespace}.${type}`;
    return library3[key] || error(`Unknown Component: ${key}`);
  };
  const use = (options, context) => {
    const { type } = options, rest = __rest71(options, ["type"]);
    if (!type)
      error(`Plot type is required!`);
    const currentLibrary = create8(type);
    return currentLibrary === null || currentLibrary === void 0 ? void 0 : currentLibrary(rest, context);
  };
  return [use, create8];
}
function documentOf(library3) {
  const { canvas, group: group3 } = library3;
  return (canvas === null || canvas === void 0 ? void 0 : canvas.document) || (group3 === null || group3 === void 0 ? void 0 : group3.ownerDocument) || error(`Cannot find library document`);
}

// node_modules/@antv/g2/esm/runtime/coordinate.js
var __rest72 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function createCoordinate(layout, partialOptions, library3) {
  const [useCoordinate] = useLibrary("coordinate", library3);
  const { innerHeight, innerWidth, insetLeft, insetTop, insetRight, insetBottom } = layout;
  const { coordinates: partialTransform = [] } = partialOptions;
  const transform2 = inferCoordinate(partialTransform);
  const isCartesian3D = transform2[0].type === "cartesian3D";
  const options = Object.assign(Object.assign({}, layout), { x: insetLeft, y: insetTop, width: innerWidth - insetLeft - insetRight, height: innerHeight - insetBottom - insetTop, transformations: transform2.flatMap(useCoordinate) });
  const coordinate = isCartesian3D ? (
    // @ts-ignore
    new Coordinate3D(options)
  ) : new Coordinate(options);
  return coordinate;
}
function coordinate2Transform(node, library3) {
  const { coordinate = {}, coordinates } = node, rest = __rest72(node, ["coordinate", "coordinates"]);
  if (coordinates)
    return node;
  const { type, transform: transform2 = [] } = coordinate, options = __rest72(coordinate, ["type", "transform"]);
  if (!type)
    return Object.assign(Object.assign({}, rest), { coordinates: transform2 });
  const [, createCoordinate2] = useLibrary("coordinate", library3);
  const { transform: isTransform = false } = createCoordinate2(type).props || {};
  if (isTransform) {
    throw new Error(`Unknown coordinate: ${type}.`);
  }
  return Object.assign(Object.assign({}, rest), { coordinates: [Object.assign({ type }, options), ...transform2] });
}
function coordOf(coordinates, type) {
  return coordinates.filter((d3) => d3.type === type);
}
function isPolar2(coordinates) {
  return coordOf(coordinates, "polar").length > 0;
}
function isHelix2(coordinates) {
  return coordOf(coordinates, "helix").length > 0;
}
function isTranspose2(coordinates) {
  return coordOf(coordinates, "transpose").length % 2 === 1;
}
function isParallel2(coordinates) {
  return coordOf(coordinates, "parallel").length > 0;
}
function isTheta2(coordinates) {
  return coordOf(coordinates, "theta").length > 0;
}
function isReflect(coordinates) {
  return coordOf(coordinates, "reflect").length > 0;
}
function isRadial2(coordinates) {
  return coordOf(coordinates, "radial").length > 0;
}
function isRadar2(coordinates) {
  return coordOf(coordinates, "radar").length > 0;
}
function isReflectY(coordinates) {
  return coordOf(coordinates, "reflectY").length > 0;
}
function inferCoordinate(coordinates) {
  if (coordinates.find((d3) => d3.type === "cartesian" || d3.type === "cartesian3D"))
    return coordinates;
  return [...coordinates, { type: "cartesian" }];
}

// node_modules/@antv/g2/node_modules/@antv/vendor/es/d3-scale-chromatic.mjs
var d3_scale_chromatic_exports = {};
__export(d3_scale_chromatic_exports, {
  interpolateBlues: () => Blues_default,
  interpolateBrBG: () => BrBG_default,
  interpolateBuGn: () => BuGn_default,
  interpolateBuPu: () => BuPu_default,
  interpolateCividis: () => cividis_default,
  interpolateCool: () => cool,
  interpolateCubehelixDefault: () => cubehelix_default2,
  interpolateGnBu: () => GnBu_default,
  interpolateGreens: () => Greens_default,
  interpolateGreys: () => Greys_default,
  interpolateInferno: () => inferno,
  interpolateMagma: () => magma,
  interpolateOrRd: () => OrRd_default,
  interpolateOranges: () => Oranges_default,
  interpolatePRGn: () => PRGn_default,
  interpolatePiYG: () => PiYG_default,
  interpolatePlasma: () => plasma,
  interpolatePuBu: () => PuBu_default,
  interpolatePuBuGn: () => PuBuGn_default,
  interpolatePuOr: () => PuOr_default,
  interpolatePuRd: () => PuRd_default,
  interpolatePurples: () => Purples_default,
  interpolateRainbow: () => rainbow_default,
  interpolateRdBu: () => RdBu_default,
  interpolateRdGy: () => RdGy_default,
  interpolateRdPu: () => RdPu_default,
  interpolateRdYlBu: () => RdYlBu_default,
  interpolateRdYlGn: () => RdYlGn_default,
  interpolateReds: () => Reds_default,
  interpolateSinebow: () => sinebow_default,
  interpolateSpectral: () => Spectral_default,
  interpolateTurbo: () => turbo_default,
  interpolateViridis: () => viridis_default,
  interpolateWarm: () => warm,
  interpolateYlGn: () => YlGn_default,
  interpolateYlGnBu: () => YlGnBu_default,
  interpolateYlOrBr: () => YlOrBr_default,
  interpolateYlOrRd: () => YlOrRd_default,
  schemeAccent: () => Accent_default,
  schemeBlues: () => scheme22,
  schemeBrBG: () => scheme,
  schemeBuGn: () => scheme10,
  schemeBuPu: () => scheme11,
  schemeCategory10: () => category10_default,
  schemeDark2: () => Dark2_default,
  schemeGnBu: () => scheme12,
  schemeGreens: () => scheme23,
  schemeGreys: () => scheme24,
  schemeObservable10: () => observable10_default,
  schemeOrRd: () => scheme13,
  schemeOranges: () => scheme27,
  schemePRGn: () => scheme2,
  schemePaired: () => Paired_default,
  schemePastel1: () => Pastel1_default,
  schemePastel2: () => Pastel2_default,
  schemePiYG: () => scheme3,
  schemePuBu: () => scheme15,
  schemePuBuGn: () => scheme14,
  schemePuOr: () => scheme4,
  schemePuRd: () => scheme16,
  schemePurples: () => scheme25,
  schemeRdBu: () => scheme5,
  schemeRdGy: () => scheme6,
  schemeRdPu: () => scheme17,
  schemeRdYlBu: () => scheme7,
  schemeRdYlGn: () => scheme8,
  schemeReds: () => scheme26,
  schemeSet1: () => Set1_default,
  schemeSet2: () => Set2_default,
  schemeSet3: () => Set3_default,
  schemeSpectral: () => scheme9,
  schemeTableau10: () => Tableau10_default,
  schemeYlGn: () => scheme19,
  schemeYlGnBu: () => scheme18,
  schemeYlOrBr: () => scheme20,
  schemeYlOrRd: () => scheme21
});

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n)
    colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// node_modules/d3-scale-chromatic/src/categorical/observable10.js
var observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

// node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend4(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color5() {
}
var darker2 = 0.7;
var brighter2 = 1 / darker2;
var reI2 = "\\s*([+-]?\\d+)\\s*";
var reN2 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP2 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex2 = /^#([0-9a-f]{3,8})$/;
var reRgbInteger2 = new RegExp(`^rgb\\(${reI2},${reI2},${reI2}\\)$`);
var reRgbPercent2 = new RegExp(`^rgb\\(${reP2},${reP2},${reP2}\\)$`);
var reRgbaInteger2 = new RegExp(`^rgba\\(${reI2},${reI2},${reI2},${reN2}\\)$`);
var reRgbaPercent2 = new RegExp(`^rgba\\(${reP2},${reP2},${reP2},${reN2}\\)$`);
var reHslPercent2 = new RegExp(`^hsl\\(${reN2},${reP2},${reP2}\\)$`);
var reHslaPercent2 = new RegExp(`^hsla\\(${reN2},${reP2},${reP2},${reN2}\\)$`);
var named2 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color5, color2, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex2,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex2,
  formatHex8: color_formatHex82,
  formatHsl: color_formatHsl2,
  formatRgb: color_formatRgb2,
  toString: color_formatRgb2
});
function color_formatHex2() {
  return this.rgb().formatHex();
}
function color_formatHex82() {
  return this.rgb().formatHex8();
}
function color_formatHsl2() {
  return hslConvert2(this).formatHsl();
}
function color_formatRgb2() {
  return this.rgb().formatRgb();
}
function color2(format3) {
  var m3, l;
  format3 = (format3 + "").trim().toLowerCase();
  return (m3 = reHex2.exec(format3)) ? (l = m3[1].length, m3 = parseInt(m3[1], 16), l === 6 ? rgbn2(m3) : l === 3 ? new Rgb2(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l === 8 ? rgba2(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l === 4 ? rgba2(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger2.exec(format3)) ? new Rgb2(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent2.exec(format3)) ? new Rgb2(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger2.exec(format3)) ? rgba2(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent2.exec(format3)) ? rgba2(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent2.exec(format3)) ? hsla2(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent2.exec(format3)) ? hsla2(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named2.hasOwnProperty(format3) ? rgbn2(named2[format3]) : format3 === "transparent" ? new Rgb2(NaN, NaN, NaN, 0) : null;
}
function rgbn2(n) {
  return new Rgb2(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba2(r, g, b, a4) {
  if (a4 <= 0)
    r = g = b = NaN;
  return new Rgb2(r, g, b, a4);
}
function rgbConvert2(o) {
  if (!(o instanceof Color5))
    o = color2(o);
  if (!o)
    return new Rgb2();
  o = o.rgb();
  return new Rgb2(o.r, o.g, o.b, o.opacity);
}
function rgb2(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert2(r) : new Rgb2(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb2(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb2, rgb2, extend4(Color5, {
  brighter(k2) {
    k2 = k2 == null ? brighter2 : Math.pow(brighter2, k2);
    return new Rgb2(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker2 : Math.pow(darker2, k2);
    return new Rgb2(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb2(clampi2(this.r), clampi2(this.g), clampi2(this.b), clampa2(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex2,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex2,
  formatHex8: rgb_formatHex82,
  formatRgb: rgb_formatRgb2,
  toString: rgb_formatRgb2
}));
function rgb_formatHex2() {
  return `#${hex2(this.r)}${hex2(this.g)}${hex2(this.b)}`;
}
function rgb_formatHex82() {
  return `#${hex2(this.r)}${hex2(this.g)}${hex2(this.b)}${hex2((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb2() {
  const a4 = clampa2(this.opacity);
  return `${a4 === 1 ? "rgb(" : "rgba("}${clampi2(this.r)}, ${clampi2(this.g)}, ${clampi2(this.b)}${a4 === 1 ? ")" : `, ${a4})`}`;
}
function clampa2(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi2(value2) {
  return Math.max(0, Math.min(255, Math.round(value2) || 0));
}
function hex2(value2) {
  value2 = clampi2(value2);
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla2(h, s3, l, a4) {
  if (a4 <= 0)
    h = s3 = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s3 = NaN;
  else if (s3 <= 0)
    h = NaN;
  return new Hsl2(h, s3, l, a4);
}
function hslConvert2(o) {
  if (o instanceof Hsl2)
    return new Hsl2(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color5))
    o = color2(o);
  if (!o)
    return new Hsl2();
  if (o instanceof Hsl2)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min10 = Math.min(r, g, b), max11 = Math.max(r, g, b), h = NaN, s3 = max11 - min10, l = (max11 + min10) / 2;
  if (s3) {
    if (r === max11)
      h = (g - b) / s3 + (g < b) * 6;
    else if (g === max11)
      h = (b - r) / s3 + 2;
    else
      h = (r - g) / s3 + 4;
    s3 /= l < 0.5 ? max11 + min10 : 2 - max11 - min10;
    h *= 60;
  } else {
    s3 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl2(h, s3, l, o.opacity);
}
function hsl2(h, s3, l, opacity) {
  return arguments.length === 1 ? hslConvert2(h) : new Hsl2(h, s3, l, opacity == null ? 1 : opacity);
}
function Hsl2(h, s3, l, opacity) {
  this.h = +h;
  this.s = +s3;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl2, hsl2, extend4(Color5, {
  brighter(k2) {
    k2 = k2 == null ? brighter2 : Math.pow(brighter2, k2);
    return new Hsl2(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker2 : Math.pow(darker2, k2);
    return new Hsl2(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s3 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m22 = l + (l < 0.5 ? l : 1 - l) * s3, m1 = 2 * l - m22;
    return new Rgb2(
      hsl2rgb2(h >= 240 ? h - 240 : h + 120, m1, m22),
      hsl2rgb2(h, m1, m22),
      hsl2rgb2(h < 120 ? h + 240 : h - 120, m1, m22),
      this.opacity
    );
  },
  clamp() {
    return new Hsl2(clamph2(this.h), clampt2(this.s), clampt2(this.l), clampa2(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a4 = clampa2(this.opacity);
    return `${a4 === 1 ? "hsl(" : "hsla("}${clamph2(this.h)}, ${clampt2(this.s) * 100}%, ${clampt2(this.l) * 100}%${a4 === 1 ? ")" : `, ${a4})`}`;
  }
}));
function clamph2(value2) {
  value2 = (value2 || 0) % 360;
  return value2 < 0 ? value2 + 360 : value2;
}
function clampt2(value2) {
  return Math.max(0, Math.min(1, value2 || 0));
}
function hsl2rgb2(h, m1, m22) {
  return (h < 60 ? m1 + (m22 - m1) * h / 60 : h < 180 ? m22 : h < 240 ? m1 + (m22 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians2 = Math.PI / 180;
var degrees2 = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb2))
    o = rgbConvert2(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y3 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x3, z;
  if (r === g && g === b)
    x3 = z = y3;
  else {
    x3 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y3 - 16, 500 * (x3 - y3), 200 * (y3 - z), o.opacity);
}
function lab(l, a4, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a4, b, opacity == null ? 1 : opacity);
}
function Lab(l, a4, b, opacity) {
  this.l = +l;
  this.a = +a4;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend4(Color5, {
  brighter(k2) {
    return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  darker(k2) {
    return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  rgb() {
    var y3 = (this.l + 16) / 116, x3 = isNaN(this.a) ? y3 : y3 + this.a / 500, z = isNaN(this.b) ? y3 : y3 - this.b / 200;
    x3 = Xn * lab2xyz(x3);
    y3 = Yn * lab2xyz(y3);
    z = Zn * lab2xyz(z);
    return new Rgb2(
      lrgb2rgb(3.1338561 * x3 - 1.6168667 * y3 - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x3 + 1.9161415 * y3 + 0.033454 * z),
      lrgb2rgb(0.0719453 * x3 - 0.2289914 * y3 + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x3) {
  return 255 * (x3 <= 31308e-7 ? 12.92 * x3 : 1.055 * Math.pow(x3, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x3) {
  return (x3 /= 255) <= 0.04045 ? x3 / 12.92 : Math.pow((x3 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees2;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c5, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c5, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c5, l, opacity) {
  this.h = +h;
  this.c = +c5;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians2;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend4(Color5, {
  brighter(k2) {
    return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
  },
  darker(k2) {
    return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A5 = -0.14861;
var B3 = 1.78277;
var C3 = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B3;
var BC_DA = B3 * C3 - D * A5;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb2))
    o = rgbConvert2(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C3 * bl) / D, s3 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h = s3 ? Math.atan2(k2, bl) * degrees2 - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s3, l, o.opacity);
}
function cubehelix(h, s3, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s3, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s3, l, opacity) {
  this.h = +h;
  this.s = +s3;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend4(Color5, {
  brighter(k2) {
    k2 = k2 == null ? brighter2 : Math.pow(brighter2, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker2 : Math.pow(darker2, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians2, l = +this.l, a4 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb2(
      255 * (l + a4 * (A5 * cosh2 + B3 * sinh2)),
      255 * (l + a4 * (C3 * cosh2 + D * sinh2)),
      255 * (l + a4 * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t12, v0, v1, v2, v3) {
  var t22 = t12 * t12, t32 = t22 * t12;
  return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default2(values4) {
  var n = values4.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values4[i], v2 = values4[i + 1], v0 = i > 0 ? values4[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values4[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default2(values4) {
  var n = values4.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values4[(i + n - 1) % n], v1 = values4[i % n], v2 = values4[(i + 1) % n], v3 = values4[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default5 = (x3) => () => x3;

// node_modules/d3-interpolate/src/color.js
function linear4(a4, d3) {
  return function(t) {
    return a4 + t * d3;
  };
}
function exponential(a4, b, y3) {
  return a4 = Math.pow(a4, y3), b = Math.pow(b, y3) - a4, y3 = 1 / y3, function(t) {
    return Math.pow(a4 + t * b, y3);
  };
}
function hue(a4, b) {
  var d3 = b - a4;
  return d3 ? linear4(a4, d3 > 180 || d3 < -180 ? d3 - 360 * Math.round(d3 / 360) : d3) : constant_default5(isNaN(a4) ? b : a4);
}
function gamma(y3) {
  return (y3 = +y3) === 1 ? nogamma : function(a4, b) {
    return b - a4 ? exponential(a4, b, y3) : constant_default5(isNaN(a4) ? b : a4);
  };
}
function nogamma(a4, b) {
  var d3 = b - a4;
  return d3 ? linear4(a4, d3) : constant_default5(isNaN(a4) ? b : a4);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y3) {
  var color3 = gamma(y3);
  function rgb3(start, end) {
    var r = color3((start = rgb2(start)).r, (end = rgb2(end)).r), g = color3(start.g, end.g), b = color3(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb3.gamma = rgbGamma;
  return rgb3;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color3;
    for (i = 0; i < n; ++i) {
      color3 = rgb2(colors[i]);
      r[i] = color3.r || 0;
      g[i] = color3.g || 0;
      b[i] = color3.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color3.opacity = 1;
    return function(t) {
      color3.r = r(t);
      color3.g = g(t);
      color3.b = b(t);
      return color3 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default2);
var rgbBasisClosed = rgbSpline(basisClosed_default2);

// node_modules/d3-interpolate/src/number.js
function number_default(a4, b) {
  return a4 = +a4, b = +b, function(t) {
    return a4 * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees3 = 180 / Math.PI;
var identity6 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a4, b, c5, d3, e, f) {
  var scaleX2, scaleY2, skewX2;
  if (scaleX2 = Math.sqrt(a4 * a4 + b * b))
    a4 /= scaleX2, b /= scaleX2;
  if (skewX2 = a4 * c5 + b * d3)
    c5 -= a4 * skewX2, d3 -= b * skewX2;
  if (scaleY2 = Math.sqrt(c5 * c5 + d3 * d3))
    c5 /= scaleY2, d3 /= scaleY2, skewX2 /= scaleY2;
  if (a4 * d3 < b * c5)
    a4 = -a4, b = -b, skewX2 = -skewX2, scaleX2 = -scaleX2;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a4) * degrees3,
    skewX: Math.atan(skewX2) * degrees3,
    scaleX: scaleX2,
    scaleY: scaleY2
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value2) {
  const m3 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value2 + "");
  return m3.isIdentity ? identity6 : decompose_default(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
}
function parseSvg(value2) {
  if (value2 == null)
    return identity6;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value2);
  if (!(value2 = svgNode.transform.baseVal.consolidate()))
    return identity6;
  value2 = value2.matrix;
  return decompose_default(value2.a, value2.b, value2.c, value2.d, value2.e, value2.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s3) {
    return s3.length ? s3.pop() + " " : "";
  }
  function translate6(xa, ya, xb, yb, s3, q) {
    if (xa !== xb || ya !== yb) {
      var i = s3.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s3.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate7(a4, b, s3, q) {
    if (a4 !== b) {
      if (a4 - b > 180)
        b += 360;
      else if (b - a4 > 180)
        a4 += 360;
      q.push({ i: s3.push(pop(s3) + "rotate(", null, degParen) - 2, x: number_default(a4, b) });
    } else if (b) {
      s3.push(pop(s3) + "rotate(" + b + degParen);
    }
  }
  function skewX2(a4, b, s3, q) {
    if (a4 !== b) {
      q.push({ i: s3.push(pop(s3) + "skewX(", null, degParen) - 2, x: number_default(a4, b) });
    } else if (b) {
      s3.push(pop(s3) + "skewX(" + b + degParen);
    }
  }
  function scale11(xa, ya, xb, yb, s3, q) {
    if (xa !== xb || ya !== yb) {
      var i = s3.push(pop(s3) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s3.push(pop(s3) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a4, b) {
    var s3 = [], q = [];
    a4 = parse(a4), b = parse(b);
    translate6(a4.translateX, a4.translateY, b.translateX, b.translateY, s3, q);
    rotate7(a4.rotate, b.rotate, s3, q);
    skewX2(a4.skewX, b.skewX, s3, q);
    scale11(a4.scaleX, a4.scaleY, b.scaleX, b.scaleY, s3, q);
    a4 = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s3[(o = q[i]).i] = o.x(t);
      return s3.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon23 = 1e-12;
function cosh(x3) {
  return ((x3 = Math.exp(x3)) + 1 / x3) / 2;
}
function sinh(x3) {
  return ((x3 = Math.exp(x3)) - 1 / x3) / 2;
}
function tanh(x3) {
  return ((x3 = Math.exp(2 * x3)) - 1) / (x3 + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d22 = dx * dx + dy * dy, i, S;
    if (d22 < epsilon23) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d22), b0 = (w1 * w1 - w0 * w0 + rho4 * d22) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d22) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s3 = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s3 + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s3 + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function(_2) {
    var _1 = Math.max(1e-3, +_2), _22 = _1 * _1, _4 = _22 * _22;
    return zoomRho(_1, _22, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl3(hue2) {
  return function(start, end) {
    var h = hue2((start = hsl2(start)).h, (end = hsl2(end)).h), s3 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s3(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hsl_default = hsl3(hue);
var hslLong = hsl3(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hcl(start)).h, (end = hcl(end)).h), c5 = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c5(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y3) {
    y3 = +y3;
    function cubehelix3(start, end) {
      var h = hue2((start = cubehelix(start)).h, (end = cubehelix(end)).h), s3 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s3(t);
        start.l = l(Math.pow(t, y3));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

// node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default = ramp_default(scheme);

// node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme2 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default = ramp_default(scheme2);

// node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme3 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default = ramp_default(scheme3);

// node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme4 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default = ramp_default(scheme4);

// node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme5 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default = ramp_default(scheme5);

// node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default = ramp_default(scheme6);

// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme7 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default = ramp_default(scheme7);

// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme8 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default = ramp_default(scheme8);

// node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme9 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default = ramp_default(scheme9);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme10 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default = ramp_default(scheme10);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme11 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default = ramp_default(scheme11);

// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme12 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default = ramp_default(scheme12);

// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme13 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default = ramp_default(scheme13);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme14 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default = ramp_default(scheme14);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme15 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default = ramp_default(scheme15);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme16 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default = ramp_default(scheme16);

// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme17 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default = ramp_default(scheme17);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme18 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default = ramp_default(scheme18);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme19 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default = ramp_default(scheme19);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme20 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default = ramp_default(scheme20);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme21 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default = ramp_default(scheme21);

// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme22 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default = ramp_default(scheme22);

// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme23 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default = ramp_default(scheme23);

// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme24 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default = ramp_default(scheme24);

// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme25 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default = ramp_default(scheme25);

// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme26 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default = ramp_default(scheme26);

// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme27 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default = ramp_default(scheme27);

// node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
function cividis_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c3 = cubehelix();
function rainbow_default(t) {
  if (t < 0 || t > 1)
    t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c3.h = 360 * t - 100;
  c3.s = 1.5 - 1.5 * ts;
  c3.l = 0.8 - 0.9 * ts;
  return c3 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c4 = rgb2();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;
function sinebow_default(t) {
  var x3;
  t = (0.5 - t) * Math.PI;
  c4.r = 255 * (x3 = Math.sin(t)) * x3;
  c4.g = 255 * (x3 = Math.sin(t + pi_1_3)) * x3;
  c4.b = 255 * (x3 = Math.sin(t + pi_2_3)) * x3;
  return c4 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
function turbo_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range3) {
  var n = range3.length;
  return function(t) {
    return range3[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// node_modules/@antv/g2/esm/runtime/scale.js
function inferScale(name2, values4, options, coordinates, theme, library3) {
  const { guide = {} } = options;
  const type = inferScaleType(name2, values4, options);
  if (typeof type !== "string")
    return options;
  const expectedDomain = inferScaleDomain(type, name2, values4, options);
  const actualDomain = maybeRatio(type, expectedDomain, options);
  return Object.assign(Object.assign(Object.assign({}, options), inferScaleOptions(type, name2, values4, options, coordinates)), {
    domain: actualDomain,
    range: inferScaleRange(type, name2, values4, options, actualDomain, theme, library3),
    expectedDomain,
    guide,
    name: name2,
    type
  });
}
function applyScale(channels, scale11) {
  const scaledValue = {};
  for (const channel of channels) {
    const { values: values4, name: scaleName } = channel;
    const scaleInstance = scale11[scaleName];
    for (const value2 of values4) {
      const { name: name2, value: V } = value2;
      scaledValue[name2] = V.map((d3) => scaleInstance.map(d3));
    }
  }
  return scaledValue;
}
function groupTransform(markState, uidScale) {
  const channels = Array.from(markState.values()).flatMap((d3) => d3.channels);
  const scaleGroups = rollups(channels, (channels2) => channels2.map((d3) => uidScale.get(d3.scale.uid)), (d3) => d3.name).filter(([, scales]) => scales.some((d3) => typeof d3.getOptions().groupTransform === "function") && // only sync scales with groupTransform options
  scales.every((d3) => d3.getTicks)).map((d3) => d3[1]);
  scaleGroups.forEach((group3) => {
    const groupTransform2 = group3.map((d3) => d3.getOptions().groupTransform)[0];
    groupTransform2(group3);
  });
}
function collectScales(states, options) {
  var _a2;
  const { components = [] } = options;
  const NONE_STATIC_KEYS = [
    "scale",
    "encode",
    "axis",
    "legend",
    "data",
    "transform"
  ];
  const scales = Array.from(new Set(states.flatMap((d3) => d3.channels.map((d4) => d4.scale))));
  const nameScale = new Map(scales.map((scale11) => [scale11.name, scale11]));
  for (const component of components) {
    const channels = inferChannelsForComponent(component);
    for (const channel of channels) {
      const scale11 = nameScale.get(channel);
      const staticScale = ((_a2 = component.scale) === null || _a2 === void 0 ? void 0 : _a2[channel]) || {};
      const { independent = false } = staticScale;
      if (scale11 && !independent) {
        const { guide } = scale11;
        const guide1 = typeof guide === "boolean" ? {} : guide;
        scale11.guide = deep_mix_default({}, guide1, component);
        Object.assign(scale11, staticScale);
      } else {
        const options1 = Object.assign(Object.assign({}, staticScale), { expectedDomain: staticScale.domain, name: channel, guide: omit_default(component, NONE_STATIC_KEYS) });
        scales.push(options1);
      }
    }
  }
  return scales;
}
function useRelation(relations) {
  if (!relations || !Array.isArray(relations))
    return [identity5, identity5];
  let map5;
  let invert5;
  const conditionalize = (scale11) => {
    var _a2;
    map5 = scale11.map.bind(scale11);
    invert5 = (_a2 = scale11.invert) === null || _a2 === void 0 ? void 0 : _a2.bind(scale11);
    const funcRelations = relations.filter(([v]) => typeof v === "function");
    const valueRelations = relations.filter(([v]) => typeof v !== "function");
    const valueOutput = new Map(valueRelations);
    scale11.map = (x3) => {
      for (const [verify, value2] of funcRelations) {
        if (verify(x3))
          return value2;
      }
      if (valueOutput.has(x3))
        return valueOutput.get(x3);
      return map5(x3);
    };
    if (!invert5)
      return scale11;
    const outputValue = new Map(valueRelations.map(([a4, b]) => [b, a4]));
    const outputFunc = new Map(funcRelations.map(([a4, b]) => [b, a4]));
    scale11.invert = (x3) => {
      if (outputFunc.has(x3))
        return x3;
      if (outputValue.has(x3))
        return outputValue.get(x3);
      return invert5(x3);
    };
    return scale11;
  };
  const deconditionalize = (scale11) => {
    if (map5 !== null)
      scale11.map = map5;
    if (invert5 !== null)
      scale11.invert = invert5;
    return scale11;
  };
  return [conditionalize, deconditionalize];
}
function assignScale(target, source) {
  const keys2 = Object.keys(target);
  for (const scale11 of Object.values(source)) {
    const { name: name2 } = scale11.getOptions();
    if (!(name2 in target))
      target[name2] = scale11;
    else {
      const I = keys2.filter((d3) => d3.startsWith(name2)).map((d3) => +(d3.replace(name2, "") || 0));
      const index3 = max5(I) + 1;
      const newKey = `${name2}${index3}`;
      target[newKey] = scale11;
      scale11.getOptions().key = newKey;
    }
  }
  return target;
}
function useRelationScale(options, library3) {
  const [useScale] = useLibrary("scale", library3);
  const { relations } = options;
  const [conditionalize] = useRelation(relations);
  const scale11 = useScale(options);
  return conditionalize(scale11);
}
function syncFacetsScales(states) {
  const scales = states.flatMap((d3) => Array.from(d3.values())).flatMap((d3) => d3.channels.map((d4) => d4.scale));
  syncFacetsScaleByChannel(scales, "x");
  syncFacetsScaleByChannel(scales, "y");
}
function inferChannelsForComponent(component) {
  const { channels = [], type, scale: scale11 = {} } = component;
  const L = ["shape", "color", "opacity", "size"];
  if (channels.length !== 0)
    return channels;
  if (type === "axisX")
    return ["x"];
  if (type === "axisY")
    return ["y"];
  if (type === "legends")
    return Object.keys(scale11).filter((d3) => L.includes(d3));
  return [];
}
function syncFacetsScaleByChannel(scales, channel) {
  const S = scales.filter(({ name: name2, facet = true }) => facet && name2 === channel);
  const D2 = S.flatMap((d3) => d3.domain);
  const syncedD = S.every(isQuantitativeScale) ? extent(D2) : S.every(isDiscreteScale) ? Array.from(new Set(D2)) : null;
  if (syncedD === null)
    return;
  for (const scale11 of S) {
    scale11.domain = syncedD;
  }
}
function maybeRatio(type, domain, options) {
  const { ratio } = options;
  if (ratio === void 0 || ratio === null)
    return domain;
  if (isQuantitativeScale({ type })) {
    return clampQuantitativeScale(domain, ratio, type);
  }
  if (isDiscreteScale({ type }))
    return clampDiscreteScale(domain, ratio);
  return domain;
}
function clampQuantitativeScale(domain, ratio, type) {
  const D2 = domain.map(Number);
  const scale11 = new Linear({
    domain: D2,
    range: [D2[0], D2[0] + (D2[D2.length - 1] - D2[0]) * ratio]
  });
  if (type === "time")
    return domain.map((d3) => new Date(scale11.map(d3)));
  return domain.map((d3) => scale11.map(d3));
}
function clampDiscreteScale(domain, ratio) {
  const index3 = Math.round(domain.length * ratio);
  return domain.slice(0, index3);
}
function isQuantitativeScale(scale11) {
  const { type } = scale11;
  if (typeof type !== "string")
    return false;
  const names = ["linear", "log", "pow", "time"];
  return names.includes(type);
}
function isDiscreteScale(scale11) {
  const { type } = scale11;
  if (typeof type !== "string")
    return false;
  const names = ["band", "point", "ordinal"];
  return names.includes(type);
}
function inferScaleType(name2, values4, options) {
  const { type, domain, range: range3, quantitative, ordinal } = options;
  if (type !== void 0)
    return type;
  if (isObject3(values4))
    return "identity";
  if (typeof range3 === "string")
    return "linear";
  if ((domain || range3 || []).length > 2)
    return asOrdinalType(name2, ordinal);
  if (domain !== void 0) {
    if (isOrdinal([domain]))
      return asOrdinalType(name2, ordinal);
    if (isTemporal(values4))
      return "time";
    return asQuantitativeType(name2, range3, quantitative);
  }
  if (isOrdinal(values4))
    return asOrdinalType(name2, ordinal);
  if (isTemporal(values4))
    return "time";
  return asQuantitativeType(name2, range3, quantitative);
}
function inferScaleDomain(type, name2, values4, options) {
  const { domain } = options;
  if (domain !== void 0)
    return domain;
  switch (type) {
    case "linear":
    case "time":
    case "log":
    case "pow":
    case "sqrt":
    case "quantize":
    case "threshold":
      return maybeMinMax(inferDomainQ(values4, options), options);
    case "band":
    case "ordinal":
    case "point":
      return inferDomainC(values4);
    case "quantile":
      return inferDomainO(values4);
    case "sequential":
      return maybeMinMax(inferDomainS(values4), options);
    default:
      return [];
  }
}
function inferScaleRange(type, name2, values4, options, domain, theme, library3) {
  const { range: range3 } = options;
  if (typeof range3 === "string")
    return gradientColors(range3);
  if (range3 !== void 0)
    return range3;
  const { rangeMin, rangeMax } = options;
  switch (type) {
    case "linear":
    case "time":
    case "log":
    case "pow":
    case "sqrt": {
      const colors = categoricalColors(values4, options, domain, theme, library3);
      const [r0, r1] = inferRangeQ(name2, colors);
      return [rangeMin !== null && rangeMin !== void 0 ? rangeMin : r0, rangeMax !== null && rangeMax !== void 0 ? rangeMax : r1];
    }
    case "band":
    case "point": {
      const min10 = name2 === "size" ? 5 : 0;
      const max11 = name2 === "size" ? 10 : 1;
      return [rangeMin !== null && rangeMin !== void 0 ? rangeMin : min10, rangeMax !== null && rangeMax !== void 0 ? rangeMax : max11];
    }
    case "ordinal": {
      return categoricalColors(values4, options, domain, theme, library3);
    }
    case "sequential":
      return void 0;
    case "constant":
      return [values4[0][0]];
    default:
      return [];
  }
}
function inferScaleOptions(type, name2, values4, options, coordinates) {
  switch (type) {
    case "linear":
    case "time":
    case "log":
    case "pow":
    case "sqrt":
      return inferOptionsQ(coordinates, options);
    case "band":
    case "point":
      return inferOptionsC(type, name2, coordinates, options);
    case "sequential":
      return inferOptionsS(options);
    default:
      return options;
  }
}
function categoricalColors(values4, options, domain, theme, library3) {
  const [usePalette] = useLibrary("palette", library3);
  const { category10: c10, category20: c20 } = theme;
  const defaultPalette = unique(domain).length <= c10.length ? c10 : c20;
  const { palette = defaultPalette, offset: offset2 } = options;
  if (Array.isArray(palette))
    return palette;
  try {
    return usePalette({ type: palette });
  } catch (e) {
    const colors = interpolatedColors(palette, domain, offset2);
    if (colors)
      return colors;
    throw new Error(`Unknown Component: ${palette} `);
  }
}
function gradientColors(range3) {
  return range3.split("-");
}
function interpolatedColors(palette, domain, offset2 = (d3) => d3) {
  if (!palette)
    return null;
  const fullName = upper_first_default(palette);
  const scheme28 = d3_scale_chromatic_exports[`scheme${fullName}`];
  const interpolator = d3_scale_chromatic_exports[`interpolate${fullName}`];
  if (!scheme28 && !interpolator)
    return null;
  if (scheme28) {
    if (!scheme28.some(Array.isArray))
      return scheme28;
    const schemeColors = scheme28[domain.length];
    if (schemeColors)
      return schemeColors;
  }
  return domain.map((_2, i) => interpolator(offset2(i / domain.length)));
}
function inferOptionsS(options) {
  const { palette = "ylGnBu", offset: offset2 } = options;
  const name2 = upper_first_default(palette);
  const interpolator = d3_scale_chromatic_exports[`interpolate${name2}`];
  if (!interpolator)
    throw new Error(`Unknown palette: ${name2}`);
  return {
    interpolator: offset2 ? (x3) => interpolator(offset2(x3)) : interpolator
  };
}
function inferOptionsQ(coordinates, options) {
  const { interpolate: interpolate4 = createInterpolateValue, nice: nice2 = false, tickCount = 5 } = options;
  return Object.assign(Object.assign({}, options), { interpolate: interpolate4, nice: nice2, tickCount });
}
function inferOptionsC(type, name2, coordinates, options) {
  if (options.padding !== void 0 || options.paddingInner !== void 0 || options.paddingOuter !== void 0) {
    return Object.assign(Object.assign({}, options), { unknown: NaN });
  }
  const padding = inferPadding(type, name2, coordinates);
  const { paddingInner = padding, paddingOuter = padding } = options;
  return Object.assign(Object.assign({}, options), {
    paddingInner,
    paddingOuter,
    padding,
    unknown: NaN
  });
}
function inferPadding(type, name2, coordinates) {
  if (name2 === "enterDelay" || name2 === "enterDuration")
    return 0;
  if (name2 === "size")
    return 0;
  if (type === "band")
    return isTheta2(coordinates) ? 0 : 0.1;
  if (type === "point")
    return 0.5;
  return 0;
}
function asOrdinalType(name2, defaults4) {
  if (defaults4)
    return defaults4;
  return isQuantitative(name2) ? "point" : "ordinal";
}
function asQuantitativeType(name2, range3, defaults4) {
  if (defaults4)
    return defaults4;
  if (name2 !== "color")
    return "linear";
  return range3 ? "linear" : "sequential";
}
function maybeMinMax(domain, options) {
  if (domain.length === 0)
    return domain;
  const { domainMin, domainMax } = options;
  const [d0, d1] = domain;
  return [domainMin !== null && domainMin !== void 0 ? domainMin : d0, domainMax !== null && domainMax !== void 0 ? domainMax : d1];
}
function inferDomainQ(values4, options) {
  const { zero: zero5 = false } = options;
  let min10 = Infinity;
  let max11 = -Infinity;
  for (const value2 of values4) {
    for (const d3 of value2) {
      if (defined(d3)) {
        min10 = Math.min(min10, +d3);
        max11 = Math.max(max11, +d3);
      }
    }
  }
  if (min10 === Infinity)
    return [];
  return zero5 ? [Math.min(0, min10), max11] : [min10, max11];
}
function inferDomainC(values4) {
  return Array.from(new Set(values4.flat()));
}
function inferDomainO(values4) {
  return values4.flat().sort();
}
function inferDomainS(values4) {
  let min10 = Infinity;
  let max11 = -Infinity;
  for (const value2 of values4) {
    for (const d3 of value2) {
      if (defined(d3)) {
        min10 = Math.min(min10, +d3);
        max11 = Math.max(max11, +d3);
      }
    }
  }
  if (min10 === Infinity)
    return [];
  return [min10 < 0 ? -max11 : min10, max11];
}
function inferRangeQ(name2, palette) {
  if (name2 === "enterDelay")
    return [0, 1e3];
  if (name2 == "enterDuration")
    return [300, 1e3];
  if (name2.startsWith("y") || name2.startsWith("position"))
    return [1, 0];
  if (name2 === "color")
    return [firstOf(palette), lastOf(palette)];
  if (name2 === "opacity")
    return [0, 1];
  if (name2 === "size")
    return [1, 10];
  return [0, 1];
}
function isOrdinal(values4) {
  return some2(values4, (d3) => {
    const type = typeof d3;
    return type === "string" || type === "boolean";
  });
}
function isTemporal(values4) {
  return some2(values4, (d3) => d3 instanceof Date);
}
function isObject3(values4) {
  return some2(values4, isStrictObject);
}
function some2(values4, callback) {
  for (const V of values4) {
    if (V.some(callback))
      return true;
  }
  return false;
}
function isQuantitative(name2) {
  return name2.startsWith("x") || name2.startsWith("y") || name2.startsWith("position") || name2.startsWith("size");
}
function isPosition(name2) {
  return name2.startsWith("x") || name2.startsWith("y") || name2.startsWith("position") || name2 === "enterDelay" || name2 === "enterDuration" || name2 === "updateDelay" || name2 === "updateDuration" || name2 === "exitDelay" || name2 === "exitDuration";
}
function isValidScale(scale11) {
  if (!scale11 || !scale11.type)
    return false;
  if (typeof scale11.type === "function")
    return true;
  const { type, domain, range: range3, interpolator } = scale11;
  const isValidDomain = domain && domain.length > 0;
  const isValidRange = range3 && range3.length > 0;
  if ([
    "linear",
    "sqrt",
    "log",
    "time",
    "pow",
    "threshold",
    "quantize",
    "quantile",
    "ordinal",
    "band",
    "point"
  ].includes(type) && isValidDomain && isValidRange) {
    return true;
  }
  if (["sequential"].includes(type) && isValidDomain && (isValidRange || interpolator)) {
    return true;
  }
  if (["constant", "identity"].includes(type) && isValidRange)
    return true;
  return false;
}

// node_modules/@antv/g2/esm/runtime/types/scale.js
var ContinuousScale = {
  linear: "linear",
  identity: "identity",
  log: "log",
  pow: "pow",
  sqrt: "sqrt",
  sequential: "sequential"
};
var DistributionScale = {
  threshold: "threshold",
  quantize: "quantize",
  quantile: "quantile"
};
var DiscreteScale = {
  ordinal: "ordinal",
  band: "band",
  point: "point"
};
var ConstantScale = {
  constant: "constant"
};

// node_modules/@antv/g2/esm/runtime/component.js
var __rest73 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function inferComponent(scales, partialOptions, library3) {
  const { coordinates = [], title } = partialOptions;
  const [, createGuideComponent] = useLibrary("component", library3);
  const displayedScales = scales.filter(({ guide }) => {
    if (guide === null)
      return false;
    return true;
  });
  const components = [];
  const sliders = inferScrollableComponents(partialOptions, scales, library3);
  components.push(...sliders);
  if (title) {
    const { props } = createGuideComponent("title");
    const { defaultPosition, defaultOrientation, defaultOrder, defaultSize, defaultCrossPadding } = props;
    const titleOptions = typeof title === "string" ? { title } : title;
    components.push(Object.assign({ type: "title", position: defaultPosition, orientation: defaultOrientation, order: defaultOrder, crossPadding: defaultCrossPadding[0], defaultSize }, titleOptions));
  }
  const inferredComponents = inferComponentsType(displayedScales, coordinates);
  inferredComponents.forEach(([type, relativeScales]) => {
    const { props } = createGuideComponent(type);
    const { defaultPosition, defaultPlane = "xy", defaultOrientation, defaultSize, defaultOrder, defaultLength, defaultPadding: DP = [0, 0], defaultCrossPadding: DCP = [0, 0] } = props;
    const scale11 = deep_mix_default({}, ...relativeScales);
    const { guide: guideOptions, field: field3 } = scale11;
    const guides = Array.isArray(guideOptions) ? guideOptions : [guideOptions];
    for (const partialGuide of guides) {
      const [position, orientation] = inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, partialGuide, relativeScales, displayedScales, coordinates);
      if (!position && !orientation)
        continue;
      const isVertical2 = position === "left" || position === "right";
      const defaultPadding = isVertical2 ? DP[1] : DP[0];
      const defaultCrossPadding = isVertical2 ? DCP[1] : DCP[0];
      const { size: size3, order = defaultOrder, length: length5 = defaultLength, padding = defaultPadding, crossPadding = defaultCrossPadding } = partialGuide;
      components.push(Object.assign(Object.assign({ title: field3 }, partialGuide), {
        defaultSize,
        length: length5,
        position,
        plane: defaultPlane,
        orientation,
        padding,
        order,
        crossPadding,
        size: size3,
        type,
        scales: relativeScales
      }));
    }
  });
  return components;
}
function renderComponent(component, coordinate, theme, library3, markState) {
  const [useGuideComponent] = useLibrary("component", library3);
  const { scaleInstances: scales, scale: scale11, bbox } = component, options = __rest73(component, ["scaleInstances", "scale", "bbox"]);
  const value2 = { bbox, library: library3 };
  const render3 = useGuideComponent(options);
  return render3({
    coordinate,
    library: library3,
    markState,
    scales,
    theme,
    value: value2,
    scale: scale11
  });
}
function normalizeComponents(components) {
  return components.map((d3) => {
    const component = deep_mix_default(d3, d3.style);
    delete component.style;
    return component;
  });
}
function groupComponents(components, crossSize) {
  const P = ["left", "right", "bottom", "top"];
  const key = ({ type, position, group: group3 }) => {
    if (!P.includes(position))
      return Symbol("independent");
    if (group3 === void 0) {
      if (type.startsWith("legend"))
        return `legend-${position}`;
      return Symbol("independent");
    }
    if (group3 === "independent")
      return Symbol("independent");
    return group3;
  };
  const grouped = groups(components, key);
  return grouped.flatMap(([, components2]) => {
    if (components2.length === 1)
      return components2[0];
    if (crossSize !== void 0) {
      const DL = components2.filter((d3) => d3.length !== void 0).map((d3) => d3.length);
      const totalLength = sum(DL);
      if (totalLength > crossSize) {
        components2.forEach((d3) => d3.group = Symbol("independent"));
        return components2;
      }
      const emptyLength = crossSize - totalLength;
      const emptyCount = components2.length - DL.length;
      const length5 = emptyLength / emptyCount;
      components2.forEach((d3) => {
        if (d3.length !== void 0)
          return;
        d3.length = length5;
      });
    }
    const size3 = max5(components2, (d3) => d3.size);
    const order = max5(components2, (d3) => d3.order);
    const crossPadding = max5(components2, (d3) => d3.crossPadding);
    const position = components2[0].position;
    return {
      type: "group",
      size: size3,
      order,
      position,
      children: components2,
      crossPadding
    };
  });
}
function inferLegendComponentType(scales, coordinates) {
  const channels = ["shape", "size", "color", "opacity"];
  const isConstantSize = (type, name2) => type === "constant" && name2 === "size";
  const accepts = scales.filter(({ type, name: name2 }) => typeof type === "string" && channels.includes(name2) && !isConstantSize(type, name2));
  const constants = accepts.filter(({ type }) => type === "constant");
  const nonConstants = accepts.filter(({ type }) => type !== "constant");
  const groupKey = (d3) => d3.field ? d3.field : Symbol("independent");
  const fieldScales = groups(nonConstants, groupKey).map(([key, scales2]) => [key, [...scales2, ...constants]]).filter(([, scales2]) => scales2.some((scale11) => scale11.type !== "constant"));
  const scalesByField = new Map(fieldScales);
  if (scalesByField.size === 0)
    return [];
  const sort2 = (arr) => arr.sort(([a4], [b]) => a4.localeCompare(b));
  const components = Array.from(scalesByField).map(([, scs]) => {
    const combinations = combine(scs).sort((a4, b) => b.length - a4.length);
    const options = combinations.map((combination) => ({
      combination,
      option: combination.map((scale11) => [scale11.name, getScaleType(scale11)])
    }));
    for (const { option, combination } of options) {
      if (option.every((d3) => d3[1] === "constant"))
        continue;
      if (option.every((d3) => d3[1] === "discrete" || d3[1] === "constant")) {
        return ["legendCategory", combination];
      }
    }
    for (const [componentType, accords] of LEGEND_INFER_STRATEGIES) {
      for (const { option, combination } of options) {
        if (accords.some((accord) => is_equal_default(sort2(accord), sort2(option)))) {
          return [componentType, combination];
        }
      }
    }
    return null;
  }).filter(defined);
  return components;
}
function getScaleType(scale11) {
  const { type } = scale11;
  if (typeof type !== "string")
    return null;
  if (type in ContinuousScale)
    return "continuous";
  if (type in DiscreteScale)
    return "discrete";
  if (type in DistributionScale)
    return "distribution";
  if (type in ConstantScale)
    return "constant";
  return null;
}
function inferAxisComponentType(scales, coordinates) {
  return scales.map((scale11) => {
    const { name: name2 } = scale11;
    if (isHelix2(coordinates) || isTheta2(coordinates))
      return null;
    if (isTranspose2(coordinates) && (isPolar2(coordinates) || isRadial2(coordinates)))
      return null;
    if (name2.startsWith("x")) {
      if (isPolar2(coordinates))
        return ["axisArc", [scale11]];
      if (isRadial2(coordinates))
        return ["axisLinear", [scale11]];
      return [isTranspose2(coordinates) ? "axisY" : "axisX", [scale11]];
    }
    if (name2.startsWith("y")) {
      if (isPolar2(coordinates))
        return ["axisLinear", [scale11]];
      if (isRadial2(coordinates))
        return ["axisArc", [scale11]];
      return [isTranspose2(coordinates) ? "axisX" : "axisY", [scale11]];
    }
    if (name2.startsWith("z")) {
      return ["axisZ", [scale11]];
    }
    if (name2.startsWith("position")) {
      if (isRadar2(coordinates))
        return ["axisRadar", [scale11]];
      if (!isPolar2(coordinates))
        return ["axisY", [scale11]];
    }
    return null;
  }).filter(defined);
}
function inferComponentsType(scales, coordinates) {
  const availableScales = scales.filter((scale11) => isValidScale(scale11));
  return [
    ...inferLegendComponentType(availableScales, coordinates),
    ...inferAxisComponentType(availableScales, coordinates)
  ];
}
function angleOf3(coordinates) {
  const polar2 = coordOf(coordinates, "polar");
  if (polar2.length) {
    const lastPolar = polar2[polar2.length - 1];
    const { startAngle, endAngle } = getPolarOptions(lastPolar);
    return [startAngle, endAngle];
  }
  const radial = coordOf(coordinates, "radial");
  if (radial.length) {
    const lastRadial = radial[radial.length - 1];
    const { startAngle, endAngle } = getRadialOptions(lastRadial);
    return [startAngle, endAngle];
  }
  return [-Math.PI / 2, Math.PI / 2 * 3];
}
function matchPosition(name2) {
  const match = /position(\d*)/g.exec(name2);
  if (!match)
    return null;
  return +match[1];
}
function inferAxisPositionAndOrientation(type, ordinalPosition, relativeScales, scales, coordinates) {
  const { name: name2 } = relativeScales[0];
  if (type === "axisRadar") {
    const positions = scales.filter((scale11) => scale11.name.startsWith("position"));
    const index3 = matchPosition(name2);
    if (name2 === positions.slice(-1)[0].name || index3 === null)
      return [null, null];
    const [startAngle, endAngle] = angleOf3(coordinates);
    const angle4 = (endAngle - startAngle) / (positions.length - 1) * index3 + startAngle;
    return ["center", angle4];
  }
  if (type === "axisY" && isParallel2(coordinates)) {
    return isTranspose2(coordinates) ? ["center", "horizontal"] : ["center", "vertical"];
  }
  if (type === "axisLinear") {
    const [startAngle] = angleOf3(coordinates);
    return ["center", startAngle];
  }
  if (type === "axisArc") {
    if (ordinalPosition[0] === "inner")
      return ["inner", null];
    return ["outer", null];
  }
  if (isPolar2(coordinates))
    return ["center", null];
  if (isRadial2(coordinates))
    return ["center", null];
  if (type === "axisX" && isReflect(coordinates) || type === "axisX" && isReflectY(coordinates)) {
    return ["top", null];
  }
  return ordinalPosition;
}
function inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, guide, relativeScales, scales, coordinates) {
  const [startAngle] = angleOf3(coordinates);
  const ordinalPositionAndOrientation = [
    guide.position || defaultPosition,
    startAngle !== null && startAngle !== void 0 ? startAngle : defaultOrientation
  ];
  if (typeof type === "string" && type.startsWith("axis")) {
    return inferAxisPositionAndOrientation(type, ordinalPositionAndOrientation, relativeScales, scales, coordinates);
  }
  if (typeof type === "string" && type.startsWith("legend") && isPolar2(coordinates)) {
    if (guide.position === "center")
      return ["center", "vertical"];
  }
  return ordinalPositionAndOrientation;
}
function inferScrollableType(name2, type, coordinates = []) {
  if (name2 === "x")
    return isTranspose2(coordinates) ? `${type}Y` : `${type}X`;
  if (name2 === "y")
    return isTranspose2(coordinates) ? `${type}X` : `${type}Y`;
  return null;
}
function inferScrollableComponents(partialOptions, scales, library3) {
  const [, createGuideComponent] = useLibrary("component", library3);
  const { coordinates } = partialOptions;
  function normalized(type, channelName, scale11, options) {
    const componentType = inferScrollableType(channelName, type, coordinates);
    if (!options || !componentType)
      return;
    const { props } = createGuideComponent(componentType);
    const { defaultPosition, defaultSize, defaultOrder, defaultCrossPadding: [crossPadding] } = props;
    return Object.assign(Object.assign({ position: defaultPosition, defaultSize, order: defaultOrder, type: componentType, crossPadding }, options), { scales: [scale11] });
  }
  return scales.filter((d3) => d3.slider || d3.scrollbar).flatMap((scale11) => {
    const { slider, scrollbar, name: channelName } = scale11;
    return [
      normalized("slider", channelName, scale11, slider),
      normalized("scrollbar", channelName, scale11, scrollbar)
    ];
  }).filter((d3) => !!d3);
}
function computeComponentSize(component, crossSize, crossPadding, position, theme, library3) {
  const { type } = component;
  const paddingAreas = ["left", "right", "bottom", "top"];
  if (!paddingAreas.includes(position))
    return;
  if (typeof type !== "string")
    return;
  const t = type;
  const createCompute = () => {
    if (t.startsWith("axis"))
      return computeAxisSize;
    if (t.startsWith("group"))
      return computeGroupSize;
    if (t.startsWith("legendContinuous"))
      return computeContinuousLegendSize;
    if (t === "legendCategory")
      return computeCategoryLegendSize;
    if (t.startsWith("slider"))
      return computeSliderSize;
    if (t === "title")
      return computeTitleSize;
    if (t.startsWith("scrollbar"))
      return computeScrollbarSize;
    return () => {
    };
  };
  return createCompute()(component, crossSize, crossPadding, position, theme, library3);
}
function computeGroupSize(component, crossSize, crossPadding, position, theme, library3) {
  const { children } = component;
  const maxCrossPadding = max5(children, (d3) => d3.crossPadding);
  children.forEach((d3) => d3.crossPadding = maxCrossPadding);
  children.forEach((child) => computeComponentSize(child, crossSize, crossPadding, position, theme, library3));
  const maxSize = max5(children, (d3) => d3.size);
  component.size = maxSize;
  children.forEach((d3) => d3.size = maxSize);
}
function computeScrollbarSize(component, crossSize, crossPadding, position, theme, library3) {
  const { trackSize = 6 } = deep_mix_default({}, theme.scrollbar, component);
  component.size = trackSize;
}
function computeTitleSize(component, crossSize, crossPadding, position, theme, library3) {
  const _a2 = deep_mix_default({}, theme.title, component), { title, subtitle, spacing = 0 } = _a2, style = __rest73(_a2, ["title", "subtitle", "spacing"]);
  if (title) {
    const titleStyle = subObject(style, "title");
    const titleBBox = computeLabelSize(title, titleStyle);
    component.size = titleBBox.height;
  }
  if (subtitle) {
    const subtitleStyle = subObject(style, "subtitle");
    const subtitleBBox = computeLabelSize(subtitle, subtitleStyle);
    component.size += spacing + subtitleBBox.height;
  }
}
function computeSliderSize(component, crossSize, crossPadding, position, theme, library3) {
  const styleOf2 = () => {
    const { slider } = theme;
    return deep_mix_default({}, slider, component);
  };
  const { trackSize, handleIconSize } = styleOf2();
  const size3 = Math.max(trackSize, handleIconSize * 2.4);
  component.size = size3;
}
function computeAxisSize(component, crossSize, crossPadding, position, theme, library3) {
  var _a2;
  component.transform = component.transform || [{ type: "hide" }];
  const isVertical2 = position === "left" || position === "right";
  const style = styleOf(component, position, theme);
  const { tickLength = 0, labelSpacing = 0, titleSpacing = 0, labelAutoRotate } = style, rest = __rest73(style, ["tickLength", "labelSpacing", "titleSpacing", "labelAutoRotate"]);
  const scale11 = createScale(component, library3);
  const labelBBoxes = computeLabelsBBox(rest, scale11);
  const paddingTick = tickLength + labelSpacing;
  if (labelBBoxes && labelBBoxes.length) {
    const maxLabelWidth = max5(labelBBoxes, (d3) => d3.width);
    const maxLabelHeight = max5(labelBBoxes, (d3) => d3.height);
    if (isVertical2) {
      component.size = maxLabelWidth + paddingTick;
    } else {
      const { tickFilter, labelTransform } = component;
      if (overflowX(scale11, labelBBoxes, crossSize, crossPadding, tickFilter) && !labelTransform && labelAutoRotate !== false && labelAutoRotate !== null) {
        component.labelTransform = "rotate(90)";
        component.size = maxLabelWidth + paddingTick;
      } else {
        component.labelTransform = (_a2 = component.labelTransform) !== null && _a2 !== void 0 ? _a2 : "rotate(0)";
        component.size = maxLabelHeight + paddingTick;
      }
    }
  } else {
    component.size = tickLength;
  }
  const titleBBox = computeTitleBBox(rest);
  if (titleBBox) {
    if (isVertical2) {
      component.size += titleSpacing + titleBBox.width;
    } else {
      component.size += titleSpacing + titleBBox.height;
    }
  }
}
function computeContinuousLegendSize(component, crossSize, crossPadding, position, theme, library3) {
  const styleOf2 = () => {
    const { legendContinuous } = theme;
    return deep_mix_default({}, legendContinuous, component);
  };
  const _a2 = styleOf2(), { labelSpacing = 0, titleSpacing = 0 } = _a2, rest = __rest73(_a2, ["labelSpacing", "titleSpacing"]);
  const isVertical2 = position === "left" || position === "right";
  const ribbonStyles = subObject(rest, "ribbon");
  const { size: ribbonSize } = ribbonStyles;
  const handleIconStyles = subObject(rest, "handleIcon");
  const { size: handleIconSize } = handleIconStyles;
  const mainSize = Math.max(ribbonSize, handleIconSize * 2.4);
  component.size = mainSize;
  const scale11 = createScale(component, library3);
  const labelBBoxes = computeLabelsBBox(rest, scale11);
  if (labelBBoxes) {
    const key = isVertical2 ? "width" : "height";
    const size3 = max5(labelBBoxes, (d3) => d3[key]);
    component.size += size3 + labelSpacing;
  }
  const titleBBox = computeTitleBBox(rest);
  if (titleBBox) {
    if (isVertical2) {
      component.size = Math.max(component.size, titleBBox.width);
    } else {
      component.size += titleSpacing + titleBBox.height;
    }
  }
}
function computeCategoryLegendSize(component, crossSize0, crossPadding, position, theme, library3) {
  const styleOf2 = () => {
    const { legendCategory } = theme;
    const { title } = component;
    const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [title, void 0] : [void 0, title];
    return deep_mix_default({ title: defaultTitle }, legendCategory, Object.assign(Object.assign({}, component), { title: specifiedTitle }));
  };
  const _a2 = styleOf2(), { itemSpacing, itemMarkerSize, titleSpacing, rowPadding, colPadding, maxCols = Infinity, maxRows = Infinity } = _a2, rest = __rest73(_a2, ["itemSpacing", "itemMarkerSize", "titleSpacing", "rowPadding", "colPadding", "maxCols", "maxRows"]);
  const { cols, length: length5 } = component;
  const getRows = (rows) => Math.min(rows, maxRows);
  const getCols = (cols2) => Math.min(cols2, maxCols);
  const isVertical2 = position === "left" || position === "right";
  const crossSize = length5 === void 0 ? crossSize0 + (isVertical2 ? 0 : crossPadding[0] + crossPadding[1]) : length5;
  const titleBBox = computeTitleBBox(rest);
  const scale11 = createScale(component, library3);
  const labelBBoxes = computeLabelsBBox(rest, scale11, "itemLabel");
  const height = Math.max(labelBBoxes[0].height, itemMarkerSize) + rowPadding;
  const widthOf = (w, padding = 0) => itemMarkerSize + w + itemSpacing[0] + padding;
  const computeVerticalSize = () => {
    let maxSize = -Infinity;
    let pos = 0;
    let cols2 = 1;
    let rows = 0;
    let maxRows2 = -Infinity;
    let maxPos = -Infinity;
    const titleHeight = titleBBox ? titleBBox.height : 0;
    const maxHeight = crossSize - titleHeight;
    for (const { width } of labelBBoxes) {
      const w = widthOf(width, colPadding);
      maxSize = Math.max(maxSize, w);
      if (pos + height > maxHeight) {
        cols2++;
        maxRows2 = Math.max(maxRows2, rows);
        maxPos = Math.max(maxPos, pos);
        rows = 1;
        pos = height;
      } else {
        pos += height;
        rows++;
      }
    }
    if (cols2 <= 1) {
      maxRows2 = rows;
      maxPos = pos;
    }
    component.size = maxSize * getCols(cols2);
    component.length = maxPos + titleHeight;
    deep_mix_default(component, { cols: getCols(cols2), gridRow: maxRows2 });
  };
  const computeHorizontalGrid = () => {
    const rows = Math.ceil(labelBBoxes.length / cols);
    const maxWidth = max5(labelBBoxes, (d3) => widthOf(d3.width)) * cols;
    component.size = height * getRows(rows) - rowPadding;
    component.length = Math.min(maxWidth, crossSize);
  };
  const computeHorizontalFlex = () => {
    let rows = 1;
    let pos = 0;
    let maxPos = -Infinity;
    for (const { width } of labelBBoxes) {
      const w = widthOf(width, colPadding);
      if (pos + w > crossSize) {
        maxPos = Math.max(maxPos, pos);
        pos = w;
        rows++;
      } else {
        pos += w;
      }
    }
    if (rows === 1)
      maxPos = pos;
    component.size = height * getRows(rows) - rowPadding;
    component.length = maxPos;
  };
  if (isVertical2)
    computeVerticalSize();
  else if (typeof cols === "number")
    computeHorizontalGrid();
  else
    computeHorizontalFlex();
  if (titleBBox) {
    if (isVertical2) {
      component.size = Math.max(component.size, titleBBox.width);
    } else {
      component.size += titleSpacing + titleBBox.height;
    }
  }
}
function createScale(component, library3) {
  const [useScale] = useLibrary("scale", library3);
  const { scales, tickCount, tickMethod } = component;
  const scaleOptions = scales.find((d3) => d3.type !== "constant" && d3.type !== "identity");
  if (tickCount !== void 0)
    scaleOptions.tickCount = tickCount;
  if (tickMethod !== void 0)
    scaleOptions.tickMethod = tickMethod;
  return useScale(scaleOptions);
}
function computeLabelsBBox(component, scale11, key = "label") {
  const { labelFormatter: labelFormatter2, tickFilter, label = true } = component, style = __rest73(component, ["labelFormatter", "tickFilter", "label"]);
  if (!label)
    return null;
  const labels = labelsOf(scale11, labelFormatter2, tickFilter);
  const labelStyle = subObject(style, key);
  const labelStyles = labels.map((d3, i) => Object.fromEntries(Object.entries(labelStyle).map(([key2, value2]) => [
    key2,
    typeof value2 === "function" ? value2(d3, i) : value2
  ])));
  const labelBBoxes = labels.map((d3, i) => {
    const normalizeStyle = labelStyles[i];
    return computeLabelSize(d3, normalizeStyle);
  });
  const hasTransform = labelStyles.some((d3) => d3.transform);
  if (!hasTransform) {
    const I = labels.map((_2, i) => i);
    component.indexBBox = new Map(I.map((i) => [i, [labels[i], labelBBoxes[i]]]));
  }
  return labelBBoxes;
}
function computeTitleBBox(component) {
  const isFalsy = (x3) => x3 === false || x3 === null;
  const { title } = component, style = __rest73(component, ["title"]);
  if (isFalsy(title) || title === void 0)
    return null;
  const titleStyle = subObject(style, "title");
  const { direction: direction3, transform: transform2 } = titleStyle;
  const titleText = Array.isArray(title) ? title.join(",") : title;
  if (typeof titleText !== "string")
    return null;
  const titleBBox = computeLabelSize(titleText, Object.assign(Object.assign({}, titleStyle), { transform: transform2 || (direction3 === "vertical" ? "rotate(-90)" : "") }));
  return titleBBox;
}
function styleOf(axis, position, theme) {
  const { title } = axis;
  const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [title, void 0] : [void 0, title];
  const {
    axis: baseStyle,
    // @ts-ignore
    [`axis${capitalizeFirst(position)}`]: positionStyle
  } = theme;
  return deep_mix_default({ title: defaultTitle }, baseStyle, positionStyle, Object.assign(Object.assign({}, axis), { title: specifiedTitle }));
}
function ticksOf2(scale11, tickFilter) {
  const ticks2 = scale11.getTicks ? scale11.getTicks() : scale11.getOptions().domain;
  if (!tickFilter)
    return ticks2;
  return ticks2.filter(tickFilter);
}
function labelsOf(scale11, labelFormatter2, tickFilter) {
  const T = ticksOf2(scale11, tickFilter);
  const ticks2 = T.map((d3) => typeof d3 === "number" ? prettyNumber2(d3) : d3);
  const formatter2 = labelFormatter2 ? typeof labelFormatter2 === "string" ? format2(labelFormatter2) : labelFormatter2 : scale11.getFormatter ? scale11.getFormatter() : (d3) => `${d3}`;
  return ticks2.map(formatter2);
}
function offsetOf(scale11, d3) {
  if (!scale11.getBandWidth)
    return 0;
  const offset2 = scale11.getBandWidth(d3) / 2;
  return offset2;
}
function overflowX(scale11, labelBBoxes, crossSize, crossPadding, tickFilter) {
  const totalSize = sum(labelBBoxes, (d3) => d3.width);
  if (totalSize > crossSize)
    return true;
  const scaleX2 = scale11.clone();
  scaleX2.update({ range: [0, crossSize] });
  const ticks2 = ticksOf2(scale11, tickFilter);
  const X = ticks2.map((d3) => scaleX2.map(d3) + offsetOf(scaleX2, d3));
  const I = ticks2.map((_2, i) => i);
  const startX = -crossPadding[0];
  const endX = crossSize + crossPadding[1];
  const extent2 = (x3, bbox) => {
    const { width } = bbox;
    return [x3 - width / 2, x3 + width / 2];
  };
  for (let i = 0; i < I.length; i++) {
    const x3 = X[i];
    const [x05, x12] = extent2(x3, labelBBoxes[i]);
    if (x05 < startX || x12 > endX)
      return true;
    const y3 = X[i + 1];
    if (y3) {
      const [y05] = extent2(y3, labelBBoxes[i + 1]);
      if (x12 > y05)
        return true;
    }
  }
  return false;
}
function computeLabelSize(d3, style) {
  const shape23 = normalizeLabel(d3);
  const { filter: filter3 } = style, rest = __rest73(style, ["filter"]);
  shape23.attr(Object.assign(Object.assign({}, rest), { visibility: "none" }));
  const bbox = shape23.getBBox();
  return bbox;
}
function normalizeLabel(d3) {
  if (d3 instanceof DisplayObject)
    return d3;
  return new Text({ style: { text: `${d3}` } });
}

// node_modules/@antv/g2/esm/runtime/layout.js
function processAxisZ(components) {
  const axisX = components.find(({ type }) => type === "axisX");
  const axisY = components.find(({ type }) => type === "axisY");
  const axisZ = components.find(({ type }) => type === "axisZ");
  if (axisX && axisY && axisZ) {
    axisX.plane = "xy";
    axisY.plane = "xy";
    axisZ.plane = "yz";
    axisZ.origin = [axisX.bbox.x, axisX.bbox.y, 0];
    axisZ.eulerAngles = [0, -90, 0];
    axisZ.bbox.x = axisX.bbox.x;
    axisZ.bbox.y = axisX.bbox.y;
    components.push(Object.assign(Object.assign({}, axisX), { plane: "xz", showLabel: false, showTitle: false, origin: [axisX.bbox.x, axisX.bbox.y, 0], eulerAngles: [-90, 0, 0] }));
    components.push(Object.assign(Object.assign({}, axisY), { plane: "yz", showLabel: false, showTitle: false, origin: [axisY.bbox.x + axisY.bbox.width, axisY.bbox.y, 0], eulerAngles: [0, -90, 0] }));
    components.push(Object.assign(Object.assign({}, axisZ), { plane: "xz", actualPosition: "left", showLabel: false, showTitle: false, eulerAngles: [90, -90, 0] }));
  }
}
function computeLayout(components, options, theme, library3) {
  var _a2, _b;
  const { width, height, depth, x: x3 = 0, y: y3 = 0, z = 0, inset = (_a2 = theme.inset) !== null && _a2 !== void 0 ? _a2 : 0, insetLeft = inset, insetTop = inset, insetBottom = inset, insetRight = inset, margin = (_b = theme.margin) !== null && _b !== void 0 ? _b : 0, marginLeft = margin, marginBottom = margin, marginTop = margin, marginRight = margin, padding = theme.padding, paddingBottom = padding, paddingLeft = padding, paddingRight = padding, paddingTop = padding } = computeInset(components, options, theme, library3);
  const MIN_CONTENT_RATIO = 1 / 4;
  const maybeClamp = (viewWidth2, paddingLeft2, paddingRight2, pl02, pr02) => {
    const { marks } = options;
    if (marks.length === 0)
      return [pl02, pr02];
    const contentSize = viewWidth2 - pl02 - pr02;
    const diff = contentSize - viewWidth2 * MIN_CONTENT_RATIO;
    if (diff > 0)
      return [pl02, pr02];
    const shrinkSize = viewWidth2 * (1 - MIN_CONTENT_RATIO);
    return [
      paddingLeft2 === "auto" ? shrinkSize * pl02 / (pl02 + pr02) : pl02,
      paddingRight2 === "auto" ? shrinkSize * pr02 / (pl02 + pr02) : pr02
    ];
  };
  const roughPadding = (padding2) => padding2 === "auto" ? 20 : padding2 !== null && padding2 !== void 0 ? padding2 : 20;
  const rpt = roughPadding(paddingTop);
  const rpb = roughPadding(paddingBottom);
  const horizontalPadding = computePadding(components, height - rpt - rpb, [rpt + marginTop, rpb + marginBottom], ["left", "right"], options, theme, library3);
  const { paddingLeft: pl0, paddingRight: pr0 } = horizontalPadding;
  const viewWidth = width - marginLeft - marginRight;
  const [pl, pr] = maybeClamp(viewWidth, paddingLeft, paddingRight, pl0, pr0);
  const iw = viewWidth - pl - pr;
  const verticalPadding = computePadding(components, iw, [pl + marginLeft, pr + marginRight], ["bottom", "top"], options, theme, library3);
  const { paddingTop: pt0, paddingBottom: pb0 } = verticalPadding;
  const viewHeight = height - marginBottom - marginTop;
  const [pb, pt] = maybeClamp(viewHeight, paddingBottom, paddingTop, pb0, pt0);
  const ih = viewHeight - pb - pt;
  return {
    width,
    height,
    depth,
    insetLeft,
    insetTop,
    insetBottom,
    insetRight,
    innerWidth: iw,
    innerHeight: ih,
    paddingLeft: pl,
    paddingRight: pr,
    paddingTop: pt,
    paddingBottom: pb,
    marginLeft,
    marginBottom,
    marginTop,
    marginRight,
    x: x3,
    y: y3,
    z
  };
}
function computeRoughPlotSize(options) {
  const { height, width, padding = 0, paddingLeft = padding, paddingRight = padding, paddingTop = padding, paddingBottom = padding, margin = 16, marginLeft = margin, marginRight = margin, marginTop = margin, marginBottom = margin, inset = 0, insetLeft = inset, insetRight = inset, insetTop = inset, insetBottom = inset } = options;
  const maybeAuto = (padding2) => padding2 === "auto" ? 20 : padding2;
  const finalWidth = width - maybeAuto(paddingLeft) - maybeAuto(paddingRight) - marginLeft - marginRight - insetLeft - insetRight;
  const finalHeight = height - maybeAuto(paddingTop) - maybeAuto(paddingBottom) - marginTop - marginBottom - insetTop - insetBottom;
  return { width: finalWidth, height: finalHeight };
}
function computeInset(components, options, theme, library3) {
  const { coordinates } = options;
  if (!isPolar2(coordinates) && !isRadial2(coordinates)) {
    return options;
  }
  const axes = components.filter((d3) => typeof d3.type === "string" && d3.type.startsWith("axis"));
  if (axes.length === 0)
    return options;
  const styles = axes.map((component) => {
    const key = component.type === "axisArc" ? "arc" : "linear";
    return styleOf(component, key, theme);
  });
  const maxLabelSpacing = max5(styles, (d3) => {
    var _a2;
    return (_a2 = d3.labelSpacing) !== null && _a2 !== void 0 ? _a2 : 0;
  });
  const labelBBoxes = axes.flatMap((component, i) => {
    const style = styles[i];
    const scale11 = createScale(component, library3);
    const labels = computeLabelsBBox(style, scale11);
    return labels;
  }).filter(defined);
  const size3 = max5(labelBBoxes, (d3) => d3.height) + maxLabelSpacing;
  const titleBBoxes = axes.flatMap((_2, i) => {
    const style = styles[i];
    return computeTitleBBox(style);
  }).filter((d3) => d3 !== null);
  const titleSize = titleBBoxes.length === 0 ? 0 : max5(titleBBoxes, (d3) => d3.height);
  const { inset = size3, insetLeft = inset, insetBottom = inset, insetTop = inset + titleSize, insetRight = inset } = options;
  return Object.assign(Object.assign({}, options), { insetLeft, insetBottom, insetTop, insetRight });
}
function computePadding(components, crossSize, crossPadding, positions, options, theme, library3) {
  const positionComponents = group(components, (d3) => d3.position);
  const { padding = theme.padding, paddingLeft = padding, paddingRight = padding, paddingBottom = padding, paddingTop = padding } = options;
  const layout = {
    paddingBottom,
    paddingLeft,
    paddingTop,
    paddingRight
  };
  for (const position of positions) {
    const key = `padding${capitalizeFirst(camelCase(position))}`;
    const components2 = positionComponents.get(position) || [];
    const value2 = layout[key];
    const defaultSizeOf = (d3) => {
      if (d3.size === void 0)
        d3.size = d3.defaultSize;
    };
    const sizeOf3 = (d3) => {
      if (d3.type === "group") {
        d3.children.forEach(defaultSizeOf);
        d3.size = max5(d3.children, (d4) => d4.size);
      } else {
        d3.size = d3.defaultSize;
      }
    };
    const autoSizeOf = (d3) => {
      if (d3.size)
        return;
      if (value2 !== "auto")
        sizeOf3(d3);
      else {
        computeComponentSize(d3, crossSize, crossPadding, position, theme, library3);
        defaultSizeOf(d3);
      }
    };
    const maybeHide = (d3) => {
      if (!d3.type.startsWith("axis"))
        return;
      if (d3.labelAutoHide === void 0)
        d3.labelAutoHide = true;
    };
    const isHorizontal3 = position === "bottom" || position === "top";
    const minOrder = min4(components2, (d3) => d3.order);
    const axes = components2.filter((d3) => d3.type.startsWith("axis") && d3.order == minOrder);
    if (axes.length)
      axes[0].crossPadding = 0;
    if (typeof value2 === "number") {
      components2.forEach(defaultSizeOf);
      components2.forEach(maybeHide);
    } else {
      if (components2.length === 0) {
        layout[key] = 0;
      } else {
        const size3 = isHorizontal3 ? crossSize + crossPadding[0] + crossPadding[1] : crossSize;
        const grouped = groupComponents(components2, size3);
        grouped.forEach(autoSizeOf);
        const totalSize = grouped.reduce((sum4, { size: size4, crossPadding: crossPadding2 = 12 }) => sum4 + size4 + crossPadding2, 0);
        layout[key] = totalSize;
      }
    }
  }
  return layout;
}
function placeComponents(components, coordinate, layout) {
  const positionComponents = group(components, (d3) => `${d3.plane || "xy"}-${d3.position}`);
  const { paddingLeft, paddingRight, paddingTop, paddingBottom, marginLeft, marginTop, marginBottom, marginRight, innerHeight, innerWidth, insetBottom, insetLeft, insetRight, insetTop, height, width, depth } = layout;
  const planes = {
    xy: createSection({
      width,
      height,
      paddingLeft,
      paddingRight,
      paddingTop,
      paddingBottom,
      marginLeft,
      marginTop,
      marginBottom,
      marginRight,
      innerHeight,
      innerWidth,
      insetBottom,
      insetLeft,
      insetRight,
      insetTop
    }),
    yz: createSection({
      width: depth,
      height,
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0,
      marginLeft: 0,
      marginTop: 0,
      marginBottom: 0,
      marginRight: 0,
      innerWidth: depth,
      innerHeight: height,
      insetBottom: 0,
      insetLeft: 0,
      insetRight: 0,
      insetTop: 0
    }),
    xz: createSection({
      width,
      height: depth,
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0,
      marginLeft: 0,
      marginTop: 0,
      marginBottom: 0,
      marginRight: 0,
      innerWidth: width,
      innerHeight: depth,
      insetBottom: 0,
      insetLeft: 0,
      insetRight: 0,
      insetTop: 0
    })
  };
  for (const [key, components2] of positionComponents.entries()) {
    const [plane, position] = key.split("-");
    const area2 = planes[plane][position];
    const [nonEntityComponents, entityComponents] = divide4(components2, (component) => {
      if (typeof component.type !== "string")
        return false;
      if (position === "center")
        return true;
      if (component.type.startsWith("axis") && ["inner", "outer"].includes(position)) {
        return true;
      }
      return false;
    });
    if (nonEntityComponents.length) {
      placeNonEntityComponents(nonEntityComponents, coordinate, area2, position);
    }
    if (entityComponents.length) {
      placePaddingArea(components2, coordinate, area2);
    }
  }
}
function createSection({ width, height, paddingLeft, paddingRight, paddingTop, paddingBottom, marginLeft, marginTop, marginBottom, marginRight, innerHeight, innerWidth, insetBottom, insetLeft, insetRight, insetTop }) {
  const pl = paddingLeft + marginLeft;
  const pt = paddingTop + marginTop;
  const pr = paddingRight + marginRight;
  const pb = paddingBottom + marginBottom;
  const plotWidth = width - marginLeft - marginRight;
  const centerSection = [
    pl + insetLeft,
    pt + insetTop,
    innerWidth - insetLeft - insetRight,
    innerHeight - insetTop - insetBottom,
    "center",
    null,
    null
  ];
  const xySection = {
    top: [
      pl,
      0,
      innerWidth,
      pt,
      "vertical",
      true,
      ascending,
      marginLeft,
      plotWidth
    ],
    right: [width - pr, pt, pr, innerHeight, "horizontal", false, ascending],
    bottom: [
      pl,
      height - pb,
      innerWidth,
      pb,
      "vertical",
      false,
      ascending,
      marginLeft,
      plotWidth
    ],
    left: [0, pt, pl, innerHeight, "horizontal", true, ascending],
    "top-left": [pl, 0, innerWidth, pt, "vertical", true, ascending],
    "top-right": [pl, 0, innerWidth, pt, "vertical", true, ascending],
    "bottom-left": [
      pl,
      height - pb,
      innerWidth,
      pb,
      "vertical",
      false,
      ascending
    ],
    "bottom-right": [
      pl,
      height - pb,
      innerWidth,
      pb,
      "vertical",
      false,
      ascending
    ],
    center: centerSection,
    inner: centerSection,
    outer: centerSection
  };
  return xySection;
}
function placeNonEntityComponents(components, coordinate, area2, position) {
  const [axisComponents, nonAxisComponents] = divide4(components, (component) => {
    if (typeof component.type === "string" && component.type.startsWith("axis")) {
      return true;
    }
    return false;
  });
  placeNonEntityAxis(axisComponents, coordinate, area2, position);
  placeCenter(nonAxisComponents, coordinate, area2);
}
function placeNonEntityAxis(components, coordinate, area2, position) {
  if (position === "center") {
    if (isRadar(coordinate)) {
      placeAxisRadar(components, coordinate, area2, position);
    } else if (isPolar(coordinate)) {
      placeArcLinear(components, coordinate, area2);
    } else if (isParallel(coordinate)) {
      placeAxisParallel(components, coordinate, area2, components[0].orientation);
    }
  } else if (position === "inner") {
    placeAxisArcInner(components, coordinate, area2);
  } else if (position === "outer") {
    placeAxisArcOuter(components, coordinate, area2);
  }
}
function placeAxisArcInner(components, coordinate, area2) {
  const [x3, y3, , height] = area2;
  const [cx, cy] = coordinate.getCenter();
  const [innerRadius] = radiusOf(coordinate);
  const r = height / 2;
  const size3 = innerRadius * r;
  const x05 = cx - size3;
  const y05 = cy - size3;
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    component.bbox = {
      x: x3 + x05,
      y: y3 + y05,
      width: size3 * 2,
      height: size3 * 2
    };
  }
}
function placeAxisArcOuter(components, coordinate, area2) {
  const [x3, y3, width, height] = area2;
  for (const component of components) {
    component.bbox = { x: x3, y: y3, width, height };
  }
}
function placeArcLinear(components, coordinate, area2) {
  const [x3, y3, width, height] = area2;
  for (const component of components) {
    component.bbox = { x: x3, y: y3, width, height };
  }
}
function placeAxisParallel(components, coordinate, area2, orientation) {
  if (orientation === "horizontal") {
    placeAxisParallelHorizontal(components, coordinate, area2);
  } else if (orientation === "vertical") {
    placeAxisParallelVertical(components, coordinate, area2);
  }
}
function placeAxisParallelVertical(components, coordinate, area2) {
  const [x3, y3, , height] = area2;
  const vector = new Array(components.length).fill(0);
  const points = coordinate.map(vector);
  const X = points.filter((_2, i) => i % 2 === 0).map((d3) => d3 + x3);
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    const x4 = X[i];
    const width = X[i + 1] - x4;
    component.bbox = { x: x4, y: y3, width, height };
  }
}
function placeAxisParallelHorizontal(components, coordinate, area2) {
  const [x3, y3, width] = area2;
  const vector = new Array(components.length).fill(0);
  const points = coordinate.map(vector);
  const Y = points.filter((_2, i) => i % 2 === 1).map((d3) => d3 + y3);
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    const y4 = Y[i];
    const height = Y[i + 1] - y4;
    component.bbox = { x: x3, y: y4, width, height };
  }
}
function placeAxisRadar(components, coordinate, area2, position) {
  const [x3, y3, width, height] = area2;
  for (const component of components) {
    component.bbox = { x: x3, y: y3, width, height };
    component.radar = {
      index: components.indexOf(component),
      count: components.length
    };
  }
}
function placePaddingArea(components, coordinate, area2) {
  const [x3, y3, width, height, direction3, reverse2, comparator, minX, totalSize] = area2;
  const [mainStartKey, mainStartValue, crossStartKey, crossStartValue, mainSizeKey, mainSizeValue, crossSizeKey, crossSizeValue] = direction3 === "vertical" ? ["y", y3, "x", x3, "height", height, "width", width] : ["x", x3, "y", y3, "width", width, "height", height];
  components.sort((a4, b) => comparator === null || comparator === void 0 ? void 0 : comparator(a4.order, b.order));
  const isLarge = (type) => type === "title" || type === "group" || type.startsWith("legend");
  const crossSizeOf = (type, small, bigger) => {
    if (bigger === void 0)
      return small;
    if (isLarge(type))
      return bigger;
    return small;
  };
  const crossStartOf = (type, x4, minX2) => {
    if (minX2 === void 0)
      return x4;
    if (isLarge(type))
      return minX2;
    return x4;
  };
  const startValue = reverse2 ? mainStartValue + mainSizeValue : mainStartValue;
  for (let i = 0, start = startValue; i < components.length; i++) {
    const component = components[i];
    const { crossPadding = 0, type } = component;
    const { size: size3 } = component;
    component.bbox = {
      [mainStartKey]: reverse2 ? start - size3 - crossPadding : start + crossPadding,
      [crossStartKey]: crossStartOf(type, crossStartValue, minX),
      [mainSizeKey]: size3,
      [crossSizeKey]: crossSizeOf(type, crossSizeValue, totalSize)
    };
    start += (size3 + crossPadding) * (reverse2 ? -1 : 1);
  }
  const groupComponents2 = components.filter((d3) => d3.type === "group");
  for (const group3 of groupComponents2) {
    const { bbox, children } = group3;
    const size3 = bbox[crossSizeKey];
    const step2 = size3 / children.length;
    const justifyContent = children.reduce((j, child) => {
      var _a2;
      const j0 = (_a2 = child.layout) === null || _a2 === void 0 ? void 0 : _a2.justifyContent;
      return j0 ? j0 : j;
    }, "flex-start");
    const L = children.map((d3, i) => {
      const { length: length5 = step2, padding = 0 } = d3;
      return length5 + (i === children.length - 1 ? 0 : padding);
    });
    const totalLength = sum(L);
    const diff = size3 - totalLength;
    const offset2 = justifyContent === "flex-start" ? 0 : justifyContent === "center" ? diff / 2 : diff;
    for (let i = 0, start = bbox[crossStartKey] + offset2; i < children.length; i++) {
      const component = children[i];
      const { padding = 0 } = component;
      const interval2 = i === children.length - 1 ? 0 : padding;
      component.bbox = {
        [mainSizeKey]: bbox[mainSizeKey],
        [mainStartKey]: bbox[mainStartKey],
        [crossStartKey]: start,
        [crossSizeKey]: L[i] - interval2
      };
      deep_mix_default(component, { layout: { justifyContent } });
      start += L[i];
    }
  }
}
function placeCenter(components, coordinate, area2) {
  if (components.length === 0)
    return;
  const [x3, y3, width, height] = area2;
  const [innerRadius] = radiusOf(coordinate);
  const r = height / 2 * innerRadius / Math.sqrt(2);
  const cx = x3 + width / 2;
  const cy = y3 + height / 2;
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    component.bbox = { x: cx - r, y: cy - r, width: r * 2, height: r * 2 };
  }
}

// node_modules/@antv/g2/esm/runtime/transform.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest74 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function applyDefaults(I, mark2, context) {
  const { encode = {}, scale: scale11 = {}, transform: transform2 = [] } = mark2, rest = __rest74(mark2, ["encode", "scale", "transform"]);
  return [I, Object.assign(Object.assign({}, rest), { encode, scale: scale11, transform: transform2 })];
}
function applyDataTransform(I, mark2, context) {
  return __awaiter3(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const { data: data2 } = mark2;
    const [useData] = useLibrary("data", library3);
    const descriptor = normalizedDataSource(data2);
    const { transform: T = [] } = descriptor, connector = __rest74(descriptor, ["transform"]);
    const transform2 = [connector, ...T];
    const transformFunctions2 = transform2.map((t) => useData(t, context));
    const transformedData = yield composeAsync(transformFunctions2)(data2);
    const newData = data2 && !Array.isArray(data2) && !Array.isArray(transformedData) ? { value: transformedData } : transformedData;
    return [
      Array.isArray(transformedData) ? indexOf3(transformedData) : [],
      Object.assign(Object.assign({}, mark2), { data: newData })
    ];
  });
}
function flatEncode(I, mark2, context) {
  const { encode } = mark2;
  if (!encode)
    return [I, mark2];
  const flattenEncode = {};
  for (const [key, value2] of Object.entries(encode)) {
    if (Array.isArray(value2)) {
      for (let i = 0; i < value2.length; i++) {
        const name2 = `${key}${i === 0 ? "" : i}`;
        flattenEncode[name2] = value2[i];
      }
    } else {
      flattenEncode[key] = value2;
    }
  }
  return [I, Object.assign(Object.assign({}, mark2), { encode: flattenEncode })];
}
function inferChannelsType(I, mark2, context) {
  const { encode, data: data2 } = mark2;
  if (!encode)
    return [I, mark2];
  const typedEncode = mapObject(encode, (channel) => {
    if (isTypedChannel(channel))
      return channel;
    const type = inferChannelType(data2, channel);
    return { type, value: channel };
  });
  return [I, Object.assign(Object.assign({}, mark2), { encode: typedEncode })];
}
function maybeVisualChannel(I, mark2, context) {
  const { encode } = mark2;
  if (!encode)
    return [I, mark2];
  const newEncode = mapObject(encode, (channel, name2) => {
    const { type } = channel;
    if (type !== "constant" || isPosition(name2))
      return channel;
    return Object.assign(Object.assign({}, channel), { constant: true });
  });
  return [I, Object.assign(Object.assign({}, mark2), { encode: newEncode })];
}
function extractColumns(I, mark2, context) {
  const { encode, data: data2 } = mark2;
  if (!encode)
    return [I, mark2];
  const { library: library3 } = context;
  const columnOf2 = createColumnOf(library3);
  const valuedEncode = mapObject(encode, (channel) => columnOf2(data2, channel));
  return [I, Object.assign(Object.assign({}, mark2), { encode: valuedEncode })];
}
function normalizeTooltip(I, mark2, context) {
  const { tooltip: tooltip2 = {} } = mark2;
  if (isUnset(tooltip2))
    return [I, mark2];
  if (Array.isArray(tooltip2)) {
    return [I, Object.assign(Object.assign({}, mark2), { tooltip: { items: tooltip2 } })];
  }
  if (isStrictObject(tooltip2) && isFullTooltip(tooltip2)) {
    return [I, Object.assign(Object.assign({}, mark2), { tooltip: tooltip2 })];
  }
  return [I, Object.assign(Object.assign({}, mark2), { tooltip: { items: [tooltip2] } })];
}
function extractTooltip(I, mark2, context) {
  const { data: data2, encode, tooltip: tooltip2 = {} } = mark2;
  if (isUnset(tooltip2))
    return [I, mark2];
  const valueOf4 = (item) => {
    if (!item)
      return item;
    if (typeof item === "string") {
      return I.map((i) => ({ name: item, value: data2[i][item] }));
    }
    if (isStrictObject(item)) {
      const { field: field3, channel, color: color3, name: name2 = field3, valueFormatter = (d3) => d3 } = item;
      const normalizedValueFormatter = typeof valueFormatter === "string" ? format2(valueFormatter) : valueFormatter;
      const definedChannel = channel && encode[channel];
      const channelField = definedChannel && encode[channel].field;
      const name1 = name2 || channelField || channel;
      const values4 = [];
      for (const i of I) {
        const value1 = field3 ? data2[i][field3] : definedChannel ? encode[channel].value[i] : null;
        values4[i] = {
          name: name1,
          color: color3,
          value: normalizedValueFormatter(value1)
        };
      }
      return values4;
    }
    if (typeof item === "function") {
      const values4 = [];
      for (const i of I) {
        const v = item(data2[i], i, data2, encode);
        if (isStrictObject(v))
          values4[i] = v;
        else
          values4[i] = { value: v };
      }
      return values4;
    }
    return item;
  };
  const { title, items = [] } = tooltip2, rest = __rest74(tooltip2, ["title", "items"]);
  const newTooltip = Object.assign({ title: valueOf4(title), items: Array.isArray(items) ? items.map(valueOf4) : [] }, rest);
  return [I, Object.assign(Object.assign({}, mark2), { tooltip: newTooltip })];
}
function maybeArrayField(I, mark2, context) {
  const { encode } = mark2, rest = __rest74(mark2, ["encode"]);
  if (!encode)
    return [I, mark2];
  const columns = Object.entries(encode);
  const arrayColumns = columns.filter(([, channel]) => {
    const { value: V } = channel;
    return Array.isArray(V[0]);
  }).flatMap(([key, V]) => {
    const columns2 = [[key, new Array(I.length).fill(void 0)]];
    const { value: rows } = V, rest2 = __rest74(V, ["value"]);
    for (let i = 0; i < rows.length; i++) {
      const row2 = rows[i];
      if (Array.isArray(row2)) {
        for (let j = 0; j < row2.length; j++) {
          const column2 = columns2[j] || [
            `${key}${j}`,
            new Array(I).fill(void 0)
          ];
          column2[1][i] = row2[j];
          columns2[j] = column2;
        }
      }
    }
    return columns2.map(([key2, value2]) => [
      key2,
      Object.assign({ type: "column", value: value2 }, rest2)
    ]);
  });
  const newEncode = Object.fromEntries([...columns, ...arrayColumns]);
  return [I, Object.assign(Object.assign({}, rest), { encode: newEncode })];
}
function addGuideToScale(I, mark2, context) {
  const { axis = {}, legend = {}, slider = {}, scrollbar = {} } = mark2;
  const normalize10 = (guide, channel) => {
    if (typeof guide === "boolean")
      return guide ? {} : null;
    const eachGuide = guide[channel];
    return eachGuide === void 0 || eachGuide ? eachGuide : null;
  };
  const axisChannels = typeof axis === "object" ? Array.from(/* @__PURE__ */ new Set(["x", "y", "z", ...Object.keys(axis)])) : ["x", "y", "z"];
  deep_mix_default(mark2, {
    scale: Object.assign(Object.assign({}, Object.fromEntries(axisChannels.map((channel) => {
      const scrollbarOptions = normalize10(scrollbar, channel);
      return [
        channel,
        Object.assign({ guide: normalize10(axis, channel), slider: normalize10(slider, channel), scrollbar: scrollbarOptions }, scrollbarOptions && {
          ratio: scrollbarOptions.ratio === void 0 ? 0.5 : scrollbarOptions.ratio
        })
      ];
    }))), {
      color: { guide: normalize10(legend, "color") },
      size: { guide: normalize10(legend, "size") },
      shape: { guide: normalize10(legend, "shape") },
      // fixme: opacity is conflict with DisplayObject.opacity
      // to be confirm.
      opacity: { guide: normalize10(legend, "opacity") }
    })
  });
  return [I, mark2];
}
function maybeNonAnimate(I, mark2, context) {
  const { animate: animate2 } = mark2;
  if (animate2 || animate2 === void 0)
    return [I, mark2];
  deep_mix_default(mark2, {
    animate: {
      enter: { type: null },
      exit: { type: null },
      update: { type: null }
    }
  });
  return [I, mark2];
}
function isTypedChannel(channel) {
  if (typeof channel !== "object" || channel instanceof Date || channel === null) {
    return false;
  }
  const { type } = channel;
  return defined(type);
}
function inferChannelType(data2, channel) {
  if (typeof channel === "function")
    return "transform";
  if (typeof channel === "string" && isField(data2, channel))
    return "field";
  return "constant";
}
function isField(data2, value2) {
  if (!Array.isArray(data2))
    return false;
  return data2.some((d3) => d3[value2] !== void 0);
}
function normalizedDataSource(data2) {
  if (isNumber(data2))
    return { type: "inline", value: data2 };
  if (!data2)
    return { type: "inline", value: null };
  if (Array.isArray(data2))
    return { type: "inline", value: data2 };
  const { type = "inline" } = data2, rest = __rest74(data2, ["type"]);
  return Object.assign(Object.assign({}, rest), { type });
}

// node_modules/@antv/g2/esm/runtime/mark.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest75 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function initializeMark(partialMark, partialProps, context) {
  return __awaiter4(this, void 0, void 0, function* () {
    const [I, transformedMark] = yield applyMarkTransform(partialMark, partialProps, context);
    const { encode, scale: scale11, data: data2, tooltip: tooltip2 } = transformedMark;
    if (Array.isArray(data2) === false) {
      return null;
    }
    const { channels: channelDescriptors } = partialProps;
    const nameChannels = rollups(Object.entries(encode).filter(([, value2]) => defined(value2)), (values4) => values4.map(([key, options]) => Object.assign({ name: key }, options)), ([key]) => {
      var _a2;
      const prefix = (_a2 = /([^\d]+)\d*$/.exec(key)) === null || _a2 === void 0 ? void 0 : _a2[1];
      const descriptor = channelDescriptors.find((d3) => d3.name === prefix);
      if (descriptor === null || descriptor === void 0 ? void 0 : descriptor.independent)
        return key;
      return prefix;
    });
    const channels = channelDescriptors.filter((descriptor) => {
      const { name: name2, required: required2 } = descriptor;
      if (nameChannels.find(([d3]) => d3 === name2))
        return true;
      if (required2)
        throw new Error(`Missing encoding for channel: ${name2}.`);
      return false;
    }).flatMap((descriptor) => {
      const { name: name2, scale: scaleType, scaleKey, range: range3, quantitative, ordinal } = descriptor;
      const valuesArray = nameChannels.filter(([channel]) => channel.startsWith(name2));
      return valuesArray.map(([channel, values4], i) => {
        const visual = values4.some((d3) => d3.visual);
        const constant4 = values4.some((d3) => d3.constant);
        const _a2 = scale11[channel] || {}, {
          independent = false,
          // Use channel name as default scale key.
          key = scaleKey || channel,
          // Visual channel use identity scale.
          type = constant4 ? "constant" : visual ? "identity" : scaleType
        } = _a2, scaleOptions = __rest75(_a2, ["independent", "key", "type"]);
        const isConstant = type === "constant";
        const finalRange = isConstant ? void 0 : range3;
        return {
          name: channel,
          values: values4,
          // Generate a unique key for independent channel,
          // which will not group with any other channels.
          scaleKey: independent || isConstant ? Symbol("independent") : key,
          scale: Object.assign(Object.assign({ type, range: finalRange }, scaleOptions), {
            quantitative,
            ordinal
          })
        };
      });
    });
    return [transformedMark, Object.assign(Object.assign({}, partialProps), { index: I, channels, tooltip: tooltip2 })];
  });
}
function createColumnOf(library3) {
  const [useEncode] = useLibrary("encode", library3);
  return (data2, encode) => {
    if (encode === void 0)
      return null;
    if (data2 === void 0)
      return null;
    return Object.assign(Object.assign({}, encode), { type: "column", value: useEncode(encode)(data2), field: fieldOf(encode) });
  };
}
function applyMarkTransform(mark2, props, context) {
  return __awaiter4(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const [useTransform] = useLibrary("transform", library3);
    const { preInference = [], postInference = [] } = props;
    const { transform: transform2 = [] } = mark2;
    const transforms = [
      applyDefaults,
      applyDataTransform,
      flatEncode,
      inferChannelsType,
      maybeVisualChannel,
      extractColumns,
      maybeArrayField,
      maybeNonAnimate,
      addGuideToScale,
      normalizeTooltip,
      ...preInference.map(useTransform),
      ...transform2.map(useTransform),
      ...postInference.map(useTransform),
      extractTooltip
    ];
    let index3 = [];
    let transformedMark = mark2;
    for (const t of transforms) {
      [index3, transformedMark] = yield t(index3, transformedMark, context);
    }
    return [index3, transformedMark];
  });
}
function fieldOf(encode) {
  const { type, value: value2 } = encode;
  if (type === "field" && typeof value2 === "string")
    return value2;
  return null;
}

// node_modules/@antv/g2/esm/runtime/plot.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest76 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function plot(options, selection, context) {
  var _a2;
  return __awaiter5(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const [useComposition] = useLibrary("composition", library3);
    const [useInteraction] = useLibrary("interaction", library3);
    const marks = new Set(Object.keys(library3).map((d3) => {
      var _a3;
      return (_a3 = /mark\.(.*)/.exec(d3)) === null || _a3 === void 0 ? void 0 : _a3[1];
    }).filter(defined));
    const staticMarks = new Set(Object.keys(library3).map((d3) => {
      var _a3;
      return (_a3 = /component\.(.*)/.exec(d3)) === null || _a3 === void 0 ? void 0 : _a3[1];
    }).filter(defined));
    const typeOf = (node) => {
      const { type } = node;
      if (typeof type === "function") {
        const { props = {} } = type;
        const { composite = true } = props;
        if (composite)
          return "mark";
      }
      if (typeof type !== "string")
        return type;
      if (marks.has(type) || staticMarks.has(type))
        return "mark";
      return type;
    };
    const isMark2 = (node) => typeOf(node) === "mark";
    const isStandardView = (node) => typeOf(node) === "standardView";
    const isStaticMark = (node) => {
      const { type } = node;
      if (typeof type !== "string")
        return false;
      if (staticMarks.has(type))
        return true;
      return false;
    };
    const transform2 = (node) => {
      if (isStandardView(node))
        return [node];
      const type = typeOf(node);
      const composition = useComposition({ type, static: isStaticMark(node) });
      return composition(node);
    };
    const views = [];
    const viewNode = /* @__PURE__ */ new Map();
    const nodeState = /* @__PURE__ */ new Map();
    const discovered = [options];
    const nodeGenerators = [];
    while (discovered.length) {
      const node = discovered.shift();
      if (isStandardView(node)) {
        const state = nodeState.get(node);
        const [view, children] = state ? initializeState(state, node, library3) : yield initializeView(node, context);
        viewNode.set(view, node);
        views.push(view);
        const transformedNodes = children.flatMap(transform2).map((d3) => coordinate2Transform(d3, library3));
        discovered.push(...transformedNodes);
        if (transformedNodes.every(isStandardView)) {
          const states = yield Promise.all(transformedNodes.map((d3) => initializeMarks(d3, context)));
          syncFacetsScales(states);
          for (let i = 0; i < transformedNodes.length; i++) {
            const nodeT = transformedNodes[i];
            const state2 = states[i];
            nodeState.set(nodeT, state2);
          }
        }
      } else {
        const n = isMark2(node) ? node : yield applyTransform(node, context);
        const N = transform2(n);
        if (Array.isArray(N))
          discovered.push(...N);
        else if (typeof N === "function")
          nodeGenerators.push(N());
      }
    }
    context.emitter.emit(ChartEvent.BEFORE_PAINT);
    const enterContainer = /* @__PURE__ */ new Map();
    const updateContainer = /* @__PURE__ */ new Map();
    const transitions = [];
    selection.selectAll(className(VIEW_CLASS_NAME)).data(views, (d3) => d3.key).join((enter) => enter.append("g").attr("className", VIEW_CLASS_NAME).attr("id", (view) => view.key).call(applyTranslate).each(function(view, i, element) {
      plotView(view, select(element), transitions, context);
      enterContainer.set(view, element);
    }), (update2) => update2.call(applyTranslate).each(function(view, i, element) {
      plotView(view, select(element), transitions, context);
      updateContainer.set(view, element);
    }), (exit) => exit.each(function(d3, i, element) {
      const interactions = element["nameInteraction"].values();
      for (const interaction of interactions) {
        interaction.destroy();
      }
    }).remove());
    const viewInstanceof = (viewContainer, updateInteractions2, oldStore) => {
      return Array.from(viewContainer.entries()).map(([view, container]) => {
        const store = oldStore || /* @__PURE__ */ new Map();
        const setState = (key, reducer = (x3) => x3) => store.set(key, reducer);
        const options2 = viewNode.get(view);
        const update2 = createUpdateView(select(container), options2, context);
        return {
          view,
          container,
          options: options2,
          setState,
          update: (from, updateTypes) => __awaiter5(this, void 0, void 0, function* () {
            const reducer = compose(Array.from(store.values()));
            const newOptions = reducer(options2);
            return yield update2(newOptions, from, () => {
              if (isArray(updateTypes)) {
                updateInteractions2(viewContainer, updateTypes, store);
              }
            });
          })
        };
      });
    };
    const updateInteractions = (container = updateContainer, updateType, oldStore) => {
      var _a3;
      const updateViewInstances = viewInstanceof(container, updateInteractions, oldStore);
      for (const target of updateViewInstances) {
        const { options: options2, container: container2 } = target;
        const nameInteraction = container2["nameInteraction"];
        let typeOptions = inferInteraction(options2);
        if (updateType) {
          typeOptions = typeOptions.filter((v) => updateType.includes(v[0]));
        }
        for (const typeOption of typeOptions) {
          const [type, option] = typeOption;
          const prevInteraction = nameInteraction.get(type);
          if (prevInteraction)
            (_a3 = prevInteraction.destroy) === null || _a3 === void 0 ? void 0 : _a3.call(prevInteraction);
          if (option) {
            const interaction = useThemeInteraction(target.view, type, option, useInteraction);
            const destroy2 = interaction(target, updateViewInstances, context.emitter);
            nameInteraction.set(type, { destroy: destroy2 });
          }
        }
      }
    };
    const enterViewInstances = viewInstanceof(enterContainer, updateInteractions);
    for (const target of enterViewInstances) {
      const { options: options2 } = target;
      const nameInteraction = /* @__PURE__ */ new Map();
      target.container["nameInteraction"] = nameInteraction;
      for (const typeOption of inferInteraction(options2)) {
        const [type, option] = typeOption;
        if (option) {
          const interaction = useThemeInteraction(target.view, type, option, useInteraction);
          const destroy2 = interaction(target, enterViewInstances, context.emitter);
          nameInteraction.set(type, { destroy: destroy2 });
        }
      }
    }
    updateInteractions();
    const { width, height } = options;
    const keyframes = [];
    for (const nodeGenerator of nodeGenerators) {
      const keyframe = new Promise((resolve) => __awaiter5(this, void 0, void 0, function* () {
        for (const node of nodeGenerator) {
          const sizedNode = Object.assign({ width, height }, node);
          yield plot(sizedNode, selection, context);
        }
        resolve();
      }));
      keyframes.push(keyframe);
    }
    context.views = views;
    (_a2 = context.animations) === null || _a2 === void 0 ? void 0 : _a2.forEach((animation) => animation === null || animation === void 0 ? void 0 : animation.cancel());
    context.animations = transitions;
    context.emitter.emit(ChartEvent.AFTER_PAINT);
    const finished = transitions.filter(defined).map(cancel).map((d3) => d3.finished);
    return Promise.all([...finished, ...keyframes]);
  });
}
function applyTranslate(selection) {
  selection.style("transform", (d3) => `translate(${d3.layout.x}, ${d3.layout.y})`);
}
function definedInteraction(library3) {
  const [, createInteraction] = useLibrary("interaction", library3);
  return (d3) => {
    const [name2, options] = d3;
    try {
      return [name2, createInteraction(name2)];
    } catch (_a2) {
      return [name2, options.type];
    }
  };
}
function createUpdateView(selection, options, context) {
  const { library: library3 } = context;
  const createDefinedInteraction = definedInteraction(library3);
  const filter3 = (d3) => d3[1] && d3[1].props && d3[1].props.reapplyWhenUpdate;
  const interactions = inferInteraction(options);
  const updates = interactions.map(createDefinedInteraction).filter(filter3).map((d3) => d3[0]);
  return (newOptions, source, callback) => __awaiter5(this, void 0, void 0, function* () {
    const transitions = [];
    const [newView, newChildren] = yield initializeView(newOptions, context);
    plotView(newView, selection, transitions, context);
    for (const name2 of updates.filter((d3) => d3 !== source)) {
      updateInteraction(name2, selection, newOptions, newView, context);
    }
    for (const child of newChildren) {
      plot(child, selection, context);
    }
    callback();
    return { options: newOptions, view: newView };
  });
}
function updateInteraction(name2, selection, options, view, context) {
  var _a2;
  const { library: library3 } = context;
  const [useInteraction] = useLibrary("interaction", library3);
  const container = selection.node();
  const nameInteraction = container["nameInteraction"];
  const interactionOptions = inferInteraction(options).find(([d3]) => d3 === name2);
  const interaction = nameInteraction.get(name2);
  if (!interaction)
    return;
  (_a2 = interaction.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(interaction);
  if (!interactionOptions[1])
    return;
  const applyInteraction = useThemeInteraction(view, name2, interactionOptions[1], useInteraction);
  const target = {
    options,
    view,
    container: selection.node(),
    update: (options2) => Promise.resolve(options2)
  };
  const destroy2 = applyInteraction(target, [], context.emitter);
  nameInteraction.set(name2, { destroy: destroy2 });
}
function initializeView(options, context) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const flattenOptions = yield transformMarks(options, context);
    const mergedOptions = bubbleOptions(flattenOptions);
    options.interaction = mergedOptions.interaction;
    options.coordinate = mergedOptions.coordinate;
    options.marks = [...mergedOptions.marks, ...mergedOptions.components];
    const transformedOptions = coordinate2Transform(mergedOptions, library3);
    const state = yield initializeMarks(transformedOptions, context);
    return initializeState(state, transformedOptions, library3);
  });
}
function bubbleOptions(options) {
  const { coordinate: viewCoordinate = {}, interaction: viewInteraction = {}, style: viewStyle = {}, marks } = options, rest = __rest76(options, ["coordinate", "interaction", "style", "marks"]);
  const markCoordinates = marks.map((d3) => d3.coordinate || {});
  const markInteractions = marks.map((d3) => d3.interaction || {});
  const markViewStyles = marks.map((d3) => d3.viewStyle || {});
  const newCoordinate = [...markCoordinates, viewCoordinate].reduceRight((prev, cur) => deep_mix_default(prev, cur), {});
  const newInteraction = [viewInteraction, ...markInteractions].reduce((prev, cur) => deep_mix_default(prev, cur), {});
  const newStyle = [...markViewStyles, viewStyle].reduce((prev, cur) => deep_mix_default(prev, cur), {});
  return Object.assign(Object.assign({}, rest), { marks, coordinate: newCoordinate, interaction: newInteraction, style: newStyle });
}
function transformMarks(options, context) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const [useMark, createMark] = useLibrary("mark", library3);
    const staticMarks = new Set(Object.keys(library3).map((d3) => {
      var _a2;
      return (_a2 = /component\.(.*)/.exec(d3)) === null || _a2 === void 0 ? void 0 : _a2[1];
    }).filter(defined));
    const { marks } = options;
    const flattenMarks = [];
    const components = [];
    const discovered = [...marks];
    const { width, height } = computeRoughPlotSize(options);
    const markOptions = { options, width, height };
    while (discovered.length) {
      const [node] = discovered.splice(0, 1);
      const mark2 = yield applyTransform(node, context);
      const { type = error("G2Mark type is required."), key } = mark2;
      if (staticMarks.has(type))
        components.push(mark2);
      else {
        const { props = {} } = createMark(type);
        const { composite = true } = props;
        if (!composite)
          flattenMarks.push(mark2);
        else {
          const { data: data2 } = mark2;
          const newMark = Object.assign(Object.assign({}, mark2), { data: data2 ? Array.isArray(data2) ? data2 : data2.value : data2 });
          const marks2 = yield useMark(newMark, markOptions);
          const M2 = Array.isArray(marks2) ? marks2 : [marks2];
          discovered.unshift(...M2.map((d3, i) => Object.assign(Object.assign({}, d3), { key: `${key}-${i}` })));
        }
      }
    }
    return Object.assign(Object.assign({}, options), { marks: flattenMarks, components });
  });
}
function initializeMarks(options, context) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const [useTheme] = useLibrary("theme", library3);
    const [, createMark] = useLibrary("mark", library3);
    const { theme: partialTheme, marks: partialMarks, coordinates = [] } = options;
    const theme = useTheme(inferTheme(partialTheme));
    const markState = /* @__PURE__ */ new Map();
    for (const markOptions of partialMarks) {
      const { type } = markOptions;
      const { props = {} } = createMark(type);
      const markAndState = yield initializeMark(markOptions, props, context);
      if (markAndState) {
        const [initializedMark, state] = markAndState;
        markState.set(initializedMark, state);
      }
    }
    const scaleChannels = group(Array.from(markState.values()).flatMap((d3) => d3.channels), ({ scaleKey }) => scaleKey);
    for (const channels of scaleChannels.values()) {
      const scaleOptions = channels.reduce((total, { scale: scale12 }) => deep_mix_default(total, scale12), {});
      const { scaleKey } = channels[0];
      const { values: FV } = channels[0];
      const fields = Array.from(new Set(FV.map((d3) => d3.field).filter(defined)));
      const options2 = deep_mix_default({
        guide: { title: fields.length === 0 ? void 0 : fields },
        field: fields[0]
      }, scaleOptions);
      const { name: name2 } = channels[0];
      const values4 = channels.flatMap(({ values: values5 }) => values5.map((d3) => d3.value));
      const scale11 = Object.assign(Object.assign({}, inferScale(name2, values4, options2, coordinates, theme, library3)), { uid: Symbol("scale"), key: scaleKey });
      channels.forEach((channel) => channel.scale = scale11);
    }
    return markState;
  });
}
function useThemeInteraction(view, type, option, useInteraction) {
  const theme = view.theme;
  const defaults4 = typeof type === "string" ? theme[type] || {} : {};
  const interaction = useInteraction(deep_mix_default(defaults4, Object.assign({ type }, option)));
  return interaction;
}
function initializeState(markState, options, library3) {
  var _a2;
  const [useMark] = useLibrary("mark", library3);
  const [useTheme] = useLibrary("theme", library3);
  const [useLabelTransform] = useLibrary("labelTransform", library3);
  const { key, frame: frame2 = false, theme: partialTheme, clip, style = {}, labelTransform = [] } = options;
  const theme = useTheme(inferTheme(partialTheme));
  const states = Array.from(markState.values());
  const scales = collectScales(states, options);
  const components = normalizeComponents(inferComponent(inferComponentScales(Array.from(scales), states, markState), options, library3));
  const layout = computeLayout(components, options, theme, library3);
  const coordinate = createCoordinate(layout, options, library3);
  const framedStyle = frame2 ? deep_mix_default({ mainLineWidth: 1, mainStroke: "#000" }, style) : style;
  placeComponents(groupComponents(components), coordinate, layout);
  processAxisZ(components);
  const uidScale = new Map(Array.from(markState.values()).flatMap((state) => {
    const { channels } = state;
    return channels.map(({ scale: scale11 }) => [
      scale11.uid,
      useRelationScale(scale11, library3)
    ]);
  }));
  groupTransform(markState, uidScale);
  const scaleInstance = {};
  for (const component of components) {
    const { scales: scaleDescriptors = [] } = component;
    const scales2 = [];
    for (const descriptor of scaleDescriptors) {
      const { name: name2, uid } = descriptor;
      const scale11 = (_a2 = uidScale.get(uid)) !== null && _a2 !== void 0 ? _a2 : useRelationScale(descriptor, library3);
      scales2.push(scale11);
      if (name2 === "y") {
        scale11.update(Object.assign(Object.assign({}, scale11.getOptions()), { xScale: scaleInstance.x }));
      }
      assignScale(scaleInstance, { [name2]: scale11 });
    }
    component.scaleInstances = scales2;
  }
  const children = [];
  for (const [mark2, state] of markState.entries()) {
    const {
      // scale,
      // Callback to create children options based on this mark.
      children: createChildren,
      // The total count of data (both show and hide)for this facet.
      // This is for unit visualization to sync data domain.
      dataDomain,
      modifier,
      key: markKey
    } = mark2;
    const { index: index3, channels, tooltip: tooltip2 } = state;
    const scale11 = Object.fromEntries(channels.map(({ name: name2, scale: scale12 }) => [name2, scale12]));
    const markScaleInstance = mapObject(scale11, ({ uid }) => uidScale.get(uid));
    assignScale(scaleInstance, markScaleInstance);
    const value2 = applyScale(channels, markScaleInstance);
    const calcPoints = useMark(mark2);
    const [I, P, S] = filterValid(calcPoints(index3, markScaleInstance, value2, coordinate));
    const count4 = dataDomain || I.length;
    const T = modifier ? modifier(P, count4, layout) : [];
    const titleOf = (i) => {
      var _a3, _b;
      return (_b = (_a3 = tooltip2.title) === null || _a3 === void 0 ? void 0 : _a3[i]) === null || _b === void 0 ? void 0 : _b.value;
    };
    const itemsOf2 = (i) => tooltip2.items.map((V) => V[i]);
    const visualData = I.map((d3, i) => {
      const datum = Object.assign({ points: P[i], transform: T[i], index: d3, markKey, viewKey: key }, tooltip2 && {
        title: titleOf(d3),
        items: itemsOf2(d3)
      });
      for (const [k2, V] of Object.entries(value2)) {
        datum[k2] = V[d3];
        if (S)
          datum[`series${upper_first_default(k2)}`] = S[i].map((i2) => V[i2]);
      }
      if (S)
        datum["seriesIndex"] = S[i];
      if (S && tooltip2) {
        datum["seriesItems"] = S[i].map((si) => itemsOf2(si));
        datum["seriesTitle"] = S[i].map((si) => titleOf(si));
      }
      return datum;
    });
    state.data = visualData;
    state.index = I;
    const markChildren = createChildren === null || createChildren === void 0 ? void 0 : createChildren(visualData, markScaleInstance, layout);
    children.push(...markChildren || []);
  }
  const view = {
    layout,
    theme,
    coordinate,
    markState,
    key,
    clip,
    scale: scaleInstance,
    style: framedStyle,
    components,
    labelTransform: compose(labelTransform.map(useLabelTransform))
  };
  return [view, children];
}
function plotView(view, selection, transitions, context) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const { components, theme, layout, markState, coordinate, key, style, clip, scale: scale11 } = view;
    const { x: x3, y: y3, width, height } = layout, rest = __rest76(layout, ["x", "y", "width", "height"]);
    const areaKeys = ["view", "plot", "main", "content"];
    const I = areaKeys.map((_2, i) => i);
    const sizeKeys = ["a", "margin", "padding", "inset"];
    const areaStyles = areaKeys.map((d3) => maybeSubObject(Object.assign({}, theme.view, style), d3));
    const areaSizes = sizeKeys.map((d3) => subObject(rest, d3));
    const styleArea = (selection2) => selection2.style("x", (i) => areaLayouts[i].x).style("y", (i) => areaLayouts[i].y).style("width", (i) => areaLayouts[i].width).style("height", (i) => areaLayouts[i].height).each(function(i, d3, element) {
      applyStyle2(select(element), areaStyles[i]);
    });
    let px2 = 0;
    let py = 0;
    let pw = width;
    let ph = height;
    const areaLayouts = I.map((i) => {
      const size3 = areaSizes[i];
      const { left: left2 = 0, top = 0, bottom = 0, right: right2 = 0 } = size3;
      px2 += left2;
      py += top;
      pw -= left2 + right2;
      ph -= top + bottom;
      return {
        x: px2,
        y: py,
        width: pw,
        height: ph
      };
    });
    selection.selectAll(className(AREA_CLASS_NAME)).data(
      // Only render area with defined style.
      I.filter((i) => defined(areaStyles[i])),
      (i) => areaKeys[i]
    ).join((enter) => enter.append("rect").attr("className", AREA_CLASS_NAME).style("zIndex", -2).call(styleArea), (update2) => update2.call(styleArea), (exit) => exit.remove());
    const animationExtent = computeAnimationExtent(markState);
    const componentAnimateOptions = animationExtent ? { duration: animationExtent[1] } : false;
    for (const [, C4] of groups(components, (d3) => `${d3.type}-${d3.position}`)) {
      C4.forEach((d3, i) => d3.index = i);
    }
    const componentsTransitions = selection.selectAll(className(COMPONENT_CLASS_NAME)).data(components, (d3) => `${d3.type}-${d3.position}-${d3.index}`).join((enter) => enter.append("g").style("zIndex", ({ zIndex }) => zIndex || -1).attr("className", COMPONENT_CLASS_NAME).append((options) => renderComponent(deep_mix_default({ animate: componentAnimateOptions, scale: scale11 }, options), coordinate, theme, library3, markState)), (update2) => update2.transition(function(options, i, element) {
      const { preserve = false } = options;
      if (preserve)
        return;
      const newComponent = renderComponent(deep_mix_default({ animate: componentAnimateOptions, scale: scale11 }, options), coordinate, theme, library3, markState);
      const { attributes } = newComponent;
      const [node] = element.childNodes;
      return node.update(attributes, false);
    })).transitions();
    transitions.push(...componentsTransitions.flat().filter(defined));
    const T = selection.selectAll(className(PLOT_CLASS_NAME)).data([layout], () => key).join((enter) => enter.append("rect").style("zIndex", 0).style("fill", "transparent").attr("className", PLOT_CLASS_NAME).call(updateBBox).call(updateLayers, Array.from(markState.keys())).call(applyClip, clip), (update2) => update2.call(updateLayers, Array.from(markState.keys())).call((selection2) => {
      return animationExtent ? animateBBox(selection2, animationExtent) : updateBBox(selection2);
    }).call(applyClip, clip)).transitions();
    transitions.push(...T.flat());
    for (const [mark2, state] of markState.entries()) {
      const { data: data2 } = state;
      const { key: key2, class: cls, type } = mark2;
      const viewNode = selection.select(`#${key2}`);
      const shapeFunction = createMarkShapeFunction(mark2, state, view, context);
      const enterFunction = createEnterFunction(mark2, state, view, library3);
      const updateFunction = createUpdateFunction(mark2, state, view, library3);
      const exitFunction = createExitFunction(mark2, state, view, library3);
      const facetElements = selectFacetElements(selection, viewNode, cls, "element");
      const T2 = viewNode.selectAll(className(ELEMENT_CLASS_NAME)).selectFacetAll(facetElements).data(data2, (d3) => d3.key, (d3) => d3.groupKey).join((enter) => enter.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).transition(function(data3, i, element) {
        return enterFunction(data3, [element]);
      }), (update2) => update2.call((selection2) => {
        const parent = selection2.parent();
        const origin = useMemo((node) => {
          const [x4, y4] = node.getBounds().min;
          return [x4, y4];
        });
        selection2.transition(function(data3, index3, element) {
          maybeFacetElement(element, parent, origin);
          const node = shapeFunction(data3, index3);
          const animation = updateFunction(data3, [element], [node]);
          if (animation !== null)
            return animation;
          if (element.nodeName === node.nodeName && node.nodeName !== "g") {
            copyAttributes(element, node);
          } else {
            element.parentNode.replaceChild(node, element);
            node.className = ELEMENT_CLASS_NAME;
            node.markType = type;
            node.__data__ = element.__data__;
          }
          return animation;
        }).attr("markType", type).attr("className", ELEMENT_CLASS_NAME);
      }), (exit) => {
        return exit.each(function(d3, i, element) {
          element.__removed__ = true;
        }).transition(function(data3, i, element) {
          return exitFunction(data3, [element]);
        }).remove();
      }, (merge2) => merge2.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).transition(function(data3, i, element) {
        const { __fromElements__: fromElements } = element;
        const transition2 = updateFunction(data3, fromElements, [element]);
        const exit = new Selection(fromElements, null, element.parentNode);
        exit.transition(transition2).remove();
        return transition2;
      }), (split) => split.transition(function(data3, i, element) {
        const enter = new Selection([], element.__toData__, element.parentNode);
        const toElements = enter.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).nodes();
        return updateFunction(data3, [element], toElements);
      }).remove()).transitions();
      transitions.push(...T2.flat());
    }
    plotLabel(view, selection, transitions, library3, context);
  });
}
function plotLabel(view, selection, transitions, library3, context) {
  const [useLabelTransform] = useLibrary("labelTransform", library3);
  const { markState, labelTransform } = view;
  const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();
  const labelShapeFunction = /* @__PURE__ */ new Map();
  const labelDescriptor = /* @__PURE__ */ new Map();
  const labels = Array.from(markState.entries()).flatMap(([mark2, state]) => {
    const { labels: labelOptions = [], key } = mark2;
    const shapeFunction = createLabelShapeFunction(mark2, state, view, library3, context);
    const elements = selection.select(`#${key}`).selectAll(className(ELEMENT_CLASS_NAME)).nodes().filter((n) => !n.__removed__);
    return labelOptions.flatMap((labelOption, i) => {
      const { transform: transform2 = [] } = labelOption, options = __rest76(labelOption, ["transform"]);
      return elements.flatMap((e) => {
        const L = getLabels(options, i, e);
        L.forEach((l) => {
          labelShapeFunction.set(l, (data2) => shapeFunction(Object.assign(Object.assign({}, data2), { element: e })));
          labelDescriptor.set(l, labelOption);
        });
        return L;
      });
    });
  });
  const labelShapes = select(labelLayer).selectAll(className(LABEL_CLASS_NAME)).data(labels, (d3) => d3.key).join((enter) => enter.append((d3) => labelShapeFunction.get(d3)(d3)).attr("className", LABEL_CLASS_NAME), (update2) => update2.each(function(d3, i, element) {
    const shapeFunction = labelShapeFunction.get(d3);
    const node = shapeFunction(d3);
    copyAttributes(element, node);
  }), (exit) => exit.remove()).nodes();
  const labelGroups = group(labelShapes, (d3) => labelDescriptor.get(d3.__data__));
  const { coordinate, layout } = view;
  const labelTransformContext = {
    canvas: context.canvas,
    coordinate,
    layout
  };
  for (const [label, shapes] of labelGroups) {
    const { transform: transform2 = [] } = label;
    const transformFunction = compose(transform2.map(useLabelTransform));
    transformFunction(shapes, labelTransformContext);
  }
  if (labelTransform) {
    labelTransform(labelShapes, labelTransformContext);
  }
}
function getLabels(label, labelIndex, element) {
  const { seriesIndex: SI, seriesKey, points, key, index: index3 } = element.__data__;
  const bounds = getLocalBounds(element);
  if (!SI) {
    return [
      Object.assign(Object.assign({}, label), {
        key: `${key}-${labelIndex}`,
        bounds,
        index: index3,
        points,
        dependentElement: element
      })
    ];
  }
  const selector = normalizeLabelSelector(label);
  const F = SI.map((index4, i) => Object.assign(Object.assign({}, label), {
    key: `${seriesKey[i]}-${labelIndex}`,
    bounds: [points[i]],
    index: index4,
    points,
    dependentElement: element
  }));
  return selector ? selector(F) : F;
}
function filterValid([I, P, S]) {
  if (S)
    return [I, P, S];
  const definedIndex = [];
  const definedPoints = [];
  for (let i = 0; i < I.length; i++) {
    const d3 = I[i];
    const p2 = P[i];
    if (p2.every(([x3, y3]) => defined(x3) && defined(y3))) {
      definedIndex.push(d3);
      definedPoints.push(p2);
    }
  }
  return [definedIndex, definedPoints];
}
function normalizeLabelSelector(label) {
  const { selector } = label;
  if (!selector)
    return null;
  if (typeof selector === "function")
    return selector;
  if (selector === "first")
    return (I) => [I[0]];
  if (selector === "last")
    return (I) => [I[I.length - 1]];
  throw new Error(`Unknown selector: ${selector}`);
}
function getLocalBounds(element) {
  const cloneElement = element.cloneNode();
  const animations = element.getAnimations();
  cloneElement.style.visibility = "hidden";
  animations.forEach((animation) => {
    const keyframes = animation.effect.getKeyframes();
    cloneElement.attr(keyframes[keyframes.length - 1]);
  });
  element.parentNode.appendChild(cloneElement);
  const bounds = cloneElement.getLocalBounds();
  cloneElement.destroy();
  const { min: min10, max: max11 } = bounds;
  return [min10, max11];
}
function createLabelShapeFunction(mark2, state, view, library3, context) {
  const [useShape] = useLibrary("shape", library3);
  const { data: abstractData, encode } = mark2;
  const { data: visualData, defaultLabelShape } = state;
  const point2d = visualData.map((d3) => d3.points);
  const channel = mapObject(encode, (d3) => d3.value);
  const { theme, coordinate } = view;
  const shapeContext = Object.assign(Object.assign({}, context), {
    document: documentOf(context),
    theme,
    coordinate
  });
  return (options) => {
    const { index: index3, points } = options;
    const datum = abstractData[index3];
    const { formatter: formatter2 = (d3) => `${d3}`, transform: transform2, style: abstractStyle, render: render3, selector, element } = options, abstractOptions = __rest76(options, ["formatter", "transform", "style", "render", "selector", "element"]);
    const visualOptions = mapObject(Object.assign(Object.assign({}, abstractOptions), abstractStyle), (d3) => valueOf2(d3, datum, index3, abstractData, {
      channel,
      element
    }));
    const { shape: shape23 = defaultLabelShape, text } = visualOptions, style = __rest76(visualOptions, ["shape", "text"]);
    const f = typeof formatter2 === "string" ? format2(formatter2) : formatter2;
    const value2 = Object.assign(Object.assign({}, style), { text: f(text, datum, index3, abstractData), datum });
    const shapeOptions = Object.assign({ type: `label.${shape23}`, render: render3 }, style);
    const shapeFunction = useShape(shapeOptions, shapeContext);
    const defaults4 = getDefaultsStyle(theme, "label", shape23, "label");
    return shapeFunction(points, value2, defaults4, point2d);
  };
}
function valueOf2(value2, datum, i, data2, options) {
  if (typeof value2 === "function")
    return value2(datum, i, data2, options);
  if (typeof value2 !== "string")
    return value2;
  if (isStrictObject(datum) && datum[value2] !== void 0)
    return datum[value2];
  return value2;
}
function computeAnimationExtent(markState) {
  let maxDuration = -Infinity;
  let minDelay = Infinity;
  for (const [mark2, state] of markState) {
    const { animate: animate2 = {} } = mark2;
    const { data: data2 } = state;
    const { enter = {}, update: update2 = {}, exit = {} } = animate2;
    const { type: defaultUpdateType, duration: defaultUpdateDuration = 300, delay: defaultUpdateDelay = 0 } = update2;
    const { type: defaultEnterType, duration: defaultEnterDuration = 300, delay: defaultEnterDelay = 0 } = enter;
    const { type: defaultExitType, duration: defaultExitDuration = 300, delay: defaultExitDelay = 0 } = exit;
    for (const d3 of data2) {
      const { updateType = defaultUpdateType, updateDuration = defaultUpdateDuration, updateDelay = defaultUpdateDelay, enterType = defaultEnterType, enterDuration = defaultEnterDuration, enterDelay = defaultEnterDelay, exitDuration = defaultExitDuration, exitDelay = defaultExitDelay, exitType = defaultExitType } = d3;
      if (updateType === void 0 || updateType) {
        maxDuration = Math.max(maxDuration, updateDuration + updateDelay);
        minDelay = Math.min(minDelay, updateDelay);
      }
      if (exitType === void 0 || exitType) {
        maxDuration = Math.max(maxDuration, exitDuration + exitDelay);
        minDelay = Math.min(minDelay, exitDelay);
      }
      if (enterType === void 0 || enterType) {
        maxDuration = Math.max(maxDuration, enterDuration + enterDelay);
        minDelay = Math.min(minDelay, enterDelay);
      }
    }
  }
  if (maxDuration === -Infinity)
    return null;
  return [minDelay, maxDuration - minDelay];
}
function selectFacetElements(selection, current, facetClassName, elementClassName) {
  const group3 = selection.node().parentElement;
  return group3.findAll((node) => node.style.facet !== void 0 && node.style.facet === facetClassName && node !== current.node()).flatMap((node) => node.getElementsByClassName(elementClassName));
}
function maybeFacetElement(element, parent, originOf) {
  if (!element.__facet__)
    return;
  const prePlot = element.parentNode.parentNode;
  const newPlot = parent.parentNode;
  const [px2, py] = originOf(prePlot);
  const [x3, y3] = originOf(newPlot);
  const translate6 = `translate(${px2 - x3}, ${py - y3})`;
  appendTransform(element, translate6);
  parent.append(element);
}
function createMarkShapeFunction(mark2, state, view, context) {
  const { library: library3 } = context;
  const [useShape] = useLibrary("shape", library3);
  const { data: abstractData, encode } = mark2;
  const { defaultShape, data: data2, shape: shapeLibrary } = state;
  const channel = mapObject(encode, (d3) => d3.value);
  const point2d = data2.map((d3) => d3.points);
  const { theme, coordinate } = view;
  const { type: markType, style = {} } = mark2;
  const shapeContext = Object.assign(Object.assign({}, context), {
    document: documentOf(context),
    coordinate,
    theme
  });
  return (data3) => {
    const { shape: styleShape = defaultShape } = style;
    const { shape: shape23 = styleShape, points, seriesIndex, index: i } = data3, v = __rest76(data3, ["shape", "points", "seriesIndex", "index"]);
    const value2 = Object.assign(Object.assign({}, v), { index: i });
    const abstractDatum = seriesIndex ? seriesIndex.map((i2) => abstractData[i2]) : abstractData[i];
    const I = seriesIndex ? seriesIndex : i;
    const visualStyle = mapObject(style, (d3) => valueOf2(d3, abstractDatum, I, abstractData, { channel }));
    const shapeFunction = shapeLibrary[shape23] ? shapeLibrary[shape23](visualStyle, shapeContext) : useShape(Object.assign(Object.assign({}, visualStyle), { type: shapeName(mark2, shape23) }), shapeContext);
    const defaults4 = getDefaultsStyle(theme, markType, shape23, defaultShape);
    return shapeFunction(points, value2, defaults4, point2d);
  };
}
function getDefaultsStyle(theme, mark2, shape23, defaultShape) {
  if (typeof mark2 !== "string")
    return;
  const { color: color3 } = theme;
  const markTheme = theme[mark2] || {};
  const shapeTheme = markTheme[shape23] || markTheme[defaultShape];
  return Object.assign({ color: color3 }, shapeTheme);
}
function createAnimationFunction(type, mark2, state, view, library3) {
  var _a2, _b;
  const [, createShape] = useLibrary("shape", library3);
  const [useAnimation] = useLibrary("animation", library3);
  const { defaultShape, shape: shapeLibrary } = state;
  const { theme, coordinate } = view;
  const upperType = upper_first_default(type);
  const key = `default${upperType}Animation`;
  const { [key]: defaultAnimation } = ((_a2 = shapeLibrary[defaultShape]) === null || _a2 === void 0 ? void 0 : _a2.props) || createShape(shapeName(mark2, defaultShape)).props;
  const { [type]: defaultEffectTiming = {} } = theme;
  const animate2 = ((_b = mark2.animate) === null || _b === void 0 ? void 0 : _b[type]) || {};
  const context = { coordinate };
  return (data2, from, to) => {
    const { [`${type}Type`]: animation, [`${type}Delay`]: delay, [`${type}Duration`]: duration, [`${type}Easing`]: easing } = data2;
    const options = Object.assign({ type: animation || defaultAnimation }, animate2);
    if (!options.type)
      return null;
    const animateFunction = useAnimation(options, context);
    const value2 = { delay, duration, easing };
    const A6 = animateFunction(from, to, deep_mix_default(defaultEffectTiming, value2));
    if (!Array.isArray(A6))
      return [A6];
    return A6;
  };
}
function createEnterFunction(mark2, state, view, library3) {
  return createAnimationFunction("enter", mark2, state, view, library3);
}
function cancel(animation) {
  animation.finished.then(() => {
    animation.cancel();
  });
  return animation;
}
function createUpdateFunction(mark2, state, view, library3) {
  return createAnimationFunction("update", mark2, state, view, library3);
}
function createExitFunction(mark2, state, view, library3) {
  return createAnimationFunction("exit", mark2, state, view, library3);
}
function inferTheme(theme = {}) {
  if (typeof theme === "string")
    return { type: theme };
  const { type = "light" } = theme, rest = __rest76(theme, ["type"]);
  return Object.assign(Object.assign({}, rest), { type });
}
function inferInteraction(view) {
  const defaults4 = {
    event: true,
    tooltip: true,
    // @todo Inferred by slider self.
    sliderFilter: true,
    legendFilter: true,
    scrollbarFilter: true
  };
  const { interaction = {} } = view;
  return Object.entries(deep_mix_default(defaults4, interaction)).reverse();
}
function applyTransform(node, context) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { data: data2 } = node, rest = __rest76(node, ["data"]);
    if (data2 == void 0)
      return node;
    const [, { data: newData }] = yield applyDataTransform([], { data: data2 }, context);
    return Object.assign({ data: newData }, rest);
  });
}
function updateBBox(selection) {
  selection.style("transform", (d3) => `translate(${d3.paddingLeft + d3.marginLeft}, ${d3.paddingTop + d3.marginTop})`).style("width", (d3) => d3.innerWidth).style("height", (d3) => d3.innerHeight);
}
function animateBBox(selection, extent2) {
  const [delay, duration] = extent2;
  selection.transition(function(data2, i, element) {
    const { transform: transform2, width, height } = element.style;
    const { paddingLeft, paddingTop, innerWidth, innerHeight, marginLeft, marginTop } = data2;
    const keyframes = [
      {
        transform: transform2,
        width,
        height
      },
      {
        transform: `translate(${paddingLeft + marginLeft}, ${paddingTop + marginTop})`,
        width: innerWidth,
        height: innerHeight
      }
    ];
    return element.animate(keyframes, { delay, duration, fill: "both" });
  });
}
function shapeName(mark2, name2) {
  const { type } = mark2;
  if (typeof name2 === "string")
    return `${type}.${name2}`;
  return name2;
}
function updateLayers(selection, marks) {
  const facet = (d3) => d3.class !== void 0 ? `${d3.class}` : "";
  const nodes = selection.nodes();
  if (nodes.length === 0)
    return;
  selection.selectAll(className(MAIN_LAYER_CLASS_NAME)).data(marks, (d3) => d3.key).join((enter) => enter.append("g").attr("className", MAIN_LAYER_CLASS_NAME).attr("id", (d3) => d3.key).style("facet", facet).style("fill", "transparent").style("zIndex", (d3) => {
    var _a2;
    return (_a2 = d3.zIndex) !== null && _a2 !== void 0 ? _a2 : 0;
  }), (update2) => update2.style("facet", facet).style("fill", "transparent").style("zIndex", (d3) => {
    var _a2;
    return (_a2 = d3.zIndex) !== null && _a2 !== void 0 ? _a2 : 0;
  }), (exit) => exit.remove());
  const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();
  if (labelLayer)
    return;
  selection.append("g").attr("className", LABEL_LAYER_CLASS_NAME).style("zIndex", 0);
}
function className(...names) {
  return names.map((d3) => `.${d3}`).join("");
}
function applyClip(selection, clip) {
  if (!selection.node())
    return;
  selection.style("clipPath", (data2) => {
    if (!clip)
      return null;
    const { paddingTop: y3, paddingLeft: x3, marginLeft: x12, marginTop: y12, innerWidth: width, innerHeight: height } = data2;
    return new Rect({ style: { x: x3 + x12, y: y3 + y12, width, height } });
  });
}
function inferComponentScales(scales, states, markState) {
  var _a2;
  for (const [key] of markState.entries()) {
    if (key.type === "cell") {
      return scales.filter((scale11) => scale11.name !== "shape");
    }
  }
  if (states.length !== 1 || scales.some((scale11) => scale11.name === "shape")) {
    return scales;
  }
  const { defaultShape: shape23 } = states[0];
  const acceptMarkTypes = ["point", "line", "rect", "hollow"];
  if (!acceptMarkTypes.includes(shape23))
    return scales;
  const shapeMap = {
    point: "point",
    line: "hyphen",
    rect: "square",
    hollow: "hollow"
  };
  const field3 = ((_a2 = scales.find((scale11) => scale11.name === "color")) === null || _a2 === void 0 ? void 0 : _a2.field) || null;
  const shapeScale = {
    field: field3,
    name: "shape",
    type: "constant",
    domain: [],
    range: [shapeMap[shape23]]
  };
  return [...scales, shapeScale];
}
function applyStyle2(selection, style) {
  for (const [key, value2] of Object.entries(style)) {
    selection.style(key, value2);
  }
}

// node_modules/@antv/g2/esm/utils/flow.js
function flow(...flows) {
  return (param) => {
    return flows.reduce((result, f) => {
      return f(result);
    }, param);
  };
}

// node_modules/@antv/g2/esm/runtime/option-preprocess/style.js
function columnWidthRatio(options) {
  const { style, scale: scale11, type } = options;
  const scaleOption = {};
  const columnWidthRatio2 = get_default(style, "columnWidthRatio");
  if (columnWidthRatio2 && type === "interval") {
    scaleOption.x = Object.assign(Object.assign({}, scale11 === null || scale11 === void 0 ? void 0 : scale11.x), { padding: 1 - columnWidthRatio2 });
  }
  return Object.assign(Object.assign({}, options), { scale: Object.assign(Object.assign({}, scale11), scaleOption) });
}

// node_modules/@antv/g2/esm/runtime/option-preprocess/index.js
function preprocessOption(options) {
  const convertedOptions = adapter(options);
  if (convertedOptions.children && Array.isArray(convertedOptions.children)) {
    convertedOptions.children = convertedOptions.children.map((child) => preprocessOption(child));
  }
  return convertedOptions;
}
function adapter(options) {
  return flow(columnWidthRatio)(options);
}

// node_modules/@antv/g2/esm/runtime/render.js
function inferKeys(options) {
  const root2 = deep_mix_default({}, options);
  const nodeParent = /* @__PURE__ */ new Map([[root2, null]]);
  const nodeIndex = /* @__PURE__ */ new Map([[null, -1]]);
  const discovered = [root2];
  while (discovered.length) {
    const node = discovered.shift();
    if (node.key === void 0) {
      const parent = nodeParent.get(node);
      const index3 = nodeIndex.get(node);
      const key = parent === null ? `${0}` : `${parent.key}-${index3}`;
      node.key = key;
    }
    const { children = [] } = node;
    if (Array.isArray(children)) {
      for (let i = 0; i < children.length; i++) {
        const child = deep_mix_default({}, children[i]);
        children[i] = child;
        nodeParent.set(child, node);
        nodeIndex.set(child, i);
        discovered.push(child);
      }
    }
  }
  return root2;
}
function Canvas2(width, height) {
  const renderer = new Renderer();
  renderer.registerPlugin(new Plugin7());
  return new Canvas({
    width,
    height,
    container: document.createElement("div"),
    renderer
  });
}
function render(options, context = {}, resolve = () => {
}, reject = (e) => {
  throw e;
}) {
  const { width = 640, height = 480, depth = 0 } = options;
  const preprocessedOption = preprocessOption(options);
  const keyed2 = inferKeys(preprocessedOption);
  const { canvas = Canvas2(width, height), emitter = new esm_default(), library: library3 } = context;
  context.canvas = canvas;
  context.emitter = emitter;
  const { width: prevWidth, height: prevHeight } = canvas.getConfig();
  if (prevWidth !== width || prevHeight !== height) {
    canvas.resize(width, height);
  }
  emitter.emit(ChartEvent.BEFORE_RENDER);
  const selection = select(canvas.document.documentElement);
  canvas.ready.then(() => plot(Object.assign(Object.assign({}, keyed2), { width, height, depth }), selection, context)).then(() => {
    if (depth) {
      const [x3, y3] = canvas.document.documentElement.getPosition();
      canvas.document.documentElement.setPosition(x3, y3, -depth / 2);
    }
    canvas.requestAnimationFrame(() => {
      canvas.requestAnimationFrame(() => {
        emitter.emit(ChartEvent.AFTER_RENDER);
        resolve === null || resolve === void 0 ? void 0 : resolve();
      });
    });
  }).catch((e) => {
    reject === null || reject === void 0 ? void 0 : reject(e);
  });
  return normalizeContainer(canvas.getConfig().container);
}
function renderToMountedElement(options, context = {}, resolve = () => {
}, reject = (e) => {
  throw e;
}) {
  var _a2;
  const { width = 640, height = 480 } = options;
  const keyed2 = inferKeys(options);
  const { group: group3 = new Group2(), emitter = new esm_default(), library: library3 } = context;
  if (!(group3 === null || group3 === void 0 ? void 0 : group3.parentElement)) {
    error(`renderToMountedElement can't render chart to unmounted group.`);
  }
  const selection = select(group3);
  context.group = group3;
  context.emitter = emitter;
  context.canvas = context.canvas || ((_a2 = group3 === null || group3 === void 0 ? void 0 : group3.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView);
  emitter.emit(ChartEvent.BEFORE_RENDER);
  plot(Object.assign(Object.assign({}, keyed2), { width, height }), selection, context).then(() => {
    var _a3;
    (_a3 = context.canvas) === null || _a3 === void 0 ? void 0 : _a3.requestAnimationFrame(() => {
      emitter.emit(ChartEvent.AFTER_RENDER);
      resolve === null || resolve === void 0 ? void 0 : resolve();
    });
  }).catch((e) => {
    reject === null || reject === void 0 ? void 0 : reject(e);
  });
  return group3;
}
function destroy(options, context = {}, isDestroyCanvas = false) {
  const { canvas, emitter } = context;
  if (canvas) {
    destroyAllInteractions(canvas);
    isDestroyCanvas ? canvas.destroy() : canvas.destroyChildren();
  }
  emitter.off();
}
function destroyAllInteractions(canvas) {
  const viewGroups = canvas.getRoot().querySelectorAll(`.${VIEW_CLASS_NAME}`);
  viewGroups === null || viewGroups === void 0 ? void 0 : viewGroups.forEach((group3) => {
    const { nameInteraction = /* @__PURE__ */ new Map() } = group3;
    if ((nameInteraction === null || nameInteraction === void 0 ? void 0 : nameInteraction.size) > 0) {
      Array.from(nameInteraction === null || nameInteraction === void 0 ? void 0 : nameInteraction.values()).forEach((value2) => {
        value2 === null || value2 === void 0 ? void 0 : value2.destroy();
      });
    }
  });
}
function normalizeContainer(container) {
  return typeof container === "string" ? document.getElementById(container) : container;
}

// node_modules/@antv/g2/esm/utils/style.js
var defaultStyle = {
  visibility: "visible",
  opacity: 1,
  fillOpacity: 1,
  strokeOpacity: 1
};
function getStyle2(element, key) {
  var _a2;
  return (_a2 = element.style[key]) !== null && _a2 !== void 0 ? _a2 : defaultStyle[key];
}
function setStyle2(element, key, value2, recursive) {
  element.style[key] = value2;
  if (recursive) {
    element.children.forEach((child) => setStyle2(child, key, value2, recursive));
  }
}
function hide2(element) {
  setStyle2(element, "visibility", "hidden", true);
}
function show2(element) {
  setStyle2(element, "visibility", "visible", true);
}

// node_modules/@antv/g2/esm/interaction/utils.js
var __rest77 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function selectG2Elements(root2) {
  return select(root2).selectAll(`.${ELEMENT_CLASS_NAME}`).nodes().filter((d3) => !d3.__removed__);
}
function selectFacetG2Elements(target, viewInstances) {
  return selectFacetViews(target, viewInstances).flatMap(({ container }) => selectG2Elements(container));
}
function selectFacetViews(target, viewInstances) {
  return viewInstances.filter((d3) => d3 !== target && d3.options.parentKey === target.options.key);
}
function selectPlotArea(root2) {
  return select(root2).select(`.${PLOT_CLASS_NAME}`).node();
}
function bboxOf(element) {
  if (element.tagName === "g")
    return element.getRenderBounds();
  const bounds = element.getGeometryBounds();
  const aabb = new AABB();
  aabb.setFromTransformedAABB(bounds, element.getWorldTransform());
  return aabb;
}
function mousePosition(target, event) {
  const { offsetX, offsetY } = event;
  const bbox = bboxOf(target);
  const { min: [x3, y3], max: [x12, y12] } = bbox;
  const isOutX = offsetX < x3 || offsetX > x12;
  const isOutY = offsetY < y3 || offsetY > y12;
  if (isOutX || isOutY)
    return null;
  return [offsetX - x3, offsetY - y3];
}
function brushMousePosition(target, event) {
  const { offsetX, offsetY } = event;
  const [x3, y3, x12, y12] = boundsOfBrushArea(target);
  return [
    Math.min(x12, Math.max(x3, offsetX)) - x3,
    Math.min(y12, Math.max(y3, offsetY)) - y3
  ];
}
function boundsOfBrushArea(target) {
  const bbox = target.getRenderBounds();
  const { min: [x05, y05], max: [x12, y12] } = bbox;
  return [x05, y05, x12, y12];
}
function createColorKey(view) {
  return (element) => element.__data__.color;
}
function createXKey(view) {
  return (element) => element.__data__.x;
}
function createDatumof(view) {
  const views = Array.isArray(view) ? view : [view];
  const keyData = new Map(views.flatMap((view2) => {
    const marks = Array.from(view2.markState.keys());
    return marks.map((mark2) => [keyed(view2.key, mark2.key), mark2.data]);
  }));
  return (element) => {
    const { index: index3, markKey, viewKey } = element.__data__;
    const data2 = keyData.get(keyed(viewKey, markKey));
    return data2[index3];
  };
}
function useState(style, valueof2 = (d3, element) => d3, setAttribute = (element, key, v) => element.setAttribute(key, v)) {
  const STATES = "__states__";
  const ORIGINAL = "__ordinal__";
  const updateState = (element) => {
    const { [STATES]: states = [], [ORIGINAL]: original = {} } = element;
    const stateStyle = states.reduce((mixedStyle, state) => Object.assign(Object.assign({}, mixedStyle), style[state]), original);
    if (Object.keys(stateStyle).length === 0)
      return;
    for (const [key, value2] of Object.entries(stateStyle)) {
      const currentValue = getStyle2(element, key);
      const v = valueof2(value2, element);
      setAttribute(element, key, v);
      if (!(key in original))
        original[key] = currentValue;
    }
    element[ORIGINAL] = original;
  };
  const initState = (element) => {
    if (element[STATES])
      return;
    element[STATES] = [];
    return;
  };
  const setState = (element, ...states) => {
    initState(element);
    element[STATES] = [...states];
    updateState(element);
  };
  const removeState = (element, ...states) => {
    initState(element);
    for (const state of states) {
      const index3 = element[STATES].indexOf(state);
      if (index3 !== -1) {
        element[STATES].splice(index3, 1);
      }
    }
    updateState(element);
  };
  const hasState = (element, state) => {
    initState(element);
    return element[STATES].indexOf(state) !== -1;
  };
  return {
    setState,
    removeState,
    hasState
  };
}
function isEmptyObject(obj) {
  if (obj === void 0)
    return true;
  if (typeof obj !== "object")
    return false;
  return Object.keys(obj).length === 0;
}
function keyed(viewKey, markKey) {
  return `${viewKey},${markKey}`;
}
function mergeState(options, states) {
  const views = Array.isArray(options) ? options : [options];
  const markState = views.flatMap((view) => view.marks.map((mark2) => [keyed(view.key, mark2.key), mark2.state]));
  const state = {};
  for (const descriptor of states) {
    const [key, defaults4] = Array.isArray(descriptor) ? descriptor : [descriptor, {}];
    state[key] = markState.reduce((merged, mark2) => {
      const [markKey, markState2 = {}] = mark2;
      const selectedState = isEmptyObject(markState2[key]) ? defaults4 : markState2[key];
      for (const [attr2, value2] of Object.entries(selectedState)) {
        const oldValue = merged[attr2];
        const newValue = (data2, index3, array2, element) => {
          const k2 = keyed(element.__data__.viewKey, element.__data__.markKey);
          if (markKey !== k2)
            return oldValue === null || oldValue === void 0 ? void 0 : oldValue(data2, index3, array2, element);
          if (typeof value2 !== "function")
            return value2;
          return value2(data2, index3, array2, element);
        };
        merged[attr2] = newValue;
      }
      return merged;
    }, {});
  }
  return state;
}
function createValueof(elements, datum) {
  const elementIndex = new Map(elements.map((d3, i) => [d3, i]));
  const fa = datum ? elements.map(datum) : elements;
  return (d3, e) => {
    if (typeof d3 !== "function")
      return d3;
    const i = elementIndex.get(e);
    const fe = datum ? datum(e) : e;
    return d3(fe, i, fa, e);
  };
}
function renderLink(_a2) {
  var { link: link3 = false, valueof: valueof2 = (d3, element) => d3, coordinate } = _a2, style = __rest77(_a2, ["link", "valueof", "coordinate"]);
  const LINK_CLASS_NAME = "element-link";
  if (!link3)
    return [() => {
    }, () => {
    }];
  const pointsOf = (element) => element.__data__.points;
  const pathPointsOf = (P0, P1) => {
    const [, p1, p2] = P0;
    const [p0, , , p3] = P1;
    const P = [p1, p0, p3, p2];
    return P;
  };
  const append3 = (elements) => {
    var _a3;
    if (elements.length <= 1)
      return;
    const sortedElements = sort(elements, (e0, e1) => {
      const { x: x05 } = e0.__data__;
      const { x: x12 } = e1.__data__;
      const dx = x05 - x12;
      return dx;
    });
    for (let i = 1; i < sortedElements.length; i++) {
      const p2 = path();
      const e0 = sortedElements[i - 1];
      const e1 = sortedElements[i];
      const [p0, p1, p22, p3] = pathPointsOf(pointsOf(e0), pointsOf(e1));
      p2.moveTo(...p0);
      p2.lineTo(...p1);
      p2.lineTo(...p22);
      p2.lineTo(...p3);
      p2.closePath();
      const _b = mapObject(style, (d3) => valueof2(d3, e0)), { fill = e0.getAttribute("fill") } = _b, rest = __rest77(_b, ["fill"]);
      const link4 = new Path2({
        className: LINK_CLASS_NAME,
        style: Object.assign({ d: p2.toString(), fill, zIndex: -2 }, rest)
      });
      (_a3 = e0.link) === null || _a3 === void 0 ? void 0 : _a3.remove();
      e0.parentNode.appendChild(link4);
      e0.link = link4;
    }
  };
  const remove2 = (element) => {
    var _a3;
    (_a3 = element.link) === null || _a3 === void 0 ? void 0 : _a3.remove();
    element.link = null;
  };
  return [append3, remove2];
}
function offsetTransform(element, offset2, coordinate) {
  const append3 = (t) => {
    const { transform: transform2 } = element.style;
    return transform2 ? `${transform2} ${t}` : t;
  };
  if (isPolar(coordinate)) {
    const { points } = element.__data__;
    const [p0, p1] = isTranspose(coordinate) ? reorder(points) : points;
    const center2 = coordinate.getCenter();
    const v0 = sub6(p0, center2);
    const v1 = sub6(p1, center2);
    const a0 = angle3(v0);
    const da = angleBetween2(v0, v1);
    const amid = a0 + da / 2;
    const dx = offset2 * Math.cos(amid);
    const dy = offset2 * Math.sin(amid);
    return append3(`translate(${dx}, ${dy})`);
  }
  if (isTranspose(coordinate))
    return append3(`translate(${offset2}, 0)`);
  return append3(`translate(0, ${-offset2})`);
}
function renderBackground(_a2) {
  var { document: document2, background, scale: scale11, coordinate, valueof: valueof2 } = _a2, rest = __rest77(_a2, ["document", "background", "scale", "coordinate", "valueof"]);
  const BACKGROUND_CLASS_NAME = "element-background";
  if (!background)
    return [() => {
    }, () => {
    }];
  const extentOf2 = (scale12, x3, padding) => {
    const ax = scale12.invert(x3);
    const mid2 = x3 + scale12.getBandWidth(ax) / 2;
    const half = scale12.getStep(ax) / 2;
    const offset2 = half * padding;
    return [mid2 - half + offset2, mid2 + half - offset2];
  };
  const sizeXOf = (element, padding) => {
    const { x: scaleX2 } = scale11;
    if (!isOrdinalScale(scaleX2))
      return [0, 1];
    const { __data__: data2 } = element;
    const { x: x3 } = data2;
    const [e1, e23] = extentOf2(scaleX2, x3, padding);
    return [e1, e23];
  };
  const sizeYOf = (element, padding) => {
    const { y: scaleY2 } = scale11;
    if (!isOrdinalScale(scaleY2))
      return [0, 1];
    const { __data__: data2 } = element;
    const { y: y3 } = data2;
    const [e1, e23] = extentOf2(scaleY2, y3, padding);
    return [e1, e23];
  };
  const bandShapeOf = (element, style) => {
    const { padding } = style;
    const [x12, x22] = sizeXOf(element, padding);
    const [y12, y22] = sizeYOf(element, padding);
    const points = [
      [x12, y12],
      [x22, y12],
      [x22, y22],
      [x12, y22]
    ].map((d3) => coordinate.map(d3));
    const { __data__: data2 } = element;
    const { y: dy, y1: dy1 } = data2;
    return rect(document2, points, { y: dy, y1: dy1 }, coordinate, style);
  };
  const cloneShapeOf = (element, style) => {
    const { transform: transform2 = "scale(1.2, 1.2)", transformOrigin = "center center", stroke: stroke2 = "" } = style, rest2 = __rest77(style, ["transform", "transformOrigin", "stroke"]);
    const finalStyle = Object.assign({ transform: transform2, transformOrigin, stroke: stroke2 }, rest2);
    const shape23 = element.cloneNode(true);
    for (const [key, value2] of Object.entries(finalStyle)) {
      shape23.style[key] = value2;
    }
    return shape23;
  };
  const isOrdinalShape = () => {
    const { x: x3, y: y3 } = scale11;
    return [x3, y3].some(isOrdinalScale);
  };
  const append3 = (element) => {
    if (element.background)
      element.background.remove();
    const _a3 = mapObject(rest, (d3) => valueof2(d3, element)), { fill = "#CCD6EC", fillOpacity = 0.3, zIndex = -2, padding = 1e-3, lineWidth = 0 } = _a3, style = __rest77(_a3, ["fill", "fillOpacity", "zIndex", "padding", "lineWidth"]);
    const finalStyle = Object.assign(Object.assign({}, style), {
      fill,
      fillOpacity,
      zIndex,
      padding,
      lineWidth
    });
    const shapeOf = isOrdinalShape() ? bandShapeOf : cloneShapeOf;
    const shape23 = shapeOf(element, finalStyle);
    shape23.className = BACKGROUND_CLASS_NAME;
    element.parentNode.parentNode.appendChild(shape23);
    element.background = shape23;
  };
  const remove2 = (element) => {
    var _a3;
    (_a3 = element.background) === null || _a3 === void 0 ? void 0 : _a3.remove();
    element.background = null;
  };
  const is = (element) => {
    return element.className === BACKGROUND_CLASS_NAME;
  };
  return [append3, remove2, is];
}
function setCursor(root2, cursor) {
  const canvas = root2.getRootNode().defaultView;
  const dom2 = canvas.getContextService().getDomElement();
  if (dom2 === null || dom2 === void 0 ? void 0 : dom2.style) {
    root2.cursor = dom2.style.cursor;
    dom2.style.cursor = cursor;
  }
}
function restoreCursor(root2) {
  setCursor(root2, root2.cursor);
}
function selectElementByData(elements, data2, datum) {
  return elements.find((d3) => Object.entries(data2).every(([key, value2]) => datum(d3)[key] === value2));
}
function getPointsR(point7, nextPoint) {
  return Math.sqrt(Math.pow(point7[0] - nextPoint[0], 2) + Math.pow(point7[1] - nextPoint[1], 2));
}
function getPointsPath(points, isClose = false) {
  const path2 = filter_default(points, (d3) => !!d3).map((d3, i) => {
    return [i === 0 ? "M" : "L", ...d3];
  });
  if (isClose) {
    path2.push(["Z"]);
  }
  return path2;
}
function getElements(plot2) {
  return plot2.querySelectorAll(".element");
}
function getThetaPath(center2, points, isBig = 0) {
  const path2 = [["M", ...points[1]]];
  const innerRadius = getPointsR(center2, points[1]);
  const outerRadius = getPointsR(center2, points[0]);
  if (innerRadius === 0) {
    path2.push(["L", ...points[3]], ["A", outerRadius, outerRadius, 0, isBig, 1, ...points[0]], ["Z"]);
  } else {
    path2.push(["A", innerRadius, innerRadius, 0, isBig, 0, ...points[2]], ["L", ...points[3]], ["A", outerRadius, outerRadius, 0, isBig, 1, ...points[0]], ["Z"]);
  }
  return path2;
}
function maybeRoot(node, rootOf) {
  if (rootOf(node))
    return node;
  let root2 = node.parent;
  while (root2 && !rootOf(root2))
    root2 = root2.parent;
  return root2;
}

// node_modules/@antv/g2/esm/interaction/elementHighlight.js
var __rest78 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function elementHighlight(root2, {
  elements: elementsof,
  // given the root of chart returns elements to be manipulated
  datum,
  // given each element returns the datum of it
  groupKey = (d3) => d3,
  // group elements by specified key
  link: link3 = false,
  // draw link or not
  background = false,
  // draw background or not
  delay = 60,
  // delay to unhighlighted element
  scale: scale11,
  coordinate,
  emitter,
  state = {}
}) {
  var _a2;
  const elements = elementsof(root2);
  const elementSet = new Set(elements);
  const keyGroup = group(elements, groupKey);
  const valueof2 = createValueof(elements, datum);
  const [appendLink, removeLink] = renderLink(Object.assign({
    elements,
    valueof: valueof2,
    link: link3,
    coordinate
  }, subObject(state.active, "link")));
  const [appendBackground, removeBackground, isBackground] = renderBackground(Object.assign({
    document: root2.ownerDocument,
    scale: scale11,
    coordinate,
    background,
    valueof: valueof2
  }, subObject(state.active, "background")));
  const elementStyle = deep_mix_default(state, {
    active: Object.assign({}, ((_a2 = state.active) === null || _a2 === void 0 ? void 0 : _a2.offset) && {
      //Apply translate to mock slice out.
      transform: (...params) => {
        const value2 = state.active.offset(...params);
        const [, i] = params;
        return offsetTransform(elements[i], value2, coordinate);
      }
    })
  });
  const { setState, removeState, hasState } = useState(elementStyle, valueof2);
  let out;
  const pointerover = (event) => {
    const { target: element, nativeEvent = true } = event;
    if (!elementSet.has(element))
      return;
    if (out)
      clearTimeout(out);
    const k2 = groupKey(element);
    const group3 = keyGroup.get(k2);
    const groupSet = new Set(group3);
    for (const e of elements) {
      if (groupSet.has(e)) {
        if (!hasState(e, "active"))
          setState(e, "active");
      } else {
        setState(e, "inactive");
        removeLink(e);
      }
      if (e !== element)
        removeBackground(e);
    }
    appendBackground(element);
    appendLink(group3);
    if (!nativeEvent)
      return;
    emitter.emit("element:highlight", {
      nativeEvent,
      data: {
        data: datum(element),
        group: group3.map(datum)
      }
    });
  };
  const delayUnhighlighted = () => {
    if (out)
      clearTimeout(out);
    out = setTimeout(() => {
      unhighlighted();
      out = null;
    }, delay);
  };
  const unhighlighted = (nativeEvent = true) => {
    for (const e of elements) {
      removeState(e, "active", "inactive");
      removeBackground(e);
      removeLink(e);
    }
    if (nativeEvent) {
      emitter.emit("element:unhighlight", { nativeEvent });
    }
  };
  const pointerout = (event) => {
    const { target: element } = event;
    if (background && !isBackground(element))
      return;
    if (!background && !elementSet.has(element))
      return;
    if (delay > 0)
      delayUnhighlighted();
    else
      unhighlighted();
  };
  const pointerleave = () => {
    unhighlighted();
  };
  root2.addEventListener("pointerover", pointerover);
  root2.addEventListener("pointerout", pointerout);
  root2.addEventListener("pointerleave", pointerleave);
  const onRest = (e) => {
    const { nativeEvent } = e;
    if (nativeEvent)
      return;
    unhighlighted(false);
  };
  const onHighlight = (e) => {
    const { nativeEvent } = e;
    if (nativeEvent)
      return;
    const { data: data2 } = e.data;
    const element = selectElementByData(elements, data2, datum);
    if (!element)
      return;
    pointerover({ target: element, nativeEvent: false });
  };
  emitter.on("element:highlight", onHighlight);
  emitter.on("element:unhighlight", onRest);
  return () => {
    root2.removeEventListener("pointerover", pointerover);
    root2.removeEventListener("pointerout", pointerout);
    root2.removeEventListener("pointerleave", pointerleave);
    emitter.off("element:highlight", onHighlight);
    emitter.off("element:unhighlight", onRest);
    for (const e of elements) {
      removeBackground(e);
      removeLink(e);
    }
  };
}
function ElementHighlight(_a2) {
  var { delay, createGroup, background = false, link: link3 = false } = _a2, rest = __rest78(_a2, ["delay", "createGroup", "background", "link"]);
  return (context, _2, emitter) => {
    const { container, view, options } = context;
    const { scale: scale11, coordinate } = view;
    const plotArea = selectPlotArea(container);
    return elementHighlight(plotArea, Object.assign({
      elements: selectG2Elements,
      datum: createDatumof(view),
      groupKey: createGroup ? createGroup(view) : void 0,
      coordinate,
      scale: scale11,
      state: mergeState(options, [
        ["active", background ? {} : { lineWidth: "1", stroke: "#000" }],
        "inactive"
      ]),
      background,
      link: link3,
      delay,
      emitter
    }, rest));
  };
}
ElementHighlight.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementHighlightByX.js
function ElementHighlightByX(options) {
  return ElementHighlight(Object.assign(Object.assign({}, options), { createGroup: createXKey }));
}
ElementHighlightByX.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementHighlightByColor.js
function ElementHighlightByColor(options) {
  return ElementHighlight(Object.assign(Object.assign({}, options), { createGroup: createColorKey }));
}
ElementHighlightByColor.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementSelect.js
var __rest79 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function elementSelect(root2, {
  elements: elementsof,
  // given the root of chart returns elements to be manipulated
  datum,
  // given each element returns the datum of it
  groupKey = (d3) => d3,
  // group elements by specified key
  link: link3 = false,
  // draw link or not
  single = false,
  // single select or not
  coordinate,
  background = false,
  scale: scale11,
  emitter,
  state = {}
}) {
  var _a2;
  const elements = elementsof(root2);
  const elementSet = new Set(elements);
  const keyGroup = group(elements, groupKey);
  const valueof2 = createValueof(elements, datum);
  const [appendLink, removeLink] = renderLink(Object.assign({
    link: link3,
    elements,
    valueof: valueof2,
    coordinate
  }, subObject(state.selected, "link")));
  const [appendBackground, removeBackground] = renderBackground(Object.assign({
    document: root2.ownerDocument,
    background,
    coordinate,
    scale: scale11,
    valueof: valueof2
  }, subObject(state.selected, "background")));
  const elementStyle = deep_mix_default(state, {
    selected: Object.assign({}, ((_a2 = state.selected) === null || _a2 === void 0 ? void 0 : _a2.offset) && {
      //Apply translate to mock slice out.
      transform: (...params) => {
        const value2 = state.selected.offset(...params);
        const [, i] = params;
        return offsetTransform(elements[i], value2, coordinate);
      }
    })
  });
  const { setState, removeState, hasState } = useState(elementStyle, valueof2);
  const clear = (nativeEvent = true) => {
    for (const e of elements) {
      removeState(e, "selected", "unselected");
      removeLink(e);
      removeBackground(e);
    }
    if (nativeEvent)
      emitter.emit("element:unselect", { nativeEvent: true });
    return;
  };
  const singleSelect = (event, element, nativeEvent = true) => {
    if (hasState(element, "selected"))
      clear();
    else {
      const k2 = groupKey(element);
      const group3 = keyGroup.get(k2);
      const groupSet = new Set(group3);
      for (const e of elements) {
        if (groupSet.has(e))
          setState(e, "selected");
        else {
          setState(e, "unselected");
          removeLink(e);
        }
        if (e !== element)
          removeBackground(e);
      }
      appendLink(group3);
      appendBackground(element);
      if (!nativeEvent)
        return;
      emitter.emit("element:select", Object.assign(Object.assign({}, event), { nativeEvent, data: {
        data: [datum(element), ...group3.map(datum)]
      } }));
    }
  };
  const multipleSelect = (event, element, nativeEvent = true) => {
    const k2 = groupKey(element);
    const group3 = keyGroup.get(k2);
    const groupSet = new Set(group3);
    if (!hasState(element, "selected")) {
      const hasSelectedGroup = group3.some((e) => hasState(e, "selected"));
      for (const e of elements) {
        if (groupSet.has(e))
          setState(e, "selected");
        else if (!hasState(e, "selected"))
          setState(e, "unselected");
      }
      if (!hasSelectedGroup && link3)
        appendLink(group3);
      appendBackground(element);
    } else {
      const hasSelected = elements.some((e) => !groupSet.has(e) && hasState(e, "selected"));
      if (!hasSelected)
        return clear();
      for (const e of group3) {
        setState(e, "unselected");
        removeLink(e);
        removeBackground(e);
      }
    }
    if (!nativeEvent)
      return;
    emitter.emit("element:select", Object.assign(Object.assign({}, event), { nativeEvent, data: {
      data: elements.filter((e) => hasState(e, "selected")).map(datum)
    } }));
  };
  const click = (event) => {
    const { target: element, nativeEvent = true } = event;
    if (!elementSet.has(element))
      return clear();
    if (single)
      return singleSelect(event, element, nativeEvent);
    return multipleSelect(event, element, nativeEvent);
  };
  root2.addEventListener("click", click);
  const onSelect = (e) => {
    const { nativeEvent, data: data2 } = e;
    if (nativeEvent)
      return;
    const selectedData = single ? data2.data.slice(0, 1) : data2.data;
    for (const d3 of selectedData) {
      const element = selectElementByData(elements, d3, datum);
      click({ target: element, nativeEvent: false });
    }
  };
  const onUnSelect = () => {
    clear(false);
  };
  emitter.on("element:select", onSelect);
  emitter.on("element:unselect", onUnSelect);
  return () => {
    for (const e of elements)
      removeLink(e);
    root2.removeEventListener("click", click);
    emitter.off("element:select", onSelect);
    emitter.off("element:unselect", onUnSelect);
  };
}
function ElementSelect(_a2) {
  var { createGroup, background = false, link: link3 = false } = _a2, rest = __rest79(_a2, ["createGroup", "background", "link"]);
  return (context, _2, emitter) => {
    const { container, view, options } = context;
    const { coordinate, scale: scale11 } = view;
    const plotArea = selectPlotArea(container);
    return elementSelect(plotArea, Object.assign({
      elements: selectG2Elements,
      datum: createDatumof(view),
      groupKey: createGroup ? createGroup(view) : void 0,
      coordinate,
      scale: scale11,
      state: mergeState(options, [
        ["selected", background ? {} : { lineWidth: "1", stroke: "#000" }],
        "unselected"
      ]),
      background,
      link: link3,
      emitter
    }, rest));
  };
}
ElementSelect.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementSelectByX.js
function ElementSelectByX(options) {
  return ElementSelect(Object.assign(Object.assign({}, options), { createGroup: createXKey }));
}
ElementSelectByX.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementSelectByColor.js
function ElementSelectByColor(options) {
  return ElementSelect(Object.assign(Object.assign({}, options), { createGroup: createColorKey }));
}
ElementSelectByColor.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/chartIndex.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest80 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function maybeTransform(options) {
  const { transform: transform2 = [] } = options;
  const normalizeY = transform2.find((d3) => d3.type === "normalizeY");
  if (normalizeY)
    return normalizeY;
  const newNormalizeY = { type: "normalizeY" };
  transform2.push(newNormalizeY);
  options.transform = transform2;
  return newNormalizeY;
}
function markValue2(markState, markName, channels) {
  const [value2] = Array.from(markState.entries()).filter(([mark2]) => mark2.type === markName).map(([mark2]) => {
    const { encode } = mark2;
    const channel = (name2) => {
      const channel2 = encode[name2];
      return [name2, channel2 ? channel2.value : void 0];
    };
    return Object.fromEntries(channels.map(channel));
  });
  return value2;
}
function ChartIndex(_a2) {
  var { wait = 20, leading, trailing = false, labelFormatter: labelFormatter2 = (date) => `${date}` } = _a2, style = __rest80(_a2, ["wait", "leading", "trailing", "labelFormatter"]);
  return (context) => {
    const { view, container, update: update2, setState } = context;
    const { markState, scale: scale11, coordinate } = view;
    const value2 = markValue2(markState, "line", ["x", "y", "series"]);
    if (!value2)
      return;
    const { y: Y, x: X, series: S = [] } = value2;
    const I = Y.map((_2, i) => i);
    const sortedX = sort(I.map((i) => X[i]));
    const plotArea = selectPlotArea(container);
    const lines = container.getElementsByClassName(ELEMENT_CLASS_NAME);
    const labels = container.getElementsByClassName(LABEL_CLASS_NAME);
    const keyofLabel = (d3) => d3.__data__.key.split("-")[0];
    const keyLabels = group(labels, keyofLabel);
    const rule = new Line({
      style: Object.assign({ x1: 0, y1: 0, x2: 0, y2: plotArea.getAttribute("height"), stroke: "black", lineWidth: 1 }, subObject(style, "rule"))
    });
    const text = new Text({
      style: Object.assign({ x: 0, y: plotArea.getAttribute("height"), text: "", fontSize: 10 }, subObject(style, "label"))
    });
    rule.append(text);
    plotArea.appendChild(rule);
    const dateByFocus = (coordinate2, scaleX2, focus) => {
      const [normalizedX] = coordinate2.invert(focus);
      const date = scaleX2.invert(normalizedX);
      return sortedX[bisectCenter(sortedX, date)];
    };
    const updateRule = (focus, date) => {
      rule.setAttribute("x1", focus[0]);
      rule.setAttribute("x2", focus[0]);
      text.setAttribute("text", labelFormatter2(date));
    };
    let newView;
    const updateBasisByRerender = (focus) => __awaiter6(this, void 0, void 0, function* () {
      const { x: scaleX2 } = scale11;
      const date = dateByFocus(coordinate, scaleX2, focus);
      updateRule(focus, date);
      setState("chartIndex", (options) => {
        const clonedOptions = deep_mix_default({}, options);
        const lineMark = clonedOptions.marks.find((d3) => d3.type === "line");
        const r = (I2) => max5(I2, (i) => +Y[i]) / min4(I2, (i) => +Y[i]);
        const k2 = max5(rollup(I, r, (i) => S[i]).values());
        const domainY = [1 / k2, k2];
        deep_mix_default(lineMark, {
          scale: { y: { domain: domainY } }
        });
        const normalizeY = maybeTransform(lineMark);
        normalizeY.groupBy = "color";
        normalizeY.basis = (I2, Y3) => {
          const i = I2[bisector((i2) => X[+i2]).center(I2, date)];
          return Y3[i];
        };
        for (const mark2 of clonedOptions.marks)
          mark2.animate = false;
        return clonedOptions;
      });
      const newState = yield update2("chartIndex");
      newView = newState.view;
    });
    const updateBasisByTranslate = (focus) => {
      const { scale: scale12, coordinate: coordinate2 } = newView;
      const { x: scaleX2, y: scaleY2 } = scale12;
      const date = dateByFocus(coordinate2, scaleX2, focus);
      updateRule(focus, date);
      for (const line4 of lines) {
        const { seriesIndex: SI, key } = line4.__data__;
        const i = SI[bisector((i2) => X[+i2]).center(SI, date)];
        const p0 = [0, scaleY2.map(1)];
        const p1 = [0, scaleY2.map(Y[i] / Y[SI[0]])];
        const [, y05] = coordinate2.map(p0);
        const [, y12] = coordinate2.map(p1);
        const dy = y05 - y12;
        line4.setAttribute("transform", `translate(0, ${dy})`);
        const labels2 = keyLabels.get(key) || [];
        for (const label of labels2) {
          label.setAttribute("dy", dy);
        }
      }
    };
    const updateBasis = throttle_default((event) => {
      const focus = mousePosition(plotArea, event);
      if (!focus)
        return;
      updateBasisByTranslate(focus);
    }, wait, { leading, trailing });
    updateBasisByRerender([0, 0]);
    plotArea.addEventListener("pointerenter", updateBasis);
    plotArea.addEventListener("pointermove", updateBasis);
    plotArea.addEventListener("pointerleave", updateBasis);
    return () => {
      rule.remove();
      plotArea.removeEventListener("pointerenter", updateBasis);
      plotArea.removeEventListener("pointermove", updateBasis);
      plotArea.removeEventListener("pointerleave", updateBasis);
    };
  };
}
ChartIndex.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/fisheye.js
function maybeCoordinate(options) {
  const { coordinate = {} } = options;
  const { transform: transform2 = [] } = coordinate;
  const fisheye2 = transform2.find((d3) => d3.type === "fisheye");
  if (fisheye2)
    return fisheye2;
  const newFisheye = { type: "fisheye" };
  transform2.push(newFisheye);
  coordinate.transform = transform2;
  options.coordinate = coordinate;
  return newFisheye;
}
function Fisheye2({ wait = 30, leading, trailing = false }) {
  return (context) => {
    const { options, update: update2, setState, container } = context;
    const plotArea = selectPlotArea(container);
    const updateFocus = throttle_default((event) => {
      const focus = mousePosition(plotArea, event);
      if (!focus) {
        setState("fisheye");
        update2();
        return;
      }
      setState("fisheye", (options2) => {
        const clonedOptions = deep_mix_default({}, options2, {
          interaction: { tooltip: { preserve: true } }
        });
        for (const mark2 of clonedOptions.marks)
          mark2.animate = false;
        const [x3, y3] = focus;
        const fisheye2 = maybeCoordinate(clonedOptions);
        fisheye2.focusX = x3;
        fisheye2.focusY = y3;
        fisheye2.visual = true;
        return clonedOptions;
      });
      update2();
    }, wait, { leading, trailing });
    plotArea.addEventListener("pointerenter", updateFocus);
    plotArea.addEventListener("pointermove", updateFocus);
    plotArea.addEventListener("pointerleave", updateFocus);
    return () => {
      plotArea.removeEventListener("pointerenter", updateFocus);
      plotArea.removeEventListener("pointermove", updateFocus);
      plotArea.removeEventListener("pointerleave", updateFocus);
    };
  };
}

// node_modules/@antv/g2/esm/interaction/tooltip.js
var __rest81 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function getContainer(group3, mount) {
  if (mount) {
    return typeof mount === "string" ? document.querySelector(mount) : mount;
  }
  const canvas = group3.ownerDocument.defaultView.getContextService().getDomElement();
  return canvas.parentElement;
}
function getBounding(root2) {
  const bbox = root2.getRenderBounds();
  const { min: [x12, y12], max: [x22, y22] } = bbox;
  return {
    x: x12,
    y: y12,
    width: x22 - x12,
    height: y22 - y12
  };
}
function getContainerOffset(container1, container2) {
  const r1 = container1.getBoundingClientRect();
  const r2 = container2.getBoundingClientRect();
  return {
    x: r1.x - r2.x,
    y: r1.y - r2.y
  };
}
function createTooltip(container, x05, y05, position, enterable, bounding, containerOffset, css = {}, offset2 = [10, 10]) {
  const defaults4 = {
    ".g2-tooltip": {},
    ".g2-tooltip-title": {
      overflow: "hidden",
      "white-space": "nowrap",
      "text-overflow": "ellipsis"
    }
  };
  const tooltipElement = new Tooltip({
    className: "tooltip",
    style: {
      x: x05,
      y: y05,
      container: containerOffset,
      data: [],
      bounding,
      position,
      enterable,
      title: "",
      offset: offset2,
      template: {
        prefixCls: "g2-"
      },
      style: deep_mix_default(defaults4, css)
    }
  });
  container.appendChild(tooltipElement.HTMLTooltipElement);
  return tooltipElement;
}
function showTooltip({ root: root2, data: data2, x: x3, y: y3, render: render3, event, single, position = "right-bottom", enterable = false, css, mount, bounding, offset: offset2 }) {
  const container = getContainer(root2, mount);
  const canvasContainer = getContainer(root2);
  const parent = single ? canvasContainer : root2;
  const b = bounding || getBounding(root2);
  const containerOffset = getContainerOffset(canvasContainer, container);
  const { tooltipElement = createTooltip(container, x3, y3, position, enterable, b, containerOffset, css, offset2) } = parent;
  const { items, title = "" } = data2;
  tooltipElement.update(Object.assign({
    x: x3,
    y: y3,
    data: items,
    title,
    position,
    enterable,
    container: containerOffset
  }, render3 !== void 0 && {
    content: render3(event, { items, title })
  }));
  parent.tooltipElement = tooltipElement;
}
function hideTooltip({ root: root2, single, emitter, nativeEvent = true, event = null }) {
  if (nativeEvent) {
    emitter.emit("tooltip:hide", { nativeEvent });
  }
  const container = getContainer(root2);
  const parent = single ? container : root2;
  const { tooltipElement } = parent;
  if (tooltipElement) {
    tooltipElement.hide(event === null || event === void 0 ? void 0 : event.clientX, event === null || event === void 0 ? void 0 : event.clientY);
  }
  hideRuleY(root2);
  hideRuleX(root2);
  hideMarker(root2);
}
function destroyTooltip({ root: root2, single }) {
  const container = getContainer(root2);
  const parent = single ? container : root2;
  if (!parent)
    return;
  const { tooltipElement } = parent;
  if (tooltipElement) {
    tooltipElement.destroy();
    parent.tooltipElement = void 0;
  }
  hideRuleY(root2);
  hideRuleX(root2);
  hideMarker(root2);
}
function showUndefined(item) {
  const { value: value2 } = item;
  return Object.assign(Object.assign({}, item), { value: value2 === void 0 ? "undefined" : value2 });
}
function singleItem(element) {
  const { __data__: datum } = element;
  const { title, items = [] } = datum;
  const newItems = items.filter(defined).map((_a2) => {
    var { color: color3 = itemColorOf(element) } = _a2, item = __rest81(_a2, ["color"]);
    return Object.assign(Object.assign({}, item), { color: color3 });
  }).map(showUndefined);
  return Object.assign(Object.assign({}, title && { title }), { items: newItems });
}
function groupNameOf(scale11, datum) {
  const { color: scaleColor, series: scaleSeries, facet = false } = scale11;
  const { color: color3, series } = datum;
  const invertAble = (scale12) => {
    return scale12 && scale12.invert && !(scale12 instanceof Band) && !(scale12 instanceof Constant2);
  };
  if (invertAble(scaleSeries)) {
    const cloned = scaleSeries.clone();
    return cloned.invert(series);
  }
  if (series && scaleSeries instanceof Band && scaleSeries.invert(series) !== color3 && !facet) {
    return scaleSeries.invert(series);
  }
  if (invertAble(scaleColor)) {
    const name2 = scaleColor.invert(color3);
    if (Array.isArray(name2))
      return null;
    return name2;
  }
  return null;
}
function itemColorOf(element) {
  const fill = element.getAttribute("fill");
  const stroke2 = element.getAttribute("stroke");
  const { __data__: datum } = element;
  const { color: color3 = fill && fill !== "transparent" ? fill : stroke2 } = datum;
  return color3;
}
function unique2(items, key = (d3) => d3) {
  const valueName = new Map(items.map((d3) => [key(d3), d3]));
  return Array.from(valueName.values());
}
function groupItems(elements, scale11, groupName, data2 = elements.map((d3) => d3["__data__"]), theme = {}) {
  const key = (d3) => d3 instanceof Date ? +d3 : d3;
  const T = unique2(data2.map((d3) => d3.title), key).filter(defined);
  const newItems = data2.flatMap((datum, i) => {
    const element = elements[i];
    const { items = [], title } = datum;
    const definedItems = items.filter(defined);
    const useGroupName = groupName !== void 0 ? groupName : items.length <= 1 ? true : false;
    return definedItems.map((_a2) => {
      var { color: color3 = itemColorOf(element) || theme.color, name: name2 } = _a2, item = __rest81(_a2, ["color", "name"]);
      const groupName2 = groupNameOf(scale11, datum);
      const name1 = useGroupName ? groupName2 || name2 : name2 || groupName2;
      return Object.assign(Object.assign({}, item), { color: color3, name: name1 || title });
    });
  }).map(showUndefined);
  return Object.assign(Object.assign({}, T.length > 0 && { title: T.join(",") }), { items: unique2(newItems, (d3) => `(${key(d3.name)}, ${key(d3.value)}, ${key(d3.color)})`) });
}
function updateRuleX(root2, points, mouse, _a2) {
  var { plotWidth, plotHeight, mainWidth, mainHeight, startX, startY, transposed, polar: polar2, insetLeft, insetTop } = _a2, rest = __rest81(_a2, ["plotWidth", "plotHeight", "mainWidth", "mainHeight", "startX", "startY", "transposed", "polar", "insetLeft", "insetTop"]);
  const defaults4 = Object.assign({ lineWidth: 1, stroke: "#1b1e23", strokeOpacity: 0.5 }, rest);
  const createCircle = (cx, cy, r) => {
    const circle3 = new Circle({
      style: Object.assign({
        cx,
        cy,
        r
      }, defaults4)
    });
    root2.appendChild(circle3);
    return circle3;
  };
  const createLine = (x12, x22, y12, y22) => {
    const line4 = new Line({
      style: Object.assign({
        x1: x12,
        x2: x22,
        y1: y12,
        y2: y22
      }, defaults4)
    });
    root2.appendChild(line4);
    return line4;
  };
  const minDistPoint = (mouse2, points2) => {
    if (points2.length === 1) {
      return points2[0];
    }
    const dists = points2.map((p2) => dist4(p2, mouse2));
    const minDistIndex = minIndex(dists, (d3) => d3);
    return points2[minDistIndex];
  };
  const target = minDistPoint(mouse, points);
  const pointsOf = () => {
    if (transposed)
      return [
        startX + target[0],
        startX + target[0],
        startY,
        startY + plotHeight
      ];
    return [startX, startX + plotWidth, target[1] + startY, target[1] + startY];
  };
  const pointsOfPolar = () => {
    const cx = startX + insetLeft + mainWidth / 2;
    const cy = startY + insetTop + mainHeight / 2;
    const cdist = dist4([cx, cy], target);
    return [cx, cy, cdist];
  };
  if (polar2) {
    const [cx, cy, r] = pointsOfPolar();
    const ruleX = root2.ruleX || createCircle(cx, cy, r);
    ruleX.style.cx = cx;
    ruleX.style.cy = cy;
    ruleX.style.r = r;
    root2.ruleX = ruleX;
  } else {
    const [x12, x22, y12, y22] = pointsOf();
    const ruleX = root2.ruleX || createLine(x12, x22, y12, y22);
    ruleX.style.x1 = x12;
    ruleX.style.x2 = x22;
    ruleX.style.y1 = y12;
    ruleX.style.y2 = y22;
    root2.ruleX = ruleX;
  }
}
function updateRuleY(root2, points, _a2) {
  var { plotWidth, plotHeight, mainWidth, mainHeight, startX, startY, transposed, polar: polar2, insetLeft, insetTop } = _a2, rest = __rest81(_a2, ["plotWidth", "plotHeight", "mainWidth", "mainHeight", "startX", "startY", "transposed", "polar", "insetLeft", "insetTop"]);
  const defaults4 = Object.assign({ lineWidth: 1, stroke: "#1b1e23", strokeOpacity: 0.5 }, rest);
  const Y = points.map((p2) => p2[1]);
  const X = points.map((p2) => p2[0]);
  const y3 = mean(Y);
  const x3 = mean(X);
  const pointsOf = () => {
    if (polar2) {
      const r = Math.min(mainWidth, mainHeight) / 2;
      const cx = startX + insetLeft + mainWidth / 2;
      const cy = startY + insetTop + mainHeight / 2;
      const a4 = angle3(sub6([x3, y3], [cx, cy]));
      const x05 = cx + r * Math.cos(a4);
      const y05 = cy + r * Math.sin(a4);
      return [cx, x05, cy, y05];
    }
    if (transposed)
      return [startX, startX + plotWidth, y3 + startY, y3 + startY];
    return [x3 + startX, x3 + startX, startY, startY + plotHeight];
  };
  const [x12, x22, y12, y22] = pointsOf();
  const createLine = () => {
    const line4 = new Line({
      style: Object.assign({
        x1: x12,
        x2: x22,
        y1: y12,
        y2: y22
      }, defaults4)
    });
    root2.appendChild(line4);
    return line4;
  };
  if (X.length > 0) {
    const ruleY = root2.ruleY || createLine();
    ruleY.style.x1 = x12;
    ruleY.style.x2 = x22;
    ruleY.style.y1 = y12;
    ruleY.style.y2 = y22;
    root2.ruleY = ruleY;
  }
}
function hideRuleY(root2) {
  if (root2.ruleY) {
    root2.ruleY.remove();
    root2.ruleY = void 0;
  }
}
function hideRuleX(root2) {
  if (root2.ruleX) {
    root2.ruleX.remove();
    root2.ruleX = void 0;
  }
}
function updateMarker(root2, { data: data2, style, theme }) {
  if (root2.markers)
    root2.markers.forEach((d3) => d3.remove());
  const { type = "" } = style;
  const markers = data2.filter((d3) => {
    const [{ x: x3, y: y3 }] = d3;
    return defined(x3) && defined(y3);
  }).map((d3) => {
    const [{ color: color3, element }, point7] = d3;
    const originColor = color3 || // encode value
    element.style.fill || element.style.stroke || theme.color;
    const fill = type === "hollow" ? "transparent" : originColor;
    const stroke2 = type === "hollow" ? originColor : "#fff";
    const shape23 = new Circle({
      className: "g2-tooltip-marker",
      style: Object.assign({ cx: point7[0], cy: point7[1], fill, r: 4, stroke: stroke2, lineWidth: 2 }, style)
    });
    return shape23;
  });
  for (const marker of markers)
    root2.appendChild(marker);
  root2.markers = markers;
}
function hideMarker(root2) {
  if (root2.markers) {
    root2.markers.forEach((d3) => d3.remove());
    root2.markers = [];
  }
}
function interactionKeyof(markState, key) {
  return Array.from(markState.values()).some(
    // @ts-ignore
    (d3) => {
      var _a2;
      return (_a2 = d3.interaction) === null || _a2 === void 0 ? void 0 : _a2[key];
    }
  );
}
function maybeValue(specified, defaults4) {
  return specified === void 0 ? defaults4 : specified;
}
function isEmptyTooltipData(data2) {
  const { title, items } = data2;
  if (items.length === 0 && title === void 0)
    return true;
  return false;
}
function hasSeries(markState) {
  return Array.from(markState.values()).some(
    // @ts-ignore
    (d3) => {
      var _a2;
      return ((_a2 = d3.interaction) === null || _a2 === void 0 ? void 0 : _a2.seriesTooltip) && d3.tooltip;
    }
  );
}
function seriesTooltip(root2, _a2) {
  var { elements: elementsof, sort: sortFunction, filter: filterFunction, scale: scale11, coordinate, crosshairs, crosshairsX, crosshairsY, render: render3, groupName, emitter, wait = 50, leading = true, trailing = false, startX = 0, startY = 0, body = true, single = true, position, enterable, mount, bounding, theme, offset: offset2, disableNative = false, marker = true, preserve = false, style: _style = {}, css = {} } = _a2, rest = __rest81(_a2, ["elements", "sort", "filter", "scale", "coordinate", "crosshairs", "crosshairsX", "crosshairsY", "render", "groupName", "emitter", "wait", "leading", "trailing", "startX", "startY", "body", "single", "position", "enterable", "mount", "bounding", "theme", "offset", "disableNative", "marker", "preserve", "style", "css"]);
  const elements = elementsof(root2);
  const transposed = isTranspose(coordinate);
  const polar2 = isPolar(coordinate);
  const style = deep_mix_default(_style, rest);
  const { innerWidth: plotWidth, innerHeight: plotHeight, width: mainWidth, height: mainHeight, insetLeft, insetTop } = coordinate.getOptions();
  const seriesElements = [];
  const itemElements = [];
  for (const element of elements) {
    const { __data__: data2 } = element;
    const { seriesX, title, items } = data2;
    if (seriesX)
      seriesElements.push(element);
    else if (title || items)
      itemElements.push(element);
  }
  const inInterval = (d3) => d3.markType === "interval";
  const isBar = itemElements.length && itemElements.every(inInterval) && !isPolar(coordinate);
  const xof = (d3) => d3.__data__.x;
  const isBandScale = !!scale11.x.getBandWidth;
  const closest = isBandScale && itemElements.length > 0;
  seriesElements.sort((a4, b) => {
    const index3 = transposed ? 0 : 1;
    const minY = (d3) => d3.getBounds().min[index3];
    return transposed ? minY(b) - minY(a4) : minY(a4) - minY(b);
  });
  const extent2 = (d3) => {
    const index3 = transposed ? 1 : 0;
    const { min: min10, max: max11 } = d3.getLocalBounds();
    return sort([min10[index3], max11[index3]]);
  };
  if (isBar)
    elements.sort((a4, b) => xof(a4) - xof(b));
  else {
    itemElements.sort((a4, b) => {
      const [minA, maxA] = extent2(a4);
      const [minB, maxB] = extent2(b);
      const midA = (minA + maxA) / 2;
      const midB = (minB + maxB) / 2;
      return transposed ? midB - midA : midA - midB;
    });
  }
  const elementSortedX = new Map(seriesElements.map((element) => {
    const { __data__: data2 } = element;
    const { seriesX } = data2;
    const seriesIndex = seriesX.map((_2, i) => i);
    const sortedIndex2 = sort(seriesIndex, (i) => seriesX[+i]);
    return [element, [sortedIndex2, seriesX]];
  }));
  const { x: scaleX2 } = scale11;
  const offsetX = (scaleX2 === null || scaleX2 === void 0 ? void 0 : scaleX2.getBandWidth) ? scaleX2.getBandWidth() / 2 : 0;
  const abstractX = (focus) => {
    const [normalizedX] = coordinate.invert(focus);
    return normalizedX - offsetX;
  };
  const indexByFocus = (event, focus, I, X) => {
    const { _x } = event;
    const finalX = _x !== void 0 ? scaleX2.map(_x) : abstractX(focus);
    const DX = X.filter(defined);
    const [minX, maxX] = sort([DX[0], DX[DX.length - 1]]);
    const isOnlyOneElement = minX === maxX;
    if (!closest && (finalX < minX || finalX > maxX) && !isOnlyOneElement)
      return null;
    const search2 = bisector((i2) => X[+i2]).center;
    const i = search2(I, finalX);
    return I[i];
  };
  const elementsByFocus = isBar ? (focus, elements2) => {
    const search2 = bisector(xof).center;
    const i = search2(elements2, abstractX(focus));
    const find6 = elements2[i];
    const groups2 = group(elements2, xof);
    const selected = groups2.get(xof(find6));
    return selected;
  } : (focus, elements2) => {
    const index3 = transposed ? 1 : 0;
    const x3 = focus[index3];
    const filtered = elements2.filter((element) => {
      const [min10, max11] = extent2(element);
      return x3 >= min10 && x3 <= max11;
    });
    if (!closest || filtered.length > 0)
      return filtered;
    const search2 = bisector((element) => {
      const [min10, max11] = extent2(element);
      return (min10 + max11) / 2;
    }).center;
    const i = search2(elements2, x3);
    return [elements2[i]].filter(defined);
  };
  const seriesData = (element, index3) => {
    const { __data__: data2 } = element;
    return Object.fromEntries(Object.entries(data2).filter(([key]) => key.startsWith("series") && key !== "series").map(([key, V]) => {
      const d3 = V[index3];
      return [lower_first_default(key.replace("series", "")), d3];
    }));
  };
  const update2 = throttle_default((event) => {
    var _a3;
    const mouse = mousePosition(root2, event);
    if (!mouse)
      return;
    const bbox = bboxOf(root2);
    const x3 = bbox.min[0];
    const y3 = bbox.min[1];
    const focus = [mouse[0] - startX, mouse[1] - startY];
    if (!focus)
      return;
    const selectedItems = elementsByFocus(focus, itemElements);
    const selectedSeriesElements = [];
    const selectedSeriesData = [];
    for (const element of seriesElements) {
      const [sortedIndex2, X] = elementSortedX.get(element);
      const index3 = indexByFocus(event, focus, sortedIndex2, X);
      if (index3 !== null) {
        selectedSeriesElements.push(element);
        const d3 = seriesData(element, index3);
        const { x: x4, y: y4 } = d3;
        const p2 = coordinate.map([(x4 || 0) + offsetX, y4 || 0]);
        selectedSeriesData.push([Object.assign(Object.assign({}, d3), { element }), p2]);
      }
    }
    const SX = Array.from(new Set(selectedSeriesData.map((d3) => d3[0].x)));
    const closestX = SX[minIndex(SX, (x4) => Math.abs(x4 - abstractX(focus)))];
    const filteredSeriesData = selectedSeriesData.filter((d3) => d3[0].x === closestX);
    const selectedData = [
      ...filteredSeriesData.map((d3) => d3[0]),
      ...selectedItems.map((d3) => d3.__data__)
    ];
    const selectedElements = [...selectedSeriesElements, ...selectedItems];
    const tooltipData = groupItems(selectedElements, scale11, groupName, selectedData, theme);
    if (sortFunction) {
      tooltipData.items.sort((a4, b) => sortFunction(a4) - sortFunction(b));
    }
    if (filterFunction) {
      tooltipData.items = tooltipData.items.filter(filterFunction);
    }
    if (selectedElements.length === 0 || isEmptyTooltipData(tooltipData)) {
      hide3(event);
      return;
    }
    if (body) {
      showTooltip({
        root: root2,
        data: tooltipData,
        x: mouse[0] + x3,
        y: mouse[1] + y3,
        render: render3,
        event,
        single,
        position,
        enterable,
        mount,
        bounding,
        css,
        offset: offset2
      });
    }
    if (crosshairs || crosshairsX || crosshairsY) {
      const ruleStyle = subObject(style, "crosshairs");
      const ruleStyleX = Object.assign(Object.assign({}, ruleStyle), subObject(style, "crosshairsX"));
      const ruleStyleY = Object.assign(Object.assign({}, ruleStyle), subObject(style, "crosshairsY"));
      const points = filteredSeriesData.map((d3) => d3[1]);
      if (crosshairsX) {
        updateRuleX(root2, points, mouse, Object.assign(Object.assign({}, ruleStyleX), {
          plotWidth,
          plotHeight,
          mainWidth,
          mainHeight,
          insetLeft,
          insetTop,
          startX,
          startY,
          transposed,
          polar: polar2
        }));
      }
      if (crosshairsY) {
        updateRuleY(root2, points, Object.assign(Object.assign({}, ruleStyleY), {
          plotWidth,
          plotHeight,
          mainWidth,
          mainHeight,
          insetLeft,
          insetTop,
          startX,
          startY,
          transposed,
          polar: polar2
        }));
      }
    }
    if (marker) {
      const markerStyles = subObject(style, "marker");
      updateMarker(root2, {
        data: filteredSeriesData,
        style: markerStyles,
        theme
      });
    }
    const firstX = (_a3 = filteredSeriesData[0]) === null || _a3 === void 0 ? void 0 : _a3[0].x;
    const transformedX = firstX !== null && firstX !== void 0 ? firstX : abstractX(focus);
    emitter.emit("tooltip:show", Object.assign(Object.assign({}, event), { nativeEvent: true, data: Object.assign(Object.assign({}, tooltipData), { data: { x: invert4(scale11.x, transformedX, true) } }) }));
  }, wait, { leading, trailing });
  const hide3 = (event) => {
    hideTooltip({ root: root2, single, emitter, event });
  };
  const destroy2 = () => {
    destroyTooltip({ root: root2, single });
  };
  const onTooltipShow = (_a3) => {
    var _b;
    var { nativeEvent, data: data2, offsetX: offsetX2, offsetY } = _a3, rest2 = __rest81(_a3, ["nativeEvent", "data", "offsetX", "offsetY"]);
    if (nativeEvent)
      return;
    const x3 = (_b = data2 === null || data2 === void 0 ? void 0 : data2.data) === null || _b === void 0 ? void 0 : _b.x;
    const scaleX3 = scale11.x;
    const x12 = scaleX3.map(x3);
    const [x22, y22] = coordinate.map([x12, 0.5]);
    const rootBounds = root2.getRenderBounds();
    const minX = rootBounds.min[0];
    const minY = rootBounds.min[1];
    update2(Object.assign(Object.assign({}, rest2), { offsetX: offsetX2 !== void 0 ? offsetX2 : minX + x22, offsetY: offsetY !== void 0 ? offsetY : minY + y22, _x: x3 }));
  };
  const onTooltipHide = () => {
    hideTooltip({ root: root2, single, emitter, nativeEvent: false });
  };
  const onTooltipDisable = () => {
    removeEventListeners();
    destroy2();
  };
  const onTooltipEnable = () => {
    addEventListeners();
  };
  const addEventListeners = () => {
    if (!disableNative) {
      root2.addEventListener("pointerenter", update2);
      root2.addEventListener("pointermove", update2);
      root2.addEventListener("pointerleave", (e) => {
        if (mousePosition(root2, e))
          return;
        hide3(e);
      });
    }
  };
  const removeEventListeners = () => {
    if (!disableNative) {
      root2.removeEventListener("pointerenter", update2);
      root2.removeEventListener("pointermove", update2);
      root2.removeEventListener("pointerleave", hide3);
    }
  };
  addEventListeners();
  emitter.on("tooltip:show", onTooltipShow);
  emitter.on("tooltip:hide", onTooltipHide);
  emitter.on("tooltip:disable", onTooltipDisable);
  emitter.on("tooltip:enable", onTooltipEnable);
  return () => {
    removeEventListeners();
    emitter.off("tooltip:show", onTooltipShow);
    emitter.off("tooltip:hide", onTooltipHide);
    emitter.off("tooltip:disable", onTooltipDisable);
    emitter.off("tooltip:enable", onTooltipEnable);
    if (preserve) {
      hideTooltip({ root: root2, single, emitter, nativeEvent: false });
    } else {
      destroy2();
    }
  };
}
function tooltip(root2, {
  elements: elementsof,
  coordinate,
  scale: scale11,
  render: render3,
  groupName,
  sort: sortFunction,
  filter: filterFunction,
  emitter,
  wait = 50,
  leading = true,
  trailing = false,
  groupKey = (d3) => d3,
  // group elements by specified key
  single = true,
  position,
  enterable,
  datum,
  view,
  mount,
  bounding,
  theme,
  offset: offset2,
  shared = false,
  body = true,
  disableNative = false,
  preserve = false,
  css = {}
}) {
  var _a2, _b;
  const elements = elementsof(root2);
  const keyGroup = group(elements, groupKey);
  const inInterval = (d3) => d3.markType === "interval";
  const isBar = elements.every(inInterval) && !isPolar(coordinate);
  const scaleX2 = scale11.x;
  const scaleSeries = scale11.series;
  const bandWidth3 = (_b = (_a2 = scaleX2 === null || scaleX2 === void 0 ? void 0 : scaleX2.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(scaleX2)) !== null && _b !== void 0 ? _b : 0;
  const xof = scaleSeries ? (d3) => {
    const seriesCount = Math.round(1 / scaleSeries.valueBandWidth);
    return d3.__data__.x + d3.__data__.series * bandWidth3 + bandWidth3 / (seriesCount * 2);
  } : (d3) => d3.__data__.x + bandWidth3 / 2;
  if (isBar)
    elements.sort((a4, b) => xof(a4) - xof(b));
  const findElementByTarget = (event) => {
    const { target } = event;
    return maybeRoot(target, (node) => {
      if (!node.classList)
        return false;
      return node.classList.includes("element");
    });
  };
  const findElement = isBar ? (event) => {
    const mouse = mousePosition(root2, event);
    if (!mouse)
      return;
    const [abstractX] = coordinate.invert(mouse);
    const search2 = bisector(xof).center;
    const i = search2(elements, abstractX);
    const target = elements[i];
    if (!shared) {
      const isGrouped = elements.find((d3) => d3 !== target && xof(d3) === xof(target));
      if (isGrouped)
        return findElementByTarget(event);
    }
    return target;
  } : findElementByTarget;
  const pointermove = throttle_default((event) => {
    const element = findElement(event);
    if (!element) {
      hideTooltip({ root: root2, single, emitter, event });
      return;
    }
    const k2 = groupKey(element);
    const group3 = keyGroup.get(k2);
    if (!group3) {
      return;
    }
    const data2 = group3.length === 1 && !shared ? singleItem(group3[0]) : groupItems(group3, scale11, groupName, void 0, theme);
    if (sortFunction) {
      data2.items.sort((a4, b) => sortFunction(a4) - sortFunction(b));
    }
    if (filterFunction) {
      data2.items = data2.items.filter(filterFunction);
    }
    if (isEmptyTooltipData(data2)) {
      hideTooltip({ root: root2, single, emitter, event });
      return;
    }
    const { offsetX, offsetY } = event;
    if (body) {
      showTooltip({
        root: root2,
        data: data2,
        x: offsetX,
        y: offsetY,
        render: render3,
        event,
        single,
        position,
        enterable,
        mount,
        bounding,
        css,
        offset: offset2
      });
    }
    emitter.emit("tooltip:show", Object.assign(Object.assign({}, event), { nativeEvent: true, data: Object.assign(Object.assign({}, data2), { data: dataOf(element, view) }) }));
  }, wait, { leading, trailing });
  const pointerleave = (event) => {
    hideTooltip({ root: root2, single, emitter, event });
  };
  const addEventListeners = () => {
    if (!disableNative) {
      root2.addEventListener("pointermove", pointermove);
      root2.addEventListener("pointerleave", pointerleave);
    }
  };
  const removeEventListeners = () => {
    if (!disableNative) {
      root2.removeEventListener("pointermove", pointermove);
      root2.removeEventListener("pointerleave", pointerleave);
    }
  };
  const onTooltipShow = ({ nativeEvent, offsetX, offsetY, data: raw }) => {
    if (nativeEvent)
      return;
    const { data: data2 } = raw;
    const element = selectElementByData(elements, data2, datum);
    if (!element)
      return;
    const bbox = element.getBBox();
    const { x: x3, y: y3, width, height } = bbox;
    const rootBBox = root2.getBBox();
    pointermove({
      target: element,
      offsetX: offsetX !== void 0 ? offsetX + rootBBox.x : x3 + width / 2,
      offsetY: offsetY !== void 0 ? offsetY + rootBBox.y : y3 + height / 2
    });
  };
  const onTooltipHide = ({ nativeEvent } = {}) => {
    if (nativeEvent)
      return;
    hideTooltip({ root: root2, single, emitter, nativeEvent: false });
  };
  const onTooltipDisable = () => {
    removeEventListeners();
    destroyTooltip({ root: root2, single });
  };
  const onTooltipEnable = () => {
    addEventListeners();
  };
  emitter.on("tooltip:show", onTooltipShow);
  emitter.on("tooltip:hide", onTooltipHide);
  emitter.on("tooltip:enable", onTooltipEnable);
  emitter.on("tooltip:disable", onTooltipDisable);
  addEventListeners();
  return () => {
    removeEventListeners();
    emitter.off("tooltip:show", onTooltipShow);
    emitter.off("tooltip:hide", onTooltipHide);
    if (preserve) {
      hideTooltip({ root: root2, single, emitter, nativeEvent: false });
    } else {
      destroyTooltip({ root: root2, single });
    }
  };
}
function Tooltip2(options) {
  const { shared, crosshairs, crosshairsX, crosshairsY, series, name: name2, item = () => ({}), facet = false } = options, rest = __rest81(options, ["shared", "crosshairs", "crosshairsX", "crosshairsY", "series", "name", "item", "facet"]);
  return (target, viewInstances, emitter) => {
    const { container, view } = target;
    const { scale: scale11, markState, coordinate, theme } = view;
    const defaultSeries = interactionKeyof(markState, "seriesTooltip");
    const defaultShowCrosshairs = interactionKeyof(markState, "crosshairs");
    const plotArea = selectPlotArea(container);
    const isSeries = maybeValue(series, defaultSeries);
    const crosshairsSetting = maybeValue(crosshairs, defaultShowCrosshairs);
    if (isSeries && hasSeries(markState) && !facet) {
      return seriesTooltip(plotArea, Object.assign(Object.assign({}, rest), {
        theme,
        elements: selectG2Elements,
        scale: scale11,
        coordinate,
        crosshairs: crosshairsSetting,
        // the crosshairsX settings level: crosshairsX > crosshairs > false
        // it means crosshairsX default is false
        crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),
        // crosshairsY default depend on the crossharisSettings
        crosshairsY: maybeValue(crosshairsY, crosshairsSetting),
        item,
        emitter
      }));
    }
    if (isSeries && facet) {
      const facetInstances = viewInstances.filter((d3) => d3 !== target && d3.options.parentKey === target.options.key);
      const elements = selectFacetG2Elements(target, viewInstances);
      const scale12 = facetInstances[0].view.scale;
      const bbox = plotArea.getBounds();
      const startX = bbox.min[0];
      const startY = bbox.min[1];
      Object.assign(scale12, { facet: true });
      return seriesTooltip(plotArea.parentNode.parentNode, Object.assign(Object.assign({}, rest), {
        theme,
        elements: () => elements,
        scale: scale12,
        coordinate,
        crosshairs: maybeValue(crosshairs, defaultShowCrosshairs),
        // the crosshairsX settings level: crosshairsX > crosshairs > false
        // it means crosshairsX default is false
        crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),
        crosshairsY: maybeValue(crosshairsY, crosshairsSetting),
        item,
        startX,
        startY,
        emitter
      }));
    }
    return tooltip(plotArea, Object.assign(Object.assign({}, rest), {
      datum: createDatumof(view),
      elements: selectG2Elements,
      scale: scale11,
      coordinate,
      groupKey: shared ? createXKey(view) : void 0,
      item,
      emitter,
      view,
      theme,
      shared
    }));
  };
}
Tooltip2.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/legendFilter.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CATEGORY_LEGEND_CLASS_NAME = "legend-category";
var CONTINUOUS_LEGEND_CLASS_NAME = "legend-continuous";
var LEGEND_ITEMS_CLASS_NAME = "items-item";
var LEGEND_MAKER_CLASS_NAME = "legend-category-item-marker";
var LEGEND_LABEL_CLASS_NAME = "legend-category-item-label";
function markerOf(item) {
  return item.getElementsByClassName(LEGEND_MAKER_CLASS_NAME)[0];
}
function labelOf(item) {
  return item.getElementsByClassName(LEGEND_LABEL_CLASS_NAME)[0];
}
function itemsOf(root2) {
  return root2.getElementsByClassName(LEGEND_ITEMS_CLASS_NAME);
}
function legendsOf(root2) {
  return root2.getElementsByClassName(CATEGORY_LEGEND_CLASS_NAME);
}
function legendsContinuousOf(root2) {
  return root2.getElementsByClassName(CONTINUOUS_LEGEND_CLASS_NAME);
}
function legendClearSetState(root2, setState) {
  const legends = [...legendsOf(root2), ...legendsContinuousOf(root2)];
  legends.forEach((legend) => {
    setState(legend, (v) => v);
  });
}
function dataOf2(root2) {
  let parent = root2.parentNode;
  while (parent && !parent.__data__) {
    parent = parent.parentNode;
  }
  return parent.__data__;
}
function legendFilterOrdinal(root2, {
  legends,
  // given the root of chart returns legends to be manipulated
  marker: markerOf2,
  // given the legend returns the marker
  label: labelOf2,
  // given the legend returns the label
  datum,
  // given the legend returns the value
  filter: filter3,
  // invoke when dispatch filter event,
  emitter,
  channel,
  state = {}
  // state options
}) {
  const itemClick = /* @__PURE__ */ new Map();
  const itemPointerenter = /* @__PURE__ */ new Map();
  const itemPointerout = /* @__PURE__ */ new Map();
  const { unselected = {
    markerStroke: "#aaa",
    markerFill: "#aaa",
    labelFill: "#aaa"
  } } = state;
  const markerStyle = { unselected: subObject(unselected, "marker") };
  const labelStyle = { unselected: subObject(unselected, "label") };
  const { setState: setM, removeState: removeM } = useState(markerStyle, void 0);
  const { setState: setL, removeState: removeL } = useState(labelStyle, void 0);
  const items = Array.from(legends(root2));
  let selectedValues = items.map(datum);
  const updateLegendState = () => {
    for (const item of items) {
      const value2 = datum(item);
      const marker = markerOf2(item);
      const label = labelOf2(item);
      if (!selectedValues.includes(value2)) {
        setM(marker, "unselected");
        setL(label, "unselected");
      } else {
        removeM(marker, "unselected");
        removeL(label, "unselected");
      }
    }
  };
  for (const item of items) {
    const pointerenter = () => {
      setCursor(root2, "pointer");
    };
    const pointerout = () => {
      restoreCursor(root2);
    };
    const click = (event) => __awaiter7(this, void 0, void 0, function* () {
      const value2 = datum(item);
      const index3 = selectedValues.indexOf(value2);
      if (index3 === -1)
        selectedValues.push(value2);
      else
        selectedValues.splice(index3, 1);
      yield filter3(selectedValues);
      updateLegendState();
      const { nativeEvent = true } = event;
      if (!nativeEvent)
        return;
      if (selectedValues.length === items.length) {
        emitter.emit("legend:reset", { nativeEvent });
      } else {
        emitter.emit("legend:filter", Object.assign(Object.assign({}, event), { nativeEvent, data: {
          channel,
          values: selectedValues
        } }));
      }
    });
    item.addEventListener("click", click);
    item.addEventListener("pointerenter", pointerenter);
    item.addEventListener("pointerout", pointerout);
    itemClick.set(item, click);
    itemPointerenter.set(item, pointerenter);
    itemPointerout.set(item, pointerout);
  }
  const onFilter = (event) => __awaiter7(this, void 0, void 0, function* () {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    const { data: data2 } = event;
    const { channel: specifiedChannel, values: values4 } = data2;
    if (specifiedChannel !== channel)
      return;
    selectedValues = values4;
    yield filter3(selectedValues);
    updateLegendState();
  });
  const onEnd = (event) => __awaiter7(this, void 0, void 0, function* () {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    selectedValues = items.map(datum);
    yield filter3(selectedValues);
    updateLegendState();
  });
  emitter.on("legend:filter", onFilter);
  emitter.on("legend:reset", onEnd);
  return () => {
    for (const item of items) {
      item.removeEventListener("click", itemClick.get(item));
      item.removeEventListener("pointerenter", itemPointerenter.get(item));
      item.removeEventListener("pointerout", itemPointerout.get(item));
      emitter.off("legend:filter", onFilter);
      emitter.off("legend:reset", onEnd);
    }
  };
}
function legendFilterContinuous(_2, { legend, filter: filter3, emitter, channel }) {
  const onValueChange = ({ detail: { value: value2 } }) => {
    filter3(value2);
    emitter.emit({
      nativeEvent: true,
      data: {
        channel,
        values: value2
      }
    });
  };
  legend.addEventListener("valuechange", onValueChange);
  return () => {
    legend.removeEventListener("valuechange", onValueChange);
  };
}
function filterView(context, {
  legend,
  // Legend instance.
  channel,
  // Filter Channel.
  value: value2,
  // Filtered Values.
  ordinal,
  // Data type of the legend.
  channels,
  // Channels for this legend.
  allChannels,
  // Channels for all legends.
  facet = false
  // For facet.
}) {
  return __awaiter7(this, void 0, void 0, function* () {
    const { view, update: update2, setState } = context;
    setState(legend, (viewOptions) => {
      const { marks } = viewOptions;
      const newMarks = marks.map((mark2) => {
        if (mark2.type === "legends")
          return mark2;
        const { transform: transform2 = [], data: data2 = [] } = mark2;
        const index3 = transform2.findIndex(({ type }) => type.startsWith("group") || type.startsWith("bin"));
        const newTransform = [...transform2];
        if (data2.length) {
          newTransform.splice(index3 + 1, 0, {
            type: "filter",
            [channel]: { value: value2, ordinal }
          });
        }
        const newScale = Object.fromEntries(channels.map((channel2) => [
          channel2,
          { domain: view.scale[channel2].getOptions().domain }
        ]));
        return deep_mix_default({}, mark2, Object.assign(Object.assign({ transform: newTransform, scale: newScale }, !ordinal && { animate: false }), { legend: facet ? false : Object.fromEntries(allChannels.map((d3) => [d3, { preserve: true }])) }));
      });
      return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
    });
    yield update2();
  });
}
function filterFacets(facets, options) {
  for (const facet of facets) {
    filterView(facet, Object.assign(Object.assign({}, options), { facet: true }));
  }
}
function LegendFilter() {
  return (context, contexts, emitter) => {
    const { container } = context;
    const facets = contexts.filter((d3) => d3 !== context);
    const isFacet = facets.length > 0;
    const channelsOf = (legend) => {
      return dataOf2(legend).scales.map((d3) => d3.name);
    };
    const legends = [
      ...legendsOf(container),
      ...legendsContinuousOf(container)
    ];
    const allChannels = legends.flatMap(channelsOf);
    const filter3 = isFacet ? throttle_default(filterFacets, 50, { trailing: true }) : throttle_default(filterView, 50, { trailing: true });
    const removes = legends.map((legend) => {
      const { name: channel, domain } = dataOf2(legend).scales[0];
      const channels = channelsOf(legend);
      const common = {
        legend,
        channel,
        channels,
        allChannels
      };
      if (legend.className === CATEGORY_LEGEND_CLASS_NAME) {
        return legendFilterOrdinal(container, {
          legends: itemsOf,
          marker: markerOf,
          label: labelOf,
          datum: (d3) => {
            const { __data__: datum } = d3;
            const { index: index3 } = datum;
            return domain[index3];
          },
          filter: (value2) => {
            const options = Object.assign(Object.assign({}, common), { value: value2, ordinal: true });
            if (isFacet)
              filter3(facets, options);
            else
              filter3(context, options);
          },
          state: legend.attributes.state,
          channel,
          emitter
        });
      } else {
        return legendFilterContinuous(container, {
          legend,
          filter: (value2) => {
            const options = Object.assign(Object.assign({}, common), { value: value2, ordinal: false });
            if (isFacet)
              filter3(facets, options);
            else
              filter3(context, options);
          },
          emitter,
          channel
        });
      }
    });
    return () => {
      removes.forEach((remove2) => remove2());
    };
  };
}

// node_modules/@antv/g2/esm/interaction/legendHighlight.js
function LegendHighlight() {
  return (context, _2, emitter) => {
    const { container, view, options } = context;
    const legends = legendsOf(container);
    const elements = selectG2Elements(container);
    const channelOf = (legend) => {
      return dataOf2(legend).scales[0].name;
    };
    const scaleOf2 = (channel) => {
      const { scale: { [channel]: scale11 } } = view;
      return scale11;
    };
    const markState = mergeState(options, ["active", "inactive"]);
    const valueof2 = createValueof(elements, createDatumof(view));
    const destroys = [];
    for (const legend of legends) {
      const datumOf = (item) => {
        const { data: data2 } = legend.attributes;
        const { __data__: datum } = item;
        const { index: index3 } = datum;
        return data2[index3].label;
      };
      const channel = channelOf(legend);
      const items = itemsOf(legend);
      const scale11 = scaleOf2(channel);
      const elementGroup = group(elements, (d3) => scale11.invert(d3.__data__[channel]));
      const { state: legendState = {} } = legend.attributes;
      const { inactive = {} } = legendState;
      const { setState, removeState } = useState(markState, valueof2);
      const markerStyle = { inactive: subObject(inactive, "marker") };
      const labelStyle = { inactive: subObject(inactive, "label") };
      const { setState: setM, removeState: removeM } = useState(markerStyle);
      const { setState: setL, removeState: removeL } = useState(labelStyle);
      const updateLegendState = (highlight) => {
        for (const item of items) {
          const marker = markerOf(item);
          const label = labelOf(item);
          if (item === highlight || highlight === null) {
            removeM(marker, "inactive");
            removeL(label, "inactive");
          } else {
            setM(marker, "inactive");
            setL(label, "inactive");
          }
        }
      };
      const highlightItem = (event, item) => {
        const value2 = datumOf(item);
        const elementSet = new Set(elementGroup.get(value2));
        for (const e of elements) {
          if (elementSet.has(e))
            setState(e, "active");
          else
            setState(e, "inactive");
        }
        updateLegendState(item);
        const { nativeEvent = true } = event;
        if (!nativeEvent)
          return;
        emitter.emit("legend:highlight", Object.assign(Object.assign({}, event), { nativeEvent, data: { channel, value: value2 } }));
      };
      const itemPointerover = /* @__PURE__ */ new Map();
      for (const item of items) {
        const pointerover = (event) => {
          highlightItem(event, item);
        };
        item.addEventListener("pointerover", pointerover);
        itemPointerover.set(item, pointerover);
      }
      const pointerleave = (event) => {
        for (const e of elements)
          removeState(e, "inactive", "active");
        updateLegendState(null);
        const { nativeEvent = true } = event;
        if (!nativeEvent)
          return;
        emitter.emit("legend:unhighlight", { nativeEvent });
      };
      const onHighlight = (event) => {
        const { nativeEvent, data: data2 } = event;
        if (nativeEvent)
          return;
        const { channel: specifiedChannel, value: value2 } = data2;
        if (specifiedChannel !== channel)
          return;
        const item = items.find((d3) => datumOf(d3) === value2);
        if (!item)
          return;
        highlightItem({ nativeEvent: false }, item);
      };
      const onUnHighlight = (event) => {
        const { nativeEvent } = event;
        if (nativeEvent)
          return;
        pointerleave({ nativeEvent: false });
      };
      legend.addEventListener("pointerleave", pointerleave);
      emitter.on("legend:highlight", onHighlight);
      emitter.on("legend:unhighlight", onUnHighlight);
      const destroy2 = () => {
        legend.removeEventListener(pointerleave);
        emitter.off("legend:highlight", onHighlight);
        emitter.off("legend:unhighlight", onUnHighlight);
        for (const [item, pointerover] of itemPointerover) {
          item.removeEventListener(pointerover);
        }
      };
      destroys.push(destroy2);
    }
    return () => destroys.forEach((d3) => d3());
  };
}

// node_modules/@antv/g2/esm/interaction/brushHighlight.js
var __rest82 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function intersect3(bbox1, bbox2) {
  const [minX1, minY1, maxX1, maxY1] = bbox1;
  const [minX2, minY2, maxX2, maxY2] = bbox2;
  return !(minX2 > maxX1 || maxX2 < minX1 || minY2 > maxY1 || maxY2 < minY1);
}
function normalizeBounds(x3, y3, x12, y12, extent2) {
  const [minX, minY, maxX, maxY2] = extent2;
  return [
    Math.max(minX, Math.min(x3, x12)),
    Math.max(minY, Math.min(y3, y12)),
    Math.min(maxX, Math.max(x3, x12)),
    Math.min(maxY2, Math.max(y3, y12))
  ];
}
function bboxOf2(root2) {
  const { width, height } = root2.getBBox();
  return [0, 0, width, height];
}
function applyStyle3(selection, style) {
  for (const [key, value2] of Object.entries(style)) {
    selection.style(key, value2);
  }
}
var ResizableMask = createElement((g) => {
  const _a2 = g.attributes, { x: x3, y: y3, width, height, class: className2, renders = {}, handleSize: size3 = 10, document: document2 } = _a2, style = __rest82(_a2, ["x", "y", "width", "height", "class", "renders", "handleSize", "document"]);
  if (!document2 || width === void 0 || height === void 0 || x3 === void 0 || y3 === void 0)
    return;
  const half = size3 / 2;
  const renderRect = (g2, options, document3) => {
    if (!g2.handle) {
      g2.handle = document3.createElement("rect");
      g2.append(g2.handle);
    }
    const { handle } = g2;
    handle.attr(options);
    return handle;
  };
  const _b = subObject(omitPrefixObject(style, "handleNW", "handleNE"), "handleN"), { render: handleNRender = renderRect } = _b, handleNStyle = __rest82(_b, ["render"]);
  const _c = subObject(style, "handleE"), { render: handleERender = renderRect } = _c, handleEStyle = __rest82(_c, ["render"]);
  const _d = subObject(omitPrefixObject(style, "handleSE", "handleSW"), "handleS"), { render: handleSRender = renderRect } = _d, handleSStyle = __rest82(_d, ["render"]);
  const _e = subObject(style, "handleW"), { render: handleWRender = renderRect } = _e, handleWStyle = __rest82(_e, ["render"]);
  const _f = subObject(style, "handleNW"), { render: handleNWRender = renderRect } = _f, handleNWStyle = __rest82(_f, ["render"]);
  const _g = subObject(style, "handleNE"), { render: handleNERender = renderRect } = _g, handleNEStyle = __rest82(_g, ["render"]);
  const _h = subObject(style, "handleSE"), { render: handleSERender = renderRect } = _h, handleSEStyle = __rest82(_h, ["render"]);
  const _j = subObject(style, "handleSW"), { render: handleSWRender = renderRect } = _j, handleSWStyle = __rest82(_j, ["render"]);
  const renderHandle = (g2, renderNode) => {
    const { id: id4 } = g2;
    const handle = renderNode(g2, g2.attributes, document2);
    handle.id = id4;
    handle.style.draggable = true;
  };
  const appendHandle = (handleRender) => {
    return () => {
      const Node5 = createElement((g2) => renderHandle(g2, handleRender));
      return new Node5({});
    };
  };
  const container = select(g).attr("className", className2).style("transform", `translate(${x3}, ${y3})`).style("draggable", true);
  container.maybeAppend("selection", "rect").style("draggable", true).style("fill", "transparent").call(applyStyle3, Object.assign(Object.assign({
    width,
    height
  }, omitPrefixObject(style, "handle")), { transform: void 0 }));
  container.maybeAppend("handle-n", appendHandle(handleNRender)).style("x", half).style("y", -half).style("width", width - size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleNStyle);
  container.maybeAppend("handle-e", appendHandle(handleERender)).style("x", width - half).style("y", half).style("width", size3).style("height", height - size3).style("fill", "transparent").call(applyStyle3, handleEStyle);
  container.maybeAppend("handle-s", appendHandle(handleSRender)).style("x", half).style("y", height - half).style("width", width - size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleSStyle);
  container.maybeAppend("handle-w", appendHandle(handleWRender)).style("x", -half).style("y", half).style("width", size3).style("height", height - size3).style("fill", "transparent").call(applyStyle3, handleWStyle);
  container.maybeAppend("handle-nw", appendHandle(handleNWRender)).style("x", -half).style("y", -half).style("width", size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleNWStyle);
  container.maybeAppend("handle-ne", appendHandle(handleNERender)).style("x", width - half).style("y", -half).style("width", size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleNEStyle);
  container.maybeAppend("handle-se", appendHandle(handleSERender)).style("x", width - half).style("y", height - half).style("width", size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleSEStyle);
  container.maybeAppend("handle-sw", appendHandle(handleSWRender)).style("x", -half).style("y", height - half).style("width", size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleSWStyle);
});
function brush(root2, _a2) {
  var { brushed = () => {
  }, brushended = () => {
  }, brushcreated = () => {
  }, brushstarted = () => {
  }, brushupdated = () => {
  }, extent: extent2 = bboxOf2(root2), brushRegion = (x3, y3, x12, y12, extent3) => [x3, y3, x12, y12], reverse: reverse2 = false, fill = "#777", fillOpacity = "0.3", stroke: stroke2 = "#fff", selectedHandles = [
    "handle-n",
    "handle-e",
    "handle-s",
    "handle-w",
    "handle-nw",
    "handle-ne",
    "handle-se",
    "handle-sw"
  ] } = _a2, style = __rest82(_a2, ["brushed", "brushended", "brushcreated", "brushstarted", "brushupdated", "extent", "brushRegion", "reverse", "fill", "fillOpacity", "stroke", "selectedHandles"]);
  let start = null;
  let end = null;
  let moveStart = null;
  let mask = null;
  let background = null;
  let creating = false;
  const [originX, originY, width, height] = extent2;
  setCursor(root2, "crosshair");
  root2.style.draggable = true;
  const initMask = (x3, y3, event) => {
    brushstarted(event);
    if (mask)
      mask.remove();
    if (background)
      background.remove();
    start = [x3, y3];
    if (reverse2)
      return initReverseMask();
    initNormalMask();
  };
  const initReverseMask = () => {
    background = new Path2({
      style: Object.assign(Object.assign({}, style), {
        fill,
        fillOpacity,
        stroke: stroke2,
        pointerEvents: "none"
      })
    });
    mask = new ResizableMask({
      // @ts-ignore
      style: {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        draggable: true,
        document: root2.ownerDocument
      },
      className: "mask"
    });
    root2.appendChild(background);
    root2.appendChild(mask);
  };
  const initNormalMask = () => {
    mask = new ResizableMask({
      // @ts-ignore
      style: Object.assign(Object.assign({ document: root2.ownerDocument, x: 0, y: 0 }, style), {
        fill,
        fillOpacity,
        stroke: stroke2,
        draggable: true
      }),
      className: "mask"
    });
    root2.appendChild(mask);
  };
  const removeMask = (emit = true) => {
    if (mask)
      mask.remove();
    if (background)
      background.remove();
    start = null;
    end = null;
    moveStart = null;
    creating = false;
    mask = null;
    background = null;
    brushended(emit);
  };
  const updateMask = (start2, end2, emit = true) => {
    const [x3, y3, x12, y12] = normalizeBounds(start2[0], start2[1], end2[0], end2[1], extent2);
    const [fx, fy, fx1, fy1] = brushRegion(x3, y3, x12, y12, extent2);
    if (reverse2)
      updateReverseMask(fx, fy, fx1, fy1);
    else
      updateNormalMask(fx, fy, fx1, fy1);
    brushed(fx, fy, fx1, fy1, emit);
    return [fx, fy, fx1, fy1];
  };
  const updateNormalMask = (x3, y3, x12, y12) => {
    mask.style.x = x3;
    mask.style.y = y3;
    mask.style.width = x12 - x3;
    mask.style.height = y12 - y3;
  };
  const updateReverseMask = (x3, y3, x12, y12) => {
    background.style.d = `
      M${originX},${originY}L${width},${originY}L${width},${height}L${originX},${height}Z
      M${x3},${y3}L${x3},${y12}L${x12},${y12}L${x12},${y3}Z
    `;
    mask.style.x = x3;
    mask.style.y = y3;
    mask.style.width = x12 - x3;
    mask.style.height = y12 - y3;
  };
  const moveMask = (current) => {
    const clip = (dt, start2, end2, min10, max11) => {
      if (dt + start2 < min10)
        return min10 - start2;
      if (dt + end2 > max11)
        return max11 - end2;
      return dt;
    };
    const dx = current[0] - moveStart[0];
    const dy = current[1] - moveStart[1];
    const dx1 = clip(dx, start[0], end[0], originX, width);
    const dy1 = clip(dy, start[1], end[1], originY, height);
    const currentStart = [start[0] + dx1, start[1] + dy1];
    const currentEnd = [end[0] + dx1, end[1] + dy1];
    updateMask(currentStart, currentEnd);
  };
  const handles = {
    "handle-n": { vector: [0, 1, 0, 0], cursor: "ns-resize" },
    "handle-e": { vector: [0, 0, 1, 0], cursor: "ew-resize" },
    "handle-s": { vector: [0, 0, 0, 1], cursor: "ns-resize" },
    "handle-w": { vector: [1, 0, 0, 0], cursor: "ew-resize" },
    "handle-nw": { vector: [1, 1, 0, 0], cursor: "nwse-resize" },
    "handle-ne": { vector: [0, 1, 1, 0], cursor: "nesw-resize" },
    "handle-se": { vector: [0, 0, 1, 1], cursor: "nwse-resize" },
    "handle-sw": { vector: [1, 0, 0, 1], cursor: "nesw-resize" }
  };
  const isMask = (target) => {
    return isSelection(target) || isHandle(target);
  };
  const isHandle = (target) => {
    const { id: id4 } = target;
    if (selectedHandles.indexOf(id4) === -1)
      return false;
    return new Set(Object.keys(handles)).has(id4);
  };
  const isSelection = (target) => {
    return target === mask.getElementById("selection");
  };
  const dragstart = (event) => {
    const { target } = event;
    const [offsetX, offsetY] = brushMousePosition(root2, event);
    if (!mask || !isMask(target)) {
      initMask(offsetX, offsetY, event);
      creating = true;
      return;
    }
    if (isMask(target)) {
      moveStart = [offsetX, offsetY];
    }
  };
  const drag = (event) => {
    const { target } = event;
    const mouse = brushMousePosition(root2, event);
    if (!start)
      return;
    if (!moveStart)
      return updateMask(start, mouse);
    if (isSelection(target))
      return moveMask(mouse);
    const [dx, dy] = [mouse[0] - moveStart[0], mouse[1] - moveStart[1]];
    const { id: id4 } = target;
    if (handles[id4]) {
      const [sx, sy, ex, ey] = handles[id4].vector;
      return updateMask([start[0] + dx * sx, start[1] + dy * sy], [end[0] + dx * ex, end[1] + dy * ey]);
    }
  };
  const dragend = (event) => {
    if (moveStart) {
      moveStart = null;
      const { x: x3, y: y3, width: width2, height: height2 } = mask.style;
      start = [x3, y3];
      end = [x3 + width2, y3 + height2];
      brushupdated(x3, y3, x3 + width2, y3 + height2, event);
      return;
    }
    end = brushMousePosition(root2, event);
    const [fx, fy, fx1, fy1] = updateMask(start, end);
    creating = false;
    brushcreated(fx, fy, fx1, fy1, event);
  };
  const click = (event) => {
    const { target } = event;
    if (mask && !isMask(target))
      removeMask();
  };
  const pointermove = (event) => {
    const { target } = event;
    if (!mask || !isMask(target) || creating)
      setCursor(root2, "crosshair");
    else if (isSelection(target))
      setCursor(root2, "move");
    else if (isHandle(target))
      setCursor(root2, handles[target.id].cursor);
  };
  const pointerleave = () => {
    setCursor(root2, "default");
  };
  root2.addEventListener("dragstart", dragstart);
  root2.addEventListener("drag", drag);
  root2.addEventListener("dragend", dragend);
  root2.addEventListener("click", click);
  root2.addEventListener("pointermove", pointermove);
  root2.addEventListener("pointerleave", pointerleave);
  return {
    mask,
    move(x3, y3, x12, y12, emit = true) {
      if (!mask)
        initMask(x3, y3, {});
      start = [x3, y3];
      end = [x12, y12];
      updateMask([x3, y3], [x12, y12], emit);
    },
    remove(emit = true) {
      if (mask)
        removeMask(emit);
    },
    destroy() {
      if (mask)
        removeMask(false);
      setCursor(root2, "default");
      root2.removeEventListener("dragstart", dragstart);
      root2.removeEventListener("drag", drag);
      root2.removeEventListener("dragend", dragend);
      root2.removeEventListener("click", click);
      root2.removeEventListener("pointermove", pointermove);
      root2.removeEventListener("pointerleave", pointerleave);
    }
  };
}
function selectSiblingViews(target, viewInstances, brushKey) {
  return viewInstances.filter((d3) => {
    if (d3 === target)
      return false;
    const { interaction = {} } = d3.options;
    return Object.values(interaction).find((d4) => d4.brushKey === brushKey);
  });
}
function selectSiblingContainers(target, viewInstances, brushKey) {
  return selectSiblingViews(target, viewInstances, brushKey).map((d3) => selectPlotArea(d3.container));
}
function selectSiblingOptions(target, viewInstances, brushKey) {
  return selectSiblingViews(target, viewInstances, brushKey).map((d3) => d3.options);
}
function brushHighlight(root2, _a2) {
  var { elements: elementof, selectedHandles, siblings: siblingsof = (root3) => [], datum, brushRegion, extent: optionalExtent, reverse: reverse2, scale: scale11, coordinate, series = false, key = (d3) => d3, bboxOf: bboxOf3 = (root3) => {
    const { x: x3, y: y3, width, height } = root3.style;
    return { x: x3, y: y3, width, height };
  }, state = {}, emitter } = _a2, rest = __rest82(_a2, ["elements", "selectedHandles", "siblings", "datum", "brushRegion", "extent", "reverse", "scale", "coordinate", "series", "key", "bboxOf", "state", "emitter"]);
  const elements = elementof(root2);
  const siblings = siblingsof(root2);
  const siblingElements = siblings.flatMap(elementof);
  const valueof2 = createValueof(elements, datum);
  const brushStyle = subObject(rest, "mask");
  const { setState, removeState } = useState(state, valueof2);
  const clonedElement = /* @__PURE__ */ new Map();
  const { width: rootWidth, height: rootHeight, x: ordinalX = 0, y: ordinalY = 0 } = bboxOf3(root2);
  const extent2 = optionalExtent ? optionalExtent : [0, 0, rootWidth, rootHeight];
  const brushended = () => {
    for (const element of [...elements, ...siblingElements]) {
      removeState(element, "active", "inactive");
    }
  };
  const brushed = (x3, y3, x12, y12) => {
    var _a3;
    for (const sibling of siblings)
      (_a3 = sibling.brush) === null || _a3 === void 0 ? void 0 : _a3.remove();
    const keys2 = /* @__PURE__ */ new Set();
    for (const element of elements) {
      const { min: min10, max: max11 } = element.getLocalBounds();
      const [ex, ey] = min10;
      const [ex1, ey1] = max11;
      if (!intersect3([ex, ey, ex1, ey1], [x3, y3, x12, y12])) {
        setState(element, "inactive");
      } else {
        setState(element, "active");
        keys2.add(key(element));
      }
    }
    for (const element of siblingElements) {
      if (keys2.has(key(element)))
        setState(element, "active");
      else
        setState(element, "inactive");
    }
  };
  const seriesBrushend = () => {
    for (const element of elements)
      removeState(element, "inactive");
    for (const cloned of clonedElement.values())
      cloned.remove();
    clonedElement.clear();
  };
  const seriesBrushed = (x3, y3, x12, y12) => {
    const clone8 = (element) => {
      const cloned = element.cloneNode();
      cloned.__data__ = element.__data__;
      element.parentNode.appendChild(cloned);
      clonedElement.set(element, cloned);
      return cloned;
    };
    const clipPath = new Rect({
      style: {
        x: x3 + ordinalX,
        y: y3 + ordinalY,
        width: x12 - x3,
        height: y12 - y3
      }
    });
    root2.appendChild(clipPath);
    for (const element of elements) {
      const cloned = clonedElement.get(element) || clone8(element);
      cloned.style.clipPath = clipPath;
      setState(element, "inactive");
      setState(cloned, "active");
    }
  };
  const brushHandler = brush(root2, Object.assign(Object.assign({}, brushStyle), {
    extent: extent2,
    brushRegion,
    reverse: reverse2,
    selectedHandles,
    brushended: (emit) => {
      const handler = series ? seriesBrushend : brushended;
      if (emit) {
        emitter.emit("brush:remove", { nativeEvent: true });
      }
      handler();
    },
    brushed: (x3, y3, x12, y12, emit) => {
      const selection = selectionOf(x3, y3, x12, y12, scale11, coordinate);
      if (emit) {
        emitter.emit("brush:highlight", {
          nativeEvent: true,
          data: { selection }
        });
      }
      const handler = series ? seriesBrushed : brushed;
      handler(x3, y3, x12, y12);
    },
    brushcreated: (x3, y3, x12, y12, event) => {
      const selection = selectionOf(x3, y3, x12, y12, scale11, coordinate);
      emitter.emit("brush:end", Object.assign(Object.assign({}, event), { nativeEvent: true, data: { selection } }));
    },
    brushupdated: (x3, y3, x12, y12, event) => {
      const selection = selectionOf(x3, y3, x12, y12, scale11, coordinate);
      emitter.emit("brush:end", Object.assign(Object.assign({}, event), { nativeEvent: true, data: { selection } }));
    },
    brushstarted: (e) => {
      emitter.emit("brush:start", e);
    }
  }));
  const onHighlight = ({ nativeEvent, data: data2 }) => {
    if (nativeEvent)
      return;
    const { selection } = data2;
    const [x3, y3, x12, y12] = pixelsOf(selection, scale11, coordinate);
    brushHandler.move(x3, y3, x12, y12, false);
  };
  emitter.on("brush:highlight", onHighlight);
  const onRemove = ({ nativeEvent } = {}) => {
    if (nativeEvent)
      return;
    brushHandler.remove(false);
  };
  emitter.on("brush:remove", onRemove);
  const preBrushDestroy = brushHandler.destroy.bind(brushHandler);
  brushHandler.destroy = () => {
    emitter.off("brush:highlight", onHighlight);
    emitter.off("brush:remove", onRemove);
    preBrushDestroy();
  };
  return brushHandler;
}
function BrushHighlight(_a2) {
  var { facet, brushKey } = _a2, rest = __rest82(_a2, ["facet", "brushKey"]);
  return (target, viewInstances, emitter) => {
    const { container, view, options } = target;
    const plotArea = selectPlotArea(container);
    const defaultOptions = {
      maskFill: "#777",
      maskFillOpacity: "0.3",
      maskStroke: "#fff",
      reverse: false
    };
    const defaultStates = ["active", ["inactive", { opacity: 0.5 }]];
    const { scale: scale11, coordinate } = view;
    if (facet) {
      const bbox = plotArea.getBounds();
      const x3 = bbox.min[0];
      const y3 = bbox.min[1];
      const x12 = bbox.max[0];
      const y12 = bbox.max[1];
      return brushHighlight(plotArea.parentNode.parentNode, Object.assign(Object.assign({
        elements: () => selectFacetG2Elements(target, viewInstances),
        datum: createDatumof(selectFacetViews(target, viewInstances).map((d3) => d3.view)),
        brushRegion: (x4, y4, x13, y13) => [x4, y4, x13, y13],
        extent: [x3, y3, x12, y12],
        state: mergeState(selectFacetViews(target, viewInstances).map((d3) => d3.options), defaultStates),
        emitter,
        scale: scale11,
        coordinate,
        selectedHandles: void 0
      }, defaultOptions), rest));
    }
    const brush2 = brushHighlight(plotArea, Object.assign(Object.assign({
      elements: selectG2Elements,
      key: (element) => element.__data__.key,
      siblings: () => selectSiblingContainers(target, viewInstances, brushKey),
      datum: createDatumof([
        view,
        ...selectSiblingViews(target, viewInstances, brushKey).map((d3) => d3.view)
      ]),
      brushRegion: (x3, y3, x12, y12) => [x3, y3, x12, y12],
      extent: void 0,
      state: mergeState([options, ...selectSiblingOptions(target, viewInstances, brushKey)], defaultStates),
      emitter,
      scale: scale11,
      coordinate,
      selectedHandles: void 0
    }, defaultOptions), rest));
    plotArea.brush = brush2;
    return () => brush2.destroy();
  };
}

// node_modules/@antv/g2/esm/interaction/brushXHighlight.js
function brushXRegion(x3, y3, x12, y12, extent2) {
  const [, minY, , maxY2] = extent2;
  return [x3, minY, x12, maxY2];
}
function BrushXHighlight(options) {
  return BrushHighlight(Object.assign(Object.assign({}, options), { brushRegion: brushXRegion, selectedHandles: ["handle-e", "handle-w"] }));
}

// node_modules/@antv/g2/esm/interaction/brushYHighlight.js
function brushYRegion(x3, y3, x12, y12, extent2) {
  const [minX, , maxX] = extent2;
  return [minX, y3, maxX, y12];
}
function BrushYHighlight(options) {
  return BrushHighlight(Object.assign(Object.assign({}, options), { brushRegion: brushYRegion, selectedHandles: ["handle-n", "handle-s"] }));
}

// node_modules/@antv/g2/esm/interaction/brushAxisHighlight.js
var __rest83 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var AXIS_CLASS_NAME = "axis";
var AXIS_LINE_CLASS_NAME = "axis-line";
var AXIS_MAIN_CLASS_NAME = "axis-main-group";
var AXIS_HOT_AREA_CLASS_NAME = "axis-hot-area";
function axesOf(container) {
  return container.getElementsByClassName(AXIS_CLASS_NAME);
}
function lineOf(axis) {
  return axis.getElementsByClassName(AXIS_LINE_CLASS_NAME)[0];
}
function mainGroupOf(axis) {
  return axis.getElementsByClassName(AXIS_MAIN_CLASS_NAME)[0];
}
function boundsOfAxis(axis) {
  return mainGroupOf(axis).getLocalBounds();
}
function verticalBrush(axis, _a2) {
  var { cross: cross7, offsetX, offsetY } = _a2, style = __rest83(_a2, ["cross", "offsetX", "offsetY"]);
  const bounds = boundsOfAxis(axis);
  const axisLine = lineOf(axis);
  const [lineX] = axisLine.getLocalBounds().min;
  const [minX, minY] = bounds.min;
  const [maxX, maxY2] = bounds.max;
  const size3 = (maxX - minX) * 2;
  return {
    brushRegion: brushYRegion,
    hotZone: new Rect({
      className: AXIS_HOT_AREA_CLASS_NAME,
      style: Object.assign({
        // If it is not cross, draw brush in both side of axisLine,
        // otherwise the draw brush within bounds area.
        width: cross7 ? size3 / 2 : size3,
        transform: `translate(${(cross7 ? minX : lineX - size3 / 2).toFixed(2)}, ${minY})`,
        height: maxY2 - minY
      }, style)
    }),
    extent: cross7 ? (
      // If it is cross, the x range is ignored.
      (x3, y3, x12, y12) => [-Infinity, y3, Infinity, y12]
    ) : (x3, y3, x12, y12) => [
      Math.floor(minX - offsetX),
      y3,
      Math.ceil(maxX - offsetX),
      y12
    ]
  };
}
function horizontalBrush(axis, _a2) {
  var { offsetY, offsetX, cross: cross7 = false } = _a2, style = __rest83(_a2, ["offsetY", "offsetX", "cross"]);
  const bounds = boundsOfAxis(axis);
  const axisLine = lineOf(axis);
  const [, lineY] = axisLine.getLocalBounds().min;
  const [minX, minY] = bounds.min;
  const [maxX, maxY2] = bounds.max;
  const size3 = maxY2 - minY;
  return {
    brushRegion: brushXRegion,
    hotZone: new Rect({
      className: AXIS_HOT_AREA_CLASS_NAME,
      style: Object.assign({
        width: maxX - minX,
        // If it is not cross, draw brush in both side of axisLine,
        // otherwise the draw brush within bounds area.
        height: cross7 ? size3 : size3 * 2,
        transform: `translate(${minX}, ${cross7 ? minY : lineY - size3})`
      }, style)
    }),
    extent: cross7 ? (
      // If it is cross, the y range is ignored.
      (x3, y3, x12, y12) => [x3, -Infinity, x12, Infinity]
    ) : (x3, y3, x12, y12) => [
      x3,
      Math.floor(minY - offsetY),
      x12,
      Math.ceil(maxY2 - offsetY)
    ]
  };
}
function brushAxisHighlight(root2, _a2) {
  var {
    axes: axesOf2,
    // given root, return axes
    elements: elementsOf,
    // given root, return elements
    points: pointsOf,
    // given shape, return control points
    horizontal: isHorizontal3,
    // given axis, return direction
    datum,
    // given shape, return datum
    offsetY,
    // offsetY for shape area
    offsetX,
    // offsetX for shape area
    reverse: reverse2 = false,
    state = {},
    emitter,
    coordinate
  } = _a2, rest = __rest83(_a2, ["axes", "elements", "points", "horizontal", "datum", "offsetY", "offsetX", "reverse", "state", "emitter", "coordinate"]);
  const elements = elementsOf(root2);
  const axes = axesOf2(root2);
  const valueof2 = createValueof(elements, datum);
  const { setState, removeState } = useState(state, valueof2);
  const axisExtent = /* @__PURE__ */ new Map();
  const brushStyle = subObject(rest, "mask");
  const brushed = (points) => Array.from(axisExtent.values()).every(([x3, y3, x12, y12]) => points.some(([x05, y05]) => {
    return x05 >= x3 && x05 <= x12 && y05 >= y3 && y05 <= y12;
  }));
  const scales = axes.map((d3) => d3.attributes.scale);
  const extentOf2 = (D2) => D2.length > 2 ? [D2[0], D2[D2.length - 1]] : D2;
  const indexDomain = /* @__PURE__ */ new Map();
  const initIndexDomain = () => {
    indexDomain.clear();
    for (let i = 0; i < axes.length; i++) {
      const scale11 = scales[i];
      const { domain } = scale11.getOptions();
      indexDomain.set(i, extentOf2(domain));
    }
  };
  initIndexDomain();
  const updateElement = (i, emit) => {
    const selectedElements = [];
    for (const element of elements) {
      const points = pointsOf(element);
      if (brushed(points)) {
        setState(element, "active");
        selectedElements.push(element);
      } else
        setState(element, "inactive");
    }
    indexDomain.set(i, selectionOf2(selectedElements, i));
    if (!emit)
      return;
    const selection = () => {
      if (!cross7)
        return Array.from(indexDomain.values());
      const S = [];
      for (const [index3, domain] of indexDomain) {
        const scale11 = scales[index3];
        const { name: name2 } = scale11.getOptions();
        if (name2 === "x")
          S[0] = domain;
        else
          S[1] = domain;
      }
      return S;
    };
    emitter.emit("brushAxis:highlight", {
      nativeEvent: true,
      data: {
        selection: selection()
      }
    });
  };
  const clearElement = (emit) => {
    for (const element of elements)
      removeState(element, "active", "inactive");
    initIndexDomain();
    if (!emit)
      return;
    emitter.emit("brushAxis:remove", { nativeEvent: true });
  };
  const selectionOf2 = (selected, i) => {
    const scale11 = scales[i];
    const { name: name2 } = scale11.getOptions();
    const domain = selected.map((d3) => {
      const data2 = d3.__data__;
      return scale11.invert(data2[name2]);
    });
    return extentOf2(domainOf3(scale11, domain));
  };
  const cross7 = axes.some(isHorizontal3) && axes.some((d3) => !isHorizontal3(d3));
  const handlers = [];
  for (let i = 0; i < axes.length; i++) {
    const axis = axes[i];
    const createBrush = isHorizontal3(axis) ? horizontalBrush : verticalBrush;
    const { hotZone, brushRegion, extent: extent2 } = createBrush(axis, {
      offsetY,
      offsetX,
      cross: cross7,
      zIndex: 999,
      fill: "transparent"
      // Make it interactive.
    });
    axis.parentNode.appendChild(hotZone);
    const brushHandler = brush(hotZone, Object.assign(Object.assign({}, brushStyle), {
      reverse: reverse2,
      brushRegion,
      brushended(emit) {
        axisExtent.delete(axis);
        if (Array.from(axisExtent.entries()).length === 0)
          clearElement(emit);
        else
          updateElement(i, emit);
      },
      brushed(x3, y3, x12, y12, emit) {
        axisExtent.set(axis, extent2(x3, y3, x12, y12));
        updateElement(i, emit);
      }
    }));
    handlers.push(brushHandler);
  }
  const onRemove = (event = {}) => {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    handlers.forEach((d3) => d3.remove(false));
  };
  const rangeOf5 = (domain, scale11, axis) => {
    const [d0, d1] = domain;
    const maybeStep = (scale12) => scale12.getStep ? scale12.getStep() : 0;
    const x3 = abstractOf2(d0, scale11, axis);
    const x12 = abstractOf2(d1, scale11, axis) + maybeStep(scale11);
    if (isHorizontal3(axis))
      return [x3, -Infinity, x12, Infinity];
    return [-Infinity, x3, Infinity, x12];
  };
  const abstractOf2 = (x3, scale11, axis) => {
    const { height, width } = coordinate.getOptions();
    const scale1 = scale11.clone();
    if (isHorizontal3(axis))
      scale1.update({ range: [0, width] });
    else
      scale1.update({ range: [height, 0] });
    return scale1.map(x3);
  };
  const onHighlight = (event) => {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    const { selection } = event.data;
    for (let i = 0; i < handlers.length; i++) {
      const domain = selection[i];
      const handler = handlers[i];
      const axis = axes[i];
      if (domain) {
        const scale11 = scales[i];
        handler.move(...rangeOf5(domain, scale11, axis), false);
      } else {
        handler.remove(false);
      }
    }
  };
  emitter.on("brushAxis:remove", onRemove);
  emitter.on("brushAxis:highlight", onHighlight);
  return () => {
    handlers.forEach((d3) => d3.destroy());
    emitter.off("brushAxis:remove", onRemove);
    emitter.off("brushAxis:highlight", onHighlight);
  };
}
function BrushAxisHighlight(options) {
  return (target, _2, emitter) => {
    const { container, view, options: viewOptions } = target;
    const plotArea = selectPlotArea(container);
    const { x: x05, y: y05 } = plotArea.getBBox();
    const { coordinate } = view;
    return brushAxisHighlight(container, Object.assign({
      elements: selectG2Elements,
      axes: axesOf,
      offsetY: y05,
      offsetX: x05,
      points: (element) => element.__data__.points,
      horizontal: (axis) => {
        const { startPos: [sx, sy], endPos: [ex, ey] } = axis.attributes;
        return sx !== ex && sy === ey;
      },
      datum: createDatumof(view),
      state: mergeState(viewOptions, [
        "active",
        ["inactive", { opacity: 0.5 }]
      ]),
      coordinate,
      emitter
    }, options));
  };
}

// node_modules/@antv/g2/esm/interaction/brushFilter.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest84 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function dblclick(interval2 = 300) {
  let preTimeStamp = null;
  return (e) => {
    const { timeStamp } = e;
    if (preTimeStamp !== null && timeStamp - preTimeStamp < interval2) {
      preTimeStamp = timeStamp;
      return true;
    }
    preTimeStamp = timeStamp;
    return false;
  };
}
function brushFilter(root2, _a2) {
  var { filter: filter3, reset, brushRegion, extent: optionalExtent, reverse: reverse2, emitter, scale: scale11, coordinate, selection, series = false } = _a2, rest = __rest84(_a2, ["filter", "reset", "brushRegion", "extent", "reverse", "emitter", "scale", "coordinate", "selection", "series"]);
  const brushStyle = subObject(rest, "mask");
  const { width: rootWidth, height: rootHeight } = root2.getBBox();
  const extent2 = optionalExtent ? optionalExtent : [0, 0, rootWidth, rootHeight];
  const isDblclick = dblclick();
  const brush2 = brush(root2, Object.assign(Object.assign({}, brushStyle), {
    extent: extent2,
    brushRegion,
    reverse: reverse2,
    brushcreated
  }));
  root2.addEventListener("click", click);
  function brushcreated(x3, y3, x12, y12, event) {
    event.nativeEvent = true;
    filter3(selection(x3, y3, x12, y12), event);
    brush2.remove();
  }
  function click(e) {
    if (isDblclick(e)) {
      e.nativeEvent = true;
      reset(e);
    }
  }
  const onFilter = ({ nativeEvent, data: data2 }) => {
    if (nativeEvent)
      return;
    const { selection: selection2 } = data2;
    filter3(selection2, { nativeEvent: false });
  };
  emitter.on("brush:filter", onFilter);
  return () => {
    brush2.destroy();
    emitter.off("brush:filter", onFilter);
    root2.removeEventListener("click", click);
  };
}
function BrushFilter(_a2) {
  var { hideX = true, hideY = true } = _a2, rest = __rest84(_a2, ["hideX", "hideY"]);
  return (target, viewInstances, emitter) => {
    const { container, view, options: viewOptions, update: update2, setState } = target;
    const plotArea = selectPlotArea(container);
    const defaultOptions = {
      maskFill: "#777",
      maskFillOpacity: "0.3",
      maskStroke: "#fff",
      unhighlightedOpacity: 0.5,
      reverse: false
    };
    let filtered = false;
    let filtering = false;
    let newView = view;
    const { scale: scale11, coordinate } = view;
    return brushFilter(plotArea, Object.assign(Object.assign({
      brushRegion: (x3, y3, x12, y12) => [x3, y3, x12, y12],
      selection: (x3, y3, x12, y12) => {
        const { scale: scale12, coordinate: coordinate2 } = newView;
        return selectionOf(x3, y3, x12, y12, scale12, coordinate2);
      },
      filter: (selection, event) => __awaiter8(this, void 0, void 0, function* () {
        if (filtering)
          return;
        filtering = true;
        const [domainX, domainY] = selection;
        setState("brushFilter", (options) => {
          const { marks } = options;
          const newMarks = marks.map((mark2) => deep_mix_default({
            // Hide label to keep smooth transition.
            axis: Object.assign(Object.assign({}, hideX && { x: { transform: [{ type: "hide" }] } }), hideY && { y: { transform: [{ type: "hide" }] } })
          }, mark2, {
            // Set nice to false to avoid modify domain.
            scale: {
              x: { domain: domainX, nice: false },
              y: { domain: domainY, nice: false }
            }
          }));
          return Object.assign(Object.assign({}, viewOptions), { marks: newMarks, clip: true });
        });
        emitter.emit("brush:filter", Object.assign(Object.assign({}, event), { data: { selection: [domainX, domainY] } }));
        const newState = yield update2();
        newView = newState.view;
        filtering = false;
        filtered = true;
      }),
      reset: (event) => {
        if (filtering || !filtered)
          return;
        const { scale: scale12 } = view;
        const { x: scaleX2, y: scaleY2 } = scale12;
        const domainX = scaleX2.getOptions().domain;
        const domainY = scaleY2.getOptions().domain;
        emitter.emit("brush:filter", Object.assign(Object.assign({}, event), { data: { selection: [domainX, domainY] } }));
        filtered = false;
        newView = view;
        setState("brushFilter");
        update2();
      },
      extent: void 0,
      emitter,
      scale: scale11,
      coordinate
    }, defaultOptions), rest));
  };
}

// node_modules/@antv/g2/esm/interaction/brushXFilter.js
function BrushXFilter(options) {
  return BrushFilter(Object.assign(Object.assign({ hideX: true }, options), { brushRegion: brushXRegion }));
}

// node_modules/@antv/g2/esm/interaction/brushYFilter.js
function BrushYFilter(options) {
  return BrushFilter(Object.assign(Object.assign({ hideY: true }, options), { brushRegion: brushYRegion }));
}

// node_modules/@antv/g2/esm/interaction/sliderFilter.js
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SLIDER_CLASS_NAME = "slider";
function filterDataByDomain(options, scaleOptions, prefix, hasState = false, channel0 = "x", channel1 = "y") {
  const { marks } = options;
  const newMarks = marks.map((mark2) => {
    var _a2, _b;
    return deep_mix_default({
      // Hide label to keep smooth transition.
      axis: {
        x: { transform: [{ type: "hide" }] },
        y: { transform: [{ type: "hide" }] }
      }
    }, mark2, {
      scale: scaleOptions,
      // Don't rerender sliders.
      [prefix]: Object.assign(Object.assign({}, ((_a2 = mark2[prefix]) === null || _a2 === void 0 ? void 0 : _a2[channel0]) && {
        [channel0]: Object.assign({ preserve: true }, hasState && { ratio: null })
      }), ((_b = mark2[prefix]) === null || _b === void 0 ? void 0 : _b[channel1]) && {
        [channel1]: { preserve: true }
      }),
      animate: false
    });
  });
  return Object.assign(Object.assign({}, options), { marks: newMarks, clip: true, animate: false });
}
function abstractValue(values4, scale11, reverse2) {
  const [x3, x12] = values4;
  const v = reverse2 ? (d3) => 1 - d3 : (d3) => d3;
  const d0 = invert4(scale11, v(x3), true);
  const d1 = invert4(scale11, v(x12), false);
  return domainOf3(scale11, [d0, d1]);
}
function extentOf(domain) {
  return [domain[0], domain[domain.length - 1]];
}
function SliderFilter({ initDomain = {}, className: className2 = SLIDER_CLASS_NAME, prefix = "slider", setValue = (component, values4) => component.setValues(values4), hasState = false, wait = 50, leading = true, trailing = false, getInitValues = (slider) => {
  var _a2;
  const values4 = (_a2 = slider === null || slider === void 0 ? void 0 : slider.attributes) === null || _a2 === void 0 ? void 0 : _a2.values;
  if (values4[0] !== 0 || values4[1] !== 1)
    return values4;
} }) {
  return (context, _2, emitter) => {
    const { container, view, update: update2, setState } = context;
    const sliders = container.getElementsByClassName(className2);
    if (!sliders.length)
      return () => {
      };
    let filtering = false;
    const { scale: scale11, coordinate, layout } = view;
    const { paddingLeft, paddingTop, paddingBottom, paddingRight } = layout;
    const { x: scaleX2, y: scaleY2 } = scale11;
    const transposed = isTranspose(coordinate);
    const channelOf = (orientation) => {
      const channel0 = orientation === "vertical" ? "y" : "x";
      const channel1 = orientation === "vertical" ? "x" : "y";
      if (transposed)
        return [channel1, channel0];
      return [channel0, channel1];
    };
    const sliderHandler = /* @__PURE__ */ new Map();
    const emitHandlers = /* @__PURE__ */ new Set();
    const channelDomain = {
      x: initDomain.x || scaleX2.getOptions().domain,
      y: initDomain.y || scaleY2.getOptions().domain
    };
    for (const slider of sliders) {
      const { orientation } = slider.attributes;
      const [channel0, channel1] = channelOf(orientation);
      const eventName = `${prefix}${upper_first_default(channel0)}:filter`;
      const isX = channel0 === "x";
      const { ratio: ratioX } = scaleX2.getOptions();
      const { ratio: ratioY } = scaleY2.getOptions();
      const domainsOf = (event) => {
        if (event.data) {
          const { selection } = event.data;
          const [X = extentOf(channelDomain.x), Y = extentOf(channelDomain.y)] = selection;
          return isX ? [domainOf3(scaleX2, X, ratioX), domainOf3(scaleY2, Y, ratioY)] : [domainOf3(scaleY2, Y, ratioY), domainOf3(scaleX2, X, ratioX)];
        }
        const { value: values5 } = event.detail;
        const scale0 = scale11[channel0];
        const domain0 = abstractValue(values5, scale0, transposed && orientation === "horizontal");
        const domain1 = channelDomain[channel1];
        return [domain0, domain1];
      };
      const onValueChange = throttle_default((event) => __awaiter9(this, void 0, void 0, function* () {
        const { initValue = false } = event;
        if (filtering && !initValue)
          return;
        filtering = true;
        const { nativeEvent = true } = event;
        const [domain0, domain1] = domainsOf(event);
        channelDomain[channel0] = domain0;
        channelDomain[channel1] = domain1;
        if (nativeEvent) {
          const X = isX ? domain0 : domain1;
          const Y = isX ? domain1 : domain0;
          emitter.emit(eventName, Object.assign(Object.assign({}, event), { nativeEvent, data: { selection: [extentOf(X), extentOf(Y)] } }));
        }
        setState(slider, (options) => Object.assign(Object.assign({}, filterDataByDomain(
          options,
          // Set nice to false to avoid modify domain.
          // Only update domain of current slider / scrollbar.
          { [channel0]: { domain: domain0, nice: false } },
          prefix,
          hasState,
          channel0,
          channel1
        )), {
          paddingLeft,
          paddingTop,
          paddingBottom,
          paddingRight
        }));
        yield update2();
        filtering = false;
      }), wait, { leading, trailing });
      const emitHandler = (event) => {
        const { nativeEvent } = event;
        if (nativeEvent)
          return;
        const { data: data2 } = event;
        const { selection } = data2;
        const [X, Y] = selection;
        slider.dispatchEvent(new CustomEvent("valuechange", {
          data: data2,
          nativeEvent: false
        }));
        const V = isX ? abstractOf(X, scaleX2) : abstractOf(Y, scaleY2);
        setValue(slider, V);
      };
      emitter.on(eventName, emitHandler);
      slider.addEventListener("valuechange", onValueChange);
      sliderHandler.set(slider, onValueChange);
      emitHandlers.add([eventName, emitHandler]);
      const values4 = getInitValues(slider);
      if (values4) {
        slider.dispatchEvent(new CustomEvent("valuechange", {
          detail: {
            value: values4
          },
          nativeEvent: false,
          initValue: true
        }));
      }
    }
    return () => {
      for (const [slider, handler] of sliderHandler) {
        slider.removeEventListener("valuechange", handler);
      }
      for (const [name2, handler] of emitHandlers) {
        emitter.off(name2, handler);
      }
    };
  };
}

// node_modules/@antv/g2/esm/interaction/scrollbarFilter.js
var SCROLLBAR_CLASS_NAME = "g2-scrollbar";
function ScrollbarFilter(options = {}) {
  return (context, _2, emitter) => {
    const { view, container } = context;
    const scrollbars = container.getElementsByClassName(SCROLLBAR_CLASS_NAME);
    if (!scrollbars.length)
      return () => {
      };
    const { scale: scale11 } = view;
    const { x: scaleX2, y: scaleY2 } = scale11;
    const initDomain = {
      x: [...scaleX2.getOptions().domain],
      y: [...scaleY2.getOptions().domain]
    };
    scaleX2.update({ domain: scaleX2.getOptions().expectedDomain });
    scaleY2.update({ domain: scaleY2.getOptions().expectedDomain });
    const interaction = SliderFilter(Object.assign(Object.assign({}, options), { initDomain, className: SCROLLBAR_CLASS_NAME, prefix: "scrollbar", hasState: true, setValue: (component, values4) => component.setValue(values4[0]), getInitValues: (scrollbar) => {
      const values4 = scrollbar.slider.attributes.values;
      if (values4[0] !== 0)
        return values4;
    } }));
    return interaction(context, _2, emitter);
  };
}

// node_modules/@antv/g2/esm/interaction/poptip.js
var __rest85 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function dom(tag, children, style) {
  return `<${tag} style="${Object.entries(style).map(([key, value2]) => `${kebabCase(key)}:${value2}`).join(";")}">${children}</${tag}>`;
}
var defaultTipStyle = {
  backgroundColor: "rgba(0,0,0,0.75)",
  color: "#fff",
  width: "max-content",
  padding: "1px 4px",
  fontSize: "12px",
  borderRadius: "2.5px",
  boxShadow: "0 3px 6px -4px rgba(0,0,0,0.12), 0 6px 16px 0 rgba(0,0,0,0.08), 0 9px 28px 8px rgba(0,0,0,0.05)"
};
function isTipText(element) {
  if (element.nodeName !== "text")
    return false;
  if (element.isOverflowing())
    return true;
  return false;
}
function Poptip2(_a2) {
  var { offsetX = 8, offsetY = 8 } = _a2, style = __rest85(_a2, ["offsetX", "offsetY"]);
  return (context) => {
    const { container } = context;
    const [x05, y05] = container.getBounds().min;
    const tipStyle = subObject(style, "tip");
    const tips = /* @__PURE__ */ new Set();
    const pointerover = (e) => {
      const { target } = e;
      if (!isTipText(target)) {
        e.stopPropagation();
        return;
      }
      const { offsetX: mouseX, offsetY: mouseY } = e;
      const x3 = mouseX + offsetX - x05;
      const y3 = mouseY + offsetY - y05;
      if (target.tip) {
        target.tip.style.x = x3;
        target.tip.style.y = y3;
        return;
      }
      const { text } = target.style;
      const tipELement = new HTML({
        className: "poptip",
        style: {
          innerHTML: dom("div", text, Object.assign(Object.assign({}, defaultTipStyle), tipStyle)),
          x: x3,
          y: y3
        }
      });
      container.appendChild(tipELement);
      target.tip = tipELement;
      tips.add(tipELement);
    };
    const pointerout = (e) => {
      const { target } = e;
      if (!isTipText(target)) {
        e.stopPropagation();
        return;
      }
      if (!target.tip)
        return;
      target.tip.remove();
      target.tip = null;
      tips.delete(target.tip);
    };
    container.addEventListener("pointerover", pointerover);
    container.addEventListener("pointerout", pointerout);
    return () => {
      container.removeEventListener("pointerover", pointerover);
      container.removeEventListener("pointerout", pointerout);
      tips.forEach((tip) => tip.remove());
    };
  };
}
Poptip2.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/treemapDrillDown.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest86 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
function selectPlotArea2(root2) {
  return select(root2).select(`.${PLOT_CLASS_NAME}`).node();
}
var DEFAULT_BREADCRUMB_STYLE = {
  breadCrumbFill: "rgba(0, 0, 0, 0.85)",
  breadCrumbFontSize: 12,
  breadCrumbY: 12,
  activeFill: "rgba(0, 0, 0, 0.5)"
};
function TreemapDrillDown(drillDownOptions = {}) {
  const { originData = [], layout } = drillDownOptions, style = __rest86(drillDownOptions, ["originData", "layout"]);
  const breadCrumb = deep_mix_default({}, DEFAULT_BREADCRUMB_STYLE, style);
  const breadCrumbStyle = subObject(breadCrumb, "breadCrumb");
  const breadCrumbActiveStyle = subObject(breadCrumb, "active");
  return (context) => {
    const { update: update2, setState, container, options } = context;
    const plotArea = selectPlotArea2(container);
    const mark2 = options.marks[0];
    const { state } = mark2;
    const textGroup = new Group2();
    plotArea.appendChild(textGroup);
    const drillDownClick = (path2, depth) => __awaiter10(this, void 0, void 0, function* () {
      textGroup.removeChildren();
      if (depth) {
        let name2 = "";
        let y3 = breadCrumbStyle.y;
        let x3 = 0;
        const textPath = [];
        const maxWidth = plotArea.getBBox().width;
        const drillTexts = path2.map((text, index3) => {
          name2 = `${name2}${text}/`;
          textPath.push(text);
          const drillText = new Text({
            name: name2.replace(/\/$/, ""),
            style: Object.assign(Object.assign({
              text,
              x: x3,
              // @ts-ignore
              path: [...textPath],
              depth: index3
            }, breadCrumbStyle), { y: y3 })
          });
          textGroup.appendChild(drillText);
          x3 += drillText.getBBox().width;
          const textSeparator = new Text({
            style: Object.assign(Object.assign({ x: x3, text: " / " }, breadCrumbStyle), { y: y3 })
          });
          textGroup.appendChild(textSeparator);
          x3 += textSeparator.getBBox().width;
          if (x3 > maxWidth) {
            y3 = textGroup.getBBox().height + breadCrumbStyle.y;
            x3 = 0;
            drillText.attr({
              x: x3,
              y: y3
            });
            x3 += drillText.getBBox().width;
            textSeparator.attr({
              x: x3,
              y: y3
            });
            x3 += textSeparator.getBBox().width;
          }
          if (index3 === size(path2) - 1) {
            textSeparator.remove();
          }
          return drillText;
        });
        drillTexts.forEach((item, index3) => {
          if (index3 === size(drillTexts) - 1)
            return;
          const originalAttrs = Object.assign({}, item.attributes);
          item.attr("cursor", "pointer");
          item.addEventListener("mouseenter", () => {
            item.attr(breadCrumbActiveStyle);
          });
          item.addEventListener("mouseleave", () => {
            item.attr(originalAttrs);
          });
          item.addEventListener("click", () => {
            drillDownClick(get_default(item, ["style", "path"]), get_default(item, ["style", "depth"]));
          });
        });
      }
      legendClearSetState(container, setState);
      setState("treemapDrillDown", (viewOptions) => {
        const { marks } = viewOptions;
        const strPath = path2.join("/");
        const newMarks = marks.map((mark3) => {
          if (mark3.type !== "rect")
            return mark3;
          let newData = originData;
          if (depth) {
            const filterData = originData.filter((item) => {
              const id4 = get_default(item, ["id"]);
              return id4 && (id4.match(`${strPath}/`) || strPath.match(id4));
            }).map((item) => ({
              value: item.height === 0 ? get_default(item, ["value"]) : void 0,
              name: get_default(item, ["id"])
            }));
            const { paddingLeft, paddingBottom, paddingRight } = layout;
            const newLayout = Object.assign(Object.assign({}, layout), { paddingTop: (layout.paddingTop || textGroup.getBBox().height + 10) / (depth + 1), paddingLeft: paddingLeft / (depth + 1), paddingBottom: paddingBottom / (depth + 1), paddingRight: paddingRight / (depth + 1), path: (d3) => d3.name, layer: (d3) => d3.depth === depth + 1 });
            newData = treeDataTransform(filterData, newLayout, {
              value: "value"
            })[0];
          } else {
            newData = originData.filter((item) => {
              return item.depth === 1;
            });
          }
          const colorDomain = [];
          newData.forEach(({ path: path3 }) => {
            colorDomain.push(last(path3));
          });
          return deep_mix_default({}, mark3, {
            data: newData,
            scale: {
              color: { domain: colorDomain }
            }
          });
        });
        return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
      });
      yield update2(void 0, ["legendFilter"]);
    });
    const createDrillClick = (e) => {
      const item = e.target;
      if (get_default(item, ["markType"]) !== "rect")
        return;
      const key = get_default(item, ["__data__", "key"]);
      const node = find_default(originData, (d3) => d3.id === key);
      if (get_default(node, "height")) {
        drillDownClick(get_default(node, "path"), get_default(node, "depth"));
      }
    };
    plotArea.addEventListener("click", createDrillClick);
    const changeStyleKey = keys_default(Object.assign(Object.assign({}, state.active), state.inactive));
    const createActive = () => {
      const elements = getElements(plotArea);
      elements.forEach((element) => {
        const cursor = get_default(element, ["style", "cursor"]);
        const node = find_default(originData, (d3) => d3.id === get_default(element, ["__data__", "key"]));
        if (cursor !== "pointer" && (node === null || node === void 0 ? void 0 : node.height)) {
          element.style.cursor = "pointer";
          const originalAttrs = pick_default(element.attributes, changeStyleKey);
          element.addEventListener("mouseenter", () => {
            element.attr(state.active);
          });
          element.addEventListener("mouseleave", () => {
            element.attr(deep_mix_default(originalAttrs, state.inactive));
          });
        }
      });
    };
    createActive();
    plotArea.addEventListener("mousemove", createActive);
    return () => {
      textGroup.remove();
      plotArea.removeEventListener("click", createDrillClick);
      plotArea.removeEventListener("mousemove", createActive);
    };
  };
}

// node_modules/@antv/g2/esm/interaction/elementPointMove.js
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest87 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var DEFAULT_STYLE2 = {
  pointR: 6,
  pointStrokeWidth: 1,
  pointStroke: "#888",
  pointActiveStroke: "#f5f5f5",
  pathStroke: "#888",
  pathLineDash: [3, 4],
  labelFontSize: 12,
  labelFill: "#888",
  labelStroke: "#fff",
  labelLineWidth: 1,
  labelY: -6,
  labelX: 2
};
var MOVE_POINT_NAME = "movePoint";
var elementMouseenter = (e) => {
  const element = e.target;
  const { markType } = element;
  if (markType === "line") {
    element.attr("_lineWidth", element.attr("lineWidth") || 1);
    element.attr("lineWidth", element.attr("_lineWidth") + 3);
  }
  if (markType === "interval") {
    element.attr("_opacity", element.attr("opacity") || 1);
    element.attr("opacity", 0.7 * element.attr("_opacity"));
  }
};
var elementMouseleave = (e) => {
  const element = e.target;
  const { markType } = element;
  if (markType === "line") {
    element.attr("lineWidth", element.attr("_lineWidth"));
  }
  if (markType === "interval") {
    element.attr("opacity", element.attr("_opacity"));
  }
};
var getNewData = (newChangeData, data2, encode) => {
  return data2.map((d3) => {
    const isUpdate = ["x", "color"].reduce((v, key) => {
      const field3 = encode[key];
      if (!field3)
        return v;
      if (d3[field3] !== newChangeData[field3])
        return false;
      return v;
    }, true);
    return isUpdate ? Object.assign(Object.assign({}, d3), newChangeData) : d3;
  });
};
var getIntervalDataRatioTransformFn = (element) => {
  const y3 = get_default(element, ["__data__", "y"]);
  const y12 = get_default(element, ["__data__", "y1"]);
  const v = y12 - y3;
  const { __data__: { data: data2, encode, transform: transform2 }, childNodes } = element.parentNode;
  const isNormalizeY = find_default(transform2, ({ type }) => type === "normalizeY");
  const yField = get_default(encode, ["y", "field"]);
  const value2 = data2[childNodes.indexOf(element)][yField];
  return (newValue, isTheta3 = false) => {
    if (isNormalizeY || isTheta3) {
      return newValue / (1 - newValue) / (v / (1 - v)) * value2;
    }
    return newValue;
  };
};
var getPathDataRatioTransformFn = (element, index3) => {
  const v = get_default(element, ["__data__", "seriesItems", index3, "0", "value"]);
  const i = get_default(element, ["__data__", "seriesIndex", index3]);
  const { __data__: { data: data2, encode, transform: transform2 } } = element.parentNode;
  const isNormalizeY = find_default(transform2, ({ type }) => type === "normalizeY");
  const yField = get_default(encode, ["y", "field"]);
  const value2 = data2[i][yField];
  return (newValue) => {
    if (isNormalizeY) {
      if (v === 1) {
        return newValue;
      }
      return newValue / (1 - newValue) / (v / (1 - v)) * value2;
    }
    return newValue;
  };
};
var selectedPointsStyle = (pointsShape, selection, defaultStyle2) => {
  pointsShape.forEach((shape23, index3) => {
    shape23.attr("stroke", selection[1] === index3 ? defaultStyle2["activeStroke"] : defaultStyle2["stroke"]);
  });
};
var createHelpShape = (group3, circle3, pathStyle, labelStyle) => {
  const pathShape = new Path2({
    style: pathStyle
  });
  const labelShape = new Text({
    style: labelStyle
  });
  circle3.appendChild(labelShape);
  group3.appendChild(pathShape);
  return [pathShape, labelShape];
};
var getColorType = (scaleColor, color3) => {
  const indexOf5 = get_default(scaleColor, ["options", "range", "indexOf"]);
  if (!indexOf5)
    return;
  const i = scaleColor.options.range.indexOf(color3);
  return scaleColor.sortedDomain[i];
};
var getSamePointPosition = (center2, point7, target) => {
  const oldR = getPointsR(center2, point7);
  const newR = getPointsR(center2, target);
  const ratio = newR / oldR;
  const newX = center2[0] + (point7[0] - center2[0]) * ratio;
  const newY = center2[1] + (point7[1] - center2[1]) * ratio;
  return [newX, newY];
};
function ElementPointMove(elementPointMoveOptions = {}) {
  const { selection = [], precision = 2 } = elementPointMoveOptions, style = __rest87(elementPointMoveOptions, ["selection", "precision"]);
  const defaultStyle2 = Object.assign(Object.assign({}, DEFAULT_STYLE2), style || {});
  const pathDefaultStyle = subObject(defaultStyle2, "path");
  const labelDefaultStyle = subObject(defaultStyle2, "label");
  const pointDefaultStyle = subObject(defaultStyle2, "point");
  return (context, _2, emitter) => {
    const { update: update2, setState, container, view, options: { marks, coordinate: coordinateOptions } } = context;
    const plotArea = selectPlotArea(container);
    let elements = getElements(plotArea);
    let newState;
    let newSelection = selection;
    const { transform: transform2 = [], type: coordinateType } = coordinateOptions;
    const isTranspose3 = !!find_default(transform2, ({ type }) => type === "transpose");
    const isPolar3 = coordinateType === "polar";
    const isTheta3 = coordinateType === "theta";
    const isArea = !!find_default(elements, ({ markType }) => markType === "area");
    if (isArea) {
      elements = elements.filter(({ markType }) => markType === "area");
    }
    const pointsGroup = new Group2({
      style: {
        // Tooltip point need down.
        zIndex: 2
      }
    });
    plotArea.appendChild(pointsGroup);
    const selectedChange = () => {
      emitter.emit("element-point:select", {
        nativeEvent: true,
        data: {
          selection: newSelection
        }
      });
    };
    const dataChange = (changeData, data2) => {
      emitter.emit("element-point:moved", {
        nativeEvent: true,
        data: {
          changeData,
          data: data2
        }
      });
    };
    const elementClick = (e) => {
      const element = e.target;
      newSelection = [element.parentNode.childNodes.indexOf(element)];
      selectedChange();
      createPoints(element);
    };
    const elementSelect2 = (d3) => {
      const { data: { selection: selection2 }, nativeEvent } = d3;
      if (nativeEvent)
        return;
      newSelection = selection2;
      const element = get_default(elements, [newSelection === null || newSelection === void 0 ? void 0 : newSelection[0]]);
      if (element) {
        createPoints(element);
      }
    };
    const createPoints = (element) => {
      const { attributes, markType, __data__: data2 } = element;
      const { stroke: fill } = attributes;
      const { points, seriesTitle, color: color3, title, seriesX, y1: y12 } = data2;
      if (isTranspose3 && markType !== "interval")
        return;
      const { scale: scale11, coordinate } = (newState === null || newState === void 0 ? void 0 : newState.view) || view;
      const { color: scaleColor, y: scaleY2, x: scaleX2 } = scale11;
      const center2 = coordinate.getCenter();
      pointsGroup.removeChildren();
      let downPoint;
      const updateView = (x3, y3, color4, markTypes) => __awaiter11(this, void 0, void 0, function* () {
        setState("elementPointMove", (viewOptions) => {
          var _a2;
          const newMarks = (((_a2 = newState === null || newState === void 0 ? void 0 : newState.options) === null || _a2 === void 0 ? void 0 : _a2.marks) || marks).map((mark2) => {
            if (!markTypes.includes(mark2.type))
              return mark2;
            const { data: data3, encode } = mark2;
            const encodeKeys = Object.keys(encode);
            const newChangeData = encodeKeys.reduce((value2, key) => {
              const dataKey = encode[key];
              if (key === "x") {
                value2[dataKey] = x3;
              }
              if (key === "y") {
                value2[dataKey] = y3;
              }
              if (key === "color") {
                value2[dataKey] = color4;
              }
              return value2;
            }, {});
            const newData = getNewData(newChangeData, data3, encode);
            dataChange(newChangeData, newData);
            return deep_mix_default({}, mark2, {
              data: newData,
              // No need animate
              animate: false
            });
          });
          return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
        });
        return yield update2("elementPointMove");
      });
      if (["line", "area"].includes(markType)) {
        points.forEach((p2, index3) => {
          const title2 = scaleX2.invert(seriesX[index3]);
          if (!title2)
            return;
          const circle3 = new Circle({
            name: MOVE_POINT_NAME,
            style: Object.assign({ cx: p2[0], cy: p2[1], fill }, pointDefaultStyle)
          });
          const ratioTransform = getPathDataRatioTransformFn(element, index3);
          circle3.addEventListener("mousedown", (e) => {
            const oldPoint = coordinate.output([seriesX[index3], 0]);
            const pathLength = seriesTitle === null || seriesTitle === void 0 ? void 0 : seriesTitle.length;
            container.attr("cursor", "move");
            if (newSelection[1] !== index3) {
              newSelection[1] = index3;
              selectedChange();
            }
            selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);
            const [pathShape, labelShape] = createHelpShape(pointsGroup, circle3, pathDefaultStyle, labelDefaultStyle);
            const pointMousemove = (e3) => {
              const newCy = p2[1] + e3.clientY - downPoint[1];
              if (isArea) {
                if (isPolar3) {
                  const newCx = p2[0] + e3.clientX - downPoint[0];
                  const [newX, newY] = getSamePointPosition(center2, oldPoint, [
                    newCx,
                    newCy
                  ]);
                  const [, initY] = coordinate.output([1, scaleY2.output(0)]);
                  const [, y3] = coordinate.invert([
                    newX,
                    initY - (points[index3 + pathLength][1] - newY)
                  ]);
                  const nextIndex = (index3 + 1) % pathLength;
                  const lastIndex = (index3 - 1 + pathLength) % pathLength;
                  const newPath = getPointsPath([
                    points[lastIndex],
                    [newX, newY],
                    seriesTitle[nextIndex] && points[nextIndex]
                  ]);
                  labelShape.attr("text", ratioTransform(scaleY2.invert(y3)).toFixed(precision));
                  pathShape.attr("d", newPath);
                  circle3.attr("cx", newX);
                  circle3.attr("cy", newY);
                } else {
                  const [, initY] = coordinate.output([1, scaleY2.output(0)]);
                  const [, y3] = coordinate.invert([
                    p2[0],
                    initY - (points[index3 + pathLength][1] - newCy)
                  ]);
                  const newPath = getPointsPath([
                    points[index3 - 1],
                    [p2[0], newCy],
                    seriesTitle[index3 + 1] && points[index3 + 1]
                  ]);
                  labelShape.attr("text", ratioTransform(scaleY2.invert(y3)).toFixed(precision));
                  pathShape.attr("d", newPath);
                  circle3.attr("cy", newCy);
                }
              } else {
                const [, y3] = coordinate.invert([p2[0], newCy]);
                const newPath = getPointsPath([
                  points[index3 - 1],
                  [p2[0], newCy],
                  points[index3 + 1]
                ]);
                labelShape.attr("text", scaleY2.invert(y3).toFixed(precision));
                pathShape.attr("d", newPath);
                circle3.attr("cy", newCy);
              }
            };
            downPoint = [e.clientX, e.clientY];
            window.addEventListener("mousemove", pointMousemove);
            const mouseupFn = () => __awaiter11(this, void 0, void 0, function* () {
              container.attr("cursor", "default");
              window.removeEventListener("mousemove", pointMousemove);
              container.removeEventListener("mouseup", mouseupFn);
              if (is_undefined_default(labelShape.attr("text")))
                return;
              const y3 = Number(labelShape.attr("text"));
              const colorType = getColorType(scaleColor, color3);
              newState = yield updateView(title2, y3, colorType, [
                "line",
                "area"
              ]);
              labelShape.remove();
              pathShape.remove();
              createPoints(element);
            });
            container.addEventListener("mouseup", mouseupFn);
          });
          pointsGroup.appendChild(circle3);
        });
        selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);
      } else if (markType === "interval") {
        let circlePoint = [(points[0][0] + points[1][0]) / 2, points[0][1]];
        if (isTranspose3) {
          circlePoint = [points[0][0], (points[0][1] + points[1][1]) / 2];
        } else if (isTheta3) {
          circlePoint = points[0];
        }
        const ratioTransform = getIntervalDataRatioTransformFn(element);
        const circle3 = new Circle({
          name: MOVE_POINT_NAME,
          style: Object.assign(Object.assign({ cx: circlePoint[0], cy: circlePoint[1], fill }, pointDefaultStyle), { stroke: pointDefaultStyle["activeStroke"] })
        });
        circle3.addEventListener("mousedown", (e) => {
          container.attr("cursor", "move");
          const colorType = getColorType(scaleColor, color3);
          const [pathShape, labelShape] = createHelpShape(pointsGroup, circle3, pathDefaultStyle, labelDefaultStyle);
          const pointMousemove = (e3) => {
            if (isTranspose3) {
              const newCx = circlePoint[0] + e3.clientX - downPoint[0];
              const [initX] = coordinate.output([
                scaleY2.output(0),
                scaleY2.output(0)
              ]);
              const [, x3] = coordinate.invert([
                initX + (newCx - points[2][0]),
                circlePoint[1]
              ]);
              const newPath = getPointsPath([
                [newCx, points[0][1]],
                [newCx, points[1][1]],
                points[2],
                points[3]
              ], true);
              labelShape.attr("text", ratioTransform(scaleY2.invert(x3)).toFixed(precision));
              pathShape.attr("d", newPath);
              circle3.attr("cx", newCx);
            } else if (isTheta3) {
              const newCy = circlePoint[1] + e3.clientY - downPoint[1];
              const newCx = circlePoint[0] + e3.clientX - downPoint[0];
              const [newXOut, newYOut] = getSamePointPosition(center2, [newCx, newCy], circlePoint);
              const [newXIn, newYIn] = getSamePointPosition(center2, [newCx, newCy], points[1]);
              const lastPercent = coordinate.invert([newXOut, newYOut])[1];
              const percent2 = y12 - lastPercent;
              if (percent2 < 0)
                return;
              const newPath = getThetaPath(center2, [[newXOut, newYOut], [newXIn, newYIn], points[2], points[3]], percent2 > 0.5 ? 1 : 0);
              labelShape.attr("text", ratioTransform(percent2, true).toFixed(precision));
              pathShape.attr("d", newPath);
              circle3.attr("cx", newXOut);
              circle3.attr("cy", newYOut);
            } else {
              const newCy = circlePoint[1] + e3.clientY - downPoint[1];
              const [, initY] = coordinate.output([1, scaleY2.output(0)]);
              const [, y3] = coordinate.invert([
                circlePoint[0],
                initY - (points[2][1] - newCy)
              ]);
              const newPath = getPointsPath([
                [points[0][0], newCy],
                [points[1][0], newCy],
                points[2],
                points[3]
              ], true);
              labelShape.attr("text", ratioTransform(scaleY2.invert(y3)).toFixed(precision));
              pathShape.attr("d", newPath);
              circle3.attr("cy", newCy);
            }
          };
          downPoint = [e.clientX, e.clientY];
          window.addEventListener("mousemove", pointMousemove);
          const mouseupFn = () => __awaiter11(this, void 0, void 0, function* () {
            container.attr("cursor", "default");
            container.removeEventListener("mouseup", mouseupFn);
            window.removeEventListener("mousemove", pointMousemove);
            if (is_undefined_default(labelShape.attr("text")))
              return;
            const y3 = Number(labelShape.attr("text"));
            newState = yield updateView(title, y3, colorType, [markType]);
            labelShape.remove();
            pathShape.remove();
            createPoints(element);
          });
          container.addEventListener("mouseup", mouseupFn);
        });
        pointsGroup.appendChild(circle3);
      }
    };
    elements.forEach((element, index3) => {
      if (newSelection[0] === index3) {
        createPoints(element);
      }
      element.addEventListener("click", elementClick);
      element.addEventListener("mouseenter", elementMouseenter);
      element.addEventListener("mouseleave", elementMouseleave);
    });
    const rootClick = (e) => {
      const element = e === null || e === void 0 ? void 0 : e.target;
      if (!element || element.name !== MOVE_POINT_NAME && !elements.includes(element)) {
        newSelection = [];
        selectedChange();
        pointsGroup.removeChildren();
      }
    };
    emitter.on("element-point:select", elementSelect2);
    emitter.on("element-point:unselect", rootClick);
    container.addEventListener("mousedown", rootClick);
    return () => {
      pointsGroup.remove();
      emitter.off("element-point:select", elementSelect2);
      emitter.off("element-point:unselect", rootClick);
      container.removeEventListener("mousedown", rootClick);
      elements.forEach((element) => {
        element.removeEventListener("click", elementClick);
        element.removeEventListener("mouseenter", elementMouseenter);
        element.removeEventListener("mouseleave", elementMouseleave);
      });
    };
  };
}

// node_modules/d3-dsv/src/dsv.js
var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name2, i) {
    return JSON.stringify(name2) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row2, i) {
    return f(object(row2), i, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row2) {
    for (var column2 in row2) {
      if (!(column2 in columnSet)) {
        columns.push(columnSet[column2] = column2);
      }
    }
  });
  return columns;
}
function pad2(value2, width) {
  var s3 = value2 + "", length5 = s3.length;
  return length5 < width ? new Array(width - length5 + 1).join(0) + s3 : s3;
}
function formatYear(year2) {
  return year2 < 0 ? "-" + pad2(-year2, 6) : year2 > 9999 ? "+" + pad2(year2, 6) : pad2(year2, 4);
}
function formatDate(date) {
  var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear(), 4) + "-" + pad2(date.getUTCMonth() + 1, 2) + "-" + pad2(date.getUTCDate(), 2) + (milliseconds ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + ":" + pad2(seconds, 2) + "." + pad2(milliseconds, 3) + "Z" : seconds ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + ":" + pad2(seconds, 2) + "Z" : minutes || hours ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row2, i) {
      if (convert)
        return convert(row2, i - 1);
      columns = row2, convert = f ? customConverter(row2, f) : objectConverter(row2);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text, f) {
    var rows = [], N = text.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
    if (text.charCodeAt(N - 1) === NEWLINE)
      --N;
    if (text.charCodeAt(N - 1) === RETURN)
      --N;
    function token2() {
      if (eof)
        return EOF;
      if (eol)
        return eol = false, EOL;
      var i, j = I, c5;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE)
          ;
        if ((i = I) >= N)
          eof = true;
        else if ((c5 = text.charCodeAt(I++)) === NEWLINE)
          eol = true;
        else if (c5 === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE)
            ++I;
        }
        return text.slice(j + 1, i - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c5 = text.charCodeAt(i = I++)) === NEWLINE)
          eol = true;
        else if (c5 === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE)
            ++I;
        } else if (c5 !== DELIMITER)
          continue;
        return text.slice(j, i);
      }
      return eof = true, text.slice(j, N);
    }
    while ((t = token2()) !== EOF) {
      var row2 = [];
      while (t !== EOL && t !== EOF)
        row2.push(t), t = token2();
      if (f && (row2 = f(row2, n++)) == null)
        continue;
      rows.push(row2);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row2) {
      return columns.map(function(column2) {
        return formatValue(row2[column2]);
      }).join(delimiter);
    });
  }
  function format3(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row2) {
    return row2.map(formatValue).join(delimiter);
  }
  function formatValue(value2) {
    return value2 == null ? "" : value2 instanceof Date ? formatDate(value2) : reFormat.test(value2 += "") ? '"' + value2.replace(/"/g, '""') + '"' : value2;
  }
  return {
    parse,
    parseRows,
    format: format3,
    formatBody,
    formatRows,
    formatRow,
    formatValue
  };
}

// node_modules/d3-dsv/src/csv.js
var csv = dsv_default(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

// node_modules/d3-dsv/src/tsv.js
var tsv = dsv_default("	");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

// node_modules/d3-dsv/src/autoType.js
function autoType(object) {
  for (var key in object) {
    var value2 = object[key].trim(), number3, m3;
    if (!value2)
      value2 = null;
    else if (value2 === "true")
      value2 = true;
    else if (value2 === "false")
      value2 = false;
    else if (value2 === "NaN")
      value2 = NaN;
    else if (!isNaN(number3 = +value2))
      value2 = number3;
    else if (m3 = value2.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
      if (fixtz && !!m3[4] && !m3[7])
        value2 = value2.replace(/-/g, "/").replace(/T/, " ");
      value2 = new Date(value2);
    } else
      continue;
    object[key] = value2;
  }
  return object;
}
var fixtz = (/* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || (/* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();

// node_modules/@antv/g2/esm/data/fetch.js
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Fetch = (options) => {
  const { value: value2, format: format3 = value2.split(".").pop(), delimiter = ",", autoType: autoType2 = true } = options;
  return () => __awaiter12(void 0, void 0, void 0, function* () {
    const response = yield fetch(value2);
    if (format3 === "csv") {
      const str7 = yield response.text();
      return dsv_default(delimiter).parse(str7, autoType2 ? autoType : identity5);
    } else if (format3 === "json") {
      return yield response.json();
    }
    throw new Error(`Unknown format: ${format3}.`);
  });
};
Fetch.props = {};

// node_modules/@antv/g2/esm/data/fold.js
function isEmpty(obj) {
  return !obj || Object.keys(obj).length === 0;
}
var Fold = (options) => {
  const { fields, key = "key", value: value2 = "value" } = options;
  return (data2) => {
    if (isEmpty(fields))
      return data2;
    return data2.flatMap((d3) => fields.map((f) => Object.assign(Object.assign({}, d3), { [key]: f, [value2]: d3[f] })));
  };
};
Fold.props = {};

// node_modules/@antv/g2/esm/data/filter.js
function defined3(d3) {
  return d3 !== void 0 && d3 !== null && !Number.isNaN(d3);
}
var Filter2 = (options) => {
  const { callback = defined3 } = options;
  return (data2) => data2.filter(callback);
};
Filter2.props = {};

// node_modules/@antv/g2/esm/data/sort.js
var Sort2 = (options) => {
  const { callback } = options;
  return (data2) => Array.isArray(data2) ? [...data2].sort(callback) : data2;
};
Sort2.props = {};

// node_modules/@antv/g2/esm/data/pick.js
function pick(v, fields = []) {
  return fields.reduce((datum, field3) => {
    if (field3 in v) {
      datum[field3] = v[field3];
    }
    return datum;
  }, {});
}
var Pick = (options) => {
  const { fields } = options;
  return (data2) => data2.map((d3) => pick(d3, fields));
};
Pick.props = {};

// node_modules/@antv/g2/esm/data/rename.js
function isEmpty2(obj) {
  return Object.keys(obj).length === 0;
}
var Rename = (options) => {
  return (data2) => {
    if (!options || isEmpty2(options))
      return data2;
    const rename = (v) => Object.entries(v).reduce((datum, [key, value2]) => (datum[options[key] || key] = value2, datum), {});
    return data2.map(rename);
  };
};
Rename.props = {};

// node_modules/@antv/g2/esm/data/utils/fields.js
function normalizeFields(fields, defaultValue) {
  return fields.map((d3) => {
    if (Array.isArray(d3)) {
      const [field3, value2 = defaultValue] = d3;
      return [field3, value2];
    }
    return [d3, defaultValue];
  });
}

// node_modules/@antv/g2/esm/data/sortBy.js
var SortBy = (options) => {
  const { fields: F = [] } = options;
  const normalizedF = normalizeFields(F, true);
  return (data2) => {
    const comparator = (a4, b) => normalizedF.reduce((ret, [field3, order = true]) => {
      if (ret !== 0) {
        return ret;
      }
      if (order) {
        return a4[field3] < b[field3] ? -1 : +(a4[field3] !== b[field3]);
      } else {
        return a4[field3] > b[field3] ? -1 : +(a4[field3] !== b[field3]);
      }
    }, 0);
    return [...data2].sort(comparator);
  };
};
SortBy.props = {};

// node_modules/@antv/g2/esm/data/inline.js
var Inline = (options) => {
  const { value: value2 } = options;
  return () => value2;
};
Inline.props = {};

// node_modules/@antv/g2/esm/data/custom.js
var Custom = (options) => {
  const { callback = identity5 } = options;
  return (data2) => callback(data2);
};
Custom.props = {};

// node_modules/@antv/g2/esm/data/map.js
var Map2 = (options) => {
  const { callback = identity5 } = options;
  return (data2) => Array.isArray(data2) ? data2.map(callback) : data2;
};
Map2.props = {};

// node_modules/@antv/g2/esm/data/utils/flow.js
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function flow2(target, source) {
  return {
    set(key, normalize10, callback) {
      if (source[key] === void 0)
        return this;
      const value2 = normalize10 ? normalize10.call(null, source[key]) : source[key];
      if (callback)
        callback.call(null, value2);
      else if (typeof target[key] === "function")
        target[key](value2);
      else
        target[key] = value2;
      return this;
    },
    setAsync(key, normalize10, callback) {
      return __awaiter13(this, void 0, void 0, function* () {
        if (source[key] === void 0)
          return this;
        const value2 = normalize10 ? yield normalize10.call(null, source[key]) : source[key];
        if (callback)
          callback.call(null, value2);
        else if (typeof target[key] === "function")
          target[key](value2);
        else
          target[key] = value2;
        return this;
      });
    }
  };
}

// node_modules/@antv/g2/esm/data/utils/d3-cloud/index.js
var cloudRadians = Math.PI / 180;
var cw = 1 << 11 >> 5;
var ch = 1 << 11;
function cloudText(d3) {
  return d3.text;
}
function cloudFont() {
  return "serif";
}
function cloudFontNormal() {
  return "normal";
}
function cloudFontSize(d3) {
  return d3.value;
}
function cloudRotate() {
  return ~~(Math.random() * 2) * 90;
}
function cloudPadding() {
  return 1;
}
function cloudDispatch() {
  return;
}
function cloudSprite(contextAndRatio, d3, data2, di) {
  if (d3.sprite)
    return;
  const c5 = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c5.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  let x3 = 0, y3 = 0, maxh = 0;
  const n = data2.length;
  --di;
  while (++di < n) {
    d3 = data2[di];
    c5.save();
    c5.font = d3.style + " " + d3.weight + " " + ~~((d3.size + 1) / ratio) + "px " + d3.font;
    let w = c5.measureText(d3.text + "m").width * ratio, h = d3.size << 1;
    if (d3.rotate) {
      const sr = Math.sin(d3.rotate * cloudRadians), cr = Math.cos(d3.rotate * cloudRadians), wcr = w * cr, wsr = w * sr, hcr = h * cr, hsr = h * sr;
      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w = w + 31 >> 5 << 5;
    }
    if (h > maxh)
      maxh = h;
    if (x3 + w >= cw << 5) {
      x3 = 0;
      y3 += maxh;
      maxh = 0;
    }
    if (y3 + h >= ch)
      break;
    c5.translate((x3 + (w >> 1)) / ratio, (y3 + (h >> 1)) / ratio);
    if (d3.rotate)
      c5.rotate(d3.rotate * cloudRadians);
    c5.fillText(d3.text, 0, 0);
    if (d3.padding) {
      c5.lineWidth = 2 * d3.padding;
      c5.strokeText(d3.text, 0, 0);
    }
    c5.restore();
    d3.width = w;
    d3.height = h;
    d3.xoff = x3;
    d3.yoff = y3;
    d3.x1 = w >> 1;
    d3.y1 = h >> 1;
    d3.x0 = -d3.x1;
    d3.y0 = -d3.y1;
    d3.hasText = true;
    x3 += w;
  }
  const pixels = c5.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di >= 0) {
    d3 = data2[di];
    if (!d3.hasText)
      continue;
    const w = d3.width, w32 = w >> 5;
    let h = d3.y1 - d3.y0;
    for (let i = 0; i < h * w32; i++)
      sprite[i] = 0;
    x3 = d3.xoff;
    if (x3 == null)
      return;
    y3 = d3.yoff;
    let seen = 0, seenRow = -1;
    for (let j = 0; j < h; j++) {
      for (let i = 0; i < w; i++) {
        const k2 = w32 * j + (i >> 5), m3 = pixels[(y3 + j) * (cw << 5) + (x3 + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k2] |= m3;
        seen |= m3;
      }
      if (seen)
        seenRow = j;
      else {
        d3.y0++;
        h--;
        j--;
        y3++;
      }
    }
    d3.y1 = d3.y0 + seenRow;
    d3.sprite = sprite.slice(0, (d3.y1 - d3.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  const sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
  let x3 = (tag.y + tag.y0) * sw + (lx >> 5), last5;
  for (let j = 0; j < h; j++) {
    last5 = 0;
    for (let i = 0; i <= w; i++) {
      if ((last5 << msx | (i < w ? (last5 = sprite[j * w + i]) >>> sx : 0)) & board[x3 + i])
        return true;
    }
    x3 += sw;
  }
  return false;
}
function cloudBounds(bounds, d3) {
  const b0 = bounds[0], b1 = bounds[1];
  if (d3.x + d3.x0 < b0.x)
    b0.x = d3.x + d3.x0;
  if (d3.y + d3.y0 < b0.y)
    b0.y = d3.y + d3.y0;
  if (d3.x + d3.x1 > b1.x)
    b1.x = d3.x + d3.x1;
  if (d3.y + d3.y1 > b1.y)
    b1.y = d3.y + d3.y1;
}
function collideRects(a4, b) {
  return a4.x + a4.x1 > b[0].x && a4.x + a4.x0 < b[1].x && a4.y + a4.y1 > b[0].y && a4.y + a4.y0 < b[1].y;
}
function archimedeanSpiral(size3) {
  const e = size3[0] / size3[1];
  return function(t) {
    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}
function rectangularSpiral(size3) {
  const dy = 4, dx = dy * size3[0] / size3[1];
  let x3 = 0, y3 = 0;
  return function(t) {
    const sign3 = t < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign3 * t) - sign3 & 3) {
      case 0:
        x3 += dx;
        break;
      case 1:
        y3 += dy;
        break;
      case 2:
        x3 -= dx;
        break;
      default:
        y3 -= dy;
        break;
    }
    return [x3, y3];
  };
}
function zeroArray(n) {
  const a4 = [];
  let i = -1;
  while (++i < n)
    a4[i] = 0;
  return a4;
}
function cloudCanvas() {
  return document.createElement("canvas");
}
function functor(d3) {
  return typeof d3 === "function" ? d3 : function() {
    return d3;
  };
}
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
function tagCloud() {
  let size3 = [256, 256], text = cloudText, font = cloudFont, fontSize = cloudFontSize, fontWeight = cloudFontNormal, rotate7 = cloudRotate, padding = cloudPadding, spiral = archimedeanSpiral, random5 = Math.random, event = cloudDispatch, words = [], timer2 = null, timeInterval = Infinity, canvas = cloudCanvas;
  const fontStyle = cloudFontNormal;
  const cloud = {};
  cloud.start = function() {
    const [width, height] = size3;
    const contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size3[0] >> 5) * size3[1]), n = words.length, tags = [], data2 = words.map(function(d3, i2, data3) {
      d3.text = text.call(this, d3, i2, data3);
      d3.font = font.call(this, d3, i2, data3);
      d3.style = fontStyle.call(this, d3, i2, data3);
      d3.weight = fontWeight.call(this, d3, i2, data3);
      d3.rotate = rotate7.call(this, d3, i2, data3);
      d3.size = ~~fontSize.call(this, d3, i2, data3);
      d3.padding = padding.call(this, d3, i2, data3);
      return d3;
    }).sort(function(a4, b) {
      return b.size - a4.size;
    });
    let i = -1, bounds = !cloud.board ? void 0 : [
      {
        x: 0,
        y: 0
      },
      {
        x: width,
        y: height
      }
    ];
    if (timer2)
      clearInterval(timer2);
    timer2 = setInterval(step2, 0);
    step2();
    function step2() {
      const start = Date.now();
      while (Date.now() - start < timeInterval && ++i < n) {
        const d3 = data2[i];
        d3.x = width * (random5() + 0.5) >> 1;
        d3.y = height * (random5() + 0.5) >> 1;
        cloudSprite(contextAndRatio, d3, data2, i);
        if (d3.hasText && place2(board, d3, bounds)) {
          event.call(null, "word", { cloud, word: d3 });
          tags.push(d3);
          if (bounds) {
            if (!cloud.hasImage) {
              cloudBounds(bounds, d3);
            }
          } else {
            bounds = [
              { x: d3.x + d3.x0, y: d3.y + d3.y0 },
              { x: d3.x + d3.x1, y: d3.y + d3.y1 }
            ];
          }
          d3.x -= size3[0] >> 1;
          d3.y -= size3[1] >> 1;
        }
      }
      cloud._tags = tags;
      cloud._bounds = bounds;
      if (i >= n) {
        cloud.stop();
        event.call(null, "end", { cloud, words: tags, bounds });
      }
    }
    return cloud;
  };
  cloud.stop = function() {
    if (timer2) {
      clearInterval(timer2);
      timer2 = null;
    }
    return cloud;
  };
  function getContext(canvas2) {
    canvas2.width = canvas2.height = 1;
    const ratio = Math.sqrt(canvas2.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas2.width = (cw << 5) / ratio;
    canvas2.height = ch / ratio;
    const context = canvas2.getContext("2d");
    context.fillStyle = context.strokeStyle = "red";
    context.textAlign = "center";
    context.textBaseline = "middle";
    return { context, ratio };
  }
  function place2(board, tag, bounds) {
    const startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size3[0] * size3[0] + size3[1] * size3[1]), s3 = spiral(size3), dt = random5() < 0.5 ? 1 : -1;
    let dxdy, t = -dt, dx, dy;
    while (dxdy = s3(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
        break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size3[0] || tag.y + tag.y1 > size3[1])
        continue;
      if (!bounds || !cloudCollide(tag, board, size3[0])) {
        if (!bounds || collideRects(tag, bounds)) {
          const sprite = tag.sprite, w = tag.width >> 5, sw = size3[0] >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
          let last5, x3 = (tag.y + tag.y0) * sw + (lx >> 5);
          for (let j = 0; j < h; j++) {
            last5 = 0;
            for (let i = 0; i <= w; i++) {
              board[x3 + i] |= last5 << msx | (i < w ? (last5 = sprite[j * w + i]) >>> sx : 0);
            }
            x3 += sw;
          }
          delete tag.sprite;
          return true;
        }
      }
    }
    return false;
  }
  cloud.createMask = (img) => {
    const can = document.createElement("canvas");
    const [width, height] = size3;
    if (!width || !height) {
      return;
    }
    const w32 = width >> 5;
    const board = zeroArray((width >> 5) * height);
    can.width = width;
    can.height = height;
    const cxt = can.getContext("2d");
    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
    const imageData = cxt.getImageData(0, 0, width, height).data;
    for (let j = 0; j < height; j++) {
      for (let i = 0; i < width; i++) {
        const k2 = w32 * j + (i >> 5);
        const tmp2 = j * width + i << 2;
        const flag = imageData[tmp2] >= 250 && imageData[tmp2 + 1] >= 250 && imageData[tmp2 + 2] >= 250;
        const m3 = flag ? 1 << 31 - i % 32 : 0;
        board[k2] |= m3;
      }
    }
    cloud.board = board;
    cloud.hasImage = true;
  };
  cloud.timeInterval = function(_2) {
    timeInterval = _2 == null ? Infinity : _2;
  };
  cloud.words = function(_2) {
    words = _2;
  };
  cloud.size = function(_2 = []) {
    size3 = [+_2[0], +_2[1]];
  };
  cloud.text = function(_2) {
    text = functor(_2);
  };
  cloud.font = function(_2) {
    font = functor(_2);
  };
  cloud.fontWeight = function(_2) {
    fontWeight = functor(_2);
  };
  cloud.rotate = function(_2) {
    rotate7 = functor(_2);
  };
  cloud.canvas = function(_2) {
    canvas = functor(_2);
  };
  cloud.spiral = function(_2) {
    spiral = spirals[_2] || _2;
  };
  cloud.fontSize = function(_2) {
    fontSize = functor(_2);
  };
  cloud.padding = function(_2) {
    padding = functor(_2);
  };
  cloud.random = function(_2) {
    random5 = functor(_2);
  };
  cloud.on = function(_2) {
    event = functor(_2);
  };
  return cloud;
}

// node_modules/@antv/g2/esm/data/wordCloud.js
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest88 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var DEFAULT_OPTIONS5 = {
  fontSize: [20, 60],
  font: "Impact",
  padding: 2,
  rotate: function() {
    return (~~(Math.random() * 6) - 3) * 30;
  }
};
function processImageMask(img) {
  return new Promise((res, rej) => {
    if (img instanceof HTMLImageElement) {
      res(img);
      return;
    }
    if (typeof img === "string") {
      const image = new Image();
      image.crossOrigin = "anonymous";
      image.src = img;
      image.onload = () => res(image);
      image.onerror = () => {
        console.error(`'image ${img} load failed !!!'`);
        rej();
      };
      return;
    }
    rej();
  });
}
function normalizeFontSize(fontSize, range3) {
  if (typeof fontSize === "function")
    return fontSize;
  if (Array.isArray(fontSize)) {
    const [fMin, fMax] = fontSize;
    if (!range3)
      return () => (fMax + fMin) / 2;
    const [min10, max11] = range3;
    if (max11 === min10)
      return () => (fMax + fMin) / 2;
    return ({ value: value2 }) => (fMax - fMin) / (max11 - min10) * (value2 - min10) + fMin;
  }
  return () => fontSize;
}
var WordCloud2 = (options, context) => {
  return (data2) => __awaiter14(void 0, void 0, void 0, function* () {
    const cloudOptions = Object.assign({}, DEFAULT_OPTIONS5, options, {
      canvas: context.createCanvas
    });
    const layout = tagCloud();
    yield flow2(layout, cloudOptions).set("fontSize", (v) => {
      const arr = data2.map((d3) => d3.value);
      return normalizeFontSize(v, [min4(arr), max5(arr)]);
    }).set("font").set("fontStyle").set("fontWeight").set("padding").set("rotate").set("size").set("spiral").set("timeInterval").set("random").set("text").set("on").set("canvas").setAsync("imageMask", processImageMask, layout.createMask);
    layout.words([...data2]);
    const result = layout.start();
    const [cw2, ch2] = cloudOptions.size;
    const defaultBounds = [
      { x: 0, y: 0 },
      { x: cw2, y: ch2 }
    ];
    const { _bounds: bounds = defaultBounds, _tags, hasImage } = result;
    const tags = _tags.map((_a2) => {
      var { x: x3, y: y3, font } = _a2, rest = __rest88(_a2, ["x", "y", "font"]);
      return Object.assign(Object.assign({}, rest), { x: x3 + cw2 / 2, y: y3 + ch2 / 2, fontFamily: font });
    });
    const [{ x: tlx, y: tly }, { x: brx, y: bry }] = bounds;
    const invisibleText = { text: "", value: 0, opacity: 0, fontSize: 0 };
    tags.push(Object.assign(Object.assign({}, invisibleText), { x: hasImage ? 0 : tlx, y: hasImage ? 0 : tly }), Object.assign(Object.assign({}, invisibleText), { x: hasImage ? cw2 : brx, y: hasImage ? ch2 : bry }));
    return tags;
  });
};
WordCloud2.props = {};

// node_modules/@antv/g2/esm/data/join.js
function field2(key) {
  return typeof key === "string" ? (d3) => d3[key] : key;
}
var Join = (options) => {
  const { join, on, select: select3 = [], as = select3, unknown = NaN } = options;
  const [key, fromKey] = on;
  const fk = field2(fromKey);
  const k2 = field2(key);
  const keyData = rollup(
    join,
    ([d3]) => d3,
    // Get the first matched.
    (d3) => fk(d3)
  );
  return (data2) => data2.map((d3) => {
    const source = keyData.get(k2(d3));
    return Object.assign(Object.assign({}, d3), select3.reduce((prev, key2, idx) => (prev[as[idx]] = source ? source[key2] : unknown, prev), {}));
  });
};
Join.props = {};

// node_modules/@antv/g2/esm/data/slice.js
var Slice = (options) => {
  const { start, end } = options;
  return (data2) => data2.slice(start, end);
};
Slice.props = {};

// node_modules/@antv/g2/esm/data/kde.js
var import_pdfast = __toESM(require_src());
var KDE = (options) => {
  const { field: field3, groupBy: groupBy3, as = ["y", "size"], min: min10, max: max11, size: size3 = 10, width } = options;
  const [yField, sizeField] = as;
  return (data2) => {
    const gs = Array.from(group(data2, (d3) => groupBy3.map((gb) => d3[gb]).join("-")).values());
    return gs.map((g) => {
      const pdfResult = import_pdfast.default.create(g.map((i) => i[field3]), {
        min: min10,
        max: max11,
        size: size3,
        width
      });
      const _y = pdfResult.map((result) => result.x);
      const _size = pdfResult.map((result) => result.y);
      return Object.assign(Object.assign({}, g[0]), { [yField]: _y, [sizeField]: _size });
    });
  };
};
KDE.props = {};

// node_modules/fmin/src/bisect.js
function bisect2(f, a4, b, parameters) {
  parameters = parameters || {};
  var maxIterations = parameters.maxIterations || 100, tolerance2 = parameters.tolerance || 1e-10, fA = f(a4), fB = f(b), delta = b - a4;
  if (fA * fB > 0) {
    throw "Initial bisect points must have opposite signs";
  }
  if (fA === 0)
    return a4;
  if (fB === 0)
    return b;
  for (var i = 0; i < maxIterations; ++i) {
    delta /= 2;
    var mid2 = a4 + delta, fMid = f(mid2);
    if (fMid * fA >= 0) {
      a4 = mid2;
    }
    if (Math.abs(delta) < tolerance2 || fMid === 0) {
      return mid2;
    }
  }
  return a4 + delta;
}

// node_modules/fmin/src/blas1.js
function zeros(x3) {
  var r = new Array(x3);
  for (var i = 0; i < x3; ++i) {
    r[i] = 0;
  }
  return r;
}
function zerosM(x3, y3) {
  return zeros(x3).map(function() {
    return zeros(y3);
  });
}
function dot8(a4, b) {
  var ret = 0;
  for (var i = 0; i < a4.length; ++i) {
    ret += a4[i] * b[i];
  }
  return ret;
}
function norm2(a4) {
  return Math.sqrt(dot8(a4, a4));
}
function scale10(ret, value2, c5) {
  for (var i = 0; i < value2.length; ++i) {
    ret[i] = value2[i] * c5;
  }
}
function weightedSum(ret, w1, v1, w2, v2) {
  for (var j = 0; j < ret.length; ++j) {
    ret[j] = w1 * v1[j] + w2 * v2[j];
  }
}

// node_modules/fmin/src/nelderMead.js
function nelderMead(f, x05, parameters) {
  parameters = parameters || {};
  var maxIterations = parameters.maxIterations || x05.length * 200, nonZeroDelta = parameters.nonZeroDelta || 1.05, zeroDelta = parameters.zeroDelta || 1e-3, minErrorDelta = parameters.minErrorDelta || 1e-6, minTolerance = parameters.minErrorDelta || 1e-5, rho = parameters.rho !== void 0 ? parameters.rho : 1, chi = parameters.chi !== void 0 ? parameters.chi : 2, psi = parameters.psi !== void 0 ? parameters.psi : -0.5, sigma = parameters.sigma !== void 0 ? parameters.sigma : 0.5, maxDiff;
  var N = x05.length, simplex = new Array(N + 1);
  simplex[0] = x05;
  simplex[0].fx = f(x05);
  simplex[0].id = 0;
  for (var i = 0; i < N; ++i) {
    var point7 = x05.slice();
    point7[i] = point7[i] ? point7[i] * nonZeroDelta : zeroDelta;
    simplex[i + 1] = point7;
    simplex[i + 1].fx = f(point7);
    simplex[i + 1].id = i + 1;
  }
  function updateSimplex(value2) {
    for (var i2 = 0; i2 < value2.length; i2++) {
      simplex[N][i2] = value2[i2];
    }
    simplex[N].fx = value2.fx;
  }
  var sortOrder = function(a4, b) {
    return a4.fx - b.fx;
  };
  var centroid = x05.slice(), reflected = x05.slice(), contracted = x05.slice(), expanded = x05.slice();
  for (var iteration = 0; iteration < maxIterations; ++iteration) {
    simplex.sort(sortOrder);
    if (parameters.history) {
      var sortedSimplex = simplex.map(function(x3) {
        var state = x3.slice();
        state.fx = x3.fx;
        state.id = x3.id;
        return state;
      });
      sortedSimplex.sort(function(a4, b) {
        return a4.id - b.id;
      });
      parameters.history.push({
        x: simplex[0].slice(),
        fx: simplex[0].fx,
        simplex: sortedSimplex
      });
    }
    maxDiff = 0;
    for (i = 0; i < N; ++i) {
      maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
    }
    if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {
      break;
    }
    for (i = 0; i < N; ++i) {
      centroid[i] = 0;
      for (var j = 0; j < N; ++j) {
        centroid[i] += simplex[j][i];
      }
      centroid[i] /= N;
    }
    var worst = simplex[N];
    weightedSum(reflected, 1 + rho, centroid, -rho, worst);
    reflected.fx = f(reflected);
    if (reflected.fx < simplex[0].fx) {
      weightedSum(expanded, 1 + chi, centroid, -chi, worst);
      expanded.fx = f(expanded);
      if (expanded.fx < reflected.fx) {
        updateSimplex(expanded);
      } else {
        updateSimplex(reflected);
      }
    } else if (reflected.fx >= simplex[N - 1].fx) {
      var shouldReduce = false;
      if (reflected.fx > worst.fx) {
        weightedSum(contracted, 1 + psi, centroid, -psi, worst);
        contracted.fx = f(contracted);
        if (contracted.fx < worst.fx) {
          updateSimplex(contracted);
        } else {
          shouldReduce = true;
        }
      } else {
        weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);
        contracted.fx = f(contracted);
        if (contracted.fx < reflected.fx) {
          updateSimplex(contracted);
        } else {
          shouldReduce = true;
        }
      }
      if (shouldReduce) {
        if (sigma >= 1)
          break;
        for (i = 1; i < simplex.length; ++i) {
          weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
          simplex[i].fx = f(simplex[i]);
        }
      }
    } else {
      updateSimplex(reflected);
    }
  }
  simplex.sort(sortOrder);
  return {
    fx: simplex[0].fx,
    x: simplex[0]
  };
}

// node_modules/fmin/src/linesearch.js
function wolfeLineSearch(f, pk, current, next, a4, c1, c22) {
  var phi0 = current.fx, phiPrime0 = dot8(current.fxprime, pk), phi2 = phi0, phi_old = phi0, phiPrime = phiPrime0, a0 = 0;
  a4 = a4 || 1;
  c1 = c1 || 1e-6;
  c22 = c22 || 0.1;
  function zoom(a_lo, a_high, phi_lo) {
    for (var iteration2 = 0; iteration2 < 16; ++iteration2) {
      a4 = (a_lo + a_high) / 2;
      weightedSum(next.x, 1, current.x, a4, pk);
      phi2 = next.fx = f(next.x, next.fxprime);
      phiPrime = dot8(next.fxprime, pk);
      if (phi2 > phi0 + c1 * a4 * phiPrime0 || phi2 >= phi_lo) {
        a_high = a4;
      } else {
        if (Math.abs(phiPrime) <= -c22 * phiPrime0) {
          return a4;
        }
        if (phiPrime * (a_high - a_lo) >= 0) {
          a_high = a_lo;
        }
        a_lo = a4;
        phi_lo = phi2;
      }
    }
    return 0;
  }
  for (var iteration = 0; iteration < 10; ++iteration) {
    weightedSum(next.x, 1, current.x, a4, pk);
    phi2 = next.fx = f(next.x, next.fxprime);
    phiPrime = dot8(next.fxprime, pk);
    if (phi2 > phi0 + c1 * a4 * phiPrime0 || iteration && phi2 >= phi_old) {
      return zoom(a0, a4, phi_old);
    }
    if (Math.abs(phiPrime) <= -c22 * phiPrime0) {
      return a4;
    }
    if (phiPrime >= 0) {
      return zoom(a4, a0, phi2);
    }
    phi_old = phi2;
    a0 = a4;
    a4 *= 2;
  }
  return a4;
}

// node_modules/fmin/src/conjugateGradient.js
function conjugateGradient(f, initial, params) {
  var current = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, next = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, yk = initial.slice(), pk, temp, a4 = 1, maxIterations;
  params = params || {};
  maxIterations = params.maxIterations || initial.length * 20;
  current.fx = f(current.x, current.fxprime);
  pk = current.fxprime.slice();
  scale10(pk, current.fxprime, -1);
  for (var i = 0; i < maxIterations; ++i) {
    a4 = wolfeLineSearch(f, pk, current, next, a4);
    if (params.history) {
      params.history.push({
        x: current.x.slice(),
        fx: current.fx,
        fxprime: current.fxprime.slice(),
        alpha: a4
      });
    }
    if (!a4) {
      scale10(pk, current.fxprime, -1);
    } else {
      weightedSum(yk, 1, next.fxprime, -1, current.fxprime);
      var delta_k = dot8(current.fxprime, current.fxprime), beta_k = Math.max(0, dot8(yk, next.fxprime) / delta_k);
      weightedSum(pk, beta_k, pk, -1, next.fxprime);
      temp = current;
      current = next;
      next = temp;
    }
    if (norm2(current.fxprime) <= 1e-5) {
      break;
    }
  }
  if (params.history) {
    params.history.push({
      x: current.x.slice(),
      fx: current.fx,
      fxprime: current.fxprime.slice(),
      alpha: a4
    });
  }
  return current;
}

// node_modules/@antv/g2/esm/data/utils/venn/circleintersection.js
var SMALL = 1e-10;
function intersectionArea(circles, stats) {
  const intersectionPoints = getIntersectionPoints(circles);
  const innerPoints = intersectionPoints.filter(function(p2) {
    return containedInCircles(p2, circles);
  });
  let arcArea = 0, polygonArea = 0, i;
  const arcs = [];
  if (innerPoints.length > 1) {
    const center2 = getCenter(innerPoints);
    for (i = 0; i < innerPoints.length; ++i) {
      const p3 = innerPoints[i];
      p3.angle = Math.atan2(p3.x - center2.x, p3.y - center2.y);
    }
    innerPoints.sort(function(a4, b) {
      return b.angle - a4.angle;
    });
    let p2 = innerPoints[innerPoints.length - 1];
    for (i = 0; i < innerPoints.length; ++i) {
      const p1 = innerPoints[i];
      polygonArea += (p2.x + p1.x) * (p1.y - p2.y);
      const midPoint2 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      let arc = null;
      for (let j = 0; j < p1.parentIndex.length; ++j) {
        if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
          const circle3 = circles[p1.parentIndex[j]], a1 = Math.atan2(p1.x - circle3.x, p1.y - circle3.y), a22 = Math.atan2(p2.x - circle3.x, p2.y - circle3.y);
          let angleDiff = a22 - a1;
          if (angleDiff < 0) {
            angleDiff += 2 * Math.PI;
          }
          const a4 = a22 - angleDiff / 2;
          let width = distance6(midPoint2, {
            x: circle3.x + circle3.radius * Math.sin(a4),
            y: circle3.y + circle3.radius * Math.cos(a4)
          });
          if (width > circle3.radius * 2) {
            width = circle3.radius * 2;
          }
          if (arc === null || arc.width > width) {
            arc = { circle: circle3, width, p1, p2 };
          }
        }
      }
      if (arc !== null) {
        arcs.push(arc);
        arcArea += circleArea(arc.circle.radius, arc.width);
        p2 = p1;
      }
    }
  } else {
    let smallest = circles[0];
    for (i = 1; i < circles.length; ++i) {
      if (circles[i].radius < smallest.radius) {
        smallest = circles[i];
      }
    }
    let disjoint2 = false;
    for (i = 0; i < circles.length; ++i) {
      if (distance6(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
        disjoint2 = true;
        break;
      }
    }
    if (disjoint2) {
      arcArea = polygonArea = 0;
    } else {
      arcArea = smallest.radius * smallest.radius * Math.PI;
      arcs.push({
        circle: smallest,
        p1: { x: smallest.x, y: smallest.y + smallest.radius },
        p2: { x: smallest.x - SMALL, y: smallest.y + smallest.radius },
        width: smallest.radius * 2
      });
    }
  }
  polygonArea /= 2;
  if (stats) {
    stats.area = arcArea + polygonArea;
    stats.arcArea = arcArea;
    stats.polygonArea = polygonArea;
    stats.arcs = arcs;
    stats.innerPoints = innerPoints;
    stats.intersectionPoints = intersectionPoints;
  }
  return arcArea + polygonArea;
}
function containedInCircles(point7, circles) {
  for (let i = 0; i < circles.length; ++i) {
    if (distance6(point7, circles[i]) > circles[i].radius + SMALL) {
      return false;
    }
  }
  return true;
}
function getIntersectionPoints(circles) {
  const ret = [];
  for (let i = 0; i < circles.length; ++i) {
    for (let j = i + 1; j < circles.length; ++j) {
      const intersect4 = circleCircleIntersection(circles[i], circles[j]);
      for (let k2 = 0; k2 < intersect4.length; ++k2) {
        const p2 = intersect4[k2];
        p2.parentIndex = [i, j];
        ret.push(p2);
      }
    }
  }
  return ret;
}
function circleArea(r, width) {
  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));
}
function distance6(p1, p2) {
  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}
function circleOverlap(r1, r2, d3) {
  if (d3 >= r1 + r2) {
    return 0;
  }
  if (d3 <= Math.abs(r1 - r2)) {
    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
  }
  const w1 = r1 - (d3 * d3 - r2 * r2 + r1 * r1) / (2 * d3), w2 = r2 - (d3 * d3 - r1 * r1 + r2 * r2) / (2 * d3);
  return circleArea(r1, w1) + circleArea(r2, w2);
}
function circleCircleIntersection(p1, p2) {
  const d3 = distance6(p1, p2), r1 = p1.radius, r2 = p2.radius;
  if (d3 >= r1 + r2 || d3 <= Math.abs(r1 - r2)) {
    return [];
  }
  const a4 = (r1 * r1 - r2 * r2 + d3 * d3) / (2 * d3), h = Math.sqrt(r1 * r1 - a4 * a4), x05 = p1.x + a4 * (p2.x - p1.x) / d3, y05 = p1.y + a4 * (p2.y - p1.y) / d3, rx = -(p2.y - p1.y) * (h / d3), ry = -(p2.x - p1.x) * (h / d3);
  return [
    { x: x05 + rx, y: y05 - ry },
    { x: x05 - rx, y: y05 + ry }
  ];
}
function getCenter(points) {
  const center2 = { x: 0, y: 0 };
  for (let i = 0; i < points.length; ++i) {
    center2.x += points[i].x;
    center2.y += points[i].y;
  }
  center2.x /= points.length;
  center2.y /= points.length;
  return center2;
}

// node_modules/@antv/g2/esm/data/utils/venn/layout.js
function venn(areas, parameters) {
  parameters = parameters || {};
  parameters.maxIterations = parameters.maxIterations || 500;
  const initialLayout = parameters.initialLayout || bestInitialLayout;
  const loss = parameters.lossFunction || lossFunction;
  areas = addMissingAreas(areas);
  const circles = initialLayout(areas, parameters);
  const initial = [], setids = [];
  let setid;
  for (setid in circles) {
    if (circles.hasOwnProperty(setid)) {
      initial.push(circles[setid].x);
      initial.push(circles[setid].y);
      setids.push(setid);
    }
  }
  const solution = nelderMead(function(values4) {
    const current = {};
    for (let i = 0; i < setids.length; ++i) {
      const setid2 = setids[i];
      current[setid2] = {
        x: values4[2 * i],
        y: values4[2 * i + 1],
        radius: circles[setid2].radius
      };
    }
    return loss(current, areas);
  }, initial, parameters);
  const positions = solution.x;
  for (let i = 0; i < setids.length; ++i) {
    setid = setids[i];
    circles[setid].x = positions[2 * i];
    circles[setid].y = positions[2 * i + 1];
  }
  return circles;
}
var SMALL2 = 1e-10;
function distanceFromIntersectArea(r1, r2, overlap) {
  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL2) {
    return Math.abs(r1 - r2);
  }
  return bisect2(function(distance7) {
    return circleOverlap(r1, r2, distance7) - overlap;
  }, 0, r1 + r2);
}
function addMissingAreas(areas) {
  areas = areas.slice();
  const ids = [], pairs2 = {};
  let i, j, a4, b;
  for (i = 0; i < areas.length; ++i) {
    const area2 = areas[i];
    if (area2.sets.length == 1) {
      ids.push(area2.sets[0]);
    } else if (area2.sets.length == 2) {
      a4 = area2.sets[0];
      b = area2.sets[1];
      pairs2[[a4, b]] = true;
      pairs2[[b, a4]] = true;
    }
  }
  ids.sort((a5, b2) => {
    return a5 > b2 ? 1 : -1;
  });
  for (i = 0; i < ids.length; ++i) {
    a4 = ids[i];
    for (j = i + 1; j < ids.length; ++j) {
      b = ids[j];
      if (!([a4, b] in pairs2)) {
        areas.push({ sets: [a4, b], size: 0 });
      }
    }
  }
  return areas;
}
function getDistanceMatrices(areas, sets, setids) {
  const distances = zerosM(sets.length, sets.length), constraints = zerosM(sets.length, sets.length);
  areas.filter(function(x3) {
    return x3.sets.length == 2;
  }).map(function(current) {
    const left2 = setids[current.sets[0]], right2 = setids[current.sets[1]], r1 = Math.sqrt(sets[left2].size / Math.PI), r2 = Math.sqrt(sets[right2].size / Math.PI), distance7 = distanceFromIntersectArea(r1, r2, current.size);
    distances[left2][right2] = distances[right2][left2] = distance7;
    let c5 = 0;
    if (current.size + 1e-10 >= Math.min(sets[left2].size, sets[right2].size)) {
      c5 = 1;
    } else if (current.size <= 1e-10) {
      c5 = -1;
    }
    constraints[left2][right2] = constraints[right2][left2] = c5;
  });
  return { distances, constraints };
}
function constrainedMDSGradient(x3, fxprime, distances, constraints) {
  let loss = 0, i;
  for (i = 0; i < fxprime.length; ++i) {
    fxprime[i] = 0;
  }
  for (i = 0; i < distances.length; ++i) {
    const xi = x3[2 * i], yi = x3[2 * i + 1];
    for (let j = i + 1; j < distances.length; ++j) {
      const xj = x3[2 * j], yj = x3[2 * j + 1], dij = distances[i][j], constraint = constraints[i][j];
      const squaredDistance4 = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi), distance7 = Math.sqrt(squaredDistance4), delta = squaredDistance4 - dij * dij;
      if (constraint > 0 && distance7 <= dij || constraint < 0 && distance7 >= dij) {
        continue;
      }
      loss += 2 * delta * delta;
      fxprime[2 * i] += 4 * delta * (xi - xj);
      fxprime[2 * i + 1] += 4 * delta * (yi - yj);
      fxprime[2 * j] += 4 * delta * (xj - xi);
      fxprime[2 * j + 1] += 4 * delta * (yj - yi);
    }
  }
  return loss;
}
function bestInitialLayout(areas, params) {
  let initial = greedyLayout(areas, params);
  const loss = params.lossFunction || lossFunction;
  if (areas.length >= 8) {
    const constrained = constrainedMDSLayout(areas, params), constrainedLoss = loss(constrained, areas), greedyLoss = loss(initial, areas);
    if (constrainedLoss + 1e-8 < greedyLoss) {
      initial = constrained;
    }
  }
  return initial;
}
function constrainedMDSLayout(areas, params) {
  params = params || {};
  const restarts = params.restarts || 10;
  const sets = [], setids = {};
  let i;
  for (i = 0; i < areas.length; ++i) {
    const area2 = areas[i];
    if (area2.sets.length == 1) {
      setids[area2.sets[0]] = sets.length;
      sets.push(area2);
    }
  }
  const matrices = getDistanceMatrices(areas, sets, setids);
  let distances = matrices.distances;
  const constraints = matrices.constraints;
  const norm = norm2(distances.map(norm2)) / distances.length;
  distances = distances.map(function(row2) {
    return row2.map(function(value2) {
      return value2 / norm;
    });
  });
  const obj = function(x3, fxprime) {
    return constrainedMDSGradient(x3, fxprime, distances, constraints);
  };
  let best, current;
  for (i = 0; i < restarts; ++i) {
    const initial = zeros(distances.length * 2).map(Math.random);
    current = conjugateGradient(obj, initial, params);
    if (!best || current.fx < best.fx) {
      best = current;
    }
  }
  const positions = best.x;
  const circles = {};
  for (i = 0; i < sets.length; ++i) {
    const set9 = sets[i];
    circles[set9.sets[0]] = {
      x: positions[2 * i] * norm,
      y: positions[2 * i + 1] * norm,
      radius: Math.sqrt(set9.size / Math.PI)
    };
  }
  if (params.history) {
    for (i = 0; i < params.history.length; ++i) {
      scale10(params.history[i].x, norm);
    }
  }
  return circles;
}
function greedyLayout(areas, params) {
  const loss = params && params.lossFunction ? params.lossFunction : lossFunction;
  const circles = {}, setOverlaps = {};
  let set9;
  for (let i = 0; i < areas.length; ++i) {
    const area2 = areas[i];
    if (area2.sets.length == 1) {
      set9 = area2.sets[0];
      circles[set9] = {
        x: 1e10,
        y: 1e10,
        // rowid: circles.length, // fix to ->
        rowid: Object.keys(circles).length,
        size: area2.size,
        radius: Math.sqrt(area2.size / Math.PI)
      };
      setOverlaps[set9] = [];
    }
  }
  areas = areas.filter(function(a4) {
    return a4.sets.length == 2;
  });
  for (let i = 0; i < areas.length; ++i) {
    const current = areas[i];
    let weight2 = current.hasOwnProperty("weight") ? current.weight : 1;
    const left2 = current.sets[0], right2 = current.sets[1];
    if (current.size + SMALL2 >= Math.min(circles[left2].size, circles[right2].size)) {
      weight2 = 0;
    }
    setOverlaps[left2].push({ set: right2, size: current.size, weight: weight2 });
    setOverlaps[right2].push({ set: left2, size: current.size, weight: weight2 });
  }
  const mostOverlapped = [];
  for (set9 in setOverlaps) {
    if (setOverlaps.hasOwnProperty(set9)) {
      let size3 = 0;
      for (let i = 0; i < setOverlaps[set9].length; ++i) {
        size3 += setOverlaps[set9][i].size * setOverlaps[set9][i].weight;
      }
      mostOverlapped.push({ set: set9, size: size3 });
    }
  }
  function sortOrder(a4, b) {
    return b.size - a4.size;
  }
  mostOverlapped.sort(sortOrder);
  const positioned = {};
  function isPositioned(element) {
    return element.set in positioned;
  }
  function positionSet(point7, index3) {
    circles[index3].x = point7.x;
    circles[index3].y = point7.y;
    positioned[index3] = true;
  }
  positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);
  for (let i = 1; i < mostOverlapped.length; ++i) {
    const setIndex = mostOverlapped[i].set, overlap = setOverlaps[setIndex].filter(isPositioned);
    set9 = circles[setIndex];
    overlap.sort(sortOrder);
    if (overlap.length === 0) {
      throw "ERROR: missing pairwise overlap information";
    }
    const points = [];
    for (let j = 0; j < overlap.length; ++j) {
      const p1 = circles[overlap[j].set], d1 = distanceFromIntersectArea(set9.radius, p1.radius, overlap[j].size);
      points.push({ x: p1.x + d1, y: p1.y });
      points.push({ x: p1.x - d1, y: p1.y });
      points.push({ y: p1.y + d1, x: p1.x });
      points.push({ y: p1.y - d1, x: p1.x });
      for (let k2 = j + 1; k2 < overlap.length; ++k2) {
        const p2 = circles[overlap[k2].set], d22 = distanceFromIntersectArea(set9.radius, p2.radius, overlap[k2].size);
        const extraPoints = circleCircleIntersection({ x: p1.x, y: p1.y, radius: d1 }, { x: p2.x, y: p2.y, radius: d22 });
        for (let l = 0; l < extraPoints.length; ++l) {
          points.push(extraPoints[l]);
        }
      }
    }
    let bestLoss = 1e50, bestPoint = points[0];
    for (let j = 0; j < points.length; ++j) {
      circles[setIndex].x = points[j].x;
      circles[setIndex].y = points[j].y;
      const localLoss = loss(circles, areas);
      if (localLoss < bestLoss) {
        bestLoss = localLoss;
        bestPoint = points[j];
      }
    }
    positionSet(bestPoint, setIndex);
  }
  return circles;
}
function lossFunction(sets, overlaps) {
  let output = 0;
  function getCircles(indices) {
    return indices.map(function(i) {
      return sets[i];
    });
  }
  for (let i = 0; i < overlaps.length; ++i) {
    const area2 = overlaps[i];
    let overlap;
    if (area2.sets.length == 1) {
      continue;
    } else if (area2.sets.length == 2) {
      const left2 = sets[area2.sets[0]], right2 = sets[area2.sets[1]];
      overlap = circleOverlap(left2.radius, right2.radius, distance6(left2, right2));
    } else {
      overlap = intersectionArea(getCircles(area2.sets));
    }
    const weight2 = area2.hasOwnProperty("weight") ? area2.weight : 1;
    output += weight2 * (overlap - area2.size) * (overlap - area2.size);
  }
  return output;
}
function getBoundingBox(circles) {
  const minMax = function(d3) {
    const hi = Math.max.apply(null, circles.map(function(c5) {
      return c5[d3] + c5.radius;
    })), lo = Math.min.apply(null, circles.map(function(c5) {
      return c5[d3] - c5.radius;
    }));
    return { max: hi, min: lo };
  };
  return { xRange: minMax("x"), yRange: minMax("y") };
}
function scaleSolution(solution, width, height, padding) {
  const circles = [], setids = [];
  for (const setid in solution) {
    if (solution.hasOwnProperty(setid)) {
      setids.push(setid);
      circles.push(solution[setid]);
    }
  }
  width -= 2 * padding;
  height -= 2 * padding;
  const bounds = getBoundingBox(circles), xRange = bounds.xRange, yRange = bounds.yRange;
  if (xRange.max == xRange.min || yRange.max == yRange.min) {
    console.log("not scaling solution: zero size detected");
    return solution;
  }
  const xScaling = width / (xRange.max - xRange.min), yScaling = height / (yRange.max - yRange.min), scaling = Math.min(yScaling, xScaling), xOffset = (width - (xRange.max - xRange.min) * scaling) / 2, yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;
  const scaled = {};
  for (let i = 0; i < circles.length; ++i) {
    const circle3 = circles[i];
    scaled[setids[i]] = {
      radius: scaling * circle3.radius,
      x: padding + xOffset + (circle3.x - xRange.min) * scaling,
      y: padding + yOffset + (circle3.y - yRange.min) * scaling
    };
  }
  return scaled;
}

// node_modules/@antv/g2/esm/data/utils/venn/diagram.js
function circlePath(x3, y3, r) {
  const ret = [];
  const x05 = x3 - r;
  const y05 = y3;
  ret.push("M", x05, y05);
  ret.push("A", r, r, 0, 1, 0, x05 + 2 * r, y05);
  ret.push("A", r, r, 0, 1, 0, x05, y05);
  return ret.join(" ");
}
function intersectionAreaPath(circles) {
  const stats = {};
  intersectionArea(circles, stats);
  const arcs = stats.arcs;
  if (arcs.length === 0) {
    return "M 0 0";
  } else if (arcs.length == 1) {
    const circle3 = arcs[0].circle;
    return circlePath(circle3.x, circle3.y, circle3.radius);
  } else {
    const ret = ["\nM", arcs[0].p2.x, arcs[0].p2.y];
    for (let i = 0; i < arcs.length; ++i) {
      const arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;
      ret.push("\nA", r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);
    }
    return ret.join(" ");
  }
}

// node_modules/@antv/g2/esm/data/venn.js
var Venn = (options) => {
  const { sets = "sets", size: size3 = "size", as = ["key", "path"], padding = 0 } = options;
  const [key, path2] = as;
  return (data2) => {
    const vennData = data2.map((d3) => Object.assign(Object.assign({}, d3), { sets: d3[sets], size: d3[size3], [key]: d3.sets.join("&") }));
    vennData.sort((a4, b) => a4.sets.length - b.sets.length);
    const solution = venn(vennData);
    let circles;
    return vennData.map((datum) => {
      const setsValue = datum[sets];
      const pathFunc = ({ width, height }) => {
        circles = circles ? circles : scaleSolution(solution, width, height, padding);
        const setCircles = setsValue.map((set9) => circles[set9]);
        let p2 = intersectionAreaPath(setCircles);
        if (!/[zZ]$/.test(p2))
          p2 += " Z";
        return p2;
      };
      return Object.assign(Object.assign({}, datum), { [path2]: pathFunc });
    });
  };
};
Venn.props = {};

// node_modules/@antv/g2/esm/data/log.js
var Log3 = () => {
  return (data2) => {
    console.log("G2 data section:", data2);
    return data2;
  };
};
Log3.props = {};

// node_modules/@antv/g2/esm/data/ema.js
function ema(values4, alpha) {
  if (alpha < 0 || alpha > 1) {
    throw new Error("alpha must be between 0 and 1.");
  }
  if (values4.length === 0) {
    return [];
  }
  let last5 = values4[0];
  const smoothed = [];
  for (const point7 of values4) {
    if (point7 === null || point7 === void 0) {
      smoothed.push(point7);
      console.warn("EMA：The value is null or undefined", values4);
      continue;
    }
    if (last5 === null || last5 === void 0) {
      last5 = point7;
    }
    const smoothedVal = last5 * alpha + (1 - alpha) * point7;
    smoothed.push(smoothedVal);
    last5 = smoothedVal;
  }
  return smoothed;
}
var EMA = (options) => {
  const { field: field3 = "y", alpha = 0.6, as = field3 } = options;
  return (data2) => {
    const values4 = data2.map((d3) => {
      return d3[field3];
    });
    const out = ema(values4, alpha);
    return data2.map((d3, i) => {
      return Object.assign(Object.assign({}, d3), { [as]: out[i] });
    });
  };
};
EMA.props = {};

// node_modules/@antv/g2/esm/utils/bounds.js
var EPSILON3 = 0.01;
function parseAABB(min22) {
  const { min: min10, max: max11 } = min22;
  return [
    [min10[0], min10[1]],
    [max11[0], max11[1]]
  ];
}
function isInBounds(point7, bounds, threshold = EPSILON3) {
  const [x3, y3] = point7;
  const [min10, max11] = bounds;
  return x3 >= min10[0] - threshold && x3 <= max11[0] + threshold && y3 >= min10[1] - threshold && y3 <= max11[1] + threshold;
}
function isOverflow(b1, b2, threshold = EPSILON3) {
  const [min10, max11] = b1;
  return !(isInBounds(min10, b2, threshold) && isInBounds(max11, b2, threshold));
}
function isOverlap(b1, b2) {
  const [min1, max1] = b1;
  const [min22, max22] = b2;
  return min1[0] < max22[0] && max1[0] > min22[0] && min1[1] < max22[1] && max1[1] > min22[1];
}

// node_modules/@antv/g2/esm/label-transform/overlapHide.js
var OverlapHide = (options) => {
  const { priority } = options;
  return (labels) => {
    const displayLabels = [];
    if (priority)
      labels.sort(priority);
    labels.forEach((l) => {
      show2(l);
      const b1 = l.getLocalBounds();
      const overlaping = displayLabels.some((dl) => isOverlap(parseAABB(b1), parseAABB(dl.getLocalBounds())));
      if (overlaping)
        hide2(l);
      else
        displayLabels.push(l);
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/label-transform/overlapDodgeY.js
function isSegmentIntersect([a4, b], [c5, d3]) {
  return d3 > a4 && b > c5;
}
function useMap() {
  const map5 = /* @__PURE__ */ new Map();
  const get4 = (key) => map5.get(key);
  const set9 = (key, value2) => map5.set(key, value2);
  return [get4, set9];
}
function getBoundsWithoutConnector(shape23) {
  const node = shape23.cloneNode(true);
  const connectorShape = node.getElementById("connector");
  connectorShape && node.removeChild(connectorShape);
  const { min: min10, max: max11 } = node.getRenderBounds();
  node.destroy();
  return { min: min10, max: max11 };
}
var OverlapDodgeY = (options) => {
  const { maxIterations = 10, maxError = 0.1, padding = 1 } = options;
  return (labels) => {
    const n = labels.length;
    if (n <= 1)
      return labels;
    const [y05, setY0] = useMap();
    const [y3, setY] = useMap();
    const [h, setH] = useMap();
    const [xx, setXX] = useMap();
    for (const label of labels) {
      const { min: min10, max: max11 } = getBoundsWithoutConnector(label);
      const [x05, y06] = min10;
      const [x12, y12] = max11;
      setY0(label, y06);
      setY(label, y06);
      setH(label, y12 - y06);
      setXX(label, [x05, x12]);
    }
    for (let iter = 0; iter < maxIterations; iter++) {
      labels.sort((a4, b) => ascending(y3(a4), y3(b)));
      let error3 = 0;
      for (let i = 0; i < n - 1; i++) {
        const l0 = labels[i];
        let j = i + 1;
        let l1;
        while ((l1 = labels[j]) && !isSegmentIntersect(xx(l0), xx(l1)))
          j += 1;
        if (l1) {
          const y06 = y3(l0);
          const h0 = h(l0);
          const y12 = y3(l1);
          const delta = y12 - (y06 + h0);
          if (delta < padding) {
            const newDelta = (padding - delta) / 2;
            error3 = Math.max(error3, newDelta);
            setY(l0, y06 - newDelta);
            setY(l1, y12 + newDelta);
          }
        }
      }
      if (error3 < maxError)
        break;
    }
    for (const label of labels) {
      label.style.y += y3(label) - y05(label);
    }
    return labels;
  };
};

// node_modules/@antv/g2/esm/utils/color.js
function parseToRGB(c5) {
  if (typeof c5 === "object")
    return c5;
  return parseColor(c5);
}

// node_modules/@antv/g2/esm/label-transform/contrastReverse.js
function getsRGB(s3) {
  let c5 = s3 / 255;
  c5 = c5 <= 0.03928 ? c5 / 12.92 : Math.pow((c5 + 0.055) / 1.055, 2.4);
  return c5;
}
function getL(r, g, b) {
  return 0.2126 * getsRGB(r) + 0.7152 * getsRGB(g) + 0.0722 * getsRGB(b);
}
function contrast(foreground, background) {
  if (!foreground || !background || foreground === background)
    return 1;
  const { r, g, b } = foreground;
  const { r: rb, g: gb, b: bb } = background;
  const L1 = getL(r, g, b);
  const L2 = getL(rb, gb, bb);
  return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);
}
function mostContrast(color3, palette) {
  const i = maxIndex(palette, (c5) => contrast(color3, parseToRGB(c5)));
  return palette[i];
}
var ContrastReverse = (options) => {
  const { threshold = 4.5, palette = ["#000", "#fff"] } = options;
  return (labels) => {
    labels.forEach((l) => {
      const background = l.attr("dependentElement").parsedStyle.fill;
      const foreground = l.parsedStyle.fill;
      const c5 = contrast(foreground, background);
      if (c5 < threshold)
        l.attr("fill", mostContrast(background, palette));
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/label-transform/overflowHide.js
var OverflowHide = () => {
  return (labels) => {
    labels.forEach((l) => {
      show2(l);
      const bounds = l.attr("bounds");
      const b = l.getLocalBounds();
      const overflow = isOverflow(parseAABB(b), bounds);
      if (overflow)
        hide2(l);
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/label-transform/exceedAdjust.js
var adjustPosition = (target, edge) => {
  const [[minEdgeX, minEdgeY], [maxEdgeX, maxEdgeY]] = edge;
  const [[minX, minY], [maxX, maxY2]] = target;
  let changeX = 0, changeY = 0;
  if (minX < minEdgeX) {
    changeX = minEdgeX - minX;
  } else if (maxX > maxEdgeX) {
    changeX = maxEdgeX - maxX;
  }
  if (minY < minEdgeY) {
    changeY = minEdgeY - minY;
  } else if (maxY2 > maxEdgeY) {
    changeY = maxEdgeY - maxY2;
  }
  return [changeX, changeY];
};
var ExceedAdjust = () => {
  return (labels, { canvas, layout }) => {
    labels.forEach((l) => {
      show2(l);
      const { max: max11, min: min10 } = l.getRenderBounds();
      const [xMax, yMax] = max11, [xMin, yMin] = min10;
      const changeValue = adjustPosition(
        [
          [xMin, yMin],
          [xMax, yMax]
        ],
        // Prevent label overlap in multiple charts by calculating layouts separately to avoid collisions.
        [
          [layout.x, layout.y],
          [layout.x + layout.width, layout.y + layout.height]
        ]
      );
      if (l.style.connector && l.style.connectorPoints) {
        l.style.connectorPoints[0][0] -= changeValue[0];
        l.style.connectorPoints[0][1] -= changeValue[1];
      }
      l.style.x += changeValue[0];
      l.style.y += changeValue[1];
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/lib/core.js
function corelib() {
  return {
    "data.fetch": Fetch,
    "data.inline": Inline,
    "data.sortBy": SortBy,
    "data.sort": Sort2,
    "data.filter": Filter2,
    "data.pick": Pick,
    "data.rename": Rename,
    "data.fold": Fold,
    "data.slice": Slice,
    "data.custom": Custom,
    "data.map": Map2,
    "data.join": Join,
    "data.kde": KDE,
    "data.log": Log3,
    "data.wordCloud": WordCloud2,
    "data.ema": EMA,
    "transform.stackY": StackY,
    "transform.binX": BinX,
    "transform.bin": Bin,
    "transform.dodgeX": DodgeX,
    "transform.jitter": Jitter,
    "transform.jitterX": JitterX,
    "transform.jitterY": JitterY,
    "transform.symmetryY": SymmetryY,
    "transform.diffY": DiffY,
    "transform.stackEnter": StackEnter,
    "transform.normalizeY": NormalizeY,
    "transform.select": Select,
    "transform.selectX": SelectX,
    "transform.selectY": SelectY,
    "transform.groupX": GroupX,
    "transform.groupY": GroupY,
    "transform.groupColor": GroupColor,
    "transform.group": Group,
    "transform.sortX": SortX,
    "transform.sortY": SortY,
    "transform.sortColor": SortColor,
    "transform.flexX": FlexX,
    "transform.pack": Pack,
    "transform.sample": Sample,
    "transform.filter": Filter,
    "coordinate.cartesian": Cartesian,
    "coordinate.polar": Polar,
    "coordinate.transpose": Transpose,
    "coordinate.theta": Theta,
    "coordinate.parallel": Parallel,
    "coordinate.fisheye": Fisheye,
    "coordinate.radial": Radial,
    "coordinate.radar": Radar,
    "coordinate.helix": Helix,
    "encode.constant": Constant,
    "encode.field": Field,
    "encode.transform": Transform,
    "encode.column": Column,
    "mark.interval": Interval,
    "mark.rect": Rect3,
    "mark.line": Line5,
    "mark.point": Point4,
    "mark.text": Text4,
    "mark.cell": Cell,
    "mark.area": Area2,
    "mark.link": Link2,
    "mark.image": Image4,
    "mark.polygon": Polygon3,
    "mark.box": Box2,
    "mark.vector": Vector2,
    "mark.lineX": LineX,
    "mark.lineY": LineY,
    "mark.connector": Connector2,
    "mark.range": Range2,
    "mark.rangeX": RangeX,
    "mark.rangeY": RangeY,
    "mark.path": Path4,
    "mark.shape": Shape3,
    "mark.density": Density2,
    "mark.heatmap": Heatmap2,
    "mark.wordCloud": WordCloud,
    "palette.category10": Category10,
    "palette.category20": Category20,
    "scale.linear": Linear3,
    "scale.ordinal": Ordinal2,
    "scale.band": Band2,
    "scale.identity": Identity2,
    "scale.point": Point5,
    "scale.time": Time2,
    "scale.log": Log2,
    "scale.pow": Pow2,
    "scale.sqrt": Sqrt2,
    "scale.threshold": Threshold2,
    "scale.quantile": Quantile2,
    "scale.quantize": Quantize2,
    "scale.sequential": Sequential3,
    "scale.constant": Constant3,
    "theme.classic": Classic,
    "theme.classicDark": ClassicDark,
    "theme.academy": Academy,
    "theme.light": Light,
    "theme.dark": Dark,
    "component.axisX": AxisX,
    "component.axisY": AxisY,
    "component.legendCategory": LegendCategory,
    "component.legendContinuous": LegendContinuous,
    "component.legends": Legends,
    "component.title": TitleComponent,
    "component.sliderX": SliderX,
    "component.sliderY": SliderY,
    "component.scrollbarX": ScrollbarX,
    "component.scrollbarY": ScrollbarY,
    "animation.scaleInX": ScaleInX,
    "animation.scaleOutX": ScaleOutX,
    "animation.scaleInY": ScaleInY,
    "animation.scaleOutY": ScaleOutY,
    "animation.waveIn": WaveIn,
    "animation.fadeIn": FadeIn,
    "animation.fadeOut": FadeOut,
    "animation.zoomIn": ZoomIn,
    "animation.zoomOut": ZoomOut,
    "animation.pathIn": PathIn,
    "animation.morphing": Morphing,
    "animation.growInX": GrowInX,
    "animation.growInY": GrowInY,
    "interaction.elementHighlight": ElementHighlight,
    "interaction.elementHighlightByX": ElementHighlightByX,
    "interaction.elementHighlightByColor": ElementHighlightByColor,
    "interaction.elementSelect": ElementSelect,
    "interaction.elementSelectByX": ElementSelectByX,
    "interaction.elementSelectByColor": ElementSelectByColor,
    "interaction.fisheye": Fisheye2,
    "interaction.chartIndex": ChartIndex,
    "interaction.tooltip": Tooltip2,
    "interaction.legendFilter": LegendFilter,
    "interaction.legendHighlight": LegendHighlight,
    "interaction.brushHighlight": BrushHighlight,
    "interaction.brushXHighlight": BrushXHighlight,
    "interaction.brushYHighlight": BrushYHighlight,
    "interaction.brushAxisHighlight": BrushAxisHighlight,
    "interaction.brushFilter": BrushFilter,
    "interaction.brushXFilter": BrushXFilter,
    "interaction.brushYFilter": BrushYFilter,
    "interaction.sliderFilter": SliderFilter,
    "interaction.scrollbarFilter": ScrollbarFilter,
    "interaction.poptip": Poptip2,
    "interaction.treemapDrillDown": TreemapDrillDown,
    "interaction.elementPointMove": ElementPointMove,
    "composition.spaceLayer": SpaceLayer,
    "composition.spaceFlex": SpaceFlex,
    "composition.facetRect": FacetRect,
    "composition.repeatMatrix": RepeatMatrix,
    "composition.facetCircle": FacetCircle,
    "composition.timingKeyframe": TimingKeyframe,
    "labelTransform.overlapHide": OverlapHide,
    "labelTransform.overlapDodgeY": OverlapDodgeY,
    "labelTransform.overflowHide": OverflowHide,
    "labelTransform.contrastReverse": ContrastReverse,
    "labelTransform.exceedAdjust": ExceedAdjust
  };
}

// node_modules/@antv/g2/esm/lib/geo.js
function geolib() {
  return {
    "composition.geoView": GeoView,
    "composition.geoPath": GeoPath
  };
}

// node_modules/@antv/g2/esm/lib/graph.js
function graphlib() {
  return {
    "data.arc": Arc3,
    "data.cluster": Cluster,
    "mark.forceGraph": ForceGraph,
    "mark.tree": Tree2,
    "mark.pack": Pack2,
    "mark.sankey": Sankey3,
    "mark.chord": Chord,
    "mark.treemap": Treemap
  };
}

// node_modules/@antv/g2/esm/lib/plot.js
function plotlib() {
  return {
    "data.venn": Venn,
    "mark.boxplot": Boxplot,
    "mark.gauge": Gauge,
    "mark.wordCloud": WordCloud,
    "mark.liquid": Liquid2
  };
}

// node_modules/@antv/g2/esm/lib/std.js
function stdlib() {
  return Object.assign(Object.assign(Object.assign(Object.assign({}, geolib()), graphlib()), plotlib()), corelib());
}

// node_modules/@antv/g2/esm/api/extend.js
function extend5(Runtime2, library3) {
  class Chart4 extends Runtime2 {
    constructor(options) {
      super(Object.assign(Object.assign({}, options), { lib: library3 }));
    }
  }
  return Chart4;
}

// node_modules/@antv/g2/esm/api/library.js
var library = {};
function register(key, component) {
  if (key.startsWith("symbol."))
    registerSymbol(key.split(".").pop(), component);
  else
    Object.assign(library, { [key]: component });
}

// node_modules/@antv/g2/esm/utils/size.js
var parseInt10 = (d3) => d3 ? parseInt(d3) : 0;
function getContainerSize(container) {
  const style = getComputedStyle(container);
  const wrapperWidth = container.clientWidth || parseInt10(style.width);
  const wrapperHeight = container.clientHeight || parseInt10(style.height);
  const widthPadding = parseInt10(style.paddingLeft) + parseInt10(style.paddingRight);
  const heightPadding = parseInt10(style.paddingTop) + parseInt10(style.paddingBottom);
  return {
    width: wrapperWidth - widthPadding,
    height: wrapperHeight - heightPadding
  };
}

// node_modules/@antv/g2/esm/api/node.js
function bfs(node, callback) {
  const discovered = [node];
  while (discovered.length) {
    const currentNode = discovered.shift();
    callback && callback(currentNode);
    const children = currentNode.children || [];
    for (const child of children) {
      discovered.push(child);
    }
  }
}
var Node4 = class {
  constructor(value2 = {}, type) {
    this.parentNode = null;
    this.children = [];
    this.index = 0;
    this.type = type;
    this.value = value2;
  }
  /**
   * Apply specified transform to current value. Mount the node
   * to replace the original one in the tree and then return it.
   */
  map(transform2 = (x3) => x3) {
    const newValue = transform2(this.value);
    this.value = newValue;
    return this;
  }
  /**
   * Set or get the specified attribute. It the value is specified, update
   * the attribute of current value and return the node. Otherwise
   * return the the attribute of current value.
   */
  attr(key, value2) {
    if (arguments.length === 1)
      return this.value[key];
    return this.map((v) => (v[key] = value2, v));
  }
  /**
   * Create a new node and append to children nodes.
   */
  append(Ctor) {
    const node = new Ctor({});
    node.children = [];
    this.push(node);
    return node;
  }
  push(node) {
    node.parentNode = this;
    node.index = this.children.length;
    this.children.push(node);
    return this;
  }
  /**
   * Remove current node from parentNode.
   */
  remove() {
    const parent = this.parentNode;
    if (parent) {
      const { children } = parent;
      const index3 = children.findIndex((item) => item === this);
      children.splice(index3, 1);
    }
    return this;
  }
  getNodeByKey(key) {
    let targetNode = null;
    const callback = (node) => {
      if (key === node.attr("key")) {
        targetNode = node;
      }
    };
    bfs(this, callback);
    return targetNode;
  }
  getNodesByType(type) {
    const nodes = [];
    const callback = (node) => {
      if (type === node.type) {
        nodes.push(node);
      }
    };
    bfs(this, callback);
    return nodes;
  }
  getNodeByType(type) {
    let node = null;
    bfs(this, (current) => {
      if (node)
        return;
      if (type === current.type)
        node = current;
    });
    return node;
  }
  /**
   * Apply specified callback to the node value.
   */
  call(callback, ...params) {
    callback(this.map(), ...params);
    return this;
  }
  getRoot() {
    let root2 = this;
    while (root2 && root2.parentNode) {
      root2 = root2.parentNode;
    }
    return root2;
  }
};

// node_modules/@antv/g2/esm/api/utils.js
var __rest89 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var VIEW_KEYS = [
  "width",
  "height",
  "depth",
  "padding",
  "paddingLeft",
  "paddingRight",
  "paddingBottom",
  "paddingTop",
  "inset",
  "insetLeft",
  "insetRight",
  "insetTop",
  "insetBottom",
  "margin",
  "marginLeft",
  "marginRight",
  "marginTop",
  "marginBottom",
  "autoFit",
  "theme",
  "title",
  "interaction"
];
var REMOVE_FLAG = "__remove__";
var CALLBACK_NODE = "__callback__";
var MIN_CHART_WIDTH = 1;
var MIN_CHART_HEIGHT = 1;
function normalizeContainer2(container) {
  if (container === void 0) {
    const container2 = document.createElement("div");
    container2[REMOVE_FLAG] = true;
    return container2;
  }
  if (typeof container === "string") {
    const node = document.getElementById(container);
    return node;
  }
  return container;
}
function removeContainer(container) {
  const parent = container.parentNode;
  if (parent) {
    parent.removeChild(container);
  }
}
function normalizeRoot(node) {
  if (node.type !== null)
    return node;
  const root2 = node.children[node.children.length - 1];
  for (const key of VIEW_KEYS)
    root2.attr(key, node.attr(key));
  return root2;
}
function valueOf3(node) {
  return Object.assign(Object.assign({}, node.value), { type: node.type });
}
function sizeOf2(options, container) {
  const { width, height, autoFit, depth = 0 } = options;
  let effectiveWidth = 640;
  let effectiveHeight = 480;
  if (autoFit) {
    const { width: containerWidth, height: containerHeight } = getContainerSize(container);
    effectiveWidth = containerWidth || effectiveWidth;
    effectiveHeight = containerHeight || effectiveHeight;
  }
  effectiveWidth = width || effectiveWidth;
  effectiveHeight = height || effectiveHeight;
  return {
    width: Math.max(isNumber(effectiveWidth) ? effectiveWidth : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
    height: Math.max(isNumber(effectiveHeight) ? effectiveHeight : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT),
    depth
  };
}
function optionsOf(node) {
  const root2 = normalizeRoot(node);
  const discovered = [root2];
  const nodeValue = /* @__PURE__ */ new Map();
  nodeValue.set(root2, valueOf3(root2));
  while (discovered.length) {
    const node2 = discovered.pop();
    const value2 = nodeValue.get(node2);
    const { children = [] } = node2;
    for (const child of children) {
      if (child.type === CALLBACK_NODE) {
        value2.children = child.value;
      } else {
        const childValue = valueOf3(child);
        const { children: children2 = [] } = value2;
        children2.push(childValue);
        discovered.push(child);
        nodeValue.set(child, childValue);
        value2.children = children2;
      }
    }
  }
  return nodeValue.get(root2);
}
function isMark(type, mark2) {
  if (typeof type === "function")
    return true;
  return new Set(Object.keys(mark2)).has(type);
}
function isComposition(type, composition) {
  return typeof type !== "function" && new Set(Object.keys(composition)).has(type);
}
function normalizeRootOptions(node, options, previousType, marks, composition) {
  const { type: oldType } = node;
  const { type = previousType || oldType } = options;
  if (isComposition(type, composition)) {
    for (const key of VIEW_KEYS) {
      if (node.attr(key) !== void 0 && options[key] === void 0) {
        options[key] = node.attr(key);
      }
    }
    return options;
  }
  if (isMark(type, marks)) {
    const view = { type: "view" };
    const mark2 = Object.assign({}, options);
    for (const key of VIEW_KEYS) {
      if (mark2[key] !== void 0) {
        view[key] = mark2[key];
        delete mark2[key];
      }
    }
    return Object.assign(Object.assign({}, view), { children: [mark2] });
  }
  return options;
}
function typeCtor(type, mark2, composition) {
  if (typeof type === "function")
    return mark2.mark;
  const node = Object.assign(Object.assign({}, mark2), composition);
  const ctor = node[type];
  if (!ctor)
    throw new Error(`Unknown mark: ${type}.`);
  return ctor;
}
function createNode(options, mark2, composition) {
  if (typeof options === "function") {
    const node2 = new Node4();
    node2.value = options;
    node2.type = CALLBACK_NODE;
    return node2;
  }
  const { type, children } = options, value2 = __rest89(options, ["type", "children"]);
  const Ctor = typeCtor(type, mark2, composition);
  const node = new Ctor();
  node.value = value2;
  node.type = type;
  return node;
}
function updateNode(node, newOptions) {
  const { type, children } = newOptions, value2 = __rest89(newOptions, ["type", "children"]);
  if (node.type === type || type === void 0) {
    deepAssign(node.value, value2);
  } else if (typeof type === "string") {
    node.type = type;
    node.value = value2;
  }
}
function appendNode(parent, newOptions, mark2, composition) {
  if (!parent)
    return;
  const discovered = [[parent, newOptions]];
  while (discovered.length) {
    const [parent2, nodeOptions] = discovered.shift();
    const node = createNode(nodeOptions, mark2, composition);
    if (Array.isArray(parent2.children))
      parent2.push(node);
    const { children } = nodeOptions;
    if (Array.isArray(children)) {
      for (const child of children) {
        discovered.push([node, child]);
      }
    } else if (typeof children === "function") {
      discovered.push([node, children]);
    }
  }
}
function updateRoot(node, options, definedType, mark2, composition) {
  const rootOptions = normalizeRootOptions(node, options, definedType, mark2, composition);
  const discovered = [[null, node, rootOptions]];
  while (discovered.length) {
    const [parent, oldNode, newNode] = discovered.shift();
    if (!oldNode) {
      appendNode(parent, newNode, mark2, composition);
    } else if (!newNode) {
      oldNode.remove();
    } else {
      updateNode(oldNode, newNode);
      const { children: newChildren } = newNode;
      const { children: oldChildren } = oldNode;
      if (Array.isArray(newChildren) && Array.isArray(oldChildren)) {
        const n = Math.max(newChildren.length, oldChildren.length);
        for (let i = 0; i < n; i++) {
          const newChild = newChildren[i];
          const oldChild = oldChildren[i];
          discovered.push([oldNode, oldChild, newChild]);
        }
      } else if (typeof newChildren === "function") {
        discovered.push([oldNode, null, newChildren]);
      }
    }
  }
}
function createEmptyPromise() {
  let reject;
  let resolve;
  const cloned = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return [cloned, resolve, reject];
}

// node_modules/@antv/g2/esm/api/define.js
function defineValueProp(Node5, name2, { key = name2 }) {
  Node5.prototype[name2] = function(value2) {
    if (arguments.length === 0)
      return this.attr(key);
    return this.attr(key, value2);
  };
}
function defineArrayProp(Node5, name2, { key = name2 }) {
  Node5.prototype[name2] = function(value2) {
    if (arguments.length === 0)
      return this.attr(key);
    if (Array.isArray(value2))
      return this.attr(key, value2);
    const array2 = [...this.attr(key) || [], value2];
    return this.attr(key, array2);
  };
}
function defineObjectProp(Node5, name2, { key: k2 = name2 }) {
  Node5.prototype[name2] = function(key, value2) {
    if (arguments.length === 0)
      return this.attr(k2);
    if (arguments.length === 1 && typeof key !== "string") {
      return this.attr(k2, key);
    }
    const obj = this.attr(k2) || {};
    obj[key] = arguments.length === 1 ? true : value2;
    return this.attr(k2, obj);
  };
}
function defineMixProp(Node5, name2, descriptor) {
  Node5.prototype[name2] = function(key) {
    if (arguments.length === 0)
      return this.attr(name2);
    if (Array.isArray(key))
      return this.attr(name2, { items: key });
    if (isStrictObject(key) && (key.title !== void 0 || key.items !== void 0)) {
      return this.attr(name2, key);
    }
    if (key === null || key === false)
      return this.attr(name2, key);
    const obj = this.attr(name2) || {};
    const { items = [] } = obj;
    items.push(key);
    obj.items = items;
    return this.attr(name2, obj);
  };
}
function defineNodeProp(Node5, name2, { ctor }) {
  Node5.prototype[name2] = function(hocMark) {
    const node = this.append(ctor);
    if (name2 === "mark") {
      node.type = hocMark;
    }
    return node;
  };
}
function defineContainerProp(Node5, name2, { ctor }) {
  Node5.prototype[name2] = function() {
    this.type = null;
    return this.append(ctor);
  };
}
function defineProps(descriptors) {
  return (Node5) => {
    for (const [name2, descriptor] of Object.entries(descriptors)) {
      const { type } = descriptor;
      if (type === "value")
        defineValueProp(Node5, name2, descriptor);
      else if (type === "array")
        defineArrayProp(Node5, name2, descriptor);
      else if (type === "object")
        defineObjectProp(Node5, name2, descriptor);
      else if (type === "node")
        defineNodeProp(Node5, name2, descriptor);
      else if (type === "container")
        defineContainerProp(Node5, name2, descriptor);
      else if (type === "mix")
        defineMixProp(Node5, name2, descriptor);
    }
    return Node5;
  };
}
function nodeProps(node) {
  return Object.fromEntries(Object.entries(node).map(([name2, ctor]) => [name2, { type: "node", ctor }]));
}

// node_modules/@antv/g2/esm/api/props.js
var commonProps = {
  encode: { type: "object" },
  scale: { type: "object" },
  data: { type: "value" },
  transform: { type: "array" },
  style: { type: "object" },
  animate: { type: "object" },
  coordinate: { type: "object" },
  interaction: { type: "object" },
  label: { type: "array", key: "labels" },
  axis: { type: "object" },
  legend: { type: "object" },
  slider: { type: "object" },
  scrollbar: { type: "object" },
  state: { type: "object" },
  layout: { type: "object" },
  theme: { type: "object" },
  title: { type: "value" }
};
var markProps = Object.assign(Object.assign({}, commonProps), { tooltip: { type: "mix" }, viewStyle: { type: "object" } });
var compositionProps = Object.assign(Object.assign({}, commonProps), { labelTransform: { type: "array" } });

// node_modules/@antv/g2/esm/api/composition.js
var __decorate3 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d3 = decorators[i])
        r = (c5 < 3 ? d3(r) : c5 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c5 > 3 && r && Object.defineProperty(target, key, r), r;
};
var CompositionNode = class CompositionNode2 extends Node4 {
  /**
   * Change current node data and its children data.
   */
  changeData(data2) {
    var _a2;
    const chart = this.getRoot();
    if (!chart)
      return;
    this.attr("data", data2);
    if ((_a2 = this.children) === null || _a2 === void 0 ? void 0 : _a2.length) {
      this.children.forEach((child) => {
        child.attr("data", data2);
      });
    }
    return chart === null || chart === void 0 ? void 0 : chart.render();
  }
  /**
   * Get view instance by key.
   */
  getView() {
    const chart = this.getRoot();
    const { views } = chart.getContext();
    if (!(views === null || views === void 0 ? void 0 : views.length))
      return void 0;
    return views.find((view) => view.key === this._key);
  }
  getScale() {
    var _a2;
    return (_a2 = this.getView()) === null || _a2 === void 0 ? void 0 : _a2.scale;
  }
  getScaleByChannel(channel) {
    const scale11 = this.getScale();
    if (scale11)
      return scale11[channel];
    return;
  }
  getCoordinate() {
    var _a2;
    return (_a2 = this.getView()) === null || _a2 === void 0 ? void 0 : _a2.coordinate;
  }
  getTheme() {
    var _a2;
    return (_a2 = this.getView()) === null || _a2 === void 0 ? void 0 : _a2.theme;
  }
  getGroup() {
    const key = this._key;
    if (!key)
      return void 0;
    const chart = this.getRoot();
    const chartGroup = chart.getContext().canvas.getRoot();
    return chartGroup.getElementById(key);
  }
  /**
   * Show the view.
   */
  show() {
    const group3 = this.getGroup();
    if (!group3)
      return;
    !group3.isVisible() && show2(group3);
  }
  /**
   * Hide the view.
   */
  hide() {
    const group3 = this.getGroup();
    if (!group3)
      return;
    group3.isVisible() && hide2(group3);
  }
};
CompositionNode = __decorate3([
  defineProps(compositionProps)
], CompositionNode);

// node_modules/@antv/g2/esm/api/mark.js
var __decorate4 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d3 = decorators[i])
        r = (c5 < 3 ? d3(r) : c5 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c5 > 3 && r && Object.defineProperty(target, key, r), r;
};
var MarkNode = class MarkNode2 extends Node4 {
  changeData(data2) {
    const chart = this.getRoot();
    if (!chart)
      return;
    this.attr("data", data2);
    return chart === null || chart === void 0 ? void 0 : chart.render();
  }
  /**
   * Get mark from chart views.
   */
  getMark() {
    var _a2;
    const chartView = (_a2 = this.getRoot()) === null || _a2 === void 0 ? void 0 : _a2.getView();
    if (!chartView)
      return void 0;
    const { markState } = chartView;
    const markKey = Array.from(markState.keys()).find((item) => item.key === this.attr("key"));
    return markState.get(markKey);
  }
  /**
   * Get all scales instance.
   */
  getScale() {
    var _a2;
    const chartView = (_a2 = this.getRoot()) === null || _a2 === void 0 ? void 0 : _a2.getView();
    if (!chartView)
      return void 0;
    return chartView === null || chartView === void 0 ? void 0 : chartView.scale;
  }
  /**
   * Get the scale instance by channel.
   */
  getScaleByChannel(channel) {
    var _a2, _b;
    const chartView = (_a2 = this.getRoot()) === null || _a2 === void 0 ? void 0 : _a2.getView();
    if (!chartView)
      return void 0;
    return (_b = chartView === null || chartView === void 0 ? void 0 : chartView.scale) === null || _b === void 0 ? void 0 : _b[channel];
  }
  /**
   * Get canvas group.
   */
  getGroup() {
    const key = this.attr("key");
    if (!key)
      return void 0;
    const chart = this.getRoot();
    const chartGroup = chart.getContext().canvas.getRoot();
    return chartGroup.getElementById(key);
  }
};
MarkNode = __decorate4([
  defineProps(markProps)
], MarkNode);

// node_modules/@antv/g2/esm/api/runtime.js
var __decorate5 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d3 = decorators[i])
        r = (c5 < 3 ? d3(r) : c5 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c5 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest90 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var G2_CHART_KEY = "G2_CHART_KEY";
var Runtime = class extends CompositionNode {
  constructor(options) {
    const { container, canvas, renderer, plugins, lib, createCanvas } = options, rest = __rest90(options, ["container", "canvas", "renderer", "plugins", "lib", "createCanvas"]);
    super(rest, "view");
    this._hasBindAutoFit = false;
    this._rendering = false;
    this._trailing = false;
    this._trailingResolve = null;
    this._trailingReject = null;
    this._previousDefinedType = null;
    this._onResize = debounce_default(() => {
      this.forceFit();
    }, 300);
    this._renderer = renderer || new Renderer();
    this._plugins = plugins || [];
    this._container = normalizeContainer2(container);
    this._emitter = new esm_default();
    this._context = {
      library: Object.assign(Object.assign({}, lib), library),
      emitter: this._emitter,
      canvas,
      createCanvas
    };
    this._create();
  }
  render() {
    if (this._rendering)
      return this._addToTrailing();
    if (!this._context.canvas)
      this._createCanvas();
    this._bindAutoFit();
    this._rendering = true;
    const finished = new Promise((resolve2, reject2) => render(this._computedOptions(), this._context, this._createResolve(resolve2), this._createReject(reject2)));
    const [finished1, resolve, reject] = createEmptyPromise();
    finished.then(resolve).catch(reject).then(() => this._renderTrailing());
    return finished1;
  }
  /**
   * @overload
   * @param {G2ViewTree} [options]
   * @returns {Runtime|Spec}
   */
  options(options) {
    if (arguments.length === 0)
      return optionsOf(this);
    const { type } = options;
    if (type)
      this._previousDefinedType = type;
    updateRoot(this, options, this._previousDefinedType, this._marks, this._compositions);
    return this;
  }
  getContainer() {
    return this._container;
  }
  getContext() {
    return this._context;
  }
  on(event, callback, once) {
    this._emitter.on(event, callback, once);
    return this;
  }
  once(event, callback) {
    this._emitter.once(event, callback);
    return this;
  }
  emit(event, ...args) {
    this._emitter.emit(event, ...args);
    return this;
  }
  off(event, callback) {
    this._emitter.off(event, callback);
    return this;
  }
  clear() {
    const options = this.options();
    this.emit(ChartEvent.BEFORE_CLEAR);
    this._reset();
    destroy(options, this._context, false);
    this.emit(ChartEvent.AFTER_CLEAR);
  }
  destroy() {
    const options = this.options();
    this.emit(ChartEvent.BEFORE_DESTROY);
    this._unbindAutoFit();
    this._reset();
    destroy(options, this._context, true);
    if (this._container[REMOVE_FLAG])
      removeContainer(this._container);
    this.emit(ChartEvent.AFTER_DESTROY);
  }
  forceFit() {
    this.options["autoFit"] = true;
    const { width, height } = sizeOf2(this.options(), this._container);
    if (width === this._width && height === this._height) {
      return Promise.resolve(this);
    }
    this.emit(ChartEvent.BEFORE_CHANGE_SIZE);
    const finished = this.render();
    finished.then(() => {
      this.emit(ChartEvent.AFTER_CHANGE_SIZE);
    });
    return finished;
  }
  changeSize(width, height) {
    if (width === this._width && height === this._height) {
      return Promise.resolve(this);
    }
    this.emit(ChartEvent.BEFORE_CHANGE_SIZE);
    this.attr("width", width);
    this.attr("height", height);
    const finished = this.render();
    finished.then(() => {
      this.emit(ChartEvent.AFTER_CHANGE_SIZE);
    });
    return finished;
  }
  _create() {
    const { library: library3 } = this._context;
    const isMark2 = (key) => key.startsWith("mark.") || key === "component.axisX" || key === "component.axisY" || key === "component.legends";
    const marks = [
      "mark.mark",
      ...Object.keys(library3).filter(isMark2)
    ];
    this._marks = {};
    for (const key of marks) {
      const name2 = key.split(".").pop();
      class Mark2 extends MarkNode {
        constructor() {
          super({}, name2);
        }
      }
      this._marks[name2] = Mark2;
      this[name2] = function(composite) {
        const node = this.append(Mark2);
        if (name2 === "mark")
          node.type = composite;
        return node;
      };
    }
    const compositions = [
      "composition.view",
      ...Object.keys(library3).filter((key) => key.startsWith("composition.") && key !== "composition.mark")
    ];
    this._compositions = Object.fromEntries(compositions.map((key) => {
      const name2 = key.split(".").pop();
      let Composition = class Composition extends CompositionNode {
        constructor() {
          super({}, name2);
        }
      };
      Composition = __decorate5([
        defineProps(nodeProps(this._marks))
      ], Composition);
      return [name2, Composition];
    }));
    for (const Ctor of Object.values(this._compositions)) {
      defineProps(nodeProps(this._compositions))(Ctor);
    }
    for (const key of compositions) {
      const name2 = key.split(".").pop();
      this[name2] = function() {
        const Composition = this._compositions[name2];
        this.type = null;
        return this.append(Composition);
      };
    }
  }
  _reset() {
    const KEYS = ["theme", "type", "width", "height", "autoFit"];
    this.type = "view";
    this.value = Object.fromEntries(Object.entries(this.value).filter(([key]) => key.startsWith("margin") || key.startsWith("padding") || key.startsWith("inset") || KEYS.includes(key)));
    this.children = [];
  }
  _renderTrailing() {
    if (!this._trailing)
      return;
    this._trailing = false;
    this.render().then(() => {
      const trailingResolve = this._trailingResolve.bind(this);
      this._trailingResolve = null;
      trailingResolve(this);
    }).catch((error3) => {
      const trailingReject = this._trailingReject.bind(this);
      this._trailingReject = null;
      trailingReject(error3);
    });
  }
  _createResolve(resolve) {
    return () => {
      this._rendering = false;
      resolve(this);
    };
  }
  _createReject(reject) {
    return (error3) => {
      this._rendering = false;
      reject(error3);
    };
  }
  // Update actual size and key.
  _computedOptions() {
    const options = this.options();
    const { key = G2_CHART_KEY } = options;
    const { width, height, depth } = sizeOf2(options, this._container);
    this._width = width;
    this._height = height;
    this._key = key;
    return Object.assign(Object.assign({ key: this._key }, options), { width, height, depth });
  }
  // Create canvas if it does not exist.
  // DragAndDropPlugin is for interaction.
  // It is OK to register more than one time, G will handle this.
  _createCanvas() {
    const { width, height } = sizeOf2(this.options(), this._container);
    this._plugins.push(new Plugin7());
    this._plugins.forEach((d3) => this._renderer.registerPlugin(d3));
    this._context.canvas = new Canvas({
      container: this._container,
      width,
      height,
      renderer: this._renderer
    });
  }
  _addToTrailing() {
    var _a2;
    (_a2 = this._trailingResolve) === null || _a2 === void 0 ? void 0 : _a2.call(this, this);
    this._trailing = true;
    const promise = new Promise((resolve, reject) => {
      this._trailingResolve = resolve;
      this._trailingReject = reject;
    });
    return promise;
  }
  _bindAutoFit() {
    const options = this.options();
    const { autoFit } = options;
    if (this._hasBindAutoFit) {
      if (!autoFit)
        this._unbindAutoFit();
      return;
    }
    if (autoFit) {
      this._hasBindAutoFit = true;
      window.addEventListener("resize", this._onResize);
    }
  }
  _unbindAutoFit() {
    if (this._hasBindAutoFit) {
      this._hasBindAutoFit = false;
      window.removeEventListener("resize", this._onResize);
    }
  }
};

// node_modules/@antv/g2/esm/api/chart.js
var Chart = extend5(Runtime, library);

// node_modules/@antv/g2/esm/index.js
var library2 = Object.assign({}, stdlib());
var Chart2 = extend5(Runtime, library2);

// node_modules/@ant-design/charts-util/es/react/render.js
var ReactDOM = __toESM(require_react_dom());
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var fullClone = __assign2({}, ReactDOM);
var version = fullClone.version;
var reactRender = fullClone.render;
var unmountComponentAtNode = fullClone.unmountComponentAtNode;
var createRoot;
try {
  mainVersion = Number((version || "").split(".")[0]);
  if (mainVersion >= 18) {
    createRoot = fullClone.createRoot;
  }
} catch (e) {
}
var mainVersion;
function toggleWarning(skip) {
  var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && typeof __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === "object") {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
  }
}
var MARK = "__rc_react_root__";
function modernRender(node, container) {
  toggleWarning(true);
  var root2 = container[MARK] || createRoot(container);
  toggleWarning(false);
  root2.render(node);
  container[MARK] = root2;
}
function legacyRender(node, container) {
  reactRender(node, container);
}
function render2(node, container) {
  if (createRoot) {
    modernRender(node, container);
    return;
  }
  legacyRender(node, container);
}

// node_modules/@ant-design/charts-util/es/rc/create-node.js
var mountMapping = /* @__PURE__ */ new Map();
if (typeof document !== "undefined") {
  mountMapping.set("tooltip", document.createElement("div"));
}
var createNode2 = function(children, isTooltip) {
  if (isTooltip === void 0) {
    isTooltip = false;
  }
  var mount = null;
  if (isTooltip) {
    mount = mountMapping.get("tooltip");
  } else {
    mount = document.createElement("div");
    if (children === null || children === void 0 ? void 0 : children.key) {
      var exist = mountMapping.get(children.key);
      if (exist) {
        mount = exist;
      } else {
        mountMapping.set(children.key, mount);
      }
    }
  }
  render2(children, mount);
  return mount;
};

// node_modules/@ant-design/charts-util/es/rc/chart-loading.js
var import_react = __toESM(require_react());
var shadowLoading = function(ele) {
  if (typeof document === "undefined") {
    return "loading";
  }
  var shadowRoot = ele.attachShadow({ mode: "open" });
  var shadowDiv = document.createElement("div");
  var shadowStyle = document.createElement("style");
  shadowStyle.innerHTML = ".loading {\n    display: inline-block;\n    position: relative;\n    width: 80px;\n    height: 80px;\n  }\n  .loading div {\n    position: absolute;\n    top: 33px;\n    width: 13px;\n    height: 13px;\n    border-radius: 50%;\n    background: #ccc;\n    animation-timing-function: cubic-bezier(0, 1, 1, 0);\n  }\n  .loading div:nth-child(1) {\n    left: 8px;\n    animation: loading1 0.6s infinite;\n  }\n  .loading div:nth-child(2) {\n    left: 8px;\n    animation: loading2 0.6s infinite;\n  }\n  .loading div:nth-child(3) {\n    left: 32px;\n    animation: loading2 0.6s infinite;\n  }\n  .loading div:nth-child(4) {\n    left: 56px;\n    animation: loading3 0.6s infinite;\n  }\n  @keyframes loading1 {\n    0% {\n      transform: scale(0);\n    }\n    100% {\n      transform: scale(1);\n    }\n  }\n  @keyframes loading3 {\n    0% {\n      transform: scale(1);\n    }\n    100% {\n      transform: scale(0);\n    }\n  }\n  @keyframes loading2 {\n    0% {\n      transform: translate(0, 0);\n    }\n    100% {\n      transform: translate(24px, 0);\n    }\n  }\n  ";
  shadowDiv.classList.add("loading");
  shadowDiv.innerHTML = "<div></div><div></div><div></div><div></div>";
  shadowRoot.appendChild(shadowStyle);
  shadowRoot.appendChild(shadowDiv);
};
var ChartLoading = function(_a2) {
  var loadingTemplate = _a2.loadingTemplate, _b = _a2.theme, theme = _b === void 0 ? "light" : _b;
  var shadow = import_react.default.useRef(null);
  import_react.default.useEffect(function() {
    if (!loadingTemplate && shadow.current) {
      shadowLoading(shadow.current);
    }
  }, []);
  var renderLoading = function() {
    if (loadingTemplate)
      return loadingTemplate;
    return import_react.default.createElement("div", { ref: shadow });
  };
  return import_react.default.createElement("div", { className: "charts-loading-container", style: {
    position: "absolute",
    width: "100%",
    height: "100%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    left: 0,
    top: 0,
    zIndex: 99,
    backgroundColor: theme === "dark" ? "rgb(20, 20, 20)" : "rgb(255, 255, 255)"
  } }, renderLoading());
};

// node_modules/@ant-design/charts-util/es/rc/error-boundary.js
var import_react2 = __toESM(require_react());
var __extends2 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ErrorBoundary = (
  /** @class */
  function(_super) {
    __extends2(ErrorBoundary2, _super);
    function ErrorBoundary2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.state = {
        hasError: false
      };
      _this2.renderError = function(e) {
        var errorTemplate = _this2.props.errorTemplate;
        switch (e) {
          default:
            if (typeof errorTemplate === "function")
              return errorTemplate(e);
            return errorTemplate ? errorTemplate : import_react2.default.createElement(
              "h5",
              null,
              "组件出错了，请核查后重试： ",
              e.message
            );
        }
      };
      return _this2;
    }
    ErrorBoundary2.getDerivedStateFromError = function(error3) {
      return { hasError: true, error: error3 };
    };
    ErrorBoundary2.getDerivedStateFromProps = function(nextProps, state) {
      if (state.children !== nextProps.children) {
        return {
          children: nextProps.children,
          hasError: false,
          error: void 0
        };
      }
      return null;
    };
    ErrorBoundary2.prototype.render = function() {
      if (this.state.hasError) {
        return this.renderError(this.state.error);
      }
      return import_react2.default.createElement(import_react2.Fragment, null, this.props.children);
    };
    return ErrorBoundary2;
  }(import_react2.default.Component)
);

// node_modules/@ant-design/charts-util/es/utils/measure-text.js
var import_lodash2 = __toESM(require_lodash());

// node_modules/@ant-design/charts-util/es/utils/context.js
var ctx3;
var getCanvasContext = function() {
  if (!ctx3) {
    ctx3 = document.createElement("canvas").getContext("2d");
  }
  return ctx3;
};

// node_modules/@ant-design/charts-util/es/utils/measure-text.js
var __spreadArray6 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var measureText = (0, import_lodash2.memoize)(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, _a2 = font.fontFamily, fontFamily = _a2 === void 0 ? "sans-serif" : _a2, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  var ctx4 = getCanvasContext();
  ctx4.font = [fontStyle, fontWeight, fontVariant, "".concat(fontSize, "px"), fontFamily].join(" ");
  return ctx4.measureText((0, import_lodash2.isString)(text) ? text : "");
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArray6([text], (0, import_lodash2.values)(font), true).join("");
});
var measureTextWidth2 = function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return measureText(text, font).width;
};

// node_modules/@ant-design/plots/es/components/base/index.js
var import_react4 = __toESM(require_react());

// node_modules/@ant-design/plots/es/hooks/useChart.js
var import_react3 = __toESM(require_react());

// node_modules/@ant-design/plots/es/util/index.js
var import_lodash3 = __toESM(require_lodash());

// node_modules/@ant-design/plots/es/util/is-valid-element.js
var isValidElement = function(jsxCode) {
  var jsxRegex = /react|\.jsx|children:\[\(|return\s+[A-Za-z0-9].createElement\((?!['"][g|circle|ellipse|image|rect|line|polyline|polygon|text|path|html|mesh]['"])([^\)])*,/i;
  return jsxRegex.test(jsxCode);
};

// node_modules/@ant-design/plots/es/hooks/useChart.js
var __assign3 = function() {
  __assign3 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
function useChart(ChartClass, config) {
  var chart = (0, import_react3.useRef)();
  var chartOptions = (0, import_react3.useRef)();
  var container = (0, import_react3.useRef)(null);
  var onReady = config.onReady, onEvent = config.onEvent;
  var toDataURL = function(type, encoderOptions) {
    var _a2;
    if (type === void 0) {
      type = "image/png";
    }
    var canvas = (_a2 = container.current) === null || _a2 === void 0 ? void 0 : _a2.getElementsByTagName("canvas")[0];
    return canvas === null || canvas === void 0 ? void 0 : canvas.toDataURL(type, encoderOptions);
  };
  var downloadImage = function(name2, type, encoderOptions) {
    if (name2 === void 0) {
      name2 = "download";
    }
    if (type === void 0) {
      type = "image/png";
    }
    var imageName = name2;
    if (name2.indexOf(".") === -1) {
      imageName = "".concat(name2, ".").concat(type.split("/")[1]);
    }
    var base64 = toDataURL(type, encoderOptions);
    var a4 = document.createElement("a");
    a4.href = base64;
    a4.download = imageName;
    document.body.appendChild(a4);
    a4.click();
    document.body.removeChild(a4);
    a4 = null;
    return imageName;
  };
  var processConfig = function(cfg, flag) {
    if (flag === void 0) {
      flag = false;
    }
    var keys2 = Object.keys(cfg);
    var isTooltip = flag;
    keys2.forEach(function(key) {
      var current = cfg[key];
      if (key === "tooltip") {
        isTooltip = true;
      }
      if ((0, import_lodash3.isFunction)(current) && isValidElement("".concat(current))) {
        cfg[key] = function() {
          var arg = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            arg[_i] = arguments[_i];
          }
          return createNode2(current.apply(void 0, arg), isTooltip);
        };
      } else {
        if ((0, import_lodash3.isArray)(current)) {
          current.forEach(function(item) {
            processConfig(item, isTooltip);
          });
        } else if ((0, import_lodash3.isObject)(current)) {
          processConfig(current, isTooltip);
        } else {
          isTooltip = flag;
        }
      }
    });
  };
  (0, import_react3.useEffect)(function() {
    if (chart.current && !(0, import_lodash3.isEqual)(chartOptions.current, config)) {
      chartOptions.current = (0, import_lodash3.cloneDeep)(config);
      processConfig(config);
      chart.current.update(config);
      chart.current.render();
    }
  }, [config]);
  (0, import_react3.useEffect)(function() {
    if (!container.current) {
      return function() {
        return null;
      };
    }
    if (!chartOptions.current) {
      chartOptions.current = (0, import_lodash3.cloneDeep)(config);
    }
    processConfig(config);
    var chartInstance = new ChartClass(container.current, __assign3({}, config));
    chartInstance.toDataURL = toDataURL;
    chartInstance.downloadImage = downloadImage;
    chartInstance.render();
    chart.current = chartInstance;
    if (onReady) {
      onReady(chartInstance);
    }
    var handler = function(event) {
      if (onEvent) {
        onEvent(chartInstance, event);
      }
    };
    chartInstance.on("*", handler);
    return function() {
      if (chart.current) {
        chart.current.destroy();
        chart.current.off("*", handler);
        chart.current = void 0;
      }
    };
  }, []);
  return {
    chart,
    container
  };
}

// node_modules/@antv/g2-extension-plot/esm/utils/hierarchy/partition.js
var DEFAULT_OPTIONS6 = {
  field: "value",
  size: [1, 1],
  // width, height
  round: false,
  padding: 0,
  // Default desc.
  sort: (a4, b) => b.value - a4.value,
  as: ["x", "y"],
  // Whether to ignore parentValue. When set to true, the weight of the parent node is determined by the child element.
  ignoreParentValue: true
};
var NODE_INDEX_FIELD = "nodeIndex";
var CHILD_NODE_COUNT = "childNodeCount";
var NODE_ANCESTORS_FIELD = "nodeAncestor";
var INVALID_FIELD_ERR_MSG = "Invalid field: it must be a string!";
function getField(options, defaultField) {
  const { field: field3, fields } = options;
  if (isString(field3)) {
    return field3;
  }
  if (isArray(field3)) {
    console.warn(INVALID_FIELD_ERR_MSG);
    return field3[0];
  }
  console.warn(`${INVALID_FIELD_ERR_MSG} will try to get fields instead.`);
  if (isString(fields)) {
    return fields;
  }
  if (isArray(fields) && fields.length) {
    return fields[0];
  }
  if (defaultField) {
    return defaultField;
  }
  throw new TypeError(INVALID_FIELD_ERR_MSG);
}
function getAllNodes(root2) {
  const nodes = [];
  if (root2 && root2.each) {
    let parent;
    let index3;
    root2.each((node) => {
      var _a2, _b;
      if (node.parent !== parent) {
        parent = node.parent;
        index3 = 0;
      } else {
        index3 += 1;
      }
      const ancestors = filter_default((((_a2 = node.ancestors) === null || _a2 === void 0 ? void 0 : _a2.call(node)) || []).map((d3) => nodes.find((n) => n.name === d3.name) || d3), ({ depth }) => depth > 0 && depth < node.depth);
      node[NODE_ANCESTORS_FIELD] = ancestors;
      node[CHILD_NODE_COUNT] = ((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) || 0;
      node[NODE_INDEX_FIELD] = index3;
      nodes.push(node);
    });
  } else if (root2 && root2.eachNode) {
    root2.eachNode((node) => {
      nodes.push(node);
    });
  }
  return nodes;
}
function partition(data2, options) {
  options = mix({}, DEFAULT_OPTIONS6, options);
  const as = options.as;
  if (!isArray(as) || as.length !== 2) {
    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
  }
  let field3;
  try {
    field3 = getField(options);
  } catch (e) {
    console.warn(e);
  }
  const partition2 = (data3) => partition_default().size(options.size).round(options.round).padding(options.padding)(
    /**
     * The sum function must be specified in the d3Hierarchy layout to compute node values by calling the specified value function
     * from the current node in post-order traversal order for the current node and for each descendant node and returning the current node.
     * for example:
     * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}.
     * The computed value obtained by the parent is sum(node(parent)) + sum(node(child1)) + sum(node(child2)).
     * In the sum function, d is the data passed in by the user and children is the reserved field.
     */
    hierarchy(data3).sum((d3) => size(d3.children) ? options.ignoreParentValue ? 0 : d3[field3] - reduce_default(d3.children, (a4, b) => a4 + b[field3], 0) : d3[field3]).sort(options.sort)
  );
  const root2 = partition2(data2);
  const x3 = as[0];
  const y3 = as[1];
  root2.each((node) => {
    var _a2, _b;
    node[x3] = [node.x0, node.x1, node.x1, node.x0];
    node[y3] = [node.y1, node.y1, node.y0, node.y0];
    node.name = node.name || ((_a2 = node.data) === null || _a2 === void 0 ? void 0 : _a2.name) || ((_b = node.data) === null || _b === void 0 ? void 0 : _b.label);
    node.data.name = node.name;
    ["x0", "x1", "y0", "y1"].forEach((prop) => {
      if (as.indexOf(prop) === -1) {
        delete node[prop];
      }
    });
  });
  return getAllNodes(root2);
}

// node_modules/@antv/g2-extension-plot/esm/mark/sunburst.js
var __rest91 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var SUNBURST_TYPE = "sunburst";
var SUNBURST_TYPE_FIELD = "markType";
var SUNBURST_PATH_FIELD = "path";
var SUNBURST_ANCESTOR_FIELD = "ancestor-node";
function transformData(options) {
  const { data: data2, encode } = options;
  const { color: color3, value: value2 } = encode;
  const type = "partition";
  const nodes = partition(data2, {
    field: value2,
    // @ts-ignore
    type: `hierarchy.${type}`,
    as: ["x", "y"]
  });
  const result = [];
  nodes.forEach((node) => {
    var _a2, _b, _c, _d;
    if (node.depth === 0) {
      return null;
    }
    let path2 = node.data.name;
    const pathList = [path2];
    let ancestorNode = Object.assign({}, node);
    while (ancestorNode.depth > 1) {
      path2 = `${(_a2 = ancestorNode.parent.data) === null || _a2 === void 0 ? void 0 : _a2.name} / ${path2}`;
      pathList.unshift((_b = ancestorNode.parent.data) === null || _b === void 0 ? void 0 : _b.name);
      ancestorNode = ancestorNode.parent;
    }
    const nodeInfo = Object.assign(Object.assign(Object.assign({}, pick_default(node.data, [value2])), { [SUNBURST_PATH_FIELD]: path2, [SUNBURST_ANCESTOR_FIELD]: ancestorNode.data.name }), node);
    if (color3 && color3 !== SUNBURST_ANCESTOR_FIELD) {
      nodeInfo[color3] = node.data[color3] || ((_d = (_c = node.parent) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[color3]);
    }
    result.push(nodeInfo);
  });
  return result.map((d3) => {
    const x3 = d3.x.slice(0, 2);
    const y3 = [d3.y[2], d3.y[0]];
    if (x3[0] === x3[1]) {
      y3[0] = y3[1] = (d3.y[2] + d3.y[0]) / 2;
    }
    return Object.assign(Object.assign({}, d3), {
      x: x3,
      y: y3,
      fillOpacity: Math.pow(0.85, d3.depth)
    });
  });
}
var DEFAULT_OPTIONS7 = {
  id: SUNBURST_TYPE,
  encode: {
    x: "x",
    y: "y",
    key: SUNBURST_PATH_FIELD,
    color: SUNBURST_ANCESTOR_FIELD,
    value: "value"
  },
  axis: { x: false, y: false },
  style: {
    [SUNBURST_TYPE_FIELD]: SUNBURST_TYPE,
    stroke: "#fff",
    lineWidth: 0.5,
    fillOpacity: "fillOpacity",
    [CHILD_NODE_COUNT]: CHILD_NODE_COUNT,
    depth: "depth"
  },
  state: {
    active: { zIndex: 2, stroke: "#000" },
    inactive: { zIndex: 1, stroke: "#fff" }
  },
  legend: false,
  interaction: { drillDown: true },
  coordinate: {
    type: "polar",
    innerRadius: 0.2
  }
};
var Sunburst = (options) => {
  const { encode: encodeOption, data: data2 = [], legend } = options, resOptions = __rest91(options, ["encode", "data", "legend"]);
  const coordinate = Object.assign(Object.assign({}, resOptions.coordinate), {
    // Reac Bug InnerRadius = 0.
    innerRadius: Math.max(get_default(resOptions, ["coordinate", "innerRadius"], 0.2), 1e-5)
  });
  const encode = Object.assign(Object.assign({}, DEFAULT_OPTIONS7.encode), encodeOption);
  const { value: value2 } = encode;
  const rectData = transformData({ encode, data: data2 });
  console.log(rectData, "rectData");
  return [
    deep_mix_default({}, DEFAULT_OPTIONS7, Object.assign(Object.assign({ type: "rect", data: rectData, encode, tooltip: {
      title: "path",
      items: [
        (d3) => {
          return {
            name: value2,
            value: d3[value2]
          };
        }
      ]
    } }, resOptions), { coordinate }))
  ];
};
Sunburst.props = {};

// node_modules/@antv/g2-extension-plot/esm/interaction/drillDown.js
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getElementsSunburst = (plot2) => {
  return plot2.querySelectorAll(".element").filter((item) => get_default(item, ["style", SUNBURST_TYPE_FIELD]) === SUNBURST_TYPE);
};
function selectPlotArea3(root2) {
  return select(root2).select(`.${PLOT_CLASS_NAME}`).node();
}
var DEFAULT_BREADCRUMB = {
  rootText: "root",
  style: {
    fill: "rgba(0, 0, 0, 0.85)",
    fontSize: 12,
    y: 1
  },
  active: {
    fill: "rgba(0, 0, 0, 0.5)"
  }
};
function DrillDown(drillDownOptions = {}) {
  const { breadCrumb: textConfig = {}, isFixedColor = false } = drillDownOptions;
  const breadCrumb = deep_mix_default({}, DEFAULT_BREADCRUMB, textConfig);
  return (context) => {
    const { update: update2, setState, container, view, options } = context;
    const document2 = container.ownerDocument;
    const plotArea = selectPlotArea3(container);
    const sunburstMark = options.marks.find(({ id: id4 }) => id4 === SUNBURST_TYPE);
    const { state } = sunburstMark;
    const textGroup = document2.createElement("g");
    plotArea.appendChild(textGroup);
    const drillDownClick = (path2, depth) => __awaiter15(this, void 0, void 0, function* () {
      textGroup.removeChildren();
      if (path2) {
        const rootText = document2.createElement("text", {
          style: Object.assign({
            x: 0,
            text: breadCrumb.rootText,
            // @ts-ignore
            depth: 0
          }, breadCrumb.style)
        });
        textGroup.appendChild(rootText);
        let name2 = "";
        const pathArray = path2 === null || path2 === void 0 ? void 0 : path2.split(" / ");
        let y3 = breadCrumb.style.y;
        let x3 = textGroup.getBBox().width;
        const maxWidth = plotArea.getBBox().width;
        const drillTexts = pathArray.map((text, index3) => {
          const textSeparator = document2.createElement("text", {
            style: Object.assign(Object.assign({ x: x3, text: " / " }, breadCrumb.style), { y: y3 })
          });
          textGroup.appendChild(textSeparator);
          x3 += textSeparator.getBBox().width;
          name2 = `${name2}${text} / `;
          const drillText = document2.createElement("text", {
            name: name2.replace(/\s\/\s$/, ""),
            style: Object.assign(Object.assign({
              text,
              x: x3,
              // @ts-ignore
              depth: index3 + 1
            }, breadCrumb.style), { y: y3 })
          });
          textGroup.appendChild(drillText);
          x3 += drillText.getBBox().width;
          if (x3 > maxWidth) {
            y3 = textGroup.getBBox().height;
            x3 = 0;
            textSeparator.attr({
              x: x3,
              y: y3
            });
            x3 += textSeparator.getBBox().width;
            drillText.attr({
              x: x3,
              y: y3
            });
            x3 += drillText.getBBox().width;
          }
          return drillText;
        });
        [rootText, ...drillTexts].forEach((item, index3) => {
          if (index3 === drillTexts.length)
            return;
          const originalAttrs = Object.assign({}, item.attributes);
          item.attr("cursor", "pointer");
          item.addEventListener("mouseenter", () => {
            item.attr(breadCrumb.active);
          });
          item.addEventListener("mouseleave", () => {
            item.attr(originalAttrs);
          });
          item.addEventListener("click", () => {
            drillDownClick(item.name, get_default(item, ["style", "depth"]));
          });
        });
      }
      setState("drillDown", (viewOptions) => {
        const { marks } = viewOptions;
        const newMarks = marks.map((mark2) => {
          if (mark2.id !== SUNBURST_TYPE && mark2.type !== "rect")
            return mark2;
          const { data: data2 } = mark2;
          const newScale = Object.fromEntries(["color"].map((channel) => [channel, { domain: view.scale[channel].getOptions().domain }]));
          const newData = data2.filter((item) => {
            const key = item.path;
            if (!isFixedColor) {
              item[SUNBURST_ANCESTOR_FIELD] = key.split(" / ")[depth];
            }
            if (!path2)
              return true;
            const reg = new RegExp(`^${path2}.+`);
            return reg.test(key);
          });
          return deep_mix_default({}, mark2, isFixedColor ? {
            data: newData,
            scale: newScale
          } : {
            data: newData
          });
        });
        return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
      });
      yield update2();
    });
    const createDrillClick = (e) => {
      const item = e.target;
      if (get_default(item, ["style", SUNBURST_TYPE_FIELD]) !== SUNBURST_TYPE || get_default(item, ["markType"]) !== "rect" || !get_default(item, ["style", CHILD_NODE_COUNT]))
        return;
      const path2 = get_default(item, ["__data__", "key"]);
      const depth = get_default(item, ["style", "depth"]);
      item.style.cursor = "pointer";
      drillDownClick(path2, depth);
    };
    plotArea.addEventListener("click", createDrillClick);
    const changeStyleKey = keys_default(Object.assign(Object.assign({}, state.active), state.inactive));
    const createActive = () => {
      const elements = getElementsSunburst(plotArea);
      elements.forEach((element) => {
        const childNodeCount = get_default(element, ["style", CHILD_NODE_COUNT]);
        const cursor = get_default(element, ["style", "cursor"]);
        if (cursor !== "pointer" && childNodeCount) {
          element.style.cursor = "pointer";
          const originalAttrs = pick_default(element.attributes, changeStyleKey);
          element.addEventListener("mouseenter", () => {
            element.attr(state.active);
          });
          element.addEventListener("mouseleave", () => {
            element.attr(deep_mix_default(originalAttrs, state.inactive));
          });
        }
      });
    };
    plotArea.addEventListener("mousemove", createActive);
    return () => {
      textGroup.remove();
      plotArea.removeEventListener("click", createDrillClick);
      plotArea.removeEventListener("mousemove", createActive);
    };
  };
}

// node_modules/@antv/g2-extension-plot/esm/lib.js
function plotlib2() {
  return {
    "interaction.drillDown": DrillDown,
    "mark.sunburst": Sunburst
  };
}

// node_modules/@ant-design/plots/es/core/base/chart.js
var __assign4 = function() {
  __assign4 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign4.apply(this, arguments);
};
var Chart3 = extend5(Runtime, __assign4(__assign4({}, stdlib()), plotlib2()));

// node_modules/@ant-design/plots/es/core/utils/index.js
var import_lodash4 = __toESM(require_lodash());

// node_modules/@ant-design/plots/es/core/utils/transform.js
var transformOptions = function(params) {
  var options = filterTransformed(params);
  var _a2 = options.children, children = _a2 === void 0 ? [] : _a2;
  var rest = (0, import_lodash4.omit)(options, [].concat(VIEW_OPTIONS, CONFIG_SHAPE.map(function(item) {
    return item.key;
  })));
  var getCustomTransform = function(key) {
    var _a3;
    return (_a3 = SPECIAL_OPTIONS.find(function(option) {
      return option.key === key;
    })) === null || _a3 === void 0 ? void 0 : _a3.callback;
  };
  var updateOptions = function(origin, key, value2) {
    var callback = getCustomTransform(key);
    if (callback) {
      callback(origin, key, value2);
    } else {
      origin[key] = mergeWithArrayCoverage({}, origin[key], value2);
    }
  };
  var transformShape = function(config) {
    Object.keys(config).forEach(function(key) {
      if (!config[key])
        return;
      var exist = CONFIG_SHAPE.find(function(item) {
        return item.key === key;
      });
      if (exist) {
        var type = exist.type, extend_keys = exist.extend_keys;
        if (type) {
          children.push(transformConfig(mergeWithArrayCoverage({}, (0, import_lodash4.pick)(config, extend_keys), { type }, config[key])));
        } else {
          if ((0, import_lodash4.isArray)(config[key])) {
            config[key].forEach(function(annotation) {
              children.push(transformConfig(annotation));
            });
          }
        }
      }
    });
  };
  var transformConfig = function(config) {
    transformShape(config);
    Object.keys(TRANSFORM_OPTION_KEY).forEach(function(key) {
      var transformTarget = TRANSFORM_OPTION_KEY[key];
      if (!(0, import_lodash4.isUndefined)(config[key])) {
        if ((0, import_lodash4.isObject)(transformTarget)) {
          var value2 = transformTarget.value, target = transformTarget.target;
          var transformValue = value2(config[key]);
          updateOptions(config, target, transformValue);
        } else {
          (0, import_lodash4.set)(config, transformTarget, config[key]);
        }
      }
    });
    return config;
  };
  children.forEach(function(child) {
    var config = mergeWithArrayCoverage({}, rest, child);
    transformConfig(mergeWithArrayCoverage(child, config));
  });
  transformShape(options);
  deleteExcessKeys(options);
  return params;
};

// node_modules/@ant-design/plots/es/core/utils/delete-excess-keys.js
var __spreadArray7 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var deleteExcessKeys = function(options) {
  var _a2 = options.children, children = _a2 === void 0 ? [] : _a2;
  var deleteKeys = Object.keys(TRANSFORM_OPTION_KEY).concat(CONFIG_SHAPE.map(function(item) {
    return item.key;
  }));
  deleteKeys.forEach(function(key) {
    delete options[key];
  });
  children.forEach(function(child) {
    Object.keys(child).forEach(function(key) {
      if (deleteKeys.includes(key)) {
        delete child[key];
      }
    });
  });
  Object.keys(options).forEach(function(key) {
    if (!__spreadArray7(__spreadArray7([], VIEW_OPTIONS, true), ANNOTATION_LIST.map(function(item) {
      return item.key;
    }), true).includes(key)) {
      delete options[key];
    }
  });
  return options;
};

// node_modules/@ant-design/plots/es/core/utils/filter-transformed.js
var filterTransformed = function(params) {
  var options = params.options;
  var _a2 = options.children, children = _a2 === void 0 ? [] : _a2;
  children.forEach(function(child) {
    Object.keys(child).forEach(function(key) {
      if ((0, import_lodash4.isArray)(child[key]) && key !== "data") {
        child[key] = child[key].filter(function(item) {
          return !item[TRANSFORM_SIGN];
        });
      }
    });
  });
  return options;
};

// node_modules/@ant-design/plots/es/core/utils/merge-with-array-coverage.js
var __spreadArray8 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var arrayCoverage = function(objValue, srcValue) {
  if ((0, import_lodash4.isArray)(srcValue)) {
    return srcValue;
  }
};
var mergeWithArrayCoverage = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return import_lodash4.mergeWith.apply(void 0, __spreadArray8(__spreadArray8([], args, false), [arrayCoverage], false));
};

// node_modules/@ant-design/plots/es/core/utils/field-adapter.js
function fieldAdapter(field3) {
  switch (typeof field3) {
    case "function":
      return field3;
    case "string":
      return function(d3) {
        return (0, import_lodash4.get)(d3, [field3]);
      };
    default:
      return function() {
        return field3;
      };
  }
}

// node_modules/@ant-design/plots/es/core/constants/index.js
var __assign5 = function() {
  __assign5 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign5.apply(this, arguments);
};
var __rest92 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var CHART_OPTIONS = ["renderer"];
var VIEW_OPTIONS = [
  "width",
  "height",
  "autoFit",
  "theme",
  "inset",
  "insetLeft",
  "insetRight",
  "insetTop",
  "insetBottom",
  "padding",
  "paddingTop",
  "paddingRight",
  "paddingBottom",
  "paddingLeft",
  "margin",
  "marginTop",
  "marginRight",
  "marginBottom",
  "marginLeft",
  "depth",
  "title",
  "clip",
  "children",
  "type",
  "data",
  "direction"
];
var TRANSFORM_SIGN = "__transform__";
var SKIP_DEL_CUSTOM_SIGN = "__skipDelCustomKeys__";
var commonCallback = function(type, value2) {
  if ((0, import_lodash4.isBoolean)(value2)) {
    return {
      type,
      available: value2
    };
  }
  return __assign5({ type }, value2);
};
var TRANSFORM_OPTION_KEY = {
  /** encode */
  xField: "encode.x",
  yField: "encode.y",
  colorField: "encode.color",
  angleField: "encode.y",
  keyField: "encode.key",
  sizeField: "encode.size",
  shapeField: "encode.shape",
  seriesField: "encode.series",
  positionField: "encode.position",
  textField: "encode.text",
  valueField: "encode.value",
  binField: "encode.x",
  srcField: "encode.src",
  linkColorField: "encode.linkColor",
  fontSizeField: "encode.fontSize",
  radius: "coordinate.outerRadius",
  innerRadius: "coordinate.innerRadius",
  startAngle: "coordinate.startAngle",
  endAngle: "coordinate.endAngle",
  focusX: "coordinate.focusX",
  focusY: "coordinate.focusY",
  distortionX: "coordinate.distortionX",
  distortionY: "coordinate.distortionY",
  visual: "coordinate.visual",
  /**
   * @title 堆叠
   * @example
   *  1. stack: true -> transform: [{type: 'stackY'}]
   */
  stack: {
    target: "transform",
    value: function(value2) {
      return commonCallback("stackY", value2);
    }
  },
  /**
   * @title 归一化
   * @example
   *  1. normalize: true -> transform: [{type: 'normalizeY'}]
   */
  normalize: {
    target: "transform",
    value: function(value2) {
      return commonCallback("normalizeY", value2);
    }
  },
  /**
   * @title 百分比
   * @description 同 normalize
   * @example
   *  1. percent: true -> transform: [{type: 'normalizeY'}]
   */
  percent: {
    target: "transform",
    value: function(value2) {
      return commonCallback("normalizeY", value2);
    }
  },
  /**
   * @title 分组
   * @example
   *  1. group: true -> transform: [{type: 'dodgeX'}]
   */
  group: {
    target: "transform",
    value: function(value2) {
      return commonCallback("dodgeX", value2);
    }
  },
  /**
   * @title 排序
   * @example
   *  1. sort: true -> transform: [{type: 'sortX'}]
   */
  sort: {
    target: "transform",
    value: function(value2) {
      return commonCallback("sortX", value2);
    }
  },
  /**
   * @title 对称
   * @example
   *  1. symmetry: true -> transform: [{type: 'symmetryY'}]
   */
  symmetry: {
    target: "transform",
    value: function(value2) {
      return commonCallback("symmetryY", value2);
    }
  },
  /**
   * @title 对 y 和 y1 通道求差集
   * @example
   *  1. diff: true -> transform: [{type: 'diffY'}]
   */
  diff: {
    target: "transform",
    value: function(value2) {
      return commonCallback("diffY", value2);
    }
  },
  meta: {
    target: "scale",
    value: function(value2) {
      return value2;
    }
  },
  label: {
    target: "labels",
    value: function(value2) {
      return value2;
    }
  },
  /**
   * @title 折线的形状
   * @example
   *  1. shape: 'smooth' -> style: {shape: 'smooth'}
   */
  shape: "style.shape",
  /**
   * @title 是否链接空值
   * @description 支持 boolean 和 对象类型
   */
  connectNulls: {
    target: "style",
    value: function(value2) {
      if ((0, import_lodash4.isBoolean)(value2)) {
        return {
          connect: value2
        };
      }
      return value2;
    }
  }
};
var EXTEND_KEYS = [
  "xField",
  "yField",
  "seriesField",
  "colorField",
  "keyField",
  "positionField",
  "meta",
  "tooltip",
  "animate",
  "stack",
  "normalize",
  "percent",
  "group",
  "sort",
  "symmetry",
  "diff"
];
var CONFIG_SHAPE = [
  {
    key: "annotations",
    extend_keys: []
  },
  {
    key: "line",
    type: "line",
    extend_keys: EXTEND_KEYS
  },
  {
    key: "point",
    type: "point",
    extend_keys: EXTEND_KEYS
  },
  {
    key: "area",
    type: "area",
    extend_keys: EXTEND_KEYS
  }
];
var SPECIAL_OPTIONS = [
  {
    key: "transform",
    callback: function(origin, key, value2) {
      var _a2;
      origin[key] = origin[key] || [];
      var _b = value2.available, available = _b === void 0 ? true : _b, rest = __rest92(value2, ["available"]);
      if (available) {
        origin[key].push(__assign5((_a2 = {}, _a2[TRANSFORM_SIGN] = true, _a2), rest));
      } else {
        var index3 = origin[key].indexOf(function(item) {
          return item.type === value2.type;
        });
        if (index3 !== -1) {
          origin[key].splice(index3, 1);
        }
      }
    }
  },
  {
    key: "labels",
    callback: function(origin, key, value2) {
      var _a2;
      if (!value2 || (0, import_lodash4.isArray)(value2)) {
        origin[key] = value2 ? value2 : [];
        return;
      }
      if (!value2.text) {
        value2["text"] = origin["yField"];
      }
      origin[key] = origin[key] || [];
      origin[key].push(__assign5((_a2 = {}, _a2[TRANSFORM_SIGN] = true, _a2), value2));
    }
  }
];
var ANNOTATION_LIST = [
  {
    key: "conversionTag",
    shape: "ConversionTag"
  },
  {
    key: "axisText",
    shape: "BidirectionalBarAxisText"
  }
];

// node_modules/@ant-design/plots/es/core/annotation/shapes/Text.js
var __extends3 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign6 = function() {
  __assign6 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign6.apply(this, arguments);
};
var __rest93 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var Text5 = (
  /** @class */
  function(_super) {
    __extends3(Text6, _super);
    function Text6(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var style = _a2.style, restOptions = __rest93(_a2, ["style"]);
      return _super.call(this, __assign6({ style: __assign6({ text: "", fontSize: 12, textBaseline: "middle", textAlign: "center", fill: "#000", fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", lineWidth: 1 }, style) }, restOptions)) || this;
    }
    return Text6;
  }(Text)
);

// node_modules/@ant-design/plots/es/core/annotation/shapes/Polygon.js
var __extends4 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign7 = function() {
  __assign7 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign7.apply(this, arguments);
};
var __rest94 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var Polygon4 = (
  /** @class */
  function(_super) {
    __extends4(Polygon5, _super);
    function Polygon5(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var style = _a2.style, restOptions = __rest94(_a2, ["style"]);
      return _super.call(this, __assign7({ style: __assign7({ fill: "#eee" }, style) }, restOptions)) || this;
    }
    return Polygon5;
  }(Polygon)
);

// node_modules/@ant-design/plots/es/core/annotation/core.js
var __extends5 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Annotaion = (
  /** @class */
  function(_super) {
    __extends5(Annotaion3, _super);
    function Annotaion3(chart, config, defaultOptions) {
      var _this2 = _super.call(this, { style: mergeWithArrayCoverage(defaultOptions, config) }) || this;
      _this2.chart = chart;
      return _this2;
    }
    Annotaion3.prototype.connectedCallback = function() {
      this.render(this.attributes, this);
      this.bindEvents(this.attributes, this);
    };
    Annotaion3.prototype.disconnectedCallback = function() {
    };
    Annotaion3.prototype.attributeChangedCallback = function(name2) {
    };
    Annotaion3.prototype.update = function(attr2, animate2) {
      var _a2;
      this.attr(mergeWithArrayCoverage({}, this.attributes, attr2 || {}));
      return (_a2 = this.render) === null || _a2 === void 0 ? void 0 : _a2.call(this, this.attributes, this, animate2);
    };
    Annotaion3.prototype.clear = function() {
      this.removeChildren();
    };
    Annotaion3.prototype.getElementsLayout = function() {
      var canvas = this.chart.getContext().canvas;
      var elements = canvas.document.getElementsByClassName("element");
      var elementsLayout = [];
      elements.forEach(function(element) {
        var bbox = element.getBBox();
        var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
        var data2 = element["__data__"];
        elementsLayout.push({
          bbox,
          x: x3,
          y: y3,
          width,
          height,
          key: data2.key,
          data: data2
        });
      });
      return elementsLayout;
    };
    Annotaion3.prototype.bindEvents = function(attributes, container) {
    };
    return Annotaion3;
  }(CustomElement)
);

// node_modules/@ant-design/plots/es/core/annotation/conversion-tag.js
var __extends6 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign8 = function() {
  __assign8 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign8.apply(this, arguments);
};
var ConversionTag = (
  /** @class */
  function(_super) {
    __extends6(ConversionTag2, _super);
    function ConversionTag2(chart, options) {
      return _super.call(this, chart, options, { type: ConversionTag2.tag }) || this;
    }
    ConversionTag2.prototype.getConversionTagLayout = function() {
      var isVertical2 = this.direction === "vertical";
      var elementsLayout = this.getElementsLayout();
      var _a2 = elementsLayout[0], firstX = _a2.x, firstY = _a2.y, firstHeigt = _a2.height, firstWidth = _a2.width, firstData = _a2.data;
      var valuePath = ["items", 0, "value"];
      var preValue = (0, import_lodash4.get)(firstData, valuePath);
      var elementDistance = isVertical2 ? elementsLayout[1].y - firstY - firstHeigt : elementsLayout[1].x - firstX - firstWidth;
      var tagLayout = [];
      var _b = this.attributes, _c = _b.size, size3 = _c === void 0 ? 40 : _c, _d = _b.arrowSize, arrowSize = _d === void 0 ? 20 : _d, _e = _b.spacing, spacing = _e === void 0 ? 4 : _e;
      elementsLayout.forEach(function(element, index3) {
        if (index3 > 0) {
          var x3 = element.x, y3 = element.y, height = element.height, width = element.width, data2 = element.data, key = element.key;
          var currentValue = (0, import_lodash4.get)(data2, valuePath);
          var halfSize = size3 / 2;
          if (isVertical2) {
            var arrowVertexX = x3 + width / 2;
            var arrowVertexY = y3;
            tagLayout.push({
              points: [
                [arrowVertexX + halfSize, arrowVertexY - elementDistance + spacing],
                [arrowVertexX + halfSize, arrowVertexY - arrowSize - spacing],
                [arrowVertexX, arrowVertexY - spacing],
                [arrowVertexX - halfSize, arrowVertexY - arrowSize - spacing],
                [arrowVertexX - halfSize, arrowVertexY - elementDistance + spacing]
              ],
              center: [arrowVertexX, arrowVertexY - elementDistance / 2 - spacing],
              width: elementDistance,
              value: [preValue, currentValue],
              key
            });
          } else {
            var arrowVertexX = x3;
            var arrowVertexY = y3 + height / 2;
            tagLayout.push({
              points: [
                [x3 - elementDistance + spacing, arrowVertexY - halfSize],
                [x3 - arrowSize - spacing, arrowVertexY - halfSize],
                [arrowVertexX - spacing, arrowVertexY],
                [x3 - arrowSize - spacing, arrowVertexY + halfSize],
                [x3 - elementDistance + spacing, arrowVertexY + halfSize]
              ],
              center: [arrowVertexX - elementDistance / 2 - spacing, arrowVertexY],
              width: elementDistance,
              value: [preValue, currentValue],
              key
            });
          }
          preValue = currentValue;
        }
      });
      return tagLayout;
    };
    ConversionTag2.prototype.render = function() {
      this.setDirection();
      this.drawConversionTag();
    };
    ConversionTag2.prototype.setDirection = function() {
      var coordinate = this.chart.getCoordinate();
      var transformations = (0, import_lodash4.get)(coordinate, "options.transformations");
      var direction3 = "horizontal";
      transformations.forEach(function(transformation) {
        if (transformation.includes("transpose")) {
          direction3 = "vertical";
        }
      });
      this.direction = direction3;
    };
    ConversionTag2.prototype.drawConversionTag = function() {
      var _this2 = this;
      var conversionLayout = this.getConversionTagLayout();
      var _a2 = this.attributes, style = _a2.style, _b = _a2.text, textStyle = _b.style, formatter2 = _b.formatter;
      conversionLayout.forEach(function(layout) {
        var points = layout.points, center2 = layout.center, value2 = layout.value, key = layout.key;
        var prev = value2[0], next = value2[1];
        var x3 = center2[0], y3 = center2[1];
        var polygon = new Polygon4({
          style: __assign8({ points, fill: "#eee" }, style),
          id: "polygon-".concat(key)
        });
        var text = new Text5({
          style: __assign8({ x: x3, y: y3, text: (0, import_lodash4.isFunction)(formatter2) ? formatter2(prev, next) : (next / prev * 100).toFixed(2) + "%" }, textStyle),
          id: "text-".concat(key)
        });
        _this2.appendChild(polygon);
        _this2.appendChild(text);
      });
    };
    ConversionTag2.prototype.update = function() {
      var _this2 = this;
      var conversionLayout = this.getConversionTagLayout();
      conversionLayout.forEach(function(layout) {
        var points = layout.points, center2 = layout.center, key = layout.key;
        var x3 = center2[0], y3 = center2[1];
        var polygon = _this2.getElementById("polygon-".concat(key));
        var text = _this2.getElementById("text-".concat(key));
        polygon.setAttribute("points", points);
        text.setAttribute("x", x3);
        text.setAttribute("y", y3);
      });
    };
    ConversionTag2.tag = "ConversionTag";
    return ConversionTag2;
  }(Annotaion)
);

// node_modules/@ant-design/plots/es/core/plots/bidirectional-bar/constants.js
var VERTICAL_MARGIN = 32;
var HORIZONTAL_MARGIN = 16;
var AXIS_LABEL_PADDING = 48;

// node_modules/@ant-design/plots/es/core/annotation/bidirectional-bar-axis-text.js
var __extends7 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign9 = function() {
  __assign9 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign9.apply(this, arguments);
};
var __rest95 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var BidirectionalBarAxisText = (
  /** @class */
  function(_super) {
    __extends7(BidirectionalBarAxisText2, _super);
    function BidirectionalBarAxisText2(chart, options) {
      return _super.call(this, chart, options, { type: BidirectionalBarAxisText2.tag }) || this;
    }
    BidirectionalBarAxisText2.prototype.render = function() {
      this.drawText();
    };
    BidirectionalBarAxisText2.prototype.getBidirectionalBarAxisTextLayout = function() {
      var layout = this.attributes.layout;
      var isVertical2 = layout === "vertical";
      var allElementsLayout = this.getElementsLayout();
      var elementsLayout = isVertical2 ? (0, import_lodash4.uniqBy)(allElementsLayout, "x") : (0, import_lodash4.uniqBy)(allElementsLayout, "y");
      var textPath = ["title"];
      var textLayout = [];
      var views = this.chart.getContext().views;
      var _a2 = (0, import_lodash4.get)(views, [0, "layout"]), viewWidth = _a2.width, viewHeight = _a2.height;
      elementsLayout.forEach(function(element) {
        var x3 = element.x, y3 = element.y, height = element.height, width = element.width, data2 = element.data, key = element.key;
        var text = (0, import_lodash4.get)(data2, textPath);
        if (isVertical2) {
          textLayout.push({
            x: x3 + width / 2,
            y: viewHeight,
            text,
            key
          });
        } else {
          textLayout.push({
            x: viewWidth,
            y: y3 + height / 2,
            text,
            key
          });
        }
      });
      if ((0, import_lodash4.uniqBy)(textLayout, "text").length !== textLayout.length) {
        textLayout = Object.values((0, import_lodash4.groupBy)(textLayout, "text")).map(function(items) {
          var _a3;
          var sum4 = items.reduce(function(pre, cur) {
            return pre + (isVertical2 ? cur.x : cur.y);
          }, 0);
          return __assign9(__assign9({}, items[0]), (_a3 = {}, _a3[isVertical2 ? "x" : "y"] = sum4 / items.length, _a3));
        });
      }
      return textLayout;
    };
    BidirectionalBarAxisText2.prototype.transformLabelStyle = function(style) {
      var removeLabel = {};
      var reg = /^label[A-Z]/;
      Object.keys(style).forEach(function(key) {
        if (reg.test(key)) {
          removeLabel[key.replace("label", "").replace(/^[A-Z]/, function(match) {
            return match.toLowerCase();
          })] = style[key];
        }
      });
      return removeLabel;
    };
    BidirectionalBarAxisText2.prototype.drawText = function() {
      var _this2 = this;
      var axisLayout = this.getBidirectionalBarAxisTextLayout();
      var _a2 = this.attributes, viewLayout = _a2.layout, labelFormatter2 = _a2.labelFormatter, textStyle = __rest95(_a2, ["layout", "labelFormatter"]);
      axisLayout.forEach(function(layout) {
        var x3 = layout.x, y3 = layout.y, text = layout.text, key = layout.key;
        var textNode = new Text5({
          style: __assign9({ x: x3, y: y3, text: (0, import_lodash4.isFunction)(labelFormatter2) ? labelFormatter2(text) : text, wordWrap: true, wordWrapWidth: viewLayout === "horizontal" ? VERTICAL_MARGIN * 2 : 120, maxLines: 2, textOverflow: "ellipsis" }, _this2.transformLabelStyle(textStyle)),
          id: "text-".concat(key)
        });
        _this2.appendChild(textNode);
      });
    };
    BidirectionalBarAxisText2.prototype.destroy = function() {
      this.clear();
    };
    BidirectionalBarAxisText2.prototype.update = function() {
      this.destroy();
      this.drawText();
    };
    BidirectionalBarAxisText2.tag = "BidirectionalBarAxisText";
    return BidirectionalBarAxisText2;
  }(Annotaion)
);

// node_modules/@ant-design/plots/es/core/annotation/index.js
var Annotaion2 = { ConversionTag, BidirectionalBarAxisText };
var Controller2 = (
  /** @class */
  function() {
    function Controller3(chart, config) {
      this.container = /* @__PURE__ */ new Map();
      this.chart = chart;
      this.config = config;
      this.init();
    }
    Controller3.prototype.init = function() {
      var _this2 = this;
      ANNOTATION_LIST.forEach(function(annotation) {
        var _a2;
        var key = annotation.key, shape23 = annotation.shape;
        var annotationOptions = _this2.config[key];
        if (annotationOptions) {
          var annotationInstance = new Annotaion2[shape23](_this2.chart, annotationOptions);
          var canvas = _this2.chart.getContext().canvas;
          canvas.appendChild(annotationInstance);
          _this2.container.set(key, annotationInstance);
        } else {
          (_a2 = _this2.container.get(key)) === null || _a2 === void 0 ? void 0 : _a2.clear();
        }
      });
    };
    Controller3.prototype.update = function() {
      var _this2 = this;
      if (!this.container.size)
        return;
      ANNOTATION_LIST.forEach(function(annotation) {
        var key = annotation.key;
        var annotationInstance = _this2.container.get(key);
        annotationInstance === null || annotationInstance === void 0 ? void 0 : annotationInstance.update();
      });
    };
    return Controller3;
  }()
);

// node_modules/@ant-design/plots/es/core/base/index.js
var __extends8 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign10 = function() {
  __assign10 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign10.apply(this, arguments);
};
var SOURCE_ATTRIBUTE_NAME = "data-chart-source-type";
var Plot = (
  /** @class */
  function(_super) {
    __extends8(Plot2, _super);
    function Plot2(container, options) {
      var _this2 = _super.call(this) || this;
      _this2.container = typeof container === "string" ? document.getElementById(container) : container;
      _this2.options = _this2.mergeOption(options);
      _this2.createG2();
      _this2.bindEvents();
      return _this2;
    }
    Plot2.prototype.getChartOptions = function() {
      return __assign10(__assign10({}, (0, import_lodash4.pick)(this.options, CHART_OPTIONS)), { container: this.container });
    };
    Plot2.prototype.getSpecOptions = function() {
      if (this.type === "base" || this[SKIP_DEL_CUSTOM_SIGN]) {
        return __assign10(__assign10({}, this.options), this.getChartOptions());
      }
      return this.options;
    };
    Plot2.prototype.createG2 = function() {
      if (!this.container) {
        throw Error("The container is not initialized!");
      }
      this.chart = new Chart3(this.getChartOptions());
      this.container.setAttribute(SOURCE_ATTRIBUTE_NAME, "Ant Design Charts");
    };
    Plot2.prototype.bindEvents = function() {
      var _this2 = this;
      if (this.chart) {
        this.chart.on("*", function(e) {
          if (e === null || e === void 0 ? void 0 : e.type) {
            _this2.emit(e.type, e);
          }
        });
      }
    };
    Plot2.prototype.getBaseOptions = function() {
      return { type: "view", autoFit: true };
    };
    Plot2.prototype.getDefaultOptions = function() {
    };
    Plot2.prototype.render = function() {
      var _this2 = this;
      if (this.type !== "base") {
        this.execAdaptor();
      }
      this.chart.options(this.getSpecOptions());
      this.chart.render().then(function() {
        _this2.annotation = new Controller2(_this2.chart, _this2.options);
      });
      this.bindSizeSensor();
    };
    Plot2.prototype.update = function(options) {
      this.options = this.mergeOption(options);
    };
    Plot2.prototype.mergeOption = function(options) {
      return mergeWithArrayCoverage({}, this.getBaseOptions(), this.getDefaultOptions(), options);
    };
    Plot2.prototype.changeData = function(data2) {
      this.chart.changeData(data2);
    };
    Plot2.prototype.changeSize = function(width, height) {
      this.chart.changeSize(width, height);
    };
    Plot2.prototype.destroy = function() {
      this.chart.destroy();
      this.off();
      this.container.removeAttribute(SOURCE_ATTRIBUTE_NAME);
    };
    Plot2.prototype.execAdaptor = function() {
      var adaptor33 = this.getSchemaAdaptor();
      adaptor33({
        chart: this.chart,
        options: this.options
      });
    };
    Plot2.prototype.triggerResize = function() {
      this.chart.forceFit();
    };
    Plot2.prototype.bindSizeSensor = function() {
      var _this2 = this;
      var _a2 = this.options.autoFit, autoFit = _a2 === void 0 ? true : _a2;
      if (autoFit) {
        this.chart.on(ChartEvent.AFTER_CHANGE_SIZE, function() {
          _this2.annotation.update();
        });
      }
    };
    return Plot2;
  }(esm_default)
);

// node_modules/@ant-design/plots/es/core/plots/base/index.js
var __extends9 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Base2 = (
  /** @class */
  function(_super) {
    __extends9(Base3, _super);
    function Base3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "base";
      return _this2;
    }
    Base3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "line" }]
      };
    };
    Base3.prototype.getDefaultOptions = function() {
      return Base3.getDefaultOptions();
    };
    Base3.prototype.getSchemaAdaptor = function() {
      return function(params) {
        return params;
      };
    };
    return Base3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/adaptor/shape-stack.js
var __assign11 = function() {
  __assign11 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign11.apply(this, arguments);
};
function shapeStack(params) {
  var options = params.options;
  var stack = options.stack, tooltip2 = options.tooltip, xField = options.xField;
  if (!stack)
    return params;
  var shapes = CONFIG_SHAPE.map(function(item) {
    return item.type;
  }).filter(function(item) {
    return !!item;
  });
  var hasStack = false;
  shapes.forEach(function(shape23) {
    if (options[shape23]) {
      hasStack = true;
      (0, import_lodash4.set)(options, [shape23, "stack"], __assign11({ y1: "y" }, typeof stack === "object" ? stack : {}));
    }
  });
  if (hasStack && !(0, import_lodash4.isBoolean)(tooltip2) && !tooltip2) {
    (0, import_lodash4.set)(options, "tooltip", {
      title: xField,
      items: [
        {
          channel: "y"
        }
      ]
    });
  }
  return params;
}

// node_modules/@ant-design/plots/es/core/adaptor/mark.js
function mark(params) {
  return (0, import_lodash4.flow)(shapeStack)(params);
}

// node_modules/@ant-design/plots/es/core/adaptor/coordinate-layout.js
function coordinateLayout(params) {
  var _a2 = params.options.layout, layout = _a2 === void 0 ? "horizontal" : _a2;
  params.options.coordinate.transform = layout !== "horizontal" ? void 0 : [{ type: "transpose" }];
  return params;
}
function allCoordinateLayout(params) {
  coordinateLayout(params);
  var _a2 = params.options.layout, layout = _a2 === void 0 ? "horizontal" : _a2;
  params.options.children.forEach(function(item) {
    var _a3;
    if ((_a3 = item === null || item === void 0 ? void 0 : item.coordinate) === null || _a3 === void 0 ? void 0 : _a3.transform) {
      item.coordinate.transform = layout !== "horizontal" ? void 0 : [{ type: "transpose" }];
    }
  });
  return params;
}

// node_modules/@ant-design/plots/es/core/plots/area/adaptor.js
function adaptor2(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/area/index.js
var __extends10 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Area3 = (
  /** @class */
  function(_super) {
    __extends10(Area4, _super);
    function Area4() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "area";
      return _this2;
    }
    Area4.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "area" }],
        scale: {
          y: { nice: true }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        interaction: {
          tooltip: {
            shared: true
          }
        }
      };
    };
    Area4.prototype.getDefaultOptions = function() {
      return Area4.getDefaultOptions();
    };
    Area4.prototype.getSchemaAdaptor = function() {
      return adaptor2;
    };
    return Area4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/bar/adaptor.js
var __assign12 = function() {
  __assign12 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign12.apply(this, arguments);
};
function adaptor3(params) {
  var background = function(params2) {
    var options = params2.options;
    if ((0, import_lodash4.get)(options, "children.length") > 1) {
      (0, import_lodash4.set)(options, "children", [{ type: "interval" }]);
    }
    var scale11 = options.scale, markBackground = options.markBackground, data2 = options.data, children = options.children, yField = options.yField;
    var domain = (0, import_lodash4.get)(scale11, "y.domain", []);
    if (markBackground && domain.length && (0, import_lodash4.isArray)(data2)) {
      var domainMax_1 = "domainMax";
      var backgroundData = data2.map(function(item) {
        var _a2;
        return __assign12(__assign12({ originData: __assign12({}, item) }, (0, import_lodash4.omit)(item, yField)), (_a2 = {}, _a2[domainMax_1] = domain[domain.length - 1], _a2));
      });
      children.unshift(__assign12({ type: "interval", data: backgroundData, yField: domainMax_1, tooltip: false, style: {
        fill: "#eee"
      }, label: false }, markBackground));
    }
    return params2;
  };
  return (0, import_lodash4.flow)(background, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/bar/shape.js
var reisterShape = function() {
  var draw25DBar = function(style, context) {
    return function(points) {
      var _a2 = style.fill, fill = _a2 === void 0 ? "#2888FF" : _a2, stroke2 = style.stroke, _b = style.fillOpacity, fillOpacity = _b === void 0 ? 1 : _b, _c = style.strokeOpacity, strokeOpacity = _c === void 0 ? 0.2 : _c, _d = style.pitch, pitch = _d === void 0 ? 8 : _d;
      var p1 = points[0], p2 = points[1], p3 = points[2], p4 = points[3];
      var height = (p2[1] - p1[1]) / 2;
      var document2 = context.document;
      var g = document2.createElement("g", {});
      var top = document2.createElement("polygon", {
        style: {
          points: [p1, [p1[0] - pitch, p1[1] + height], [p3[0] - pitch, p1[1] + height], p4],
          fill,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity,
          inset: 30
        }
      });
      var bottom = document2.createElement("polygon", {
        style: {
          points: [[p1[0] - pitch, p1[1] + height], p2, p3, [p3[0] - pitch, p1[1] + height]],
          fill,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity
        }
      });
      var right2 = document2.createElement("polygon", {
        style: {
          points: [p1, [p1[0] - pitch, p1[1] + height], p2, [p1[0] + pitch, p1[1] + height]],
          fill,
          fillOpacity: fillOpacity - 0.2
        }
      });
      g.appendChild(top);
      g.appendChild(bottom);
      g.appendChild(right2);
      return g;
    };
  };
  register("shape.interval.bar25D", draw25DBar);
};

// node_modules/@ant-design/plots/es/core/plots/bar/index.js
var __extends11 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
reisterShape();
var Bar = (
  /** @class */
  function(_super) {
    __extends11(Bar2, _super);
    function Bar2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "Bar";
      return _this2;
    }
    Bar2.getDefaultOptions = function() {
      return {
        type: "view",
        coordinate: { transform: [{ type: "transpose" }] },
        children: [{ type: "interval" }],
        scale: {
          y: { nice: true }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        interaction: {
          tooltip: {
            shared: true
          },
          elementHighlight: {
            background: true
          }
        }
      };
    };
    Bar2.prototype.getDefaultOptions = function() {
      return Bar2.getDefaultOptions();
    };
    Bar2.prototype.getSchemaAdaptor = function() {
      return adaptor3;
    };
    return Bar2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/column/shape.js
var reisterShape2 = function() {
  var draw25DColumn = function(style, context) {
    return function(points) {
      var _a2 = style.fill, fill = _a2 === void 0 ? "#2888FF" : _a2, stroke2 = style.stroke, _b = style.fillOpacity, fillOpacity = _b === void 0 ? 1 : _b, _c = style.strokeOpacity, strokeOpacity = _c === void 0 ? 0.2 : _c, _d = style.pitch, pitch = _d === void 0 ? 8 : _d;
      var x3 = points[1][0] - points[0][0];
      var x4 = x3 / 2 + points[0][0];
      var document2 = context.document;
      var g = document2.createElement("g", {});
      var left2 = document2.createElement("polygon", {
        style: {
          points: [
            [points[0][0], points[0][1]],
            [x4, points[1][1] + pitch],
            [x4, points[3][1] + pitch],
            [points[3][0], points[3][1]]
          ],
          fill,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity,
          inset: 30
        }
      });
      var right2 = document2.createElement("polygon", {
        style: {
          points: [
            [x4, points[1][1] + pitch],
            [points[1][0], points[1][1]],
            [points[2][0], points[2][1]],
            [x4, points[2][1] + pitch]
          ],
          fill,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity
        }
      });
      var top = document2.createElement("polygon", {
        style: {
          points: [
            [points[0][0], points[0][1]],
            [x4, points[1][1] - pitch],
            [points[1][0], points[1][1]],
            [x4, points[1][1] + pitch]
          ],
          fill,
          fillOpacity: fillOpacity - 0.2
        }
      });
      g.appendChild(right2);
      g.appendChild(left2);
      g.appendChild(top);
      return g;
    };
  };
  register("shape.interval.column25D", draw25DColumn);
};

// node_modules/@ant-design/plots/es/core/plots/column/index.js
var __extends12 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
reisterShape2();
var Column2 = (
  /** @class */
  function(_super) {
    __extends12(Column3, _super);
    function Column3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "column";
      return _this2;
    }
    Column3.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          y: { nice: true }
        },
        interaction: {
          tooltip: {
            shared: true
          },
          elementHighlight: {
            background: true
          }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        children: [
          {
            type: "interval"
          }
        ]
      };
    };
    Column3.prototype.getDefaultOptions = function() {
      return Column3.getDefaultOptions();
    };
    Column3.prototype.getSchemaAdaptor = function() {
      return adaptor3;
    };
    return Column3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/dual-axes/adaptor.js
function adaptor4(params) {
  var colorField = function(params2) {
    var options = params2.options;
    var _a2 = options.children, children = _a2 === void 0 ? [] : _a2, legend = options.legend;
    if (!legend)
      return params2;
    children.forEach(function(option) {
      if (!(0, import_lodash4.get)(option, "colorField")) {
        var yField_1 = (0, import_lodash4.get)(option, "yField");
        (0, import_lodash4.set)(option, "colorField", function() {
          return yField_1;
        });
      }
    });
    return params2;
  };
  var annotations = function(params2) {
    var options = params2.options;
    var _a2 = options.annotations, annotations2 = _a2 === void 0 ? [] : _a2, _b = options.children, children = _b === void 0 ? [] : _b, scale11 = options.scale;
    var sharedScale = false;
    if ((0, import_lodash4.get)(scale11, "y.key")) {
      return params2;
    }
    children.forEach(function(child, index3) {
      if (!(0, import_lodash4.get)(child, "scale.y.key")) {
        var scaleKey_1 = "child".concat(index3, "Scale");
        (0, import_lodash4.set)(child, "scale.y.key", scaleKey_1);
        var _a3 = child.annotations, childAnnotations = _a3 === void 0 ? [] : _a3;
        if (childAnnotations.length > 0) {
          (0, import_lodash4.set)(child, "scale.y.independent", false);
          childAnnotations.forEach(function(annotation) {
            (0, import_lodash4.set)(annotation, "scale.y.key", scaleKey_1);
          });
        }
        if (!sharedScale && annotations2.length > 0 && (0, import_lodash4.get)(child, "scale.y.independent") === void 0) {
          sharedScale = true;
          (0, import_lodash4.set)(child, "scale.y.independent", false);
          annotations2.forEach(function(annotation) {
            (0, import_lodash4.set)(annotation, "scale.y.key", scaleKey_1);
          });
        }
      }
    });
    return params2;
  };
  return (0, import_lodash4.flow)(colorField, annotations, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/dual-axes/index.js
var __extends13 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DualAxes = (
  /** @class */
  function(_super) {
    __extends13(DualAxes2, _super);
    function DualAxes2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "DualAxes";
      return _this2;
    }
    DualAxes2.getDefaultOptions = function() {
      return {
        type: "view",
        axis: {
          y: { title: false, tick: false },
          x: { title: false }
        },
        scale: {
          y: {
            independent: true,
            nice: true
          }
        }
      };
    };
    DualAxes2.prototype.getDefaultOptions = function() {
      return DualAxes2.getDefaultOptions();
    };
    DualAxes2.prototype.getSchemaAdaptor = function() {
      return adaptor4;
    };
    return DualAxes2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/funnel/adaptor.js
function adaptor5(params) {
  var init = function(params2) {
    var options = params2.options;
    var xField = options.xField, colorField = options.colorField;
    if (!colorField) {
      (0, import_lodash4.set)(options, "colorField", xField);
    }
    return params2;
  };
  var transform2 = function(params2) {
    var options = params2.options;
    var compareField = options.compareField, transform3 = options.transform, _a2 = options.isTransposed, isTransposed = _a2 === void 0 ? true : _a2, coordinate = options.coordinate;
    if (!transform3) {
      if (compareField) {
        (0, import_lodash4.set)(options, "transform", []);
      } else {
        (0, import_lodash4.set)(options, "transform", [{ type: "symmetryY" }]);
      }
    }
    if (!coordinate && isTransposed) {
      (0, import_lodash4.set)(options, "coordinate", { transform: [{ type: "transpose" }] });
    }
    return params2;
  };
  var compare = function(params2) {
    var options = params2.options;
    var compareField = options.compareField, seriesField = options.seriesField, data2 = options.data, children = options.children, yField = options.yField, _a2 = options.isTransposed, isTransposed = _a2 === void 0 ? true : _a2;
    if (compareField || seriesField) {
      var groupedData = Object.values((0, import_lodash4.groupBy)(data2, function(item) {
        return item[compareField || seriesField];
      }));
      children[0].data = groupedData[0];
      children.push({
        type: "interval",
        data: groupedData[1],
        // @ts-ignore
        yField: function(item) {
          return -item[yField];
        }
      });
      delete options["compareField"];
      delete options.data;
    }
    if (seriesField) {
      (0, import_lodash4.set)(options, "type", "spaceFlex");
      (0, import_lodash4.set)(options, "ratio", [1, 1]);
      (0, import_lodash4.set)(options, "direction", isTransposed ? "row" : "col");
      delete options["seriesField"];
    }
    return params2;
  };
  var tooltip2 = function(params2) {
    var options = params2.options;
    var tooltip3 = options.tooltip, xField = options.xField, yField = options.yField;
    if (!tooltip3) {
      (0, import_lodash4.set)(options, "tooltip", {
        title: false,
        items: [
          function(d3) {
            return { name: d3[xField], value: d3[yField] };
          }
        ]
      });
    }
    return params2;
  };
  return (0, import_lodash4.flow)(init, transform2, compare, tooltip2, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/funnel/index.js
var __extends14 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Funnel2 = (
  /** @class */
  function(_super) {
    __extends14(Funnel3, _super);
    function Funnel3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "column";
      return _this2;
    }
    Funnel3.getDefaultOptions = function() {
      return {
        type: "view",
        scale: { x: { padding: 0 } },
        animate: { enter: { type: "fadeIn" } },
        axis: false,
        shapeField: "funnel",
        label: {
          position: "inside",
          transform: [{ type: "contrastReverse" }]
        },
        children: [
          {
            type: "interval"
          }
        ]
      };
    };
    Funnel3.prototype.getDefaultOptions = function() {
      return Funnel3.getDefaultOptions();
    };
    Funnel3.prototype.getSchemaAdaptor = function() {
      return adaptor5;
    };
    return Funnel3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/line/adaptor.js
function adaptor6(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/line/index.js
var __extends15 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Line6 = (
  /** @class */
  function(_super) {
    __extends15(Line7, _super);
    function Line7() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "line";
      return _this2;
    }
    Line7.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          y: { nice: true }
        },
        interaction: {
          tooltip: {
            shared: true
          }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        // 使用该动画，会导致线形图-连接空值 一进入页面渲染不出来，必须要更改窗口尺寸触发重新渲染。建议动画暂时使用默认
        // animate: {
        //   enter: { type: 'growInX' },
        // },
        children: [{ type: "line" }]
      };
    };
    Line7.prototype.getDefaultOptions = function() {
      return Line7.getDefaultOptions();
    };
    Line7.prototype.getSchemaAdaptor = function() {
      return adaptor6;
    };
    return Line7;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/pie/adaptor.js
var __assign13 = function() {
  __assign13 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign13.apply(this, arguments);
};
function adaptor7(params) {
  var emptyData = function(params2) {
    var options = params2.options;
    var angleField = options.angleField, data2 = options.data, label = options.label, tooltip2 = options.tooltip, colorField = options.colorField;
    var getColorValue = fieldAdapter(colorField);
    if ((0, import_lodash4.isArray)(data2) && data2.length > 0) {
      var sum4 = data2.reduce(function(a4, b) {
        return a4 + b[angleField];
      }, 0);
      if (sum4 === 0) {
        var normalization = data2.map(function(item) {
          var _a2;
          return __assign13(__assign13({}, item), (_a2 = {}, _a2[angleField] = 1, _a2));
        });
        (0, import_lodash4.set)(options, "data", normalization);
        if (label) {
          (0, import_lodash4.set)(options, "label", __assign13(__assign13({}, label), { formatter: function() {
            return 0;
          } }));
        }
        if (tooltip2 !== false) {
          if ((0, import_lodash4.isFunction)(tooltip2)) {
            (0, import_lodash4.set)(options, "tooltip", function(arg, index3, items) {
              var _a2;
              return tooltip2(__assign13(__assign13({}, arg), (_a2 = {}, _a2[angleField] = 0, _a2)), index3, items.map(function(item) {
                var _a3;
                return __assign13(__assign13({}, item), (_a3 = {}, _a3[angleField] = 0, _a3));
              }));
            });
          } else {
            (0, import_lodash4.set)(options, "tooltip", __assign13(__assign13({}, tooltip2), { items: [
              function(arg, i, d3) {
                return {
                  name: getColorValue(arg, i, d3),
                  value: 0
                };
              }
            ] }));
          }
        }
      }
    }
    return params2;
  };
  return (0, import_lodash4.flow)(emptyData, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/pie/index.js
var __extends16 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Pie = (
  /** @class */
  function(_super) {
    __extends16(Pie2, _super);
    function Pie2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "pie";
      return _this2;
    }
    Pie2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval" }],
        coordinate: { type: "theta" },
        transform: [{ type: "stackY", reverse: true }],
        animate: { enter: { type: "waveIn" } }
      };
    };
    Pie2.prototype.getDefaultOptions = function() {
      return Pie2.getDefaultOptions();
    };
    Pie2.prototype.getSchemaAdaptor = function() {
      return adaptor7;
    };
    return Pie2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/scatter/adaptor.js
function adaptor8(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/scatter/index.js
var __extends17 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Scatter = (
  /** @class */
  function(_super) {
    __extends17(Scatter2, _super);
    function Scatter2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "scatter";
      return _this2;
    }
    Scatter2.getDefaultOptions = function() {
      return {
        axis: {
          y: { title: false },
          x: { title: false }
        },
        legend: {
          size: false
        },
        children: [{ type: "point" }]
      };
    };
    Scatter2.prototype.getDefaultOptions = function() {
      return Scatter2.getDefaultOptions();
    };
    Scatter2.prototype.getSchemaAdaptor = function() {
      return adaptor8;
    };
    return Scatter2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/radar/adaptor.js
function adaptor9(params) {
  var init = function(params2) {
    (0, import_lodash4.set)(params2, "options.coordinate", { type: (0, import_lodash4.get)(params2, "options.coordinateType", "polar") });
    return params2;
  };
  return (0, import_lodash4.flow)(init, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/radar/index.js
var __extends18 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Radar2 = (
  /** @class */
  function(_super) {
    __extends18(Radar3, _super);
    function Radar3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "radar";
      return _this2;
    }
    Radar3.getDefaultOptions = function() {
      return {
        axis: {
          x: { grid: true, line: true },
          y: { zIndex: 1, title: false, line: true, nice: true }
        },
        meta: { x: { padding: 0.5, align: 0 } },
        interaction: { tooltip: { style: { crosshairsLineDash: [4, 4] } } },
        children: [{ type: "line" }],
        // 有  polar 和 radar 两种极坐标形式
        coordinateType: "polar"
      };
    };
    Radar3.prototype.getDefaultOptions = function() {
      return Radar3.getDefaultOptions();
    };
    Radar3.prototype.getSchemaAdaptor = function() {
      return adaptor9;
    };
    return Radar3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/stock/adaptor.js
var __assign14 = function() {
  __assign14 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign14.apply(this, arguments);
};
var Y_FIELD_KEY = "__stock-range__";
var TREND_FIELD = "trend";
var TREND_UP = "up";
var TREND_DOWN = "down";
function adaptor10(params) {
  var transformData2 = function(params2) {
    var _a2 = params2.options, data2 = _a2.data, yField = _a2.yField;
    params2.options.data = (0, import_lodash4.map)(data2, function(item) {
      var obj = item && __assign14({}, item);
      if (Array.isArray(yField) && obj) {
        var open_1 = yField[0], close_1 = yField[1], high = yField[2], low = yField[3];
        obj[TREND_FIELD] = obj[open_1] <= obj[close_1] ? TREND_UP : TREND_DOWN;
        obj[Y_FIELD_KEY] = [obj[open_1], obj[close_1], obj[high], obj[low]];
      }
      return obj;
    });
    return params2;
  };
  var init = function(params2) {
    var options = params2.options;
    var xField = options.xField, yField = options.yField, fallingFill = options.fallingFill, risingFill = options.risingFill;
    var open = yField[0], close = yField[1], high = yField[2], low = yField[3];
    var getFieldData = fieldAdapter(xField);
    params2.options.children = (0, import_lodash4.map)(params2.options.children, function(child, index3) {
      var isShadow = index3 === 0;
      return __assign14(__assign14({}, child), { tooltip: {
        title: function(d3, i, data2) {
          var v = getFieldData(d3, i, data2);
          return v instanceof Date ? v.toLocaleString() : v;
        },
        items: [{ field: high }, { field: low }, { field: open }, { field: close }]
      }, encode: __assign14(__assign14({}, child.encode || {}), { y: isShadow ? [high, low] : [open, close], color: function(d3) {
        return Math.sign(d3[close] - d3[open]);
      } }), style: __assign14(__assign14({}, child.style || {}), { lineWidth: isShadow ? 1 : 10 }) });
    });
    delete options["yField"];
    params2.options.legend = {
      color: false
    };
    if (fallingFill) {
      (0, import_lodash4.set)(params2, "options.scale.color.range[0]", fallingFill);
    }
    if (risingFill) {
      (0, import_lodash4.set)(params2, "options.scale.color.range[2]", risingFill);
    }
    return params2;
  };
  return (0, import_lodash4.flow)(transformData2, init, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/stock/index.js
var __extends19 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DEFAULT_COLORS = ["#26a69a", "#999999", "#ef5350"];
var Stock = (
  /** @class */
  function(_super) {
    __extends19(Stock2, _super);
    function Stock2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "stock";
      return _this2;
    }
    Stock2.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          color: {
            domain: [-1, 0, 1],
            range: DEFAULT_COLORS
          },
          y: { nice: true }
        },
        children: [
          // shadow
          {
            type: "link"
          },
          // real body
          {
            type: "link"
          }
        ],
        axis: {
          x: { title: false, grid: false },
          y: { title: false, grid: true, gridLineDash: null }
        },
        animate: { enter: { type: "scaleInY" } },
        interaction: {
          tooltip: {
            shared: true,
            marker: false,
            groupName: false,
            crosshairs: true
          }
        }
      };
    };
    Stock2.prototype.getDefaultOptions = function() {
      return Stock2.getDefaultOptions();
    };
    Stock2.prototype.getSchemaAdaptor = function() {
      return adaptor10;
    };
    return Stock2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-line/adaptor.js
function adaptor11(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-line/index.js
var __extends20 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyLine = (
  /** @class */
  function(_super) {
    __extends20(TinyLine2, _super);
    function TinyLine2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "TinyLine";
      return _this2;
    }
    TinyLine2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "line", axis: false }],
        animate: {
          enter: { type: "growInX", duration: 500 }
        },
        padding: 0,
        margin: 0,
        tooltip: false
      };
    };
    TinyLine2.prototype.getDefaultOptions = function() {
      return TinyLine2.getDefaultOptions();
    };
    TinyLine2.prototype.getSchemaAdaptor = function() {
      return adaptor11;
    };
    return TinyLine2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-area/adaptor.js
function adaptor12(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-area/index.js
var __extends21 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyArea = (
  /** @class */
  function(_super) {
    __extends21(TinyArea2, _super);
    function TinyArea2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "TinyArea";
      return _this2;
    }
    TinyArea2.getDefaultOptions = function() {
      return {
        type: "view",
        animate: {
          enter: { type: "growInX", duration: 500 }
        },
        children: [{ type: "area", axis: false }],
        padding: 0,
        margin: 0,
        tooltip: false
      };
    };
    TinyArea2.prototype.getDefaultOptions = function() {
      return TinyArea2.getDefaultOptions();
    };
    TinyArea2.prototype.getSchemaAdaptor = function() {
      return adaptor12;
    };
    return TinyArea2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-column/adaptor.js
function adaptor13(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-column/index.js
var __extends22 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyColumn = (
  /** @class */
  function(_super) {
    __extends22(TinyColumn2, _super);
    function TinyColumn2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "TinyColumn";
      return _this2;
    }
    TinyColumn2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval", axis: false }],
        padding: 0,
        margin: 0,
        tooltip: false
      };
    };
    TinyColumn2.prototype.getDefaultOptions = function() {
      return TinyColumn2.getDefaultOptions();
    };
    TinyColumn2.prototype.getSchemaAdaptor = function() {
      return adaptor13;
    };
    return TinyColumn2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-progress/adaptor.js
var __assign15 = function() {
  __assign15 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign15.apply(this, arguments);
};
function adaptor14(params) {
  var transformData2 = function(params2) {
    var options = params2.options;
    var percent2 = options.percent, _a2 = options.color, color3 = _a2 === void 0 ? [] : _a2;
    if (!percent2)
      return params2;
    var transformOption = {
      scale: {
        color: { range: color3.length ? color3 : [] }
      },
      data: [1, percent2]
    };
    Object.assign(options, __assign15({}, transformOption));
    return params2;
  };
  return (0, import_lodash4.flow)(transformData2, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-progress/index.js
var __extends23 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyProgress = (
  /** @class */
  function(_super) {
    __extends23(TinyProgress2, _super);
    function TinyProgress2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "TinyProgress";
      return _this2;
    }
    TinyProgress2.getDefaultOptions = function() {
      return {
        type: "view",
        data: [],
        margin: 0,
        padding: 0,
        tooltip: false,
        children: [
          {
            interaction: { tooltip: false },
            coordinate: { transform: [{ type: "transpose" }] },
            type: "interval",
            axis: false,
            legend: false,
            encode: { y: function(d3) {
              return d3;
            }, color: function(d3, idx) {
              return idx;
            } }
          }
        ]
      };
    };
    TinyProgress2.prototype.getDefaultOptions = function() {
      return TinyProgress2.getDefaultOptions();
    };
    TinyProgress2.prototype.getSchemaAdaptor = function() {
      return adaptor14;
    };
    return TinyProgress2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-ring/adaptor.js
var __assign16 = function() {
  __assign16 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign16.apply(this, arguments);
};
function adaptor15(params) {
  var radius = function(params2) {
    var options = params2.options;
    var _a2 = options.radius, radius2 = _a2 === void 0 ? 0.8 : _a2;
    (0, import_lodash4.set)(params2, "options.coordinate.innerRadius", radius2);
    return params2;
  };
  var transformData2 = function(params2) {
    var options = params2.options;
    var percent2 = options.percent, _a2 = options.color, color3 = _a2 === void 0 ? [] : _a2;
    if (!percent2)
      return params2;
    var transformOption = {
      scale: {
        color: { range: color3.length ? color3 : [] }
      },
      data: [1, percent2]
    };
    Object.assign(options, __assign16({}, transformOption));
    return params2;
  };
  return (0, import_lodash4.flow)(radius, transformData2, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-ring/index.js
var __extends24 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyRing = (
  /** @class */
  function(_super) {
    __extends24(TinyRing2, _super);
    function TinyRing2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "TinyRing";
      return _this2;
    }
    TinyRing2.getDefaultOptions = function() {
      return {
        type: "view",
        data: [],
        margin: 0,
        padding: 0,
        coordinate: { type: "theta" },
        animate: { enter: { type: "waveIn" } },
        interaction: { tooltip: false },
        tooltip: false,
        children: [
          {
            type: "interval",
            axis: false,
            legend: false,
            encode: { y: function(d3) {
              return d3;
            }, color: function(d3, idx) {
              return idx;
            } }
          }
        ]
      };
    };
    TinyRing2.prototype.getDefaultOptions = function() {
      return TinyRing2.getDefaultOptions();
    };
    TinyRing2.prototype.getSchemaAdaptor = function() {
      return adaptor15;
    };
    return TinyRing2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/rose/adaptor.js
function adaptor16(params) {
  return (0, import_lodash4.flow)(transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/rose/index.js
var __extends25 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Rose = (
  /** @class */
  function(_super) {
    __extends25(Rose2, _super);
    function Rose2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "rose";
      return _this2;
    }
    Rose2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval" }],
        coordinate: { type: "polar" },
        animate: { enter: { type: "waveIn" } }
      };
    };
    Rose2.prototype.getDefaultOptions = function() {
      return Rose2.getDefaultOptions();
    };
    Rose2.prototype.getSchemaAdaptor = function() {
      return adaptor16;
    };
    return Rose2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/waterfall/constants.js
var START_KEY = "__start__";
var END_KEY = "__end__";
var WATERFALL_VALUE = "__waterfall_value__";

// node_modules/@ant-design/plots/es/core/plots/waterfall/adaptor.js
var __assign17 = function() {
  __assign17 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign17.apply(this, arguments);
};
var __spreadArray9 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function adaptor17(params) {
  var transformData2 = function(params2) {
    var options = params2.options;
    var _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2, yField = options.yField;
    if (!data2.length)
      return params2;
    data2.reduce(function(prev, cur, index3) {
      var _a3;
      var getFieldData = fieldAdapter(yField);
      var newCur = getFieldData(cur, index3, data2);
      if (index3 === 0 || cur.isTotal) {
        cur[START_KEY] = 0;
        cur[END_KEY] = newCur;
        cur[WATERFALL_VALUE] = newCur;
      } else {
        var start = (_a3 = prev[END_KEY]) !== null && _a3 !== void 0 ? _a3 : getFieldData(prev, index3, data2);
        cur[START_KEY] = start;
        cur[END_KEY] = start + newCur;
        cur[WATERFALL_VALUE] = prev[END_KEY];
      }
      return cur;
    }, []);
    Object.assign(options, { yField: [START_KEY, END_KEY] });
    return params2;
  };
  var link3 = function(params2) {
    var options = params2.options;
    var _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2, xField = options.xField, children = options.children, linkStyle = options.linkStyle;
    var linkData = __spreadArray9([], data2, true);
    linkData.reduce(function(prev, cur, index3) {
      if (index3 > 0) {
        cur.x1 = prev[xField];
        cur.x2 = cur[xField];
        cur.y1 = prev[END_KEY];
      }
      return cur;
    }, []);
    linkData.shift();
    children.push({
      type: "link",
      xField: ["x1", "x2"],
      yField: "y1",
      // 防止动画或 scrollbar 重绘时 link 层级高于 interval
      zIndex: -1,
      data: linkData,
      style: __assign17({ stroke: "#697474" }, linkStyle),
      label: false,
      tooltip: false
    });
    return params2;
  };
  return (0, import_lodash4.flow)(transformData2, link3, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/waterfall/index.js
var __extends26 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Waterfall = (
  /** @class */
  function(_super) {
    __extends26(Waterfall2, _super);
    function Waterfall2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "waterfall";
      return _this2;
    }
    Waterfall2.getDefaultOptions = function() {
      return {
        type: "view",
        legend: null,
        tooltip: {
          field: WATERFALL_VALUE,
          valueFormatter: "~s",
          name: "value"
        },
        axis: {
          y: {
            title: null,
            labelFormatter: "~s"
          },
          x: {
            title: null
          }
        },
        children: [
          {
            type: "interval",
            interaction: {
              elementHighlight: {
                background: true
              }
            }
          }
        ]
      };
    };
    Waterfall2.prototype.getDefaultOptions = function() {
      return Waterfall2.getDefaultOptions();
    };
    Waterfall2.prototype.getSchemaAdaptor = function() {
      return adaptor17;
    };
    return Waterfall2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/histogram/adaptor.js
function adaptor18(params) {
  var transformHistogramConfig = function(params2) {
    var options = params2.options;
    var data2 = options.data, binNumber = options.binNumber, binWidth = options.binWidth, children = options.children, _a2 = options.channel, channel = _a2 === void 0 ? "count" : _a2;
    var targetTransform = (0, import_lodash4.get)(children, "[0].transform[0]", {});
    if ((0, import_lodash4.isNumber)(binWidth)) {
      (0, import_lodash4.assign)(targetTransform, { thresholds: (0, import_lodash4.ceil)((0, import_lodash4.divide)(data2.length, binWidth)), y: channel });
      return params2;
    }
    if ((0, import_lodash4.isNumber)(binNumber)) {
      (0, import_lodash4.assign)(targetTransform, { thresholds: binNumber, y: channel });
      return params2;
    }
    return params2;
  };
  return (0, import_lodash4.flow)(transformHistogramConfig, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/histogram/index.js
var __extends27 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Histogram = (
  /** @class */
  function(_super) {
    __extends27(Histogram2, _super);
    function Histogram2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "Histogram";
      return _this2;
    }
    Histogram2.getDefaultOptions = function() {
      return {
        type: "view",
        autoFit: true,
        axis: {
          y: { title: false },
          x: { title: false }
        },
        children: [
          {
            type: "rect",
            transform: [{ type: "binX", y: "count" }],
            interaction: {
              elementHighlight: {
                background: true
              }
            }
          }
        ]
      };
    };
    Histogram2.prototype.getDefaultOptions = function() {
      return Histogram2.getDefaultOptions();
    };
    Histogram2.prototype.getSchemaAdaptor = function() {
      return adaptor18;
    };
    return Histogram2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/heatmap/adaptor.js
function adaptor19(params) {
  var tooltip2 = function(params2) {
    var options = params2.options;
    var _a2 = options.tooltip, tooltip3 = _a2 === void 0 ? {} : _a2, colorField = options.colorField, sizeField = options.sizeField;
    if (tooltip3 && !tooltip3.field) {
      tooltip3.field = colorField || sizeField;
    }
    return params2;
  };
  var transformMark = function(params2) {
    var options = params2.options;
    var mark2 = options.mark, children = options.children;
    if (mark2) {
      children[0].type = mark2;
    }
    return params2;
  };
  return (0, import_lodash4.flow)(tooltip2, transformMark, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/heatmap/index.js
var __extends28 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Heatmap3 = (
  /** @class */
  function(_super) {
    __extends28(Heatmap4, _super);
    function Heatmap4() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "heatmap";
      return _this2;
    }
    Heatmap4.getDefaultOptions = function() {
      return {
        type: "view",
        legend: null,
        tooltip: {
          valueFormatter: "~s"
        },
        axis: {
          y: {
            title: null,
            grid: true
          },
          x: {
            title: null,
            grid: true
          }
        },
        children: [
          {
            type: "point",
            interaction: {
              elementHighlight: {
                background: true
              }
            }
          }
        ]
      };
    };
    Heatmap4.prototype.getDefaultOptions = function() {
      return Heatmap4.getDefaultOptions();
    };
    Heatmap4.prototype.getSchemaAdaptor = function() {
      return adaptor19;
    };
    return Heatmap4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/box/adaptor.js
function adaptor20(params) {
  var init = function(params2) {
    var _a2 = params2.options.boxType, boxType = _a2 === void 0 ? "box" : _a2;
    params2.options.children[0].type = boxType;
    return params2;
  };
  return (0, import_lodash4.flow)(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/box/index.js
var __extends29 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Box3 = (
  /** @class */
  function(_super) {
    __extends29(Box4, _super);
    function Box4() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "box";
      return _this2;
    }
    Box4.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "box" }],
        axis: {
          y: { title: false },
          x: { title: false }
        },
        // 默认 tooltip
        tooltip: {
          items: [
            { name: "min", channel: "y" },
            { name: "q1", channel: "y1" },
            { name: "q2", channel: "y2" },
            { name: "q3", channel: "y3" },
            { name: "max", channel: "y4" }
          ]
        }
      };
    };
    Box4.prototype.getDefaultOptions = function() {
      return Box4.getDefaultOptions();
    };
    Box4.prototype.getSchemaAdaptor = function() {
      return adaptor20;
    };
    return Box4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/sankey/adaptor.js
function adaptor21(params) {
  var dataTransform4 = function(params2) {
    var options = params2.options;
    var data2 = options.data;
    var defaultTransform = [
      {
        type: "custom",
        callback: function(datum) {
          return { links: datum };
        }
      }
    ];
    if ((0, import_lodash4.isArray)(data2)) {
      if (data2.length > 0) {
        (0, import_lodash4.set)(options, "data", {
          value: data2,
          transform: defaultTransform
        });
      } else {
        delete options.children;
      }
    } else if ((0, import_lodash4.get)(data2, "type") === "fetch" && (0, import_lodash4.get)(data2, "value")) {
      var transform2 = (0, import_lodash4.get)(data2, "transform");
      if ((0, import_lodash4.isArray)(transform2)) {
        (0, import_lodash4.set)(data2, "transform", transform2.concat(defaultTransform));
      } else {
        (0, import_lodash4.set)(data2, "transform", defaultTransform);
      }
    }
    return params2;
  };
  return (0, import_lodash4.flow)(dataTransform4, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/sankey/index.js
var __extends30 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Sankey4 = (
  /** @class */
  function(_super) {
    __extends30(Sankey5, _super);
    function Sankey5() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "sankey";
      return _this2;
    }
    Sankey5.getDefaultOptions = function() {
      return { type: "view", children: [{ type: "sankey" }] };
    };
    Sankey5.prototype.getDefaultOptions = function() {
      return Sankey5.getDefaultOptions();
    };
    Sankey5.prototype.getSchemaAdaptor = function() {
      return adaptor21;
    };
    return Sankey5;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/bullet/adaptor.js
var __assign18 = function() {
  __assign18 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign18.apply(this, arguments);
};
var DEFAULT_COLORS2 = ["#f0efff", "#5B8FF9", "#3D76DD"];
function getTransformData(data2, field3, xField, isSort) {
  if (isSort === void 0) {
    isSort = true;
  }
  var maxSize = 0;
  var isArrayData = false;
  var transformData2 = (0, import_lodash4.map)(data2, function(d3) {
    var _a2, _b;
    var fieldData = (0, import_lodash4.get)(d3, [field3]);
    if ((0, import_lodash4.isNil)(fieldData))
      return [];
    if ((0, import_lodash4.isString)(fieldData)) {
      var numberData = Number(fieldData);
      if (isNaN(numberData))
        return [];
      return _a2 = {}, _a2[xField] = d3[xField], _a2[field3] = numberData, _a2;
    }
    if ((0, import_lodash4.isArray)(fieldData)) {
      isArrayData = true;
      maxSize = Math.max(maxSize, fieldData.length);
      return (0, import_lodash4.map)(isSort ? fieldData.sort(function(a4, b) {
        return b - a4;
      }) : fieldData, function(value2, index3) {
        var _a3;
        return _a3 = {}, _a3[xField] = d3[xField], _a3[field3] = value2, _a3.index = index3, _a3;
      });
    }
    maxSize = Math.max(1, maxSize);
    return _b = {}, _b[xField] = d3[xField], _b[field3] = fieldData, _b;
  }).flat();
  if (isArrayData) {
    return [
      transformData2.map(function(item) {
        return __assign18({ index: 0 }, item);
      }),
      maxSize
    ];
  }
  return [transformData2, maxSize];
}
function getFieldColor(maxSize, color3) {
  return new Array(maxSize).fill("").map(function(d3, i) {
    return (0, import_lodash4.isArray)(color3) ? color3[i % color3.length] : color3;
  });
}
function adaptor22(params) {
  var init = function(params2) {
    var _a2 = params2.options, color3 = _a2.color, _b = _a2.rangeField, rangeField = _b === void 0 ? "ranges" : _b, _c = _a2.measureField, measureField = _c === void 0 ? "measures" : _c, _d = _a2.targetField, targetField = _d === void 0 ? "targets" : _d, _e = _a2.xField, xField = _e === void 0 ? "title" : _e, mapField = _a2.mapField, data2 = _a2.data;
    var _f = getTransformData(data2, rangeField, xField), rangesData = _f[0], rangesMaxSize = _f[1];
    var _g = getTransformData(data2, measureField, xField, false), measuresData = _g[0], measuresMaxSize = _g[1];
    var _h = getTransformData(data2, targetField, xField, false), targetsData = _h[0], targetsMaxSize = _h[1];
    var rangesColor = (0, import_lodash4.get)(color3, [rangeField], DEFAULT_COLORS2[0]);
    var measuresColor = (0, import_lodash4.get)(color3, [measureField], DEFAULT_COLORS2[1]);
    var targetsColor = (0, import_lodash4.get)(color3, [targetField], DEFAULT_COLORS2[2]);
    var colors = [
      getFieldColor(rangesMaxSize, rangesColor),
      getFieldColor(measuresMaxSize, measuresColor),
      getFieldColor(targetsMaxSize, targetsColor)
    ].flat();
    params2.options.children = (0, import_lodash4.map)(params2.options.children, function(c5, i) {
      var datas = [rangesData, measuresData, targetsData][i];
      var yField = [rangeField, measureField, targetField][i];
      return __assign18(__assign18({}, c5), {
        data: datas,
        encode: __assign18(__assign18({}, c5.encode || {}), { x: xField, y: yField, color: function(d3) {
          var index3 = d3.index;
          var mapString = (0, import_lodash4.isNumber)(index3) ? "".concat(yField, "_").concat(index3) : yField;
          return mapField ? (0, import_lodash4.get)(mapField, [yField, index3], mapString) : mapString;
        } }),
        style: __assign18(__assign18({}, c5.style || {}), {
          // 层级
          zIndex: function(d3) {
            return -d3[yField];
          }
        }),
        // labels 对应的 yField
        labels: i !== 0 ? (0, import_lodash4.map)(c5.labels, function(l) {
          return __assign18(__assign18({}, l), { text: yField });
        }) : void 0
      });
    });
    params2.options.scale.color.range = colors;
    params2.options.legend.color.itemMarker = function(d3) {
      if (mapField && (0, import_lodash4.includes)(mapField === null || mapField === void 0 ? void 0 : mapField[targetField], d3)) {
        return "line";
      }
      return (d3 === null || d3 === void 0 ? void 0 : d3.replace(/\_\d$/, "")) === targetField ? "line" : "square";
    };
    return params2;
  };
  var layoutAdaptor = function(params2) {
    var _a2 = params2.options.layout, layout = _a2 === void 0 ? "horizontal" : _a2;
    if (layout !== "horizontal") {
      (0, import_lodash4.set)(params2, "options.children[2].shapeField", "hyphen");
    }
    return params2;
  };
  var cfgAdaptor = function(params2) {
    var _a2 = params2.options, _b = _a2.range, range3 = _b === void 0 ? {} : _b, _c = _a2.measure, measure = _c === void 0 ? {} : _c, _d = _a2.target, target = _d === void 0 ? {} : _d, children = _a2.children;
    params2.options.children = [range3, measure, target].map(function(c5, i) {
      return mergeWithArrayCoverage(children[i], c5);
    });
    return params2;
  };
  return (0, import_lodash4.flow)(init, layoutAdaptor, cfgAdaptor, allCoordinateLayout, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/bullet/index.js
var __extends31 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Bullet = (
  /** @class */
  function(_super) {
    __extends31(Bullet2, _super);
    function Bullet2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "bullet";
      return _this2;
    }
    Bullet2.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          color: {
            range: DEFAULT_COLORS2
          }
        },
        legend: {
          color: {
            itemMarker: function(d3) {
              return d3 === "target" ? "line" : "square";
            }
          }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        children: [
          {
            type: "interval",
            style: { maxWidth: 30 },
            axis: { y: { grid: true, gridLineWidth: 2 } }
          },
          {
            type: "interval",
            style: { maxWidth: 20 },
            transform: [{ type: "stackY" }]
          },
          {
            type: "point",
            encode: { size: 8, shape: "line" }
          }
        ],
        interaction: { tooltip: { shared: true } },
        coordinate: { transform: [{ type: "transpose" }] }
      };
    };
    Bullet2.prototype.getDefaultOptions = function() {
      return Bullet2.getDefaultOptions();
    };
    Bullet2.prototype.getSchemaAdaptor = function() {
      return adaptor22;
    };
    return Bullet2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/gauge/adaptor.js
function adaptor23(params) {
  var init = function(params2) {
    var data2 = params2.options.data;
    params2.options.data = {
      value: data2
    };
    return params2;
  };
  return (0, import_lodash4.flow)(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/gauge/index.js
var __extends32 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Gauge2 = (
  /** @class */
  function(_super) {
    __extends32(Gauge3, _super);
    function Gauge3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "Gauge";
      return _this2;
    }
    Gauge3.getDefaultOptions = function() {
      return {
        type: "view",
        legend: false,
        children: [{ type: "gauge" }]
      };
    };
    Gauge3.prototype.getDefaultOptions = function() {
      return Gauge3.getDefaultOptions();
    };
    Gauge3.prototype.getSchemaAdaptor = function() {
      return adaptor23;
    };
    return Gauge3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/liquid/adaptor.js
function adaptor24(params) {
  var init = function(params2) {
    var percent2 = params2.options.percent;
    if ((0, import_lodash4.isNumber)(percent2)) {
      (0, import_lodash4.set)(params2, "options.data", percent2);
      delete params2.options.percent;
    }
    return params2;
  };
  return (0, import_lodash4.flow)(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/liquid/index.js
var __extends33 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Liquid3 = (
  /** @class */
  function(_super) {
    __extends33(Liquid4, _super);
    function Liquid4() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "Liquid";
      return _this2;
    }
    Liquid4.getDefaultOptions = function() {
      return { type: "view", children: [{ type: "liquid" }] };
    };
    Liquid4.prototype.getDefaultOptions = function() {
      return Liquid4.getDefaultOptions();
    };
    Liquid4.prototype.getSchemaAdaptor = function() {
      return adaptor24;
    };
    return Liquid4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/wordCloud/adaptor.js
function adaptor25(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/wordCloud/index.js
var __extends34 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var WordCloud3 = (
  /** @class */
  function(_super) {
    __extends34(WordCloud4, _super);
    function WordCloud4() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "WordCloud";
      return _this2;
    }
    WordCloud4.getDefaultOptions = function() {
      return { type: "view", legend: false, children: [{ type: "wordCloud" }] };
    };
    WordCloud4.prototype.getDefaultOptions = function() {
      return WordCloud4.getDefaultOptions();
    };
    WordCloud4.prototype.getSchemaAdaptor = function() {
      return adaptor25;
    };
    return WordCloud4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/treemap/adaptor.js
function adaptor26(params) {
  var init = function(params2) {
    var options = params2.options;
    var data2 = options.data;
    if (data2) {
      (0, import_lodash4.set)(options, "data", {
        value: data2
      });
    }
    return params2;
  };
  return (0, import_lodash4.flow)(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/treemap/index.js
var __extends35 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Treemap2 = (
  /** @class */
  function(_super) {
    __extends35(Treemap3, _super);
    function Treemap3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "treemap";
      return _this2;
    }
    Treemap3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [
          {
            type: "treemap"
          }
        ]
      };
    };
    Treemap3.prototype.getDefaultOptions = function() {
      return Treemap3.getDefaultOptions();
    };
    Treemap3.prototype.getSchemaAdaptor = function() {
      return adaptor26;
    };
    return Treemap3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/radial-bar/adaptor.js
var __assign19 = function() {
  __assign19 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign19.apply(this, arguments);
};
function adaptor27(params) {
  var coordinate = function(params2) {
    var options = params2.options;
    var startAngle = options.startAngle, maxAngle = options.maxAngle, coordinate2 = options.coordinate;
    var start = (0, import_lodash4.isNumber)(startAngle) ? startAngle / (2 * Math.PI) * 360 : -90;
    var end = (0, import_lodash4.isNumber)(maxAngle) ? (Number(maxAngle) + start) / 180 * Math.PI : Math.PI;
    (0, import_lodash4.set)(params2, ["options", "coordinate"], __assign19(__assign19({}, coordinate2), { endAngle: end, startAngle: startAngle !== null && startAngle !== void 0 ? startAngle : -Math.PI / 2 }));
    return params2;
  };
  var tooltip2 = function(params2) {
    var options = params2.options;
    var tooltip3 = options.tooltip, xField = options.xField, yField = options.yField;
    var getXFieldData = fieldAdapter(xField);
    var getYFieldData = fieldAdapter(yField);
    if (!tooltip3) {
      (0, import_lodash4.set)(options, "tooltip", {
        title: false,
        items: [function(d3, i, data2) {
          return { name: getXFieldData(d3, i, data2), value: getYFieldData(d3, i, data2) };
        }]
      });
    }
    return params2;
  };
  var background = function(params2) {
    var options = params2.options;
    var markBackground = options.markBackground, children = options.children, scale11 = options.scale, coordinate2 = options.coordinate, xField = options.xField;
    var domain = (0, import_lodash4.get)(scale11, "y.domain", []);
    if (markBackground) {
      children.unshift(__assign19({
        type: "interval",
        xField,
        yField: domain[domain.length - 1],
        colorField: markBackground.color,
        scale: { color: { type: "identity" } },
        style: {
          fillOpacity: markBackground.opacity,
          fill: markBackground.color ? void 0 : "#e0e4ee"
          // 默认用fill填满灰色背景
        },
        // 背景图需要填满整个圆
        coordinate: __assign19(__assign19({}, coordinate2), { startAngle: -Math.PI / 2, endAngle: 3 / 2 * Math.PI }),
        animate: false
      }, markBackground));
    }
    return params2;
  };
  return (0, import_lodash4.flow)(coordinate, tooltip2, background, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/radial-bar/index.js
var __extends36 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RadialBar = (
  /** @class */
  function(_super) {
    __extends36(RadialBar3, _super);
    function RadialBar3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "radial";
      return _this2;
    }
    RadialBar3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval" }],
        coordinate: { type: "radial", innerRadius: 0.1, outerRadius: 1, endAngle: Math.PI },
        animate: { enter: { type: "waveIn", duration: 800 } },
        axis: {
          y: {
            nice: true,
            labelAutoHide: true,
            labelAutoRotate: false
          },
          x: {
            title: false,
            nice: true,
            labelAutoRotate: false,
            labelAutoHide: { type: "equidistance", cfg: { minGap: 6 } }
          }
        }
      };
    };
    RadialBar3.prototype.getDefaultOptions = function() {
      return RadialBar3.getDefaultOptions();
    };
    RadialBar3.prototype.getSchemaAdaptor = function() {
      return adaptor27;
    };
    return RadialBar3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/circlePacking/adaptor.js
function adaptor28(params) {
  return (0, import_lodash4.flow)(transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/circlePacking/index.js
var __extends37 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CirclePacking = (
  /** @class */
  function(_super) {
    __extends37(CirclePacking2, _super);
    function CirclePacking2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "CirclePacking";
      return _this2;
    }
    CirclePacking2.getDefaultOptions = function() {
      return {
        legend: false,
        type: "view",
        children: [
          {
            type: "pack"
          }
        ]
      };
    };
    CirclePacking2.prototype.getDefaultOptions = function() {
      return CirclePacking2.getDefaultOptions();
    };
    CirclePacking2.prototype.getSchemaAdaptor = function() {
      return adaptor28;
    };
    return CirclePacking2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/violin/adaptor.js
var __assign20 = function() {
  __assign20 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign20.apply(this, arguments);
};
function adaptor29(params) {
  var customTransform = function(params2) {
    var options = params2.options;
    var xField = options.xField, yField = options.yField, seriesField = options.seriesField, children = options.children;
    var newChildren = children === null || children === void 0 ? void 0 : children.map(function(item) {
      return __assign20(__assign20({}, item), { xField, yField, seriesField, colorField: seriesField, data: item.type === "density" ? {
        transform: [
          {
            type: "kde",
            field: yField,
            groupBy: [xField, seriesField]
          }
        ]
      } : item.data });
    }).filter(function(item) {
      return options.violinType !== "density" || item.type === "density";
    });
    (0, import_lodash4.set)(options, "children", newChildren);
    if (options.violinType === "polar") {
      (0, import_lodash4.set)(options, "coordinate", { type: "polar" });
    }
    (0, import_lodash4.set)(options, "violinType", void 0);
    return params2;
  };
  return (0, import_lodash4.flow)(customTransform, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/violin/index.js
var __extends38 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Violin2 = (
  /** @class */
  function(_super) {
    __extends38(Violin3, _super);
    function Violin3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "violin";
      return _this2;
    }
    Violin3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [
          {
            type: "density",
            sizeField: "size",
            tooltip: false
          },
          {
            type: "boxplot",
            shapeField: "violin",
            style: {
              opacity: 0.5,
              point: false
            }
          }
        ],
        animate: { enter: { type: "fadeIn" } }
      };
    };
    Violin3.prototype.getDefaultOptions = function() {
      return Violin3.getDefaultOptions();
    };
    Violin3.prototype.getSchemaAdaptor = function() {
      return adaptor29;
    };
    return Violin3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/bidirectional-bar/adaptor.js
var __assign21 = function() {
  __assign21 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign21.apply(this, arguments);
};
var __spreadArray10 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function adaptor30(params) {
  var field3 = function(params2) {
    var options = params2.options;
    var yField = options.yField, children = options.children;
    children.forEach(function(child, index3) {
      (0, import_lodash4.set)(child, "yField", yField[index3]);
    });
    return params2;
  };
  var data2 = function(params2) {
    var options = params2.options;
    var yField = options.yField, children = options.children, data3 = options.data;
    if ((0, import_lodash4.isPlainObject)(data3))
      return params2;
    var transformData2 = (0, import_lodash4.isArray)((0, import_lodash4.get)(data3, [0])) ? data3 : [data3, data3];
    children.forEach(function(child, index3) {
      (0, import_lodash4.set)(child, "data", __spreadArray10([], transformData2[index3].map(function(item) {
        return __assign21({ groupKey: yField[index3] }, item);
      }), true));
    });
    return params2;
  };
  var tooltip2 = function(params2) {
    var options = params2.options;
    var _a2 = options.yField, y12 = _a2[0], y22 = _a2[1], tooltip3 = options.tooltip;
    if (!tooltip3) {
      (0, import_lodash4.set)(options, "tooltip", {
        items: [
          {
            field: y12,
            value: y12
          },
          {
            field: y22,
            value: y22
          }
        ]
      });
    }
    return params2;
  };
  var layout = function(params2) {
    var options = params2.options;
    var children = options.children, layout2 = options.layout, transform2 = options.coordinate.transform, _a2 = options.paddingBottom, paddingBottom = _a2 === void 0 ? AXIS_LABEL_PADDING : _a2, _b = options.paddingLeft, paddingLeft = _b === void 0 ? AXIS_LABEL_PADDING : _b, axis = options.axis;
    (0, import_lodash4.set)(options, "axisText", __assign21(__assign21({}, (axis === null || axis === void 0 ? void 0 : axis.x) || {}), { layout: layout2 }));
    var child1 = children[0], child2 = children[1];
    if (layout2 === "vertical") {
      (0, import_lodash4.set)(options, "direction", "col");
      (0, import_lodash4.set)(options, "paddingLeft", paddingLeft);
      (0, import_lodash4.set)(options, "coordinate.transform", transform2.filter(function(item) {
        return item.type !== "transpose";
      }));
      (0, import_lodash4.set)(child1, "paddingBottom", HORIZONTAL_MARGIN);
      (0, import_lodash4.set)(child2, "paddingTop", HORIZONTAL_MARGIN);
      (0, import_lodash4.set)(child2, "axis", {
        x: {
          position: "top"
        }
      });
      (0, import_lodash4.set)(child2, "scale", {
        y: {
          range: [0, 1]
        }
      });
    } else {
      (0, import_lodash4.set)(options, "paddingBottom", paddingBottom);
      (0, import_lodash4.set)(child1, "scale", {
        y: {
          range: [0, 1]
        }
      });
      var _c = child1.paddingRight, paddingRight = _c === void 0 ? VERTICAL_MARGIN : _c;
      var _d = child2.paddingLeft, paddingLeft_1 = _d === void 0 ? VERTICAL_MARGIN : _d;
      (0, import_lodash4.set)(child1, "paddingRight", paddingRight);
      (0, import_lodash4.set)(child1, "axis", {
        x: {
          position: "right"
        }
      });
      (0, import_lodash4.set)(child2, "paddingLeft", paddingLeft_1);
    }
    return params2;
  };
  return (0, import_lodash4.flow)(field3, data2, tooltip2, layout, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/bidirectional-bar/index.js
var __extends39 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BidirectionalBar = (
  /** @class */
  function(_super) {
    __extends39(BidirectionalBar2, _super);
    function BidirectionalBar2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "BidirectionalBar";
      return _this2;
    }
    BidirectionalBar2.getDefaultOptions = function() {
      return {
        type: "spaceFlex",
        coordinate: { transform: [{ type: "transpose" }] },
        scale: {
          y: { nice: true }
        },
        direction: "row",
        layout: "horizontal",
        legend: false,
        axis: {
          y: {
            title: false
          },
          x: { title: false, label: false }
        },
        children: [{ type: "interval" }, { type: "interval" }]
      };
    };
    BidirectionalBar2.prototype.getDefaultOptions = function() {
      return BidirectionalBar2.getDefaultOptions();
    };
    BidirectionalBar2.prototype.getSchemaAdaptor = function() {
      return adaptor30;
    };
    return BidirectionalBar2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/venn/type.js
var DefaultTransformKey;
(function(DefaultTransformKey2) {
  DefaultTransformKey2["color"] = "key";
  DefaultTransformKey2["d"] = "path";
})(DefaultTransformKey || (DefaultTransformKey = {}));

// node_modules/@ant-design/plots/es/core/plots/venn/adaptor.js
function adaptor31(params) {
  var init = function(params2) {
    var options = params2.options;
    var data2 = options.data, setsField = options.setsField, sizeField = options.sizeField;
    if ((0, import_lodash4.isArray)(data2)) {
      (0, import_lodash4.set)(options, "data", {
        type: "inline",
        value: data2,
        transform: [
          {
            type: "venn",
            sets: setsField,
            size: sizeField,
            as: [DefaultTransformKey.color, DefaultTransformKey.d]
          }
        ]
      });
      (0, import_lodash4.set)(options, "colorField", setsField);
      (0, import_lodash4.set)(options, ["children", "0", "encode", "d"], DefaultTransformKey.d);
    }
    (0, import_lodash4.set)(params2, "options", (0, import_lodash4.omit)(options, ["sizeField", "setsField"]));
    return params2;
  };
  return (0, import_lodash4.flow)(init, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/venn/index.js
var __extends40 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Venn2 = (
  /** @class */
  function(_super) {
    __extends40(Venn3, _super);
    function Venn3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "venn";
      return _this2;
    }
    Venn3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "path" }],
        legend: {
          color: { itemMarker: "circle" }
        },
        encode: { color: DefaultTransformKey.color, d: DefaultTransformKey.d }
      };
    };
    Venn3.prototype.getDefaultOptions = function() {
      return Venn3.getDefaultOptions();
    };
    Venn3.prototype.getSchemaAdaptor = function() {
      return adaptor31;
    };
    return Venn3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/sunburst/adaptor.js
function adaptor32(params) {
  var init = function(params2) {
    return params2;
  };
  return (0, import_lodash4.flow)(init, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/sunburst/index.js
var __extends41 = function() {
  var extendStatics2 = function(d3, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d4[p2] = b2[p2];
    };
    return extendStatics2(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Sunburst2 = (
  /** @class */
  function(_super) {
    __extends41(Sunburst3, _super);
    function Sunburst3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "Sunburst";
      return _this2;
    }
    Sunburst3.getDefaultOptions = function() {
      return { type: "view", children: [{ type: "sunburst" }] };
    };
    Sunburst3.prototype.getDefaultOptions = function() {
      return Sunburst3.getDefaultOptions();
    };
    Sunburst3.prototype.getSchemaAdaptor = function() {
      return adaptor32;
    };
    return Sunburst3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/index.js
var Plots = {
  Base: Base2,
  Line: Line6,
  Column: Column2,
  Pie,
  Area: Area3,
  Bar,
  DualAxes,
  Funnel: Funnel2,
  Scatter,
  Radar: Radar2,
  Rose,
  Stock,
  TinyLine,
  TinyArea,
  TinyColumn,
  TinyProgress,
  TinyRing,
  Waterfall,
  Histogram,
  Heatmap: Heatmap3,
  Box: Box3,
  Sankey: Sankey4,
  Bullet,
  Gauge: Gauge2,
  Liquid: Liquid3,
  WordCloud: WordCloud3,
  Treemap: Treemap2,
  RadialBar,
  CirclePacking,
  Violin: Violin2,
  BidirectionalBar,
  Venn: Venn2,
  Mix: DualAxes,
  Sunburst: Sunburst2
};

// node_modules/@ant-design/plots/es/components/base/index.js
var __assign22 = function() {
  __assign22 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign22.apply(this, arguments);
};
var __rest96 = function(s3, e) {
  var t = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e.indexOf(p2) < 0)
      t[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
        t[p2[i]] = s3[p2[i]];
    }
  return t;
};
var BaseChart = (0, import_react4.forwardRef)(function(_a2, ref) {
  var _b = _a2.chartType, chartType = _b === void 0 ? "Base" : _b, config = __rest96(_a2, ["chartType"]);
  var _c = config.containerStyle, containerStyle = _c === void 0 ? {
    height: "inherit",
    flex: 1
  } : _c, _d = config.containerAttributes, containerAttributes = _d === void 0 ? {} : _d, className2 = config.className, loading = config.loading, loadingTemplate = config.loadingTemplate, errorTemplate = config.errorTemplate, rest = __rest96(config, ["containerStyle", "containerAttributes", "className", "loading", "loadingTemplate", "errorTemplate"]);
  var _e = useChart(Plots[chartType], rest), chart = _e.chart, container = _e.container;
  (0, import_react4.useImperativeHandle)(ref, function() {
    return chart.current;
  });
  return import_react4.default.createElement(
    ErrorBoundary,
    { errorTemplate },
    loading && import_react4.default.createElement(ChartLoading, { loadingTemplate }),
    import_react4.default.createElement("div", __assign22({ className: className2, style: containerStyle, ref: container }, containerAttributes))
  );
});

// node_modules/@ant-design/plots/es/components/area/index.js
var import_react5 = __toESM(require_react());
var __assign23 = function() {
  __assign23 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign23.apply(this, arguments);
};
var AreaChart = (0, import_react5.forwardRef)(function(props, ref) {
  return import_react5.default.createElement(BaseChart, __assign23({}, props, { chartType: "Area", ref }));
});
var area_default4 = AreaChart;

// node_modules/@ant-design/plots/es/components/bar/index.js
var import_react6 = __toESM(require_react());
var __assign24 = function() {
  __assign24 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign24.apply(this, arguments);
};
var BarChart2 = (0, import_react6.forwardRef)(function(props, ref) {
  return import_react6.default.createElement(BaseChart, __assign24({}, props, { chartType: "Bar", ref }));
});
var bar_default = BarChart2;

// node_modules/@ant-design/plots/es/components/column/index.js
var import_react7 = __toESM(require_react());
var __assign25 = function() {
  __assign25 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign25.apply(this, arguments);
};
var ColumnChart = (0, import_react7.forwardRef)(function(props, ref) {
  return import_react7.default.createElement(BaseChart, __assign25({}, props, { chartType: "Column", ref }));
});
var column_default = ColumnChart;

// node_modules/@ant-design/plots/es/components/dual-axes/index.js
var import_react8 = __toESM(require_react());
var __assign26 = function() {
  __assign26 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign26.apply(this, arguments);
};
var DualAxesChart = (0, import_react8.forwardRef)(function(props, ref) {
  return import_react8.default.createElement(BaseChart, __assign26({}, props, { chartType: "DualAxes", ref }));
});
var dual_axes_default = DualAxesChart;

// node_modules/@ant-design/plots/es/components/funnel/index.js
var import_react9 = __toESM(require_react());
var __assign27 = function() {
  __assign27 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign27.apply(this, arguments);
};
var FunnelChart = (0, import_react9.forwardRef)(function(props, ref) {
  return import_react9.default.createElement(BaseChart, __assign27({}, props, { chartType: "Funnel", ref }));
});
var funnel_default = FunnelChart;

// node_modules/@ant-design/plots/es/components/line/index.js
var import_react10 = __toESM(require_react());
var __assign28 = function() {
  __assign28 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign28.apply(this, arguments);
};
var LineChart2 = (0, import_react10.forwardRef)(function(props, ref) {
  return import_react10.default.createElement(BaseChart, __assign28({}, props, { chartType: "Line", ref }));
});
var line_default3 = LineChart2;

// node_modules/@ant-design/plots/es/components/pie/index.js
var import_react11 = __toESM(require_react());
var __assign29 = function() {
  __assign29 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign29.apply(this, arguments);
};
var PieChart = (0, import_react11.forwardRef)(function(props, ref) {
  return import_react11.default.createElement(BaseChart, __assign29({}, props, { chartType: "Pie", ref }));
});
var pie_default2 = PieChart;

// node_modules/@ant-design/plots/es/components/scatter/index.js
var import_react12 = __toESM(require_react());
var __assign30 = function() {
  __assign30 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign30.apply(this, arguments);
};
var ScatterChart = (0, import_react12.forwardRef)(function(props, ref) {
  return import_react12.default.createElement(BaseChart, __assign30({}, props, { chartType: "Scatter", ref }));
});
var scatter_default = ScatterChart;

// node_modules/@ant-design/plots/es/components/radar/index.js
var import_react13 = __toESM(require_react());
var __assign31 = function() {
  __assign31 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign31.apply(this, arguments);
};
var RadarChart = (0, import_react13.forwardRef)(function(props, ref) {
  return import_react13.default.createElement(BaseChart, __assign31({}, props, { chartType: "Radar", ref }));
});
var radar_default = RadarChart;

// node_modules/@ant-design/plots/es/components/tiny/line/index.js
var import_react14 = __toESM(require_react());
var __assign32 = function() {
  __assign32 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign32.apply(this, arguments);
};
var TinyLineChart = (0, import_react14.forwardRef)(function(props, ref) {
  return import_react14.default.createElement(BaseChart, __assign32({}, props, { chartType: "TinyLine", ref }));
});
var line_default4 = TinyLineChart;

// node_modules/@ant-design/plots/es/components/tiny/area/index.js
var import_react15 = __toESM(require_react());
var __assign33 = function() {
  __assign33 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign33.apply(this, arguments);
};
var TinyAreaChart = (0, import_react15.forwardRef)(function(props, ref) {
  return import_react15.default.createElement(BaseChart, __assign33({}, props, { chartType: "TinyArea", ref }));
});
var area_default5 = TinyAreaChart;

// node_modules/@ant-design/plots/es/components/tiny/column/index.js
var import_react16 = __toESM(require_react());
var __assign34 = function() {
  __assign34 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign34.apply(this, arguments);
};
var TinyLineChart2 = (0, import_react16.forwardRef)(function(props, ref) {
  return import_react16.default.createElement(BaseChart, __assign34({}, props, { chartType: "TinyColumn", ref }));
});
var column_default2 = TinyLineChart2;

// node_modules/@ant-design/plots/es/components/tiny/progress/index.js
var import_react17 = __toESM(require_react());
var __assign35 = function() {
  __assign35 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign35.apply(this, arguments);
};
var TinyProgressChart = (0, import_react17.forwardRef)(function(props, ref) {
  return import_react17.default.createElement(BaseChart, __assign35({}, props, { chartType: "TinyProgress", ref }));
});
var progress_default = TinyProgressChart;

// node_modules/@ant-design/plots/es/components/tiny/ring/index.js
var import_react18 = __toESM(require_react());
var __assign36 = function() {
  __assign36 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign36.apply(this, arguments);
};
var TinyRingChart = (0, import_react18.forwardRef)(function(props, ref) {
  return import_react18.default.createElement(BaseChart, __assign36({}, props, { chartType: "TinyRing", ref }));
});
var ring_default = TinyRingChart;

// node_modules/@ant-design/plots/es/components/tiny/index.js
var Tiny = { Line: line_default4, Area: area_default5, Column: column_default2, Progress: progress_default, Ring: ring_default };

// node_modules/@ant-design/plots/es/components/rose/index.js
var import_react19 = __toESM(require_react());
var __assign37 = function() {
  __assign37 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign37.apply(this, arguments);
};
var RoseChart = (0, import_react19.forwardRef)(function(props, ref) {
  return import_react19.default.createElement(BaseChart, __assign37({}, props, { chartType: "Rose", ref }));
});
var rose_default = RoseChart;

// node_modules/@ant-design/plots/es/components/waterfall/index.js
var import_react20 = __toESM(require_react());
var __assign38 = function() {
  __assign38 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign38.apply(this, arguments);
};
var WaterfallChart = (0, import_react20.forwardRef)(function(props, ref) {
  return import_react20.default.createElement(BaseChart, __assign38({}, props, { chartType: "Waterfall", ref }));
});
var waterfall_default = WaterfallChart;

// node_modules/@ant-design/plots/es/components/histogram/index.js
var import_react21 = __toESM(require_react());
var __assign39 = function() {
  __assign39 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign39.apply(this, arguments);
};
var HistogramChart = (0, import_react21.forwardRef)(function(props, ref) {
  return import_react21.default.createElement(BaseChart, __assign39({}, props, { chartType: "Histogram", ref }));
});
var histogram_default = HistogramChart;

// node_modules/@ant-design/plots/es/components/heatmap/index.js
var import_react22 = __toESM(require_react());
var __assign40 = function() {
  __assign40 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign40.apply(this, arguments);
};
var HeatmapChart = (0, import_react22.forwardRef)(function(props, ref) {
  return import_react22.default.createElement(BaseChart, __assign40({}, props, { chartType: "Heatmap", ref }));
});
var heatmap_default = HeatmapChart;

// node_modules/@ant-design/plots/es/components/box/index.js
var import_react23 = __toESM(require_react());
var __assign41 = function() {
  __assign41 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign41.apply(this, arguments);
};
var BoxChart = (0, import_react23.forwardRef)(function(props, ref) {
  return import_react23.default.createElement(BaseChart, __assign41({}, props, { chartType: "Box", ref }));
});
var box_default = BoxChart;

// node_modules/@ant-design/plots/es/components/sankey/index.js
var import_react24 = __toESM(require_react());
var __assign42 = function() {
  __assign42 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign42.apply(this, arguments);
};
var SankeyChart = (0, import_react24.forwardRef)(function(props, ref) {
  return import_react24.default.createElement(BaseChart, __assign42({}, props, { chartType: "Sankey", ref }));
});
var sankey_default = SankeyChart;

// node_modules/@ant-design/plots/es/components/stock/index.js
var import_react25 = __toESM(require_react());
var __assign43 = function() {
  __assign43 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign43.apply(this, arguments);
};
var StockChart = (0, import_react25.forwardRef)(function(props, ref) {
  return import_react25.default.createElement(BaseChart, __assign43({}, props, { chartType: "Stock", ref }));
});
var stock_default = StockChart;

// node_modules/@ant-design/plots/es/components/bullet/index.js
var import_react26 = __toESM(require_react());
var __assign44 = function() {
  __assign44 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign44.apply(this, arguments);
};
var BulletChart = (0, import_react26.forwardRef)(function(props, ref) {
  return import_react26.default.createElement(BaseChart, __assign44({}, props, { chartType: "Bullet", ref }));
});
var bullet_default = BulletChart;

// node_modules/@ant-design/plots/es/components/gauge/index.js
var import_react27 = __toESM(require_react());
var __assign45 = function() {
  __assign45 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign45.apply(this, arguments);
};
var GaugeChart = (0, import_react27.forwardRef)(function(props, ref) {
  return import_react27.default.createElement(BaseChart, __assign45({}, props, { chartType: "Gauge", ref }));
});
var gauge_default = GaugeChart;

// node_modules/@ant-design/plots/es/components/liquid/index.js
var import_react28 = __toESM(require_react());
var __assign46 = function() {
  __assign46 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign46.apply(this, arguments);
};
var LiquidChart = (0, import_react28.forwardRef)(function(props, ref) {
  return import_react28.default.createElement(BaseChart, __assign46({}, props, { chartType: "Liquid", ref }));
});
var liquid_default = LiquidChart;

// node_modules/@ant-design/plots/es/components/wordCloud/index.js
var import_react29 = __toESM(require_react());
var __assign47 = function() {
  __assign47 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign47.apply(this, arguments);
};
var WordCloudChart = (0, import_react29.forwardRef)(function(props, ref) {
  return import_react29.default.createElement(BaseChart, __assign47({}, props, { chartType: "WordCloud", ref }));
});
var wordCloud_default = WordCloudChart;

// node_modules/@ant-design/plots/es/components/treemap/index.js
var import_react30 = __toESM(require_react());
var __assign48 = function() {
  __assign48 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign48.apply(this, arguments);
};
var TreemapChart = (0, import_react30.forwardRef)(function(props, ref) {
  return import_react30.default.createElement(BaseChart, __assign48({}, props, { chartType: "Treemap", ref }));
});
var treemap_default2 = TreemapChart;

// node_modules/@ant-design/plots/es/components/radial-bar/index.js
var import_react31 = __toESM(require_react());
var __assign49 = function() {
  __assign49 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign49.apply(this, arguments);
};
var RadialBar2 = (0, import_react31.forwardRef)(function(props, ref) {
  return import_react31.default.createElement(BaseChart, __assign49({}, props, { chartType: "RadialBar", ref }));
});
var radial_bar_default = RadialBar2;

// node_modules/@ant-design/plots/es/components/circlePacking/index.js
var import_react32 = __toESM(require_react());
var __assign50 = function() {
  __assign50 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign50.apply(this, arguments);
};
var CirclePackingChart = (0, import_react32.forwardRef)(function(props, ref) {
  return import_react32.default.createElement(BaseChart, __assign50({}, props, { chartType: "CirclePacking", ref }));
});
var circlePacking_default = CirclePackingChart;

// node_modules/@ant-design/plots/es/components/violin/index.js
var import_react33 = __toESM(require_react());
var __assign51 = function() {
  __assign51 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign51.apply(this, arguments);
};
var ViolinChart = (0, import_react33.forwardRef)(function(props, ref) {
  return import_react33.default.createElement(BaseChart, __assign51({}, props, { chartType: "Violin", ref }));
});
var violin_default = ViolinChart;

// node_modules/@ant-design/plots/es/components/bidirectional-bar/index.js
var import_react34 = __toESM(require_react());
var __assign52 = function() {
  __assign52 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign52.apply(this, arguments);
};
var BidirectionalBarChart = (0, import_react34.forwardRef)(function(props, ref) {
  return import_react34.default.createElement(BaseChart, __assign52({}, props, { chartType: "BidirectionalBar", ref }));
});
var bidirectional_bar_default = BidirectionalBarChart;

// node_modules/@ant-design/plots/es/components/venn/index.js
var import_react35 = __toESM(require_react());
var __assign53 = function() {
  __assign53 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign53.apply(this, arguments);
};
var VennChart = (0, import_react35.forwardRef)(function(props, ref) {
  return import_react35.default.createElement(BaseChart, __assign53({}, props, { chartType: "Venn", ref }));
});
var venn_default = VennChart;

// node_modules/@ant-design/plots/es/components/mix/index.js
var import_react36 = __toESM(require_react());
var __assign54 = function() {
  __assign54 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign54.apply(this, arguments);
};
var MixChart = (0, import_react36.forwardRef)(function(props, ref) {
  return import_react36.default.createElement(BaseChart, __assign54({}, props, { chartType: "Mix", ref }));
});
var mix_default = MixChart;

// node_modules/@ant-design/plots/es/components/sunburst/index.js
var import_react37 = __toESM(require_react());
var __assign55 = function() {
  __assign55 = Object.assign || function(t) {
    for (var s3, i = 1, n = arguments.length; i < n; i++) {
      s3 = arguments[i];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t[p2] = s3[p2];
    }
    return t;
  };
  return __assign55.apply(this, arguments);
};
var SunburstChart = (0, import_react37.forwardRef)(function(props, ref) {
  return import_react37.default.createElement(BaseChart, __assign55({}, props, { chartType: "Sunburst", ref }));
});
var sunburst_default = SunburstChart;
export {
  area_default4 as Area,
  bar_default as Bar,
  BaseChart as Base,
  bidirectional_bar_default as BidirectionalBar,
  box_default as Box,
  bullet_default as Bullet,
  circlePacking_default as CirclePacking,
  column_default as Column,
  dual_axes_default as DualAxes,
  funnel_default as Funnel,
  esm_exports as G2,
  gauge_default as Gauge,
  heatmap_default as Heatmap,
  histogram_default as Histogram,
  line_default3 as Line,
  liquid_default as Liquid,
  mix_default as Mix,
  pie_default2 as Pie,
  radar_default as Radar,
  radial_bar_default as RadialBar,
  rose_default as Rose,
  sankey_default as Sankey,
  scatter_default as Scatter,
  stock_default as Stock,
  sunburst_default as Sunburst,
  Tiny,
  treemap_default2 as Treemap,
  venn_default as Venn,
  violin_default as Violin,
  waterfall_default as Waterfall,
  wordCloud_default as WordCloud,
  measureTextWidth2 as measureTextWidth
};
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

@antv/g-lite/dist/index.esm.js:
  (*!
   * @antv/g-lite
   * @description A core module for rendering engine implements DOM API.
   * @version 2.2.16
   * @date 1/23/2025, 8:31:51 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-camera-api/dist/index.esm.js:
  (*!
   * @antv/g-camera-api
   * @description A simple implementation of Camera API.
   * @version 2.0.35
   * @date 1/23/2025, 8:32:08 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-dom-mutation-observer-api/dist/index.esm.js:
  (*!
   * @antv/g-dom-mutation-observer-api
   * @description A simple implementation of DOM MutationObserver API.
   * @version 2.0.32
   * @date 1/23/2025, 8:32:22 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-web-animations-api/dist/index.esm.js:
  (*!
   * @antv/g-web-animations-api
   * @description A simple implementation of Web Animations API.
   * @version 2.1.21
   * @date 1/23/2025, 8:33:55 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g/dist/index.esm.js:
  (*!
   * @antv/g
   * @description A core module for rendering engine implements DOM API.
   * @version 6.1.21
   * @date 1/23/2025, 8:34:00 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-canvas-path-generator/dist/index.esm.js:
  (*!
   * @antv/g-plugin-canvas-path-generator
   * @description A G plugin of path generator with Canvas2D API
   * @version 2.1.16
   * @date 1/23/2025, 8:32:57 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-canvas-picker/dist/index.esm.js:
  (*!
   * @antv/g-plugin-canvas-picker
   * @description A G plugin for picking in canvas
   * @version 2.1.19
   * @date 2/27/2025, 8:28:58 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-image-loader/dist/index.esm.js:
  (*!
   * @antv/g-plugin-image-loader
   * @description A G plugin for loading image
   * @version 2.1.19
   * @date 2/27/2025, 8:27:22 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-canvas-renderer/dist/index.esm.js:
  (*!
   * @antv/g-plugin-canvas-renderer
   * @description A G plugin of renderer implementation with Canvas2D API
   * @version 2.2.19
   * @date 2/27/2025, 8:28:07 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-dom-interaction/dist/index.esm.js:
  (*!
   * @antv/g-plugin-dom-interaction
   * @description A G plugin
   * @version 2.1.21
   * @date 1/23/2025, 8:33:09 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-html-renderer/dist/index.esm.js:
  (*!
   * @antv/g-plugin-html-renderer
   * @description A G plugin for rendering HTML
   * @version 2.1.21
   * @date 1/23/2025, 8:33:20 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-canvas/dist/index.esm.js:
  (*!
   * @antv/g-canvas
   * @description A renderer implemented by Canvas 2D API
   * @version 2.0.40
   * @date 2/27/2025, 8:29:44 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-dragndrop/dist/index.esm.js:
  (*!
   * @antv/g-plugin-dragndrop
   * @description A G plugin for Drag n Drop implemented with PointerEvents
   * @version 2.0.32
   * @date 1/23/2025, 8:33:12 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)
*/
//# sourceMappingURL=@ant-design_plots.js.map
